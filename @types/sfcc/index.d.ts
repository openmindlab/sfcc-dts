/**
 * represents an error during pipelet execution
 */
declare const PIPELET_ERROR: number;
/**
 * represents the next pipelet to fire
 */
declare const PIPELET_NEXT: number;
/**
 * Provides access to the SlotContent object.  Available only in ISML
 *  templates that are defined as the Slot's template.  For example,
 *  <isprint value="${slotcontent.callout}"> will print out the callout message
 *  of the active Slot.
 */
declare const slotcontent: any;
/**
 * Provides access to WSDL definition files in a Cartridge's webreferences
 *  folder. For example, webreferences.mywebservice loads the
 *  mywebservice.wsdl file and returns an instance of dw.rpc.WebReference.
 *  The WebReference instance enables you to access the actual web service
 *  via the WebReference.getDefaultService() method.
 */
declare const webreferences: any;
/**
 * Provides access to WSDL definition files in a Cartridge's webreferences2
 *  folder. For example, webreferences2.mywebservice loads the
 *  mywebservice.wsdl file and returns an instance of dw.ws.WebReference2.
 *  The WebReference2 instance enables you to access the actual web service
 *  via the WebReference2.getDefaultService() method.
 */
declare const webreferences2: any;

/**
 * The current customer or null if this request is not associated with any customer.
 */
declare const customer: dw.customer.Customer;
/**
 * The current request.
 */
declare const request: dw.system.Request;
/**
 * The current response.
 */
declare const response: dw.system.Response;
/**
 * The current session.
 */
declare const session: dw.system.Session;

/**
 * The method tests, whether the given object is empty. The interpretation
 *  of empty is the following.
 *  - null is always empty
 *  - undefined is always empty
 *  - a string with zero length is empty
 *  - an array with no elements is empty
 *  - a collection with no elements is empty
 * @param obj the object to be thested
 * @return true if the object is interpreted as being empty
 */
declare function empty(obj: any): boolean;
/**
 * Import the specified class and make it
 *  available at the top level. It's equivalent in effect to the
 *  Java import declaration.
 * @param classPath the fully qualified class path.
 */
declare function importClass(classPath: any): void;
/**
 * Import all the classes in the specified package
 *  available at the top level. It's equivalent in effect to the
 *  Java import declaration.
 * @param packagePath the fully qualified package path.
 */
declare function importPackage(packagePath: any): void;
/**
 * Imports all functions from the specified script. Variables are not imported
 *  from the script and must be accessed through helper functions.
 *
 *  The script path has the following syntax: [cartridgename:]scriptname, where
 *  cartridgename identifies a cartridge where the script file is located. If
 *  cartridgename is omitted the script file is loaded from the same cartridge
 *  in which the importing component is located.
 *
 *  Examples:
 *  importScript( 'example.ds' ) imports the script file example.ds from the same cartridge
 *  importScript( 'abc:example.ds' ) imports the script file example.ds from the cartridge 'abc'
 * @param scriptPath the path to the script.
 */
declare function importScript(scriptPath: string): void;
/**
 * Determines whether the specified string is a valid name for an
 *  XML element or attribute.
 * @param name the String specified
 * @return True if the string is a valid name
 */
declare function isXMLName(name: string): boolean;
/**
 * Formats and prints the message using the specified params and returns
 *  the formatted message. The format message is a Java MessageFormat
 *  expression. Printing happens in the script log output.
 * @param msg the message to format.
 * @param params one, or multiple parameters that are used to format the message.
 */
declare function trace(msg: string, ...params: any[]): void;

/**
 * This error indicates an exceptional outcome of some business logic. Instances of
 *  this exception in general provide additional information about the reason of this case.
 *  See the actual type referred by the type property for the description of the properties
 *  with this additional information.
 *  <br><br>
 *  Limitation: The sub classes of this APIException shown in this documentation actually do not exist.
 *  All instances are of type APIException, but with different property sets as listed in the sub classes.
 *  <br><br>
 *  The APIException is always related to a systems internal Java exception. The class provides
 *  access to some more details about this internal Java exception.
 */
declare class APIException extends Error {
  /**
   * If the exception is associated with a root cause, the property
   *  contains the full name of the associated Java exception.
   */
  causeFullName: string;
  /**
   * If the exception is associated with a root cause, the property
   *  contains the message of the associated Java exception.
   */
  causeMessage: string;
  /**
   * If the exception is associated with a root cause, the property
   *  contains the simplified name of the associated Java exception.
   */
  causeName: string;
  /**
   * The full name of the underlying Java exception.
   */
  javaFullName: string;
  /**
   * The message of the underlying Java exception.
   */
  javaMessage: string;
  /**
   * The simplified name of the underlying Java exception.
   */
  javaName: string;
  /**
   * The name of the actual APIExcpetion type, without the package name.
   */
  type: string;
}

/**
 * Represents a conversion error.
 */
declare class ConversionError extends Error {
  /**
   * Constructs the error.
   *
   */
  constructor();
  /**
   * Constructs the error with the
   *  specified message.
   * @param msg the conversion error message.
   */
  constructor(msg: string);
}

/**
 * This error indicates an RPC related error in the system. The Fault
 *  is always related to a systems internal Java exception. The class provides
 *  access to some more details about this internal Java exception. In particular
 *  it provides details about the error send from the remote system.
 */
declare class Fault extends Error {
  /**
   * If the exception is associated with a root cause, the property
   *  contains the full name of the associated Java exception.
   */
  causeFullName: string;
  /**
   * If the exception is associated with a root cause, the property
   *  contains the message of the associated Java exception.
   */
  causeMessage: string;
  /**
   * If the exception is associated with a root cause, the property
   *  contains the simplified name of the associated Java exception.
   */
  causeName: string;
  /**
   * Provides some information on who cause the fault along the message
   *  path.
   */
  faultActor: string;
  /**
   * An identifier for the specific fault.
   */
  faultCode: string;
  /**
   * More detailed information about the fault.
   */
  faultDetail: string;
  /**
   * A human readable description for the fault.
   */
  faultString: string;
  /**
   * The full name of the underlying Java exception.
   */
  javaFullName: string;
  /**
   * The message of the underlying Java exception.
   */
  javaMessage: string;
  /**
   * The simplified name of the underlying Java exception.
   */
  javaName: string;

  constructor();
}

/**
 * A generator is a special type of function that works as a factory for
 *  iterators and it allows you to define an iterative algorithm by writing a
 *  single function which can maintain its own state. A function becomes a
 *  generator if it contains one or more <b>yield</b> statements.
 *
 *  When a generator function is called, the body of the function does not
 *  execute straight away; instead, it returns a generator-iterator object.
 *  Each call to the generator-iterator&apos;s next() method will execute the
 *  body of the function up to the next <b>yield</b> statement and return its result.
 *  When either the end of the function or a return statement is reached,
 *  a StopIteration exception is thrown.
 *
 *  For example, the following fib() function is a Fibonacci number generator,
 *  that returns the generator when it encounters the <b>yield</b> statement:
 *  <pre> <code>
 *  function fib() {
 *     var fibNum = 0, j = 1;
 *     while (true) {
 *        <b><i>yield</i></b> fibNum;
 *        var t = fibNum;
 *        fibNum = j;
 *        j += t;
 *     }
 *  }
 *  </code>
 *  </pre>
 *
 *  To use the generator, simply call the next() method to access the values
 *  returned by the function:
 *  <pre> <code>
 *   var gen = fib();
 *   for (var i = 0; i &lt; 10; i++) {
 *     document.write(<b><i>gen.next()</i></b> &quot; &quot;);
 *   }
 *  </code>
 *  </pre>
 */
declare class Generator {
  constructor();

  /**
   * Closes the iteration of the generator. Any finally clauses active in
   *  the generator function are run. If a finally clause throws any
   *  exception other than StopIteration, the exception is propagated to
   *  the caller of the close() method.
   *
   */
  close(): void;
  /**
   * Resumes the iteration of the generator by continuing the function
   *  at the statement after the yield statement. This function throws a
   *  StopIterator exception when there are no additional iterative steps.
   *
   * @return the result of resuming the iterative algorithm or a StopIterator exception if the sequence is exhausted.
   */
  next(): any;
  /**
   * Allows you to control the resumption of the iterative algorithm. Once a
   *  generator has been started by calling its next() method, you can use
   *  send() and pass a specific value that will be treated as the result
   *  of the last yield. The generator will then return the operand of the
   *  subsequent yield.
   *
   *  You can't start a generator at an arbitrary point; you must start
   *  it with next() before you can send() it a specific value. Note that
   *  calling send(undefined) is equivalent to calling next(). However,
   *  starting a newborn generator with any value other than 'undefined' when
   *  calling send() will result in a TypeError exception.
   * @param value the value to use.
   */
  send(value: any): any;
}

/**
 * This error indicates an I/O related error in the system. The IOError
 *  is always related to a systems internal Java exception. The class provides
 *  access to some more details about this internal Java exception.
 */
declare class IOError extends Error {
  /**
   * If the exception is associated with a root cause, the property
   *  contains the full name of the associated Java exception.
   */
  causeFullName: string;
  /**
   * If the exception is associated with a root cause, the property
   *  contains the message of the associated Java exception.
   */
  causeMessage: string;
  /**
   * If the exception is associated with a root cause, the property
   *  contains the simplified name of the associated Java exception.
   */
  causeName: string;
  /**
   * The full name of the underlying Java exception.
   */
  javaFullName: string;
  /**
   * The message of the underlying Java exception.
   */
  javaMessage: string;
  /**
   * The simplified name of the underlying Java exception.
   */
  javaName: string;

  constructor();
}

/**
 * Represents the an internal error.
 */
declare class InternalError extends Error {
  /**
   * Constructs the error.
   *
   */
  constructor();
  /**
   * Constructs the error with the
   *  specified message.
   * @param msg the internal error message.
   */
  constructor(msg: string);
}

/**
 * CommonJS modules are JavaScript files that are loaded using the <a href="class_TopLevel_global.html#TopLevel_global_require_String_DetailAnchor"> require(String)</a>
 *  function. This function returns a module object, which wraps the script code from the file. Within a module
 *  implementation, the module object can be accessed via the <a href="class_TopLevel_global.html#TopLevel_global_module_DetailAnchor"> module</a> variable.
 *  <p>
 *  A module has a unique absolute id. The same module may be resolved by <a href="class_TopLevel_global.html#TopLevel_global_require_String_DetailAnchor"> require(String)</a>
 *  for different path arguments, like relative paths (starting with &quot;./&quot; or &quot;../&quot;), or absolute paths. See the
 *  documentation of require for more details about the lookup procedure.
 *  </p>
 *  <p>
 *  Every module object has an <a href="class_TopLevel_Module.html#TopLevel_Module_exports_DetailAnchor">exports</a> property which can be used by the module implementation to expose its
 *  public functions or properties. Only functions and properties that are explicitly exported are accessible from other
 *  modules, all others are private and not visible. For convenience, the global <a href="class_TopLevel_global.html#TopLevel_global_exports_DetailAnchor"> exports</a> variable
 *  is by default also initialized with the <a href="class_TopLevel_Module.html#TopLevel_Module_exports_DetailAnchor"> module.exports</a> property of the current module.
 *  </p>
 *  In the most simple case, module elements can be exposed by adding them to the exports object, like:
 *
 *  <pre> // Greeting.js
 *  exports.sayHello = function() {
 *      return &apos;Hello World!&apos;;
 *  };
 *  </pre>
 *
 *  This is equivalent to:
 *
 *  <pre> // Greeting.js
 *  module.exports.sayHello = function() {
 *      return &apos;Hello World!&apos;;
 *  };
 *  </pre>
 *
 *  With the above implementation, a caller (for example another module in the same directory) could call the module
 *  function like this:
 *
 *  <pre> var message = require(&apos;./Greeting&apos;).sayHello();
 *  </pre>
 *
 *  It is also possible to replace the whole module exports object with a completely different value, for example with a
 *  function:
 *
 *  <pre> // Greeting.js
 *  module.exports = function sayHello() {
 *      return &apos;Hi!&apos;;
 *  }
 *  </pre>
 *
 *  Now the result of require would be a function, which can be invoked directly like:
 *
 *  <pre> var message = require(&apos;./Greeting&apos;)();
 *  </pre>
 *
 *  This construction can be used for exporting constructor functions, so that a module becomes something like a class:
 *
 *  <pre> // Greeting.js
 *  function Greeting()
 *  {
 *      this.message = &apos;Hi!&apos;;
 *  }
 *
 *  Greeting.prototype.getMessage = function() {
 *      return this.message;
 *  }
 *
 *  module.exports = Greeting;
 *  </pre>
 *
 *  which would be used like:
 *
 *  <pre> var Greeting = require(&apos;./Greeting&apos;);
 *  var m = new Greeting().getMessage();
 *  </pre>
 */
declare class NodeModule {
  /**
   * The name of the cartridge which contains the module.
   */
  cartridge: string;
  /**
   * The exports of the module.
   */
  exports: any;
  /**
   * The absolute, normalized id of the module, which uniquely identifies it. A call to the
   *  global.require(String) function with this id would resolve this module.
   */
  id: string;
  /**
   * The module (if exists) that is overridden by this module. The super module would have the same path as the
   *  current module but its code location would be checked later in the lookup sequence. This property is useful to
   *  reuse functionality implemented in overridden modules.
   */
  superModule: NodeModule;
}

/**
 * Namespace objects represent XML namespaces and provide an
 *  association between a namespace prefix and a Unique Resource
 *  Identifier (URI). The prefix is either the undefined value
 *  or a string value that may be used to reference the namespace
 *  within the lexical representation of an XML value. When an
 *  XML object containing a namespace with an undefined prefix is
 *  encoded as XML by the method toXMLString(), the implementation
 *  will automatically generate a prefix.
 *  The URI is a string value used to uniquely identify the namespace.
 */
declare class Namespace {
  /**
   * The prefix of the Namespace object.
   */
  readonly prefix: string;
  /**
   * The Uniform Resource Identifier (URI) of the Namespace object.
   */
  readonly uri: string;

  /**
   * Constructs a simple namespace where the
   *  uri and prefix properties are set to an empty string.
   *  A namespace with URI set to the empty string represents no namespace.
   *  No namespace is used in XML objects to explicitly specify
   *  that a name is not inside a namespace and may never be
   *  associated with a prefix other than the empty string.
   *
   */
  constructor();
  /**
   * Constructs a Namespace object and assigns values to the
   *  uri and prefix properties based on the type
   *  of uriValue. If uriValue is a
   *  Namespace object, a copy of the Namespace is constructed.
   *  If uriValue is a QName object, the uri property is
   *  set to the QName object's uri property.
   *  Otherwise, uriValue is converted into a string and
   *  assigned to the uri property.
   * @param uriValue the value to use when constructing the Namespace.
   */
  constructor(uriValue: any);
  /**
   * Constructs a Namespace object and assigns values to the
   *  uri and prefix properties.
   *
   *  The value of the prefixValue parameter is assigned to the
   *  prefix property in the following manner:
   *
   *  If undefined is passed, prefix is set to undefined.
   *  If the argument is a valid XML name, it is converted
   *  to a string and assigned to the prefix property.
   *  If the argument is not a valid XML name, the prefix
   *  property is set to undefined.
   *
   *  The value of the uriValue parameter is assigned
   *  to the uri property in the following manner:
   *
   *  If a QName object is passed for the uriValue parameter,
   *  the uri property is set to the value of the QName object's uri property.
   *  If a QName object is not passed for the uriValue parameter,
   *  the uriValue parameter is converted to a string and assigned to the uri property.
   * @param prefixValue the prefix value to use when constructing the Namespace.
   * @param uriValue the value to use when constructing the Namespace.
   */
  constructor(prefixValue: any, uriValue: any);

  /**
   * Returns the prefix of the Namespace object.
   *
   * @return the prefix of the Namespace object.
   */
  getPrefix(): string;
  /**
   * Returns the Uniform Resource Identifier (URI) of the Namespace object.
   *
   * @return the Uniform Resource Identifier (URI) of the Namespace object.
   */
  getUri(): string;
  /**
   * Returns a string representation of this Namespace object.
   *
   * @return a string representation of this Namespace object.
   */
  toString(): string;
}

/**
 * QName objects are used to represent qualified names of XML
 *  elements and attributes. Each QName object has a local name
 *  of type string and a namespace URI of type string or null.
 *  When the namespace URI is null, this qualified name matches
 *  any namespace.
 *
 *  If the QName of an XML element is specified without identifying a
 *  namespace (i.e., as an unqualified identifier), the uri property
 *  of the associated QName will be set to the in-scope default
 *  namespace. If the QName of an XML attribute is
 *  specified without identifying a namespace, the uri property of
 *  the associated QName will be the empty string representing no namespace.
 */
declare class QName {
  /**
   * The local name of the QName object.
   */
  readonly localName: string;
  /**
   * The Uniform Resource Identifier (URI) of the QName object.
   */
  readonly uri: string;

  /**
   * Constructs a QName object where localName
   *  is set to an empty String.
   *
   */
  constructor();
  /**
   * Constructs a QName object that is a copy of the specified
   *  qname. If the argument is not
   *  a QName object, the argument is converted to a string and assigned
   *  to the localName property of the new QName instance.
   * @param qname the QName from which this QName will be constructed.
   */
  constructor(qname: QName);
  /**
   * Creates a QName object with a uri from a Namespace object and
   *  a localName from a QName object. If either argument is not
   *  the expected data type, the argument is converted to a string
   *  and assigned to the corresponding property of the new QName object.
   * @param uri a Namespace object from which to copy the uri value. An argument of any other type is converted to a string.
   * @param localName a QName object from which to copy the localName value. An argument of any other type is converted to a string.
   */
  constructor(uri: Namespace, localName: QName);

  /**
   * Returns the local name of the QName object.
   *
   * @return the local name of the QName object.
   */
  getLocalName(): string;
  /**
   * Returns the Uniform Resource Identifier (URI) of the QName object.
   *
   * @return the Uniform Resource Identifier (URI) of the QName object.
   */
  getUri(): string;
  /**
   * Returns a string composed of the URI, and the local name for the QName
   *  object, separated by "::". The format depends on the uri property of
   *  the QName object:
   *  If uri == ""
   *        toString returns localName
   *  else if uri == null
   *        toString returns *::localName
   *  else
   *     toString returns uri::localNam
   *
   * @return a string composed of the URI, and the local name for the QName object, separated by "::".
   */
  toString(): string;
}

/**
 * A special type of exception that is thrown when an Iterator or Generator
 *  sequence is exhausted.
 */
declare class StopIteration {
  constructor();
}

/**
 * This error indicates an error in the system, which doesn&apos;t fall into
 *  any of the other error categories like for example IOError. The SystemError
 *  is always related to a systems internal Java exception. The class provides
 *  access to some more details about this internal Java exception.
 */
declare class SystemError extends Error {
  /**
   * If the exception is associated with a root cause, the property
   *  contains the full name of the associated Java exception.
   */
  causeFullName: string;
  /**
   * If the exception is associated with a root cause, the property
   *  contains the message of the associated Java exception.
   */
  causeMessage: string;
  /**
   * If the exception is associated with a root cause, the property
   *  contains the simplified name of the associated Java exception.
   */
  causeName: string;
  /**
   * The full name of the underlying Java exception.
   */
  javaFullName: string;
  /**
   * The message of the underlying Java exception.
   */
  javaMessage: string;
  /**
   * The simplified name of the underlying Java exception.
   */
  javaName: string;

  constructor();
}

/**
 * The XML object contains functions and properties for working with XML
 *  instances. The XML object implements the powerful XML-handling standards
 *  defined in the ECMA-357 specification (known as &quot;E4X&quot;).
 *  <p>
 *  Use the toXMLString() method to return a string representation of the XML
 *  object regardless of whether the XML object has simple content or complex
 *  content.
 *  </p><p>
 *  Do not create large XML objects in memory to avoid out-of-memory conditions.
 *  When dealing with XML streams use <a href="class_dw_io_XMLStreamReader.html">XMLStreamReader</a> and
 *  <a href="class_dw_io_XMLStreamWriter.html">XMLStreamWriter</a>. The following example shows how:
 *
 *  </p><pre> var id : String = &quot;p42&quot;;
 *  var pname : String = &quot;a product&quot;;
 *
 *  // use E4X syntax
 *  var product : XML =
 *    &lt;product id={id}&gt;
 *      &lt;name&gt;{pname}&lt;/name&gt;
 *      &lt;shortdesc&gt;&lt;/shortdesc&gt;
 *    &lt;/product&gt;;
 *
 *  product.shortdesc = &quot;a fine product&quot;;
 *  product.longdesc = &quot;this is a fine product&quot;;
 *
 *  var xmlString = product.toXMLString();
 *
 *  fileWriter.write(xmlString);
 *  </pre>
 *
 *  <p>
 *
 *  The code above will write the following to file:
 *
 *  </p><p>
 *
 *  </p><pre> &lt;product id=&quot;p42&quot;&gt;
 *    &lt;name&gt;a product&lt;/name&gt;
 *    &lt;shortdesc&gt;a fine product&lt;/shortdesc&gt;
 *    &lt;longdesc&gt;this is a fine product&lt;/longdesc&gt;
 *  &lt;/product&gt;
 *  </pre>
 *
 *  <p>
 *
 *  Do not create large XML objects in memory to avoid out-of-memory conditions.
 *  When dealing with XML streams use <a href="class_dw_io_XMLStreamReader.html">XMLStreamReader</a> and
 *  <a href="class_dw_io_XMLStreamWriter.html">XMLStreamWriter</a>.</p>
 */
declare class XML {
  /**
   * The ignoreComments property determines whether or not XML comments are
   *  ignored when XML objects parse the source XML data.
   */
  static ignoreComments: boolean;
  /**
   * The ignoreProcessingInstructions property determines whether or not XML
   *  processing instructions are ignored when XML objects parse the source XML data.
   */
  static ignoreProcessingInstructions: boolean;
  /**
   * The ignoreWhitespace property determines whether or not white space
   *  characters at the beginning and end of text nodes are ignored during parsing.
   */
  static ignoreWhitespace: boolean;
  /**
   * The prettyIndent property determines the amount of indentation applied by
   *  the toString() and toXMLString() methods when the XML.prettyPrinting
   *  property is set to true.
   */
  static prettyIndent: number;
  /**
   * The prettyPrinting property determines whether the toString() and toXMLString()
   *  methods normalize white space characters between some tags.
   */
  static prettyPrinting: boolean;

  /**
   * Creates a new XML object.
   *
   */
  constructor();
  /**
   * Creates a new XML object.
   *  You must use the constructor to create an XML object before you
   *  call any of the methods of the XML class.
   *  Use the toXMLString() method to return a string representation
   *  of the XML object regardless of whether the XML object has simple
   *  content or complex content.
   * @param value any Object that can be converted to XML via the top-level XML() function.
   */
  constructor(value: any);

  /**
   * Adds a namespace to the set of in-scope namespaces for the XML object.
   *  If the namespace already exists in the in-scope namespaces for the XML
   *  object, then the prefix of the existing namespace is set to undefined.
   *  If ns is a Namespace instance, it is used directly.
   *  However, if ns is a QName instance, the input parameter's URI is used
   *  to create a new namespace. If ns is not a Namespace or QName instance,
   *  ns is converted to a String and a namespace is created from the String.
   * @param ns the namespace to add to the XML object.
   * @return a new XML object, with the namespace added.
   */
  addNamespace(ns: any): XML;
  /**
   * Appends the specified child to the end of the object's properties.
   *  child should be a XML object, an XMLList object or any other
   *  data type that will then be converted to a String.
   * @param child the object to append to this XML object.
   * @return the XML object with the child appended.
   */
  appendChild(child: any): XML;
  /**
   * Returns the attribute associated with this XML object that
   *  is identified by the specified name.
   * @param attributeName the name of the attribute.
   * @return the value of the attribute as either an XMLList or an empty XMLList
   */
  attribute(attributeName: string): XMLList;
  /**
   * Returns an XMList of the attributes in this XML Object.
   *
   * @return an XMList of the attributes in this XML Object.
   */
  attributes(): XMLList;
  /**
   * Returns the children of the XML object based on the specified
   *  property name.
   * @param propertyName the property name representing the children of this XML object.
   * @return an XMLList of children that match the property name parameter.
   */
  child(propertyName: any): XMLList;
  /**
   * Identifies the zero-based index of this XML object within
   *  the context of its parent, or -1 if this object has no parent.
   *
   * @return the index of this XML object in the context of its parent, or -1 if this object has no parent.
   */
  childIndex(): number;
  /**
   * Returns an XMLList containing the children of this XML object, maintaing
   *  the sequence in which they appear.
   *
   * @return an XMLList containing the children of this XML object.
   */
  children(): XMLList;
  /**
   * Returns the properties of the XML object that contain comments.
   *
   * @return properties of the XML object that contain comments.
   */
  comments(): XMLList;
  /**
   * Returns true if this XML object contains the specified
   *  XML object, false otherwise.
   * @param value the object to locate in this XML object.
   * @return true if this XML object contains the specified XML object, false otherwise.
   */
  contains(value: XML): boolean;
  /**
   * Returns a copy of the this XML object including
   *  duplicate copies of the entire tree of nodes.
   *  The copied XML object has no parent.
   *
   * @return the copy of the object.
   */
  copy(): XML;
  /**
   * Returns a new Object with the following properties set to the default values:
   *  ignoreComments, ignoreProcessingInstructions, ignoreWhitespace, prettyIndent,
   *  and prettyPrinting. The default values are as follows:
   *
   *  ignoreComments = true
   *  ignoreProcessingInstructions = true
   *  ignoreWhitespace = true
   *  prettyIndent = 2
   *  prettyPrinting = true
   *
   *
   *  Be aware that this method does not apply the settings to an existing instance
   *  of an XML object. Instead, this method returns an Object containing the
   *  default settings.
   *
   * @return an Object with properties set to the default settings.
   */
  static defaultSettings(): any;
  /**
   * Returns all descendents of the XML object.
   *
   * @return a list of all descendents of the XML object.
   */
  descendants(): XMLList;
  /**
   * Returns all descendents of the XML object that
   *  have the specified name parameter. To return all descendents,
   *  use * as the name parameter.
   * @param name the name of the element to match. To return all descendents, use * as the name parameter.
   * @return a list of all descendents constrained by the name parameter.
   */
  descendants(name: string): XMLList;
  /**
   * Returns a list of all of the elements of the XML object.
   *
   */
  elements(): XMLList;
  /**
   * Returns a list of the elements of the XML object using the
   *  specified name to constrain the list. name can be a
   *  QName, String, or any other data type that will be converted
   *  to a string prior to performing the search for elements of that
   *  name.
   *
   *  To list all objects use * for the value of name.
   * @param name the name of the elements to return or an * to return all elements.
   * @return a list of the elements of the XML object using the specified name to constrain the list.
   */
  elements(name: any): XMLList;
  /**
   * Returns a Boolean value indicating whether
   *  this XML object contains complex content. An XML object is considered
   *  to contain complex content if it represents an XML element that has
   *  child elements. XML objects representing attributes, comments, processing
   *  instructions and text nodes do not have complex content. The existence of
   *  attributes, comments, processing instructions and text nodes within an XML
   *  object is not significant in determining if it has complex content.
   *
   * @return a Boolean value indicating whether this XML object contains complex content.
   */
  hasComplexContent(): boolean;
  /**
   * Returns a Boolean value indicating whether this object has the
   *  property specified by prop.
   * @param prop the property to locate.
   * @return true if the property exists, false otherwise.
   */
  hasOwnProperty(prop: string): boolean;
  /**
   * Returns a Boolean value indicating whether this XML object contains
   *  simple content. An XML object is considered to contain simple
   *  content if it represents a text node, represents an attribute node
   *  or if it represents an XML element that has no child elements. XML
   *  objects representing comments and processing instructions do not
   *  have simple content. The existence of attributes, comments,
   *  processing instructions and text nodes within an XML object is not
   *  significant in determining if it has simple content.
   *
   * @return a Boolean value indicating whether this XML object contains simple content.
   */
  hasSimpleContent(): boolean;
  /**
   * Returns an Array of Namespace objects representing the namespaces
   *  in scope for this XML object in the context of its parent. If the
   *  parent of this XML object is modified, the associated namespace
   *  declarations may change. The set of namespaces returned by this
   *  method may be a super set of the namespaces used by this value
   *
   * @return an Array of Namespace objects representing the namespaces in scope for this XML object in the context of its parent.
   */
  inScopeNamespaces(): Array<Namespace>;
  /**
   * Inserts the specified child2 after the specified child1
   *  in this XML object and returns this XML object. If child1 is null,
   *  inserts child2 before all children of
   *  this XML object. If child1 does not exist
   *  in this XML object, it returns without modifying this XML object.
   * @param child1 the child after which child2 is inserted.
   * @param child2 the child to insert into this XML object.
   * @return the updated XML object.
   */
  insertChildAfter(child1: any, child2: any): XML;
  /**
   * Inserts the specified child2 before the specified child1
   *  in this XML object and returns this XML object. If child1 is null,
   *  inserts child2 after all children of
   *  this XML object. If child1 does not exist
   *  in this XML object, it returns without modifying this XML object.
   * @param child1 the child before which child2 is inserted.
   * @param child2 the child to insert into this XML object.
   * @return the updated XML object.
   */
  insertChildBefore(child1: any, child2: any): XML;
  /**
   * Returns a value of 1 for XML objects.
   *
   * @return the value of 1.
   */
  length(): number;
  /**
   * Returns the local name portion of the qualified name of the XML object.
   *
   * @return the local name as either a String or null.
   */
  localName(): any;
  /**
   * Returns the qualified name for the XML object.
   *
   * @return the qualified name as either a QName or null.
   */
  name(): any;
  /**
   * Returns the namespace associated with the qualified name
   *  of this XML object.
   *
   * @return the namespace associated with the qualified name of this XML object.
   */
  namespace(): any;
  /**
   * Returns the namespace that matches the specified prefix and
   *  that is in scope for the XML object. if there is no such
   *  namespace, the method returns undefined.
   * @param prefix the prefix to use when attempting to locate a namespace.
   * @return the namespace that matches the specified prefix and that is in scope for the XML object. If specified namespace does not exist, the method returns undefined.
   */
  namespace(prefix: string): any;
  /**
   * Returns an Array of namespace declarations associated
   *  with the XML Obnject in the context of its parent.
   *
   * @return an Array of namespace declarations associated with the XML Obnject in the context of its parent.
   */
  namespaceDeclarations(): Array<Namespace>;
  /**
   * Returns the type of the XML object, such
   *  as text, comment, processing-instruction,
   *  or attribute.
   *
   * @return the type of the XML object.
   */
  nodeKind(): string;
  /**
   * Merges adjacent text nodes and eliminates and eliminates
   *  empty text nodes for this XML object and all its
   *  descendents.
   *
   * @return the normalized XML object.
   */
  normalize(): XML;
  /**
   * Returns the parent of the XML object
   *  or null if the XML object does not have
   *  a parent.
   *
   * @return the parent of the XML object of null if the XML object does not have a parent.
   */
  parent(): any;
  /**
   * Inserts the specified child into this XML object
   *  prior to its existing XML properties and then returns
   *  this XML object.
   * @param value the child to prepend to this XML object.
   * @return the XML object updated with the prepended child.
   */
  prependChild(value: any): XML;
  /**
   * Returns an XMLList containing all the children of this XML object
   *  that are processing-instructions.
   *
   * @return an XMLList containing all the children of this XML object that are processing-instructions.
   */
  processingInstructions(): XMLList;
  /**
   * Returns an XMLList containing all the children of this XML object
   *  that are processing-instructions with the specified name. If you
   *  use * for the name, all processing-instructions are returned.
   * @param name the name representing the processing-instructions you want to retreive.
   * @return an XMLList containing all the children of this XML object that are processing-instructions with the specified name.
   */
  processingInstructions(name: string): XMLList;
  /**
   * Returns a Boolean indicating whether the specified
   *  property will be included in the set of properties iterated
   *  over when this XML object is used in a for..in statement.
   * @param property the property to test.
   * @return true when the property can be iterated in a for..in statement, false otherwise.
   */
  propertyIsEnumerable(property: string): boolean;
  /**
   * Removes the specified namespace from the in scope namespaces
   *  of this object and all its descendents, then returns a copy of
   *  this XML object. This method will not remove a namespace from
   *  an object when it is referenced by that object's QName or
   *  the ONames of that object's attributes.
   * @param ns the namespace to remove.
   * @return a copy of this XML object with the namespace removed.
   */
  removeNamespace(ns: Namespace): XML;
  /**
   * Replaces the XML properties of this XML object specified by
   *  propertyName with value and returns this
   *  updated XML object. If this XML object contains no properties
   *  that match propertyName, the replace method returns without
   *  modifying this XML object.
   *
   *  The propertyName parameter may be a numeric property name,
   *  an unqualified name for a set of XML elements, a qualified
   *  name for a set of XML elements or the properties wildcard *.
   *
   *  When the propertyName parameter is an unqualified name,
   *  it identifies XML elements in the default namespace. The value
   *  parameter may be an XML object, XMLList object or any value
   *  that may be converted to a String.
   * @param propertyName a numeric property name, an unqualified name for a set of XML elements, a qualified name for a set of XML elements or the properties wildcard *.
   * @param value an XML object, XMLList object or any value that may be converted to a String.
   * @return the updated XML object.
   */
  replace(propertyName: string, value: any): XML;
  /**
   * Replaces the XML properties of this XML object
   *  with a new set of XML properties from value.
   * @param value a single XML object or an XMLList.
   * @return the updated XML object.
   */
  setChildren(value: any): XML;
  /**
   * Replaces the local name of this XML object with
   *  a string constructed from the specified name.
   * @param name the new local name.
   */
  setLocalName(name: string): void;
  /**
   * Replaces the name of this XML object with a
   *  QName or AttributeName constructed from the specified
   *  name.
   * @param name the new name of this XML object.
   */
  setName(name: string): void;
  /**
   * Replaces the namespace associated with the name of
   *  this XML object with the specified namespace.
   * @param ns the namespace to associated with the name of thix XML object.
   */
  setNamespace(ns: Namespace): void;
  /**
   * Restores the default settings for the following XML
   *  properties:
   *
   *  XML.ignoreComments = true
   *  XML.ignoreProcessingInstructions = true
   *  XML.ignoreWhitespace = true
   *  XML.prettyIndent = 2
   *  XML.prettyPrinting = true
   *
   */
  static setSettings(): void;
  /**
   * Updates the collection of global XML properties:
   *  ignoreComments, ignoreProcessingInstructions, ignoreWhitespace,
   *  prettyPrinting, prettyIndent, and prettyPrinting.
   * @param settings an object with each of the following properties: ignoreComments, ignoreProcessingInstructions, ignoreWhitespace, prettyIndent, and prettyPrinting.
   */
  static setSettings(settings: any): void;
  /**
   * Returns the collection of global XML properties:
   *  ignoreComments, ignoreProcessingInstructions, ignoreWhitespace,
   *  prettyPrinting, prettyIndent, and prettyPrinting.
   *
   * @return an object with each of the following properties: ignoreComments, ignoreProcessingInstructions, ignoreWhitespace, prettyIndent, and prettyPrinting.
   */
  static settings(): any;
  /**
   * Returns returns an XMLList containing all XML properties of
   *  this XML object that represent XML text nodes.
   *
   * @return an XMLList containing all XML properties of this XML object that represent XML text nodes.
   */
  text(): XMLList;
  /**
   * Returns the String representation of the XML object. If the object contains
   *   simple content, this method returns a String with tag, attributes, and
   *   namespace declarations removed. However, if the object contains complex
   *   content, this method returns an XML encoded String representing the entire
   *   XML object. If you want to return the entire XML object regardless of
   *   content complexity, use the toXMLString() method.
   *
   * @return the String representation of the XML object.
   */
  toString(): string;
  /**
   * Returns a XML-encoded String representation of the XML object, including tag and
   *  attributed delimiters.
   *
   * @return the string representation of the XML object.
   */
  toXMLString(): string;
  /**
   * Returns this XML object.
   *
   * @return this XML object.
   */
  valueOf(): XML;
}

/**
 * An XMLList object is an ordered collection of properties.
 *  A XMLList object represents a XML document, an XML fragment,
 *  or an arbitrary collection of XML objects.
 *  An individual XML object is the same thing as an XMLList
 *  containing only that XML object. All operations available
 *  for the XML object are also available for an XMLList object
 *  that contains exactly one XML object.
 */
declare class XMLList {
  /**
   * Creates a new XMLList object using the
   *  specified value.
   * @param value the value to use.
   */
  constructor(value: any);

  /**
   * Returns the attribute associated with this XMLList object that
   *  is identified by the specified name.
   * @param attributeName the name of the attribute.
   * @return the value of the attribute as either an XMLList or an empty XMLList
   */
  attribute(attributeName: string): XMLList;
  /**
   * Returns an XMList of the attributes in this XMLList Object.
   *
   * @return an XMList of the attributes in this XMLList Object.
   */
  attributes(): XMLList;
  /**
   * Returns the children of the XMLList object based on the specified
   *  property name.
   * @param propertyName the property name representing the children of this XMLList object.
   * @return an XMLList of children that match the property name parameter.
   */
  child(propertyName: any): XMLList;
  /**
   * Returns an XMLList containing the children of this XMLList object, maintaing
   *  the sequence in which they appear.
   *
   * @return an XMLList containing the children of this XMLList object.
   */
  children(): XMLList;
  /**
   * Returns the properties of the XMLList object that contain comments.
   *
   * @return properties of the XMLList object that contain comments.
   */
  comments(): XMLList;
  /**
   * Returns true if this XMLList object contains the specified
   *  XML object, false otherwise.
   * @param value the object to locate in this XMLList object.
   * @return true if this XMLList object contains the specified XML object, false otherwise.
   */
  contains(value: XML): boolean;
  /**
   * Returns a deep copy of the this XMLList object.
   *
   * @return the deep copy of the object.
   */
  copy(): XMLList;
  /**
   * Calls the descendants() method of each XML object in this XMLList
   *  object and returns an XMLList containing the
   *  results concatenated in order.
   *
   * @return a list of all descendents of the XML objects in this XMLList object.
   */
  descendants(): XMLList;
  /**
   * Calls the descendants(name) method of each XML object in this XMLList
   *  object and returns an XMLList containing the
   *  results concatenated in order.
   * @param name the name of the element to match. To return all descendents, use * as the name parameter.
   * @return a list of all descendents of the XML objects in this XMLList constrained by the name parameter.
   */
  descendants(name: string): XMLList;
  /**
   * Calls the elements() method in each XML object in this XMLList
   *  object and returns an XMLList containing the results concatenated in order.
   *
   */
  elements(): XMLList;
  /**
   * Calls the elements(name) method in each of the XML objects in
   *  this XMLList object and returns an XMLList containing the results
   *  concatenated in order. name can be a
   *  QName, String, or any other data type that will be converted
   *  to a string prior to performing the search for elements of that
   *  name.
   *
   *  To list all objects use * for the value of name.
   * @param name the name of the elements to return.
   * @return a list of all elements of the XML objects in this XMLList constrained by the name parameter.
   */
  elements(name: any): XMLList;
  /**
   * Returns a Boolean value indicating whether
   *  this XMLList object contains complex content. An XMLList object is considered
   *  to contain complex content if it is not empty, contains a single XML item
   *  with complex content or contains elements.
   *
   * @return a Boolean value indicating whether this XMLList object contains complex content.
   */
  hasComplexContent(): boolean;
  /**
   * Returns a Boolean value indicating whether this object has the
   *  property specified by prop.
   * @param prop the property to locate.
   * @return true if the property exists, false otherwise.
   */
  hasOwnProperty(prop: string): boolean;
  /**
   * Returns a Boolean value indicating whether this XML object contains
   *  simple content. An XMLList object is considered to contain simple
   *  content if it is empty, contains a single XML item with simple
   *  content or contains no elements.
   *
   * @return a Boolean value indicating whether this XML object contains simple content.
   */
  hasSimpleContent(): boolean;
  /**
   * Returns the number of children in this XMLList
   *  object.
   *
   * @return the number of children in this XMLList object.
   */
  length(): number;
  /**
   * Puts all text nodes in this XMLList, all the XML objects it
   *  contains and the descendents of all the XML objects it
   *  contains into a normal form by merging adjacent text nodes
   *  and eliminating empty text nodes.
   *
   * @return the XMLList object containing normailzed objects.
   */
  normalize(): XMLList;
  /**
   * Returns the parent of the XMLList object
   *  or null if the XMLList object does not have
   *  a parent.
   *
   * @return the parent of the XMLList object or null if the XMLList object does not have a parent.
   */
  parent(): any;
  /**
   * Calls the processingInstructions() method of each XML object
   *  in this XMLList object and returns an XMList containing the results
   *  in order.
   *
   * @return an XMLList contaiing the result of calling the processingInstructions() method of each XML object in this XMLList object.
   */
  processingInstructions(): XMLList;
  /**
   * Calls the processingInstructions(name) method of each XML object
   *  in this XMLList object and returns an XMList containing the results
   *  in order.
   * @param name the name representing the processing-instructions you want to retreive.
   * @return an XMLList containing the result of calling the processingInstructions(name) method of each XML object in this XMLList object.
   */
  processingInstructions(name: string): XMLList;
  /**
   * Returns a Boolean indicating whether the specified
   *  property will be included in the set of properties iterated
   *  over when this XML object is used in a for..in statement.
   * @param property the property to test.
   * @return true when the property can be iterated in a for..in statement, false otherwise.
   */
  propertyIsEnumerable(property: string): boolean;
  /**
   * Calls the text() method of each XML object contained
   *  in this XMLList object and returns an XMLList containing
   *  the results concatenated in order.
   *
   * @return the concatenated results of calling the text() method of every XML object contained in this XMLList.
   */
  text(): XMLList;
  /**
   * Returns the String representation of this XMLList object.
   *
   * @return the String representation of this XMLList object.
   */
  toString(): string;
  /**
   * Returns an XML-encoded String representation of the XMLList object
   *  by calling the toXMLString method on each property contained
   *  within this XMLList object.
   *
   * @return an XML-encoded String representation of the XMLList object by calling the toXMLString method on each property contained within this XMLList object.
   */
  toXMLString(): string;
  /**
   * Returns this XMLList object.
   *
   * @return this XMLList object.
   */
  valueOf(): XMLList;
}

/**
 * This error indicates an XML streaming related error in the system. The IOError
 *  is always related to a systems internal Java exception. The class provides
 *  access to some more details about this internal Java exception. In particular
 *  the class informs about the location of the error.
 */
declare class XMLStreamError extends Error {
  /**
   * If the exception is associated with a root cause, the property
   *  contains the full name of the associated Java exception.
   */
  causeFullName: string;
  /**
   * If the exception is associated with a root cause, the property
   *  contains the message of the associated Java exception.
   */
  causeMessage: string;
  /**
   * If the exception is associated with a root cause, the property
   *  contains the simplified name of the associated Java exception.
   */
  causeName: string;
  /**
   * The full name of the underlying Java exception.
   */
  javaFullName: string;
  /**
   * The message of the underlying Java exception.
   */
  javaMessage: string;
  /**
   * The simplified name of the underlying Java exception.
   */
  javaName: string;
  /**
   * The column number where the error occured.
   */
  xmlColumnNumber: number;
  /**
   * The line where the error occured.
   */
  xmlLineNumber: number;

  constructor();
}

declare namespace dw {
  namespace alert {
    /**
     * This class represents a single system alert to be shown to a Business Manager user.
     */
    class Alert {
      /**
       * String constant to denote the 'action required' priority.
       */
      static readonly PRIORITY_ACTION = "ACTION";
      /**
       * String constant to denote the 'informational' priority.
       */
      static readonly PRIORITY_INFO = "INFO";
      /**
       * String constant to denote the 'warning' priority.
       */
      static readonly PRIORITY_WARN = "WARN";

      /**
       * The ID of the referenced alert description.
       */
      readonly alertDescriptorID: string;
      /**
       * The ID of the referenced context object (or null, if no context object is assigned to this alert).
       */
      readonly contextObjectID: string;
      /**
       * Resolves the display message to be shown.
       *  It refers to the message resource ID specified in the alert descriptor file ("message-resource-id") and the message provided
       *  by the 'alerts.properties' resource bundle.
       *  When the referenced message contains parameter placeholders (such as '{0}' and '{1}') they are replaced by the parameters stored with the alert.
       */
      readonly displayMessage: string;
      /**
       * The priority assigned to the message.
       *  One of the string constants defined in this class (PRIORITY_INFO, PRIORITY_WARN, PRIORITY_ACTION).
       */
      readonly priority: string;
      /**
       * The URL of the page where the user can resolve the alert, as provided in the
       *  'alerts.json' descriptor file.
       */
      readonly remediationURL: string;

      /**
       * Returns the ID of the referenced alert description.
       *
       * @return the ID of the referenced alert description
       */
      getAlertDescriptorID(): string;
      /**
       * Returns the ID of the referenced context object (or null, if no context object is assigned to this alert).
       *
       * @return the ID of the referenced context object
       */
      getContextObjectID(): string;
      /**
       * Resolves the display message to be shown.
       *  It refers to the message resource ID specified in the alert descriptor file ("message-resource-id") and the message provided
       *  by the 'alerts.properties' resource bundle.
       *  When the referenced message contains parameter placeholders (such as '{0}' and '{1}') they are replaced by the parameters stored with the alert.
       *
       * @return the display message
       */
      getDisplayMessage(): string;
      /**
       * Returns the priority assigned to the message.
       *  One of the string constants defined in this class (PRIORITY_INFO, PRIORITY_WARN, PRIORITY_ACTION).
       *
       * @return the priority
       */
      getPriority(): string;
      /**
       * The URL of the page where the user can resolve the alert, as provided in the
       *  'alerts.json' descriptor file.
       *
       * @return the remediation URL
       */
      getRemediationURL(): string;
    }

    /**
     * <p>Allow creation, removal, re-validation and retrieval of alerts that might get visible to Business Manager users.</p>
     *  <p>The alerts have to be registered by the &apos;alerts.json&apos; descriptor file in a cartridge assigned to the Business Manager site.
     *  The descriptor file itself has to be defined in &apos;package.json&apos; of that cartridge using a property &apos;alerts&apos; and providing its path
     *  that is relative to the &apos;package.json&apos;.
     *  The &apos;alert.json&apos; descriptor files contain the &apos;alert descriptions&apos;, which are referenced by their ID throughout the API.</p>
     *  <p>For example, the &apos;alerts.json&apos; file could have the following content:</p>
     *  <pre> {
     *    &quot;alerts&quot;: [
     *      {
     *        &quot;alert-id&quot;: &quot;missing_org_config&quot;,
     *        &quot;menu-action&quot;: &quot;global-prefs_custom_prefs&quot;,
     *        &quot;message-resource-id&quot;: &quot;global.missing_org_config&quot;,
     *        &quot;priority&quot;: &quot;ACTION&quot;,
     *        &quot;remediation&quot;: {
     *          &quot;pipeline&quot;:&quot;GlobalCustomPreferences&quot;,
     *          &quot;start-node&quot;:&quot;View&quot;
     *        }
     *      },
     *      {
     *        &quot;alert-id&quot;:&quot;promo_in_past&quot;,
     *        &quot;menu-action&quot;:&quot;marketing_promotions&quot;,
     *        &quot;context-object-type&quot;:&quot;Promotion&quot;,
     *        &quot;message-resource-id&quot;:&quot;promotion.in_the_past&quot;,
     *        &quot;priority&quot;:&quot;WARN&quot;,
     *        &quot;remediation&quot;: {
     *          &quot;pipeline&quot;:&quot;ViewApplication&quot;,
     *          &quot;start-node&quot;:&quot;BM&quot;,
     *          &quot;parameter&quot;:&quot;screen=Promotion&quot;
     *        }
     *      }
     *    ]
     *  }
     *  </pre>
     *  The referenced menu actions can be found in the &apos;bm_extensions.xml&apos; file of a Business manager extension cartridge
     *  (a sample file containing all current menu entries is provided when creating a new extension cartridge in Studio).
     */
    class Alerts {
      /**
       * Creates a new alert for the given ID.
       *  If such an alert already exists, no new one is created, and the existing one is not modified.
       * @param alertDescriptorID the ID of the referenced alert description
       * @param params parameters which may be shown in the alert message
       */
      static addAlert(alertDescriptorID: string, ...params: string[]): void;
      /**
       * Creates a new alert for the given ID and context object.
       *  If such an alert already exists, no new one is created, and the existing one is not modified.
       *  Multiple alerts for the same alert descriptor ID may exist, as long as they reference different objects.
       *  To refer to the same alert afterwards (e.g. to remove the alert) the same object must be provided.
       * @param alertDescriptorID the ID of the referenced alert description
       * @param contextObject the context object
       * @param params parameters which may be shown in the alert message
       */
      static addAlert(
        alertDescriptorID: string,
        contextObject: dw.object.PersistentObject,
        ...params: string[]
      ): void;
      /**
       * Creates a new alert for the given ID and ID of the context object.
       *  If such an alert already exists, no new one is created, and the existing one is not modified.
       *  Multiple alerts for the same alert descriptor ID may exist, as long as they reference different objects.
       *  To refer to the same alert afterwards (e.g. to remove it) the same object ID must be provided.
       *
       *  Use this method when the alerts refers to an object which is not a PersistentObject.
       * @param alertDescriptorID the ID of the referenced alert description
       * @param contextObjectID the ID of the referenced object
       * @param params parameters which may be shown in the alert message
       */
      static addAlert(
        alertDescriptorID: string,
        contextObjectID: string,
        ...params: string[]
      ): void;
      /**
       * Retrieves all alerts for a set of alert descriptor ID.
       * @param alertDescriptorIDs the IDs of the referenced alert descriptions
       * @return the list of alerts (of type Alert)
       */
      static getAlerts(
        ...alertDescriptorIDs: string[]
      ): dw.util.List<dw.alert.Alert>;
      /**
       * Retrieves all alerts for a set of alert descriptor ID and the given context object ID.
       * @param contextObjectID the ID of the referenced object
       * @param alertDescriptorIDs the IDs of the referenced alert descriptions
       * @return the list of alerts (of type Alert)
       */
      static getAlertsForContextObject(
        contextObjectID: string,
        ...alertDescriptorIDs: string[]
      ): dw.util.List<dw.alert.Alert>;
      /**
       * Retrieves all alerts for a set of alert descriptor ID and the given context object.
       * @param contextObject the context object
       * @param alertDescriptorIDs the IDs of the referenced alert descriptions
       * @return the list of alerts (of type Alert)
       */
      static getAlertsForContextObject(
        contextObject: dw.object.PersistentObject,
        ...alertDescriptorIDs: string[]
      ): dw.util.List<dw.alert.Alert>;
      /**
       * Removes all alerts for the given alert descriptor ID. This method will remove also alert referencing
       *  context objects, as long as they reference the same alert description.
       * @param alertDescriptorID the ID of the referenced alert description
       */
      static removeAlert(alertDescriptorID: string): void;
      /**
       * Removes the alert for the given alert description and context object.
       * @param alertDescriptorID the ID of the referenced alert description
       * @param contextObject the context object
       */
      static removeAlert(
        alertDescriptorID: string,
        contextObject: dw.object.PersistentObject
      ): void;
      /**
       * Removes the alert for the given alert description and context object ID.
       * @param alertDescriptorID the ID of the referenced alert description
       * @param contextObjectID the context object ID
       */
      static removeAlert(
        alertDescriptorID: string,
        contextObjectID: string
      ): void;
      /**
       * Re-evaluates the process function, and creates or removes the respective alert.
       *  The process function must return true when the alert should be created, and false when it should be removed.
       *  When the process function states that the alert should be created, but it already exists, it is not created again. Instead, the existing
       *  alert is updated with the supplied parameters.
       * @param alertDescriptorID the ID of the referenced alert description
       * @param processFunction the validation function. Must return true when the alert needs to be created.
       * @param params parameters which may be shown in the alert message
       */
      static revalidateAlert(
        alertDescriptorID: string,
        processFunction: Function,
        ...params: string[]
      ): void;
      /**
       * Re-evaluates the process function, and creates or removes the respective alert. The context object is handed as the only parameter to the process function.
       *  The process function must return true when the alert should be created, and false when it should be removed.
       *  When the process function states that the alert should be created, but it already exists, it is not created again. Instead, the existing
       *  alert is updated with the supplied parameters.
       * @param alertDescriptorID the ID of the referenced alert description
       * @param contextObject the context object for which the validation is done, might be null
       * @param processFunction the validation function. Must return true when the alert needs to be created.
       * @param params parameters which may be shown in the alert message
       */
      static revalidateAlert(
        alertDescriptorID: string,
        contextObject: dw.object.PersistentObject,
        processFunction: Function,
        ...params: string[]
      ): void;
      /**
       * Re-evaluates the process function, and creates or removes the respective alert. When the optional
       *  context object is supplied, it is handed as the only parameter to the process function (if its not supplied,
       *  no parameter is given to the function).
       *  The process function must return true when the alert should be created, and false when it should be removed.
       *  When the process function states that the alert should be created, but it already exists, it is not created again. Instead, the existing
       *  alert is updated with the supplied parameters.
       *  Use this variant of the function when the context object is not a persistent object. In this case the ID to be assigned
       *  to the alert must be supplied as an additional parameter. (Either both the context object and the ID must be provided, or none of them)
       * @param alertDescriptorID the ID of the referenced alert description
       * @param contextObject the context object for which the validation is done
       * @param contextObjectID the id of the context object for which the validation is done (and which is used to add / remove the alert object)
       * @param processFunction the validation function. Must return true when the alert needs to be created.
       * @param params parameters which may be shown in the alert message
       */
      static revalidateAlert(
        alertDescriptorID: string,
        contextObject: any,
        contextObjectID: string,
        processFunction: Function,
        ...params: string[]
      ): void;
    }
  }

  namespace campaign {
    /**
     * Object representing an AB-test in Commerce Cloud Digital.
     *  <p>
     *  AB-tests provide the merchant the ability to compare one set of storefront
     *  &quot;experiences&quot; - promotions, sorting rules, and slot configurations in
     *  particular - against another set. The merchant configures different AB-test
     *  segments which define the sets of experiences that the merchant wishes to
     *  test. AB-tests run for a configured period of time, and customers are
     *  randomly assigned by the platform to the test segments according to
     *  allocation percentages defined by the merchant.</p>
     */
    class ABTest extends dw.object.PersistentObject {
      /**
       * Get the test ID for this AB-test.
       */
      readonly ID: string;

      /**
       * Get the test ID for this AB-test.
       *
       * @return the test ID for this AB-test.
       */
      getID(): string;
    }

    /**
     * Manager class used to access AB-test information in the storefront.
     */
    class ABTestMgr {
      /**
       * Return the AB-test segments to which the current customer is assigned.
       *  AB-test segments deleted in the meantime will not be returned.
       */
      static readonly assignedTestSegments: dw.util.Collection<
        dw.campaign.ABTestSegment
      >;

      /**
       * Return the AB-test segments to which the current customer is assigned.
       *  AB-test segments deleted in the meantime will not be returned.
       *
       * @return unordered collection of ABTestSegment instances representing the AB-test segments to which the current customer is assigned.
       */
      static getAssignedTestSegments(): dw.util.Collection<
        dw.campaign.ABTestSegment
      >;
      /**
       * Test whether the current customer is a member of the specified AB-test
       *  segment. This method can be used to customize the storefront experience
       *  in ways that are not supported using Business Manager configuration
       *  alone.
       * @param testID The ID of the AB-test, must not be null.
       * @param segmentID The ID of the segment within the AB-test, must not be null.
       * @return true if the current customer is a member of the specified AB-test segment, false otherwise.
       */
      static isParticipant(testID: string, segmentID: string): boolean;
    }

    /**
     * Object representing an AB-test segment in the Commerce Cloud Digital.
     *  <p>
     *  Each AB-test defines 1 or more segments to which customers are randomly
     *  assigned by the platform when they qualify for the AB-test. Customers are
     *  assigned to segments according to allocation percentages controlled by the
     *  merchant. Each AB-test segment defines a set of &quot;experiences&quot; that the
     *  merchant is testing and which which apply only to the customers in that
     *  segment.  There is always one &quot;control&quot; segment which contains only the
     *  default set of experiences for that site.</p>
     */
    class ABTestSegment extends dw.object.PersistentObject {
      /**
       * Get the AB-test to which this segment belongs.
       */
      readonly ABTest: dw.campaign.ABTest;
      /**
       * Returns true if this is the "control segment" for the AB-test, meaning
       *  the segment that has no experiences associated with it.
       */
      readonly controlSegment: boolean;
      /**
       * Get the ID of the AB-test segment.
       */
      readonly ID: string;

      /**
       * Get the AB-test to which this segment belongs.
       *
       * @return the AB-test to which this segment belongs.
       */
      getABTest(): dw.campaign.ABTest;
      /**
       * Get the ID of the AB-test segment.
       *
       * @return the ID of the AB-test segment.
       */
      getID(): string;
      /**
       * Returns true if this is the "control segment" for the AB-test, meaning
       *  the segment that has no experiences associated with it.
       *
       * @return true if this segment is the "control segment" for the AB-test, or false otherwise.
       */
      isControlSegment(): boolean;
    }

    /**
     * Represents an <i>amount-off</i> discount in the discount plan, for example
     *  &quot;$10 off all orders $100 or more&quot;.
     */
    class AmountDiscount extends dw.campaign.Discount {
      /**
       * The discount amount, for example 10.00 for a "$10 off" discount.
       */
      readonly amount: number;

      /**
       * Create an amount-discount on the fly. Can be used to create a custom price adjustment.
       * @param amount amount off, e.g. 15.00 for a "15$ off" discount
       */
      constructor(amount: number);

      /**
       * Returns the discount amount, for example 10.00 for a "$10 off" discount.
       *
       * @return Discount amount
       */
      getAmount(): number;
    }

    /**
     * Transient class representing a discount that a <a href="class_dw_order_LineItemCtnr.html">LineItemCtnr</a>
     *  &quot;almost&quot; qualifies for based on the amount of merchandise in it. Storefronts
     *  can display information about approaching discounts to customers in order to
     *  entice them to buy more merchandise.
     *  <p>
     *  Approaching discounts are calculated on the basis of a
     *  <a href="class_dw_campaign_DiscountPlan.html">DiscountPlan</a> instead of a LineItemCtnr itself. When one
     *  of <a href="class_dw_campaign_PromotionMgr.html#dw_campaign_PromotionMgr_getDiscounts_LineItemCtnr_DetailAnchor">PromotionMgr.getDiscounts(LineItemCtnr)</a> or
     *  <a href="class_dw_campaign_PromotionMgr.html#dw_campaign_PromotionMgr_getDiscounts_LineItemCtnr_PromotionPlan_DetailAnchor">PromotionMgr.getDiscounts(LineItemCtnr, PromotionPlan)</a> is
     *  called, the promotions engine calculates the discounts the LineItemCtnr
     *  receives based on the promotions in context, and also tries to determine the
     *  discounts the LineItemCtnr would receive if additional merchandise were
     *  added. DiscountPlan provides different methods to retrieve this approaching
     *  discount info. Merchants can use these fine-grained methods to display
     *  information about approaching order discounts on the cart page, and
     *  approaching shipping discounts on the shipping method page during checkout,
     *  for example.
     *  </p><p>
     *  The merchant may include or exclude individual promotions from being included
     *  in this list, and define distance thresholds when configuring their
     *  promotions.</p>
     */
    class ApproachingDiscount {
      /**
       * The amount of merchandise required in the cart in order to receive the
       *  discount. For an order promotion "Get 15% off orders of $100 or more",
       *  the condition threshold is $100.00.
       */
      readonly conditionThreshold: dw.value.Money;
      /**
       * The discount that the customer will receive if he adds more merchandise
       *  to the cart. For an order promotion "Get 15% off orders of $100 or more",
       *  the discount is a PercentageDiscount object.
       */
      readonly discount: dw.campaign.Discount;
      /**
       * Convenience method that returns
       *  getConditionThreshold().subtract(getMerchandiseValue())
       */
      readonly distanceFromConditionThreshold: dw.value.Money;
      /**
       * The amount of merchandise in the cart contributing towards the condition
       *  threshold. This will always be less than the condition threshold.
       */
      readonly merchandiseTotal: dw.value.Money;

      /**
       * The amount of merchandise required in the cart in order to receive the
       *  discount. For an order promotion "Get 15% off orders of $100 or more",
       *  the condition threshold is $100.00.
       *
       * @return The amount of merchandise required in the cart in order to receive the discount.
       */
      getConditionThreshold(): dw.value.Money;
      /**
       * The discount that the customer will receive if he adds more merchandise
       *  to the cart. For an order promotion "Get 15% off orders of $100 or more",
       *  the discount is a PercentageDiscount object.
       *
       * @return The discount that the customer will receive if he adds more merchandise to the cart.
       */
      getDiscount(): dw.campaign.Discount;
      /**
       * Convenience method that returns
       *  getConditionThreshold().subtract(getMerchandiseValue())
       *
       * @return The amount of money needed to add to the order or shipment in order to receive the discount.
       */
      getDistanceFromConditionThreshold(): dw.value.Money;
      /**
       * The amount of merchandise in the cart contributing towards the condition
       *  threshold. This will always be less than the condition threshold.
       *
       * @return The amount of merchandise in the cart contributing towards the condition threshold.
       */
      getMerchandiseTotal(): dw.value.Money;
    }

    /**
     * Represents a <i>choice of bonus products</i> discount in the discount plan,
     *  for example &quot;Choose 3 DVDs from a list of 20 options with your purchase of
     *  any DVD player.&quot;
     */
    class BonusChoiceDiscount extends dw.campaign.Discount {
      /**
       * Get the list of bonus products which the customer is allowed to choose
       *  from for this discount. This list is configured by a merchant entering a
       *  list of SKUs for the discount. Products which do not exist in the system,
       *  or are offline, or are not assigned to a category in the site catalog are
       *  filtered out. Unavailable (i.e. out-of-stock) products are NOT filtered
       *  out. This allows merchants to display out-of-stock bonus products with
       *  appropriate messaging.
       *
       *  If a returned product is a master product, the customer is entitled to
       *  choose from any variant. If the product is an option product, the
       *  customer is entitled to choose any value for each option. Since the
       *  promotions engine does not touch the value of the product option line
       *  items, it is the responsibility of custom code to set option prices.
       *
       *  If the promotion is rule based, then this method will return an empty list.
       *  A ProductSearchModel should be used to return the bonus products the
       *  customer may choose from instead. See
       *  ProductSearchModel.PROMOTION_PRODUCT_TYPE_BONUS and
       *  ProductSearchModel.setPromotionID(String)
       */
      readonly bonusProducts: dw.util.List<dw.catalog.Product>;
      /**
       * The maximum number of bonus items that a customer is entitled to
       *  select for this discount.
       */
      readonly maxBonusItems: number;
      /**
       * Returns true if this is a "rule based" bonus choice discount.
       *  For such discounts, there is no static list of bonus products
       *  associated with the discount but rather a discounted product
       *  rule associated with the promotion which defines the bonus
       *  products. To retrieve the list of selectable bonus products for
       *  display in the storefront, it is necessary to search for the
       *  bonus products using the ProductSearchModel
       *  API since the method getBonusProducts() in this class
       *  will always return an empty list. Furthermore, for rule based
       *  bonus-choice discounts, getBonusProductPrice(Product)
       *  will always return a price of 0.00 for bonus products.
       */
      readonly ruleBased: boolean;

      /**
       * Get the effective price for the passed bonus product. This is expected to
       *  be one of the products returned by getBonusProducts() with one
       *  exception: If a master product is configured as a bonus product, this
       *  implies that a customer may choose from any of its variants. In this
       *  case, it is allowed to pass in a variant to this method and a price will
       *  be returned. If the passed product is not a valid bonus product, this
       *  method throws an exception.
       * @param product The bonus product to retrieve a price for, must not be null.
       * @return The price of the passed bonus product as a Number.
       */
      getBonusProductPrice(product: dw.catalog.Product): number;
      /**
       * Get the list of bonus products which the customer is allowed to choose
       *  from for this discount. This list is configured by a merchant entering a
       *  list of SKUs for the discount. Products which do not exist in the system,
       *  or are offline, or are not assigned to a category in the site catalog are
       *  filtered out. Unavailable (i.e. out-of-stock) products are NOT filtered
       *  out. This allows merchants to display out-of-stock bonus products with
       *  appropriate messaging.
       *
       *  If a returned product is a master product, the customer is entitled to
       *  choose from any variant. If the product is an option product, the
       *  customer is entitled to choose any value for each option. Since the
       *  promotions engine does not touch the value of the product option line
       *  items, it is the responsibility of custom code to set option prices.
       *
       *  If the promotion is rule based, then this method will return an empty list.
       *  A ProductSearchModel should be used to return the bonus products the
       *  customer may choose from instead. See
       *  ProductSearchModel.PROMOTION_PRODUCT_TYPE_BONUS and
       *  ProductSearchModel.setPromotionID(String)
       *
       * @return An ordered list of bonus products that the customer may choose from for this discount.
       */
      getBonusProducts(): dw.util.List<dw.catalog.Product>;
      /**
       * Returns the maximum number of bonus items that a customer is entitled to
       *  select for this discount.
       *
       * @return The maximum number of bonus items that this discount permits a customer to select.
       */
      getMaxBonusItems(): number;
      /**
       * Returns true if this is a "rule based" bonus choice discount.
       *  For such discounts, there is no static list of bonus products
       *  associated with the discount but rather a discounted product
       *  rule associated with the promotion which defines the bonus
       *  products. To retrieve the list of selectable bonus products for
       *  display in the storefront, it is necessary to search for the
       *  bonus products using the ProductSearchModel
       *  API since the method getBonusProducts() in this class
       *  will always return an empty list. Furthermore, for rule based
       *  bonus-choice discounts, getBonusProductPrice(Product)
       *  will always return a price of 0.00 for bonus products.
       *
       * @return True if this is a rule-based bonus-choice discount, or false if this discount defines a simple static list of bonus products.
       */
      isRuleBased(): boolean;
    }

    /**
     * Represents a <i>bonus</i> discount in the discount plan, for example
     *  &quot;Get a free DVD with your purchase of any DVD player.&quot;
     */
    class BonusDiscount extends dw.campaign.Discount {
      /**
       * The bonus products associated with this discount that are in
       *  stock, online and assigned to site catalog.
       */
      readonly bonusProducts: dw.util.Collection<dw.catalog.Product>;

      /**
       * Returns the bonus products associated with this discount that are in
       *  stock, online and assigned to site catalog.
       *
       * @return Collection of bonus products
       */
      getBonusProducts(): dw.util.Collection<dw.catalog.Product>;
    }

    /**
     * A Campaign is a set of experiences (or site configurations) which may be
     *  deployed as a single unit for a given time frame.  The system currently
     *  supports 3 types of experience that may be assigned to a campaign:
     *
     *  <ul>
     *  <li>Promotions</li>
     *  <li>Slot Configurations</li>
     *  <li>Sorting Rules</li>
     *  </ul>
     *
     *  This list may be extended in the future.
     *  <p>
     *  A campaign can have a start and end date or be open-ended.  It may also have
     *  &quot;qualifiers&quot; which determine which customers the campaign applies to.
     *  The currently supported qualifiers are:
     *
     *  </p><ul>
     *  <li>Customer groups (where &quot;Everyone&quot; is a possible customer group)</li>
     *  <li>Source codes</li>
     *  <li>Coupons</li>
     *  </ul>
     *
     *  A campaign can have list of stores or store groups where it can be applicable to.
     */
    class Campaign extends dw.object.ExtensibleObject {
      /**
       * Returns 'true' if the campaign is currently active, otherwise
       *  'false'.
       *  A campaign is active if it is enabled and scheduled for now.
       */
      readonly active: boolean;
      /**
       * Returns true if campaign is applicable to store, otherwise false.
       */
      readonly applicableInStore: boolean;
      /**
       * Returns true if campaign is applicable to online site, otherwise false.
       */
      readonly applicableOnline: boolean;
      /**
       * The coupons assigned to the campaign.
       */
      readonly coupons: dw.util.Collection<dw.campaign.Coupon>;
      /**
       * The customer groups assigned to the campaign.
       */
      readonly customerGroups: dw.util.Collection<dw.customer.CustomerGroup>;
      /**
       * The internal description of the campaign.
       */
      readonly description: string;
      /**
       * Returns true if campaign is enabled, otherwise false.
       */
      readonly enabled: boolean;
      /**
       * The end date of the campaign. If no end date is defined for the
       *  campaign, null is returned. A campaign w/o end date will run forever.
       */
      readonly endDate: Date;
      /**
       * The unique campaign ID.
       */
      readonly ID: string;
      /**
       * Returns promotions defined in this campaign in no particular order.
       */
      readonly promotions: dw.util.Collection<dw.campaign.Promotion>;
      /**
       * The source codes assigned to the campaign.
       */
      readonly sourceCodeGroups: dw.util.Collection<
        dw.campaign.SourceCodeGroup
      >;
      /**
       * The start date of the campaign. If no start date is defined for the
       *  campaign, null is returned. A campaign w/o start date is immediately
       *  effective.
       */
      readonly startDate: Date;
      /**
       * Returns store groups assigned to the campaign.
       */
      readonly storeGroups: dw.util.Collection<dw.catalog.StoreGroup>;
      /**
       * Returns stores assigned to the campaign.
       */
      readonly stores: dw.util.Collection<dw.catalog.Store>;

      /**
       * Returns the coupons assigned to the campaign.
       *
       * @return All coupons assigned to the campaign.
       */
      getCoupons(): dw.util.Collection<dw.campaign.Coupon>;
      /**
       * Returns the customer groups assigned to the campaign.
       *
       * @return Customer groups assigned to campaign.
       */
      getCustomerGroups(): dw.util.Collection<dw.customer.CustomerGroup>;
      /**
       * Returns the internal description of the campaign.
       *
       * @return Internal description of campaign.
       */
      getDescription(): string;
      /**
       * Returns the end date of the campaign. If no end date is defined for the
       *  campaign, null is returned. A campaign w/o end date will run forever.
       *
       * @return End date of campaign.
       */
      getEndDate(): Date;
      /**
       * Returns the unique campaign ID.
       *
       * @return ID of the campaign.
       */
      getID(): string;
      /**
       * Returns promotions defined in this campaign in no particular order.
       *
       * @return All promotions defined in campaign.
       */
      getPromotions(): dw.util.Collection<dw.campaign.Promotion>;
      /**
       * Returns the source codes assigned to the campaign.
       *
       * @return All source code groups assigned to campaign.
       */
      getSourceCodeGroups(): dw.util.Collection<dw.campaign.SourceCodeGroup>;
      /**
       * Returns the start date of the campaign. If no start date is defined for the
       *  campaign, null is returned. A campaign w/o start date is immediately
       *  effective.
       *
       * @return Start date of campaign.
       */
      getStartDate(): Date;
      /**
       * Returns store groups assigned to the campaign.
       *
       * @return All store groups assigned to the campaign.
       */
      getStoreGroups(): dw.util.Collection<dw.catalog.StoreGroup>;
      /**
       * Returns stores assigned to the campaign.
       *
       * @return All stores assigned to the campaign.
       */
      getStores(): dw.util.Collection<dw.catalog.Store>;
      /**
       * Returns 'true' if the campaign is currently active, otherwise
       *  'false'.
       *  A campaign is active if it is enabled and scheduled for now.
       *
       * @return true of campaign is active, otherwise false.
       */
      isActive(): boolean;
      /**
       * Returns true if campaign is applicable to store, otherwise false.
       *
       * @return true if campaign is applicable to store, otherwise false.
       */
      isApplicableInStore(): boolean;
      /**
       * Returns true if campaign is applicable to online site, otherwise false.
       *
       * @return true if campaign is applicable to online site, otherwise false.
       */
      isApplicableOnline(): boolean;
      /**
       * Returns true if campaign is enabled, otherwise false.
       *
       * @return true if campaign is enabled, otherwise false.
       */
      isEnabled(): boolean;
    }

    /**
     * CampaignMgr provides static methods for managing campaign-specific operations
     *  such as accessing promotions or updating promotion line items.
     */
    class CampaignMgr {
      /**
       * The enabled promotions of active campaigns applicable for the
       *  current customer and source code.
       *
       *  Note that this method does not return any coupon-based promotions.
       */
      static readonly applicablePromotions: dw.util.Collection<
        dw.campaign.Promotion
      >;

      /**
       * This method has been deprecated and should not be used anymore.
       *  Instead, use PromotionMgr to apply promotions to
       *  line item containers.
       *
       *  The method does nothing, since bonus promotions  are applied as product
       *  or order promotions using methods
       *  applyProductPromotions(LineItemCtnr, Collection) and
       *  applyOrderPromotions(LineItemCtnr, Collection).
       *
       *  The method returns 'true' if any the line item container contains
       *  any bonus product line items, and otherwise false.
       * @param lineItemCtnr Basket or order
       * @param promotions Parameter not used, can be null
       * @return True if line item container contains bonus product line items, else false
       */
      static applyBonusPromotions(
        lineItemCtnr: dw.order.LineItemCtnr,
        promotions: dw.util.Collection<any>
      ): boolean;
      /**
       * Applies the applicable order promotions in the specified collection to the
       *  specified line item container.
       *
       *  This method has been deprecated and should not be used anymore.
       *  Instead, use PromotionMgr to apply promotions to
       *  line item containers.
       *
       *  Note that the method does also apply any bonus discounts defined
       *  as order promotions (see also applyBonusPromotions(LineItemCtnr, Collection)).
       * @param lineItemCtnr basket or order
       * @param promotions list of all promotions to be applied
       * @return true if changes were made to the line item container, false otherwise.
       */
      static applyOrderPromotions(
        lineItemCtnr: dw.order.LineItemCtnr,
        promotions: dw.util.Collection<any>
      ): boolean;
      /**
       * Applies all applicable product promotions in the specified collection to the
       *  specified line item container.
       *
       *  This method has been deprecated and should not be used anymore.
       *  Instead, use PromotionMgr to apply promotions to
       *  line item containers.
       *
       *  Note that the method does also apply any bonus discounts defined
       *  as product promotions (see also applyBonusPromotions(LineItemCtnr, Collection)).
       * @param lineItemCtnr basket or order
       * @param promotions list of all promotions to be applied
       * @return true if changes were made to the line item container, false otherwise.
       */
      static applyProductPromotions(
        lineItemCtnr: dw.order.LineItemCtnr,
        promotions: dw.util.Collection<any>
      ): boolean;
      /**
       * Applies all applicable shipping promotions in the specified collection to
       *  the specified line item container.
       *
       *  This method has been deprecated and should not be used anymore.
       *  Instead, use PromotionMgr to apply promotions to
       *  line item containers.
       * @param lineItemCtnr basket or order
       * @param promotions list of all promotions to be applied
       * @return true if changes were made to the line item container, false otherwise.
       */
      static applyShippingPromotions(
        lineItemCtnr: dw.order.LineItemCtnr,
        promotions: dw.util.Collection<any>
      ): boolean;
      /**
       * Returns the enabled promotions of active campaigns applicable for the
       *  current customer and source code for which the specified product
       *  is a qualifiying product.
       *
       *  As a replacement of this deprecated method, use
       *  PromotionMgr.getActiveCustomerPromotions() and
       *  PromotionPlan.getProductPromotions(Product).
       *  Unlike getApplicableConditionalPromotions(Product),
       *  PromotionPlan.getProductPromotions(Product)
       *  returns all promotions related to the specified product, regardless
       *  of whether the product is qualifying, discounted, or both, and
       *  also returns promotions where the product is a bonus product.
       * @param product Qualifying product
       * @return List of active promotions
       */
      static getApplicableConditionalPromotions(
        product: dw.catalog.Product
      ): dw.util.Collection<dw.campaign.Promotion>;
      /**
       * Returns the enabled promotions of active campaigns applicable for the
       *  current customer and source code for which the specified product is
       *  a discounted product.
       *
       *  Note that this method does not return any coupon-based promotions.
       *
       *  As a replacement of this deprecated method, use
       *  PromotionMgr.getActiveCustomerPromotions() and
       *  PromotionPlan.getProductPromotions(Product).
       *  Unlike getApplicablePromotions(Product),
       *  PromotionPlan.getProductPromotions(Product)
       *  returns all promotions related to the specified product, regardless
       *  of whether the product is qualifying, discounted, or both, and
       *  also returns promotions where the product is a bonus product.
       * @param product The product whose promotions are returned.
       * @return A list of promotions
       */
      static getApplicablePromotions(
        product: dw.catalog.Product
      ): dw.util.Collection<dw.campaign.Promotion>;
      /**
       * Returns the enabled promotions of active campaigns applicable for the
       *  current customer, source code and any coupon contained in the specified
       *  line item container.
       *
       *  Note that although the method has been deprecated, no replacement
       *  method is provided.
       * @param lineItemCtnr the basket or order
       * @return list of all applicable promotion for the given basket or order
       */
      static getApplicablePromotions(
        lineItemCtnr: dw.order.LineItemCtnr
      ): dw.util.Collection<dw.campaign.Promotion>;
      /**
       * Returns the enabled promotions of active campaigns applicable for the
       *  current customer and source code.
       *
       *  Note that this method does not return any coupon-based promotions.
       *
       * @return List of active promotions
       */
      static getApplicablePromotions(): dw.util.Collection<
        dw.campaign.Promotion
      >;
      /**
       * Returns the campaign identified by the specified ID.
       * @param id Campaign ID
       * @return Campaign or null if not found
       */
      static getCampaignByID(id: string): dw.campaign.Campaign;
      /**
       * Returns the enabled promotions of active campaigns for which the
       *  specified product is a qualifiying product.
       *  Note that the method also returns coupon-based promotions.
       *
       *  As a replacement of this deprecated method, use
       *  PromotionMgr.getActiveCustomerPromotions() and
       *  PromotionPlan.getProductPromotions(Product).
       *  Unlike getConditionalPromotions(Product),
       *  PromotionPlan.getProductPromotions(Product)
       *  returns all promotions related to the specified product, regardless
       *  of whether the product is qualifying, discounted, or both, and
       *  also returns promotions where the product is a bonus product.
       * @param product The product whose conditional promotions are returned.
       * @return A list of promotions
       */
      static getConditionalPromotions(
        product: dw.catalog.Product
      ): dw.util.Collection<dw.campaign.Promotion>;
      /**
       * Returns the promotion associated with the specified coupon code.
       * @param couponCode The coupon code used to lookup the promotion
       * @return The resolved promotion object or null if none was found
       */
      static getPromotion(couponCode: string): dw.campaign.Promotion;
      /**
       * Returns the promotion associated with the specified coupon code.
       * @param couponCode Coupon code
       * @return The associated promotion or null
       */
      static getPromotionByCouponCode(
        couponCode: string
      ): dw.campaign.Promotion;
      /**
       * Returns the promotion identified by the specified ID.
       * @param id Promotion ID
       * @return Promotion or null if not found
       */
      static getPromotionByID(id: string): dw.campaign.Promotion;
      /**
       * Returns the enabled promotions of active campaigns for which the
       *  specified product is a discounted product.
       *  Note that method does only return promotions based on customer groups
       *  or source codes.
       *
       *  As a replacement of this deprecated method, use
       *  PromotionMgr.getActiveCustomerPromotions() and
       *  PromotionPlan.getProductPromotions(Product).
       *  Unlike getPromotions(Product),
       *  PromotionPlan.getProductPromotions(Product)
       *  returns all promotions related to the specified product, regardless
       *  of whether the product is qualifying, discounted, or both, and
       *  also returns promotions where the product is a bonus product.
       * @param product Discounted product
       * @return List of promotions
       */
      static getPromotions(
        product: dw.catalog.Product
      ): dw.util.Collection<dw.campaign.Promotion>;
    }

    /**
     * Deprecated. Formerly used to contain the various statuses that a coupon may
     *  be in.
     */
    class CampaignStatusCodes {
      /**
       * Indicates that the coupon has already been applied to the basket.
       */
      static readonly COUPON_ALREADY_APPLIED = "COUPON_ALREADY_APPLIED";
      /**
       * Indicates that the coupon has already been redeemed.
       */
      static readonly COUPON_ALREADY_REDEEMED = "COUPON_ALREADY_REDEEMED";
      /**
       * Indicates that the coupon is not currently redeemable.
       */
      static readonly COUPON_NOT_REDEEMABLE = "COUPON_NOT_REDEEMABLE";
      /**
       * Indicates that the coupon code is not valid.
       */
      static readonly COUPON_UNKNOWN = "COUPON_UNKNOWN";

      constructor();
    }

    /**
     * Represents a coupon in Commerce Cloud Digital.
     */
    class Coupon extends dw.object.PersistentObject {
      /**
       * Constant representing coupon type multiple-codes.
       */
      static readonly TYPE_MULTIPLE_CODES = "MULTIPLE_CODES";
      /**
       * Constant representing coupon type single-code.
       */
      static readonly TYPE_SINGLE_CODE = "SINGLE_CODE";
      /**
       * Constant representing coupon type system-codes.
       */
      static readonly TYPE_SYSTEM_CODES = "SYSTEM_CODES";

      /**
       * The prefix defined for coupons of type TYPE_SYSTEM_CODES
       *  If no prefix is defined, or coupon is of type TYPE_SINGLE_CODE
       *  or TYPE_MULTIPLE_CODES, null is returned.
       */
      readonly codePrefix: string;
      /**
       * Returns true if coupon is enabled, else false.
       */
      readonly enabled: boolean;
      /**
       * The ID of the coupon.
       */
      readonly ID: string;
      /**
       * The next unissued code of this coupon.
       *  For single-code coupons, the single fixed coupon code is returned.
       *  For all multi-code coupons, the next available, unissued coupon code is returned.
       *  If all codes of the coupon have been issued, then there is no next code, and null is returned.
       *
       *  A transaction is required when calling this method. This needs to be ensured by the calling script.
       */
      readonly nextCouponCode: string;
      /**
       * The coupon-based promotions directly or indirectly (through
       *  campaigns) assigned to this coupon.
       */
      readonly promotions: dw.util.Collection<dw.campaign.Promotion>;
      /**
       * The defined limit on redemption per coupon code. Null is
       *  returned if no limit is defined, which means that each code can be
       *  redeemed an unlimited number of times.
       */
      readonly redemptionLimitPerCode: number;
      /**
       * The defined limit on redemption of this coupon per customer.
       *  Null is returned if no limit is defined, which means that customers can
       *  redeem this coupon an unlimited number of times.
       */
      readonly redemptionLimitPerCustomer: number;
      /**
       * The defined limit on redemption per customer per time-frame (see
       *  getRedemptionLimitTimeFrame(). Null is returned if no limit is
       *  defined, which means that there is no time-specific redemption limit for
       *  customers.
       */
      readonly redemptionLimitPerTimeFrame: number;
      /**
       * The time-frame (in days) of the defined limit on redemption per
       *  customer per time-frame. Null is returned if no limit is defined, which
       *  means that there is no time-specific redemption limit for customers.
       */
      readonly redemptionLimitTimeFrame: number;
      /**
       * The coupon type.
       *  Possible values are TYPE_SINGLE_CODE, TYPE_MULTIPLE_CODES
       *  and TYPE_SYSTEM_CODES.
       */
      readonly type: string;

      /**
       * Returns the prefix defined for coupons of type TYPE_SYSTEM_CODES
       *  If no prefix is defined, or coupon is of type TYPE_SINGLE_CODE
       *  or TYPE_MULTIPLE_CODES, null is returned.
       *
       * @return Coupon code prefix or null
       */
      getCodePrefix(): string;
      /**
       * Returns the ID of the coupon.
       *
       * @return Coupon ID
       */
      getID(): string;
      /**
       * Returns the next unissued code of this coupon.
       *  For single-code coupons, the single fixed coupon code is returned.
       *  For all multi-code coupons, the next available, unissued coupon code is returned.
       *  If all codes of the coupon have been issued, then there is no next code, and null is returned.
       *
       *  A transaction is required when calling this method. This needs to be ensured by the calling script.
       *
       * @return Next available code of this coupon, or null if there are no available codes.
       */
      getNextCouponCode(): string;
      /**
       * Returns the coupon-based promotions directly or indirectly (through
       *  campaigns) assigned to this coupon.
       *
       * @return Promotions assigned to the coupon in no particular order.
       */
      getPromotions(): dw.util.Collection<dw.campaign.Promotion>;
      /**
       * Returns the defined limit on redemption per coupon code. Null is
       *  returned if no limit is defined, which means that each code can be
       *  redeemed an unlimited number of times.
       *
       * @return The maximum number of redemption per coupon code
       */
      getRedemptionLimitPerCode(): number;
      /**
       * Returns the defined limit on redemption of this coupon per customer.
       *  Null is returned if no limit is defined, which means that customers can
       *  redeem this coupon an unlimited number of times.
       *
       * @return The maximum number of redemption per customer
       */
      getRedemptionLimitPerCustomer(): number;
      /**
       * Returns the defined limit on redemption per customer per time-frame (see
       *  getRedemptionLimitTimeFrame(). Null is returned if no limit is
       *  defined, which means that there is no time-specific redemption limit for
       *  customers.
       *
       * @return The maximum number of redemption per customer within time-frame
       */
      getRedemptionLimitPerTimeFrame(): number;
      /**
       * Returns the time-frame (in days) of the defined limit on redemption per
       *  customer per time-frame. Null is returned if no limit is defined, which
       *  means that there is no time-specific redemption limit for customers.
       *
       * @return Timeframe (days) of redemption per time
       */
      getRedemptionLimitTimeFrame(): number;
      /**
       * Returns the coupon type.
       *  Possible values are TYPE_SINGLE_CODE, TYPE_MULTIPLE_CODES
       *  and TYPE_SYSTEM_CODES.
       *
       * @return Coupon type
       */
      getType(): string;
      /**
       * Returns true if coupon is enabled, else false.
       *
       * @return true if coupon is enabled.
       */
      isEnabled(): boolean;
    }

    /**
     * Manager to access coupons.
     */
    class CouponMgr {
      /**
       * Indicates that an error occurred because a valid data domain cannot be found for given siteID.
       */
      static readonly MR_ERROR_INVALID_SITE_ID =
        "MASKREDEMPTIONS_SITE_NOT_FOUND";

      /**
       * All coupons in the current site in no specific order.
       */
      static readonly coupons: dw.util.Collection<dw.campaign.Coupon>;

      /**
       * Returns the coupon with the specified ID.
       * @param couponID the coupon identifier.
       * @return Coupon with specified ID or null
       */
      static getCoupon(couponID: string): dw.campaign.Coupon;
      /**
       * Tries to find a coupon for the given coupon code. The method first
       *  searches for a coupon with a fixed code matching the passed value. If no
       *  such fixed coupon is found, it searches for a coupon with a
       *  system-generated code matching the passed value. If found, the coupon is
       *  returned. Otherwise, the method returns null.
       * @param couponCode The coupon code to get the coupon for.
       * @return The coupon with the matching coupon code or null if no coupon was found.
       */
      static getCouponByCode(couponCode: string): dw.campaign.Coupon;
      /**
       * Returns all coupons in the current site in no specific order.
       *
       * @return Coupons in current site
       */
      static getCoupons(): dw.util.Collection<dw.campaign.Coupon>;
      /**
       * Returns list of CouponRedemptions for the specified coupon and coupon code,
       *  sorted by redemption date descending (i.e. last redemption first).
       *  Usually, there should only either be 0 or 1 redemption. But if a coupon and code
       *  is removed and recreated and re-issued later, there might be multiple such redemption records.
       *  Returns an empty list if no redemption record exists in system for the specified coupon and code.
       * @param couponID The coupon id to find redemption for.
       * @param couponCode The coupon code to find redemption for.
       * @return A sorted list of CouponRedemptions for the specified coupon and coupon code or an empty list if no redemption record exists.
       */
      static getRedemptions(
        couponID: string,
        couponCode: string
      ): dw.util.Collection<dw.campaign.CouponRedemption>;
      /**
       * Mask customer email address in coupon redemptions for the given siteID and email address
       * @param siteID the site ID
       * @param email the customer email address
       * @return The status of the masking result
       */
      static maskRedemptions(siteID: string, email: string): dw.system.Status;
    }

    /**
     * Represents a redeemed coupon.
     */
    class CouponRedemption {
      /**
       * Returns email of redeeming customer.
       */
      readonly customerEmail: string;
      /**
       * Returns number of the order the code was redeemed with.
       */
      readonly orderNo: string;
      /**
       * Returns date of redemption.
       */
      readonly redemptionDate: Date;

      /**
       * Returns email of redeeming customer.
       *
       * @return email of redeeming customer.
       */
      getCustomerEmail(): string;
      /**
       * Returns number of the order the code was redeemed with.
       *
       * @return number of the order the code was redeemed with.
       */
      getOrderNo(): string;
      /**
       * Returns date of redemption.
       *
       * @return date of redemption.
       */
      getRedemptionDate(): Date;
    }

    /**
     * Helper class containing status codes for why a coupon code cannot be added
     *  to cart or why a coupon code already in cart is not longer valid for redemption.
     */
    class CouponStatusCodes {
      /**
       * Coupon is currently applied in basket = Coupon code is valid for redemption and
       *  Coupon is assigned to one or multiple applicable! promotions.
       */
      static readonly APPLIED = "APPLIED";
      /**
       * Indicates that another code of the same MultiCode/System coupon has already been added to basket.
       */
      static readonly COUPON_ALREADY_IN_BASKET = "COUPON_ALREADY_IN_BASKET";
      /**
       * Indicates that coupon code has already been added to basket.
       */
      static readonly COUPON_CODE_ALREADY_IN_BASKET =
        "COUPON_CODE_ALREADY_IN_BASKET";
      /**
       * Indicates that code of MultiCode/System coupon has already been redeemed.
       */
      static readonly COUPON_CODE_ALREADY_REDEEMED =
        "COUPON_CODE_ALREADY_REDEEMED";
      /**
       * Indicates that coupon not found for given coupon code or that the code itself was not found.
       */
      static readonly COUPON_CODE_UNKNOWN = "COUPON_CODE_UNKNOWN";
      /**
       * Indicates that coupon is not enabled.
       */
      static readonly COUPON_DISABLED = "COUPON_DISABLED";
      /**
       * Indicates that No. of redemptions per code & customer exceeded.
       */
      static readonly CUSTOMER_REDEMPTION_LIMIT_EXCEEDED =
        "CUSTOMER_REDEMPTION_LIMIT_EXCEEDED";
      /**
       * Indicates that coupon is not assigned to an active promotion.
       */
      static readonly NO_ACTIVE_PROMOTION = "NO_ACTIVE_PROMOTION";
      /**
       * Coupon is assigned to one or multiple active promotions, but none of these promotions is currently applicable.
       */
      static readonly NO_APPLICABLE_PROMOTION = "NO_APPLICABLE_PROMOTION";
      /**
       * Indicates that no. of redemptions per code exceeded.
       *  Usually happens for single code coupons
       */
      static readonly REDEMPTION_LIMIT_EXCEEDED = "REDEMPTION_LIMIT_EXCEEDED";
      /**
       * Indicates that No. of redemptions per code,customer & time exceeded.
       */
      static readonly TIMEFRAME_REDEMPTION_LIMIT_EXCEEDED =
        "TIMEFRAME_REDEMPTION_LIMIT_EXCEEDED";
    }

    /**
     * Superclass of all specific discount classes.
     */
    class Discount {
      /**
       * Constant representing discounts of type amount.
       */
      static readonly TYPE_AMOUNT = "AMOUNT";
      /**
       * Constant representing discounts of type bonus.
       */
      static readonly TYPE_BONUS = "BONUS";
      /**
       * Constant representing discounts of type bonus choice.
       */
      static readonly TYPE_BONUS_CHOICE = "BONUS_CHOICE";
      /**
       * Constant representing discounts of type fixed-price.
       */
      static readonly TYPE_FIXED_PRICE = "FIXED_PRICE";
      /**
       * Constant representing discounts of type fixed price shipping.
       */
      static readonly TYPE_FIXED_PRICE_SHIPPING = "FIXED_PRICE_SHIPPING";
      /**
       * Constant representing discounts of type free.
       */
      static readonly TYPE_FREE = "FREE";
      /**
       * Constant representing discounts of type free shipping.
       */
      static readonly TYPE_FREE_SHIPPING = "FREE_SHIPPING";
      /**
       * Constant representing discounts of type percentage.
       */
      static readonly TYPE_PERCENTAGE = "PERCENTAGE";
      /**
       * Constant representing discounts of type percent off options.
       */
      static readonly TYPE_PERCENTAGE_OFF_OPTIONS = "PERCENTAGE_OFF_OPTIONS";
      /**
       * Constant representing discounts of type price book price.
       */
      static readonly TYPE_PRICEBOOK_PRICE = "PRICE_BOOK_PRICE";
      /**
       * Constant representing discounts of type total fixed price.
       */
      static readonly TYPE_TOTAL_FIXED_PRICE = "TOTAL_FIXED_PRICE";

      /**
       * The tier index by quantity Id of Product promotion. ProductLineItems may have more than one quantity, but
       *  not all items of that SKU may have received the same tier of promotion. Each quantity of the ProductLineItem is
       *  indexed from 1 to n, where n is the quantity of the ProductLineItem, and this method returns a mapping from that
       *  quantity index to the index of tier of the promotion that item received. For more information about tier indexes,
       *  see getPromotionTier()  method.
       */
      readonly itemPromotionTiers: dw.util.Map<number, number>;
      /**
       * The promotion this discount is based on.
       */
      readonly promotion: dw.campaign.Promotion;
      /**
       * The tier index for promotion at order level or bonus product.
       *  Promotion tiers are always evaluated in the order of the highest threshold (e.g. quantity, or amount)
       *  to the lowest threshold. The tier that is evaluated first (i.e. the highest quantity or amount) is indexed as 0,
       *  the next tier 1, etc. The lowest tier will have index n - 1, where n is the total number of tiers.
       */
      readonly promotionTier: number;
      /**
       * The quantity of the discount. This quantity specifies how often
       *  this discount applies to its target object. For example, a 10% off
       *  discount with quantity 2 associated to a product line item with
       *  quantity 3 is applied to two items of the product line item.
       *  Discounts of order and shipping promotions, and bonus discounts
       *  have a fix quantity of 1.
       */
      readonly quantity: number;
      /**
       * The type of the discount.
       */
      readonly type: string;

      /**
       * Returns the tier index by quantity Id of Product promotion. ProductLineItems may have more than one quantity, but
       *  not all items of that SKU may have received the same tier of promotion. Each quantity of the ProductLineItem is
       *  indexed from 1 to n, where n is the quantity of the ProductLineItem, and this method returns a mapping from that
       *  quantity index to the index of tier of the promotion that item received. For more information about tier indexes,
       *  see getPromotionTier()  method.
       *
       * @return Map of Tier index by quantity Id or empty map
       */
      getItemPromotionTiers(): dw.util.Map<number, number>;
      /**
       * Returns the promotion this discount is based on.
       *
       * @return Promotion related to this discount
       */
      getPromotion(): dw.campaign.Promotion;
      /**
       * Returns the tier index for promotion at order level or bonus product.
       *  Promotion tiers are always evaluated in the order of the highest threshold (e.g. quantity, or amount)
       *  to the lowest threshold. The tier that is evaluated first (i.e. the highest quantity or amount) is indexed as 0,
       *  the next tier 1, etc. The lowest tier will have index n - 1, where n is the total number of tiers.
       *
       * @return Tier index or null
       */
      getPromotionTier(): number;
      /**
       * Returns the quantity of the discount. This quantity specifies how often
       *  this discount applies to its target object. For example, a 10% off
       *  discount with quantity 2 associated to a product line item with
       *  quantity 3 is applied to two items of the product line item.
       *  Discounts of order and shipping promotions, and bonus discounts
       *  have a fix quantity of 1.
       *
       * @return Discount quantity
       */
      getQuantity(): number;
      /**
       * Returns the type of the discount.
       *
       * @return Discount type
       */
      getType(): string;
    }

    /**
     * DiscountPlan represents a set of <a href="class_dw_campaign_Discount.html">Discount</a>s. Instances of the class are
     *  returned by the <a href="class_dw_campaign_PromotionMgr.html">PromotionMgr</a> when requesting applicable discounts
     *  for a specified set of promotions and a line item container
     *  (see <a href="class_dw_campaign_PromotionMgr.html#dw_campaign_PromotionMgr_getDiscounts_LineItemCtnr_PromotionPlan_DetailAnchor">PromotionMgr.getDiscounts(LineItemCtnr, PromotionPlan)</a>).
     *  <p>
     *  DiscountPlan provides methods to access the discounts contained in the plan,
     *  add additional discounts to the plan (future) or remove discounts from the plan.</p>
     */
    class DiscountPlan {
      /**
       * Get the collection of order discounts that the LineItemCtnr "almost"
       *  qualifies for based on the merchandise total in the cart. Nearness is
       *  controlled by thresholds configured at the promotion level.
       *
       *  The collection of returned approaching discounts is ordered by the
       *  condition threshold of the promotion (e.g. "spend $100 and get 10% off"
       *  discount is returned before "spend $150 and get 15% off" discount.) A
       *  discount is not returned if it would be prevented from applying (because
       *  of compatibility rules) by an order discount already in the DiscountPlan
       *  or an approaching order discount with a lower condition threshold.
       */
      readonly approachingOrderDiscounts: dw.util.Collection<
        dw.campaign.Discount
      >;
      /**
       * All bonus discounts contained in the discount plan.
       */
      readonly bonusDiscounts: dw.util.Collection<dw.campaign.BonusDiscount>;
      /**
       * Returns line item container associated with discount plan.
       *  A discount plan is created from and associated with a line item container.
       *  This method returns the line item container associated with this discount plan.
       */
      readonly lineItemCtnr: dw.order.LineItemCtnr;
      /**
       * The percentage and amount order discounts contained in the
       *  discount plan.
       */
      readonly orderDiscounts: dw.util.Collection<dw.campaign.Discount>;

      /**
       * Get the collection of order discounts that the LineItemCtnr "almost"
       *  qualifies for based on the merchandise total in the cart. Nearness is
       *  controlled by thresholds configured at the promotion level.
       *
       *  The collection of returned approaching discounts is ordered by the
       *  condition threshold of the promotion (e.g. "spend $100 and get 10% off"
       *  discount is returned before "spend $150 and get 15% off" discount.) A
       *  discount is not returned if it would be prevented from applying (because
       *  of compatibility rules) by an order discount already in the DiscountPlan
       *  or an approaching order discount with a lower condition threshold.
       *
       * @return Collection of approaching order discounts ordered by the condition threshold of the promotion ascending.
       */
      getApproachingOrderDiscounts(): dw.util.Collection<dw.campaign.Discount>;
      /**
       * Get the collection of shipping discounts that the passed shipment
       *  "almost" qualifies for based on the merchandise total in the shipment.
       *  Nearness is controlled by thresholds configured at the promotion level.
       *
       *  The collection of returned approaching discounts is ordered by the
       *  condition threshold of the promotion (e.g.
       *  "spend $100 and get free standard shipping" discount is returned before
       *  "spend $150 and get free standard shipping" discount.) A discount is not
       *  returned if it would be prevented from applying (because of compatibility
       *  rules) by a shipping discount already in the DiscountPlan or an
       *  approaching shipping discount with a lower condition threshold.
       * @param shipment The shipment to calculate approaching discounts for.
       * @return Collection of approaching shipping discounts ordered by the condition threshold of the promotion ascending.
       */
      getApproachingShippingDiscounts(
        shipment: dw.order.Shipment
      ): dw.util.Collection<dw.campaign.Discount>;
      /**
       * Get the collection of shipping discounts that the passed shipment
       *  "almost" qualifies for based on the merchandise total in the shipment.
       *  Here "almost" is controlled by thresholds configured at the promotion
       *  level.
       *
       *  This method only returns discounts for shipping promotions which apply to
       *  the passed shipping method.
       *
       *  The collection of returned approaching discounts is ordered by the
       *  condition threshold of the promotion (e.g.
       *  "spend $100 and get free standard shipping" discount is returned before
       *  "spend $150 and get free standard shipping" discount.) A discount is not
       *  returned if it would be prevented from applying (because of compatibility
       *  rules) by a shipping discount already in the DiscountPlan or an
       *  approaching shipping discount with a lower condition threshold.
       * @param shipment The shipment to calculate approaching discounts for.
       * @param shippingMethod The shipping method to filter by.
       * @return Collection of approaching shipping discounts ordered by the condition threshold of the promotion, ascending.
       */
      getApproachingShippingDiscounts(
        shipment: dw.order.Shipment,
        shippingMethod: dw.order.ShippingMethod
      ): dw.util.Collection<dw.campaign.Discount>;
      /**
       * Get the collection of shipping discounts that the passed shipment
       *  "almost" qualifies for based on the merchandise total in the shipment.
       *  Here "almost" is controlled by thresholds configured at the promotion
       *  level.
       *
       *  This method only returns discounts for shipping promotions which apply to
       *  one of the passed shipping methods.
       *
       *  The collection of returned approaching discounts is ordered by the
       *  condition threshold of the promotion (e.g.
       *  "spend $100 and get free standard shipping" discount is returned before
       *  "spend $150 and get free standard shipping" discount.) A discount is not
       *  returned if it would be prevented from applying (because of compatibility
       *  rules) by a shipping discount already in the DiscountPlan or an
       *  approaching shipping discount with a lower condition threshold.
       * @param shipment The shipment to calculate approaching discounts for.
       * @param shippingMethods The shipping methods to filter by.
       * @return Collection of approaching shipping discounts ordered by the condition threshold of the promotion ascending.
       */
      getApproachingShippingDiscounts(
        shipment: dw.order.Shipment,
        shippingMethods: dw.util.Collection<any>
      ): dw.util.Collection<dw.campaign.Discount>;
      /**
       * Returns all bonus discounts contained in the discount plan.
       *
       * @return All bonus discounts contained in discount plan
       */
      getBonusDiscounts(): dw.util.Collection<dw.campaign.BonusDiscount>;
      /**
       * Returns line item container associated with discount plan.
       *  A discount plan is created from and associated with a line item container.
       *  This method returns the line item container associated with this discount plan.
       *
       * @return Line item container associated with plan
       */
      getLineItemCtnr(): dw.order.LineItemCtnr;
      /**
       * Returns the percentage and amount order discounts contained in the
       *  discount plan.
       *
       * @return Order discounts contained in the discount plan
       */
      getOrderDiscounts(): dw.util.Collection<dw.campaign.Discount>;
      /**
       * Returns the percentage, amount and fix price discounts associated
       *  with the specified product line item. If the specified product line
       *  item is not contained in the discount plan, an empty collection is
       *  returned.
       * @param productLineItem Product line item
       * @return Discounts associated with specified product line item
       */
      getProductDiscounts(
        productLineItem: dw.order.ProductLineItem
      ): dw.util.Collection<dw.campaign.Discount>;
      /**
       * Returns the product-shipping discounts associated with the specified
       *  product line item. If the specified product line item is not contained in
       *  the discount plan, an empty collection is returned.
       * @param productLineItem Product line item
       * @return Product-shipping discounts associated with specified product line item
       */
      getProductShippingDiscounts(
        productLineItem: dw.order.ProductLineItem
      ): dw.util.Collection<dw.campaign.Discount>;
      /**
       * Returns the percentage, amount and fix price discounts associated with
       *  the specified shipment. If the specified shipment is not contained in
       *  the discount plan, an empty collection is returned.
       * @param shipment the shipment for which to fetch discounts.
       * @return Discounts associated with specified shipment
       */
      getShippingDiscounts(
        shipment: dw.order.Shipment
      ): dw.util.Collection<dw.campaign.Discount>;
      /**
       * Removes the specified discount from the discount plan.
       *
       *  This method should only be used for very simple discount scenarios. It
       *  is not recommended to use the method in case of stacked discounts
       *  (i.e. multiple order or product discounts), or complex discount types
       *  like Buy X Get Y or Total Fixed Price, since correct re-calculation of the
       *  discount plan based on the promotion rules is not guaranteed.
       * @param discount Discount to be removed
       */
      removeDiscount(discount: dw.campaign.Discount): void;
    }

    /**
     * Represents a <i>fix price</i> discount in the discount plan, for example
     *  &quot;Shipping only 0.99 all orders $25 or more.&quot;
     */
    class FixedPriceDiscount extends dw.campaign.Discount {
      /**
       * The fixed price amount, for example 0.99 for a "Shipping only $0.99"
       *  discount.
       */
      readonly fixedPrice: number;

      /**
       * Create a fixed-price-discount on the fly. Can be used to create a custom price adjustment.
       * @param amount fixed price e.g. 10.00
       */
      constructor(amount: number);

      /**
       * Returns the fixed price amount, for example 0.99 for a "Shipping only $0.99"
       *  discount.
       *
       * @return Fixed price amount
       */
      getFixedPrice(): number;
    }

    /**
     * Represents a <i>fixed price shipping</i> discount in the discount plan, for
     *  example &quot;Shipping only 0.99 for iPods.&quot;
     */
    class FixedPriceShippingDiscount extends dw.campaign.Discount {
      /**
       * The fixed price amount, for example 0.99 for a "Shipping only $0.99"
       *  discount.
       */
      readonly fixedPrice: number;

      /**
       * Create a fixed-price-shipping-discount on the fly. Can be used to create a custom price adjustment.
       * @param amount fixed price for shipping e.g. 10.00
       */
      constructor(amount: number);

      /**
       * Returns the fixed price amount, for example 0.99 for a "Shipping only $0.99"
       *  discount.
       *
       * @return Fixed price amount
       */
      getFixedPrice(): number;
    }

    /**
     * Represents a <i>free</i> discount in the discount plan, for example
     *  &quot;Free shipping on all orders $25 or more.&quot;
     */
    class FreeDiscount extends dw.campaign.Discount {}

    /**
     * Represents a <i>free shipping</i> discount in the discount plan, for example
     *  &quot;Free shipping on all iPods.&quot;
     */
    class FreeShippingDiscount extends dw.campaign.Discount {}

    /**
     * Represents a <i>percentage-off</i> discount in the discount plan, for example
     *  &quot;10% off all T-Shirts&quot;.
     */
    class PercentageDiscount extends dw.campaign.Discount {
      /**
       * The percentage discount value, for example 10.00 for a "10% off"
       *  discount.
       */
      readonly percentage: number;

      /**
       * Create a percentage-discount on the fly. Can be used to create a custom price adjustment.
       * @param percentage percentage value, e.g. 15.00 for 15%
       */
      constructor(percentage: number);

      /**
       * Returns the percentage discount value, for example 10.00 for a "10% off"
       *  discount.
       *
       * @return Discount percentage value
       */
      getPercentage(): number;
    }

    /**
     * Represents a <i>percentage-off options</i> discount in the discount plan, for
     *  example &quot;50% off monogramming on shirts&quot;.
     */
    class PercentageOptionDiscount extends dw.campaign.Discount {
      /**
       * The percentage discount value, for example 10.00 for a "10% off"
       *  discount.
       */
      readonly percentage: number;

      /**
       * Returns the percentage discount value, for example 10.00 for a "10% off"
       *  discount.
       *
       * @return Discount percentage value
       */
      getPercentage(): number;
    }

    /**
     * Discount representing that a product&apos;s price has been calculated from a
     *  separate sales price book other than the standard price book assigned to the
     *  site.
     */
    class PriceBookPriceDiscount extends dw.campaign.Discount {
      /**
       * The price book identifier.
       */
      readonly priceBookID: string;

      /**
       * Returns the price book identifier.
       *
       * @return the price book identifier.
       */
      getPriceBookID(): string;
    }

    /**
     * This class represents a promotion in Commerce Cloud Digital. Examples of
     *  promotions include:
     *
     *  <ul>
     *  <li>&quot;Get 20% off your order&quot;</li>
     *  <li>&quot;$15 off a given product&quot;</li>
     *  <li>&quot;free shipping for all orders over $50&quot;</li>
     *  <li>Get a bonus product with purchase of another product</li>
     *  </ul>
     *
     *  The Promotion class provides access to the basic attributes of the promotion
     *  such as name, callout message, and description, but the details of the
     *  promotion rules are not available in the API due to their complexity.
     *  <p>
     *  Commerce Cloud Digital allows merchants to create a single logical &quot;promotion
     *  rule&quot; (e.g. &quot;Get 20% off your order&quot;) and then assign it to one or more
     *  &quot;containers&quot; where the supported container types are campaigns or AB-tests. A
     *  Promotion represents a specific instance of a promotion rule assigned to a
     *  container. Promotion rules themselves that are not assigned to any container
     *  are inaccessible through the API. Each instance (i.e. assignment) can have
     *  separate &quot;qualifiers&quot;. Qualifiers are the customer groups, source code
     *  groups, or coupons that trigger a given promotion for a customer.</p>
     */
    class Promotion extends dw.object.ExtensibleObject {
      /**
       * Constant representing promotion exclusivity of type class.
       */
      static readonly EXCLUSIVITY_CLASS = "CLASS";
      /**
       * Constant representing promotion exclusivity of type global.
       */
      static readonly EXCLUSIVITY_GLOBAL = "GLOBAL";
      /**
       * Constant representing promotion exclusivity of type no.
       */
      static readonly EXCLUSIVITY_NO = "NO";
      /**
       * Constant representing promotion class of type order.
       */
      static readonly PROMOTION_CLASS_ORDER = "ORDER";
      /**
       * Constant representing promotion class of type product.
       */
      static readonly PROMOTION_CLASS_PRODUCT = "PRODUCT";
      /**
       * Constant representing promotion class of type shipping.
       */
      static readonly PROMOTION_CLASS_SHIPPING = "SHIPPING";
      /**
       * Constant indicating that that all qualifier conditions must be met in
       *  order for this promotion to apply for a given customer.
       */
      static readonly QUALIFIER_MATCH_MODE_ALL = "all";
      /**
       * Constant indicating that that at least one qualifier condition must be
       *  met in order for this promotion to apply for a given customer.
       */
      static readonly QUALIFIER_MATCH_MODE_ANY = "any";

      /**
       * Returns 'true' if promotion is active, otherwise 'false'.
       *  A promotion is active if its campaign is active, and the promotion
       *  is enabled, and it is scheduled for now.
       */
      readonly active: boolean;
      /**
       * Returns 'true' if the promotion is triggered by a coupon,
       *  false otherwise.
       */
      readonly basedOnCoupon: boolean;
      /**
       * Returns 'true' if the promotion is triggered by coupons,
       *  false otherwise.
       */
      readonly basedOnCoupons: boolean;
      /**
       * Returns 'true' if the promotion is triggered by customer groups,
       *  false otherwise.
       */
      readonly basedOnCustomerGroups: boolean;
      /**
       * Returns 'true' if the promotion is triggered by source codes,
       *  false otherwise.
       */
      readonly basedOnSourceCodes: boolean;
      /**
       * The callout message of the promotion.
       */
      readonly calloutMsg: dw.content.MarkupText;
      /**
       * The campaign this particular instance of the promotion is defined
       *  in.
       *
       *  Note: If this promotion is defined as part of an AB-test, then a Campaign
       *  object will be returned, but it is a mock implementation, and not a true
       *  Campaign. This behavior is required for backwards compatibility and
       *  should not be relied upon as it may change in future releases.
       */
      readonly campaign: dw.campaign.Campaign;
      /**
       * The promotion's combinable promotions. Combinable promotions is a set of promotions or groups this
       *  promotion can be combined with.
       */
      readonly combinablePromotions: string;
      /**
       * A description of the condition that must be met for this
       *  promotion to be applicable.
       *
       *  The method and the related attribute have been deprecated. Use the
       *  getDetails() method instead.
       */
      readonly conditionalDescription: dw.content.MarkupText;
      /**
       * The coupons directly assigned to the promotion or assigned to the campaign of the promotion.
       *  If the promotion is not based on coupons (see isBasedOnCoupons()), or no coupons is assigned to the
       *  promotion or its campaign, an empty collection is returned.
       */
      readonly coupons: dw.util.Collection<dw.campaign.Coupon>;
      /**
       * The custom attributes for this extensible object.
       */
      readonly custom: PromotionCustomAttributes;
      /**
       * The customer groups directly assigned to the promotion or assigned to the campaign of the promotion.
       *  If the promotion is not based on customer groups (see isBasedOnCustomerGroups()), or no customer group is assigned to the
       *  promotion or its campaign, an empty collection is returned.
       */
      readonly customerGroups: dw.util.Collection<dw.customer.CustomerGroup>;
      /**
       * The description of the promotion.
       *
       *  Method is deprecated and returns the same value as getCalloutMsg().
       */
      readonly description: dw.content.MarkupText;
      /**
       * The detailed description of the promotion.
       */
      readonly details: dw.content.MarkupText;
      /**
       * Returns true if promotion is enabled, otherwise false.
       */
      readonly enabled: boolean;
      /**
       * The effective end date of this instance of the promotion. If no
       *  explicit end date is defined for the promotion, the end date of the
       *  containing Campaign or AB-test is returned.
       */
      readonly endDate: Date;
      /**
       * The promotion's exclusivity specifying how the promotion can be
       *  combined with other promotions.
       *  Possible values are EXCLUSIVITY_NO, EXCLUSIVITY_CLASS
       *  and EXCLUSIVITY_GLOBAL.
       */
      readonly exclusivity: string;
      /**
       * The unique ID of the promotion.
       */
      readonly ID: string;
      /**
       * The reference to the promotion image.
       */
      readonly image: dw.content.MediaFile;
      /**
       * The date that this object was last modified.
       */
      readonly lastModified: Date;
      /**
       * The promotion's mutually exclusive Promotions. Mutually exclusive Promotions is a set of promotions or
       *  groups this promotion cannot be combined with.
       */
      readonly mutuallyExclusivePromotions: string;
      /**
       * The name of the promotion.
       */
      readonly name: string;
      /**
       * The promotion class indicating the general type of the promotion.
       *  Possible values are PROMOTION_CLASS_PRODUCT,
       *  PROMOTION_CLASS_ORDER, and PROMOTION_CLASS_SHIPPING.
       */
      readonly promotionClass: string;
      /**
       * The qualifier matching mode specified by this promotion. A
       *  promotion may have up to 3 qualifier conditions based on whether it is
       *  customer-group based, coupon based, and/or source-code based. A promotion
       *  may require for example that a customer belong to a certain customer
       *  group and also have a certain coupon in the cart in order for the
       *  promotion to apply. This method returns QUALIFIER_MATCH_MODE_ALL if it is
       *  necessary that all the qualifier conditions are satisfied in order for
       *  this promotion to apply for a given customer. Otherwise, this method
       *  returns QUALIFIER_MATCH_MODE_ANY indicating that at least of the
       *  qualifier conditions must be satisfied.
       *
       *  Note: currently QUALIFIER_MATCH_MODE_ALL is only supported for promotions
       *  assigned to campaigns, and not those assigned to AB-tests.
       */
      readonly qualifierMatchMode: string;
      /**
       * The promotion's rank. Rank is a numeric attribute that you can specify.
       *  Promotions with a defined rank are calculated before promotions without a defined rank.
       *  If two promotions have a rank, the one with the lowest rank is calculated first.
       *  For example, a promotion with rank 10 is calculated before one with rank 30.
       */
      readonly rank: number;
      /**
       * Returns true if promotion is refinable, otherwise false.
       */
      readonly refinable: boolean;
      /**
       * The source code groups directly assigned to the promotion or assigned to the campaign of the promotion.
       *  If the promotion is not based on source code groups (see isBasedOnSourceCodes()), or no source code group is assigned to the
       *  promotion or its campaign, an empty collection is returned.
       */
      readonly sourceCodeGroups: dw.util.Collection<
        dw.campaign.SourceCodeGroup
      >;
      /**
       * The effective start date of this instance of the promotion. If no
       *  explicit start date is defined for this instance, the start date of the
       *  containing Campaign or AB-test is returned.
       */
      readonly startDate: Date;
      /**
       * The promotion's tags. Tags are a way of categorizing and organizing promotions. A promotion can have many
       *  tags. Tags will be returned in alphabetical order.
       */
      readonly tags: string;

      /**
       * Returns the callout message of the promotion.
       *
       * @return Callout message of the promotion.
       */
      getCalloutMsg(): dw.content.MarkupText;
      /**
       * Returns the campaign this particular instance of the promotion is defined
       *  in.
       *
       *  Note: If this promotion is defined as part of an AB-test, then a Campaign
       *  object will be returned, but it is a mock implementation, and not a true
       *  Campaign. This behavior is required for backwards compatibility and
       *  should not be relied upon as it may change in future releases.
       *
       * @return Campaign of the promotion.
       */
      getCampaign(): dw.campaign.Campaign;
      /**
       * Returns the promotion's combinable promotions. Combinable promotions is a set of promotions or groups this
       *  promotion can be combined with.
       *
       * @return The promotion's set of combinable promotions.
       */
      getCombinablePromotions(): String[];
      /**
       * Returns a description of the condition that must be met for this
       *  promotion to be applicable.
       *
       *  The method and the related attribute have been deprecated. Use the
       *  getDetails() method instead.
       *
       * @return Condition promotion description.
       */
      getConditionalDescription(): dw.content.MarkupText;
      /**
       * Returns the coupons directly assigned to the promotion or assigned to the campaign of the promotion.
       *  If the promotion is not based on coupons (see isBasedOnCoupons()), or no coupons is assigned to the
       *  promotion or its campaign, an empty collection is returned.
       *
       * @return Coupons assigned to promotion in no particular order.
       */
      getCoupons(): dw.util.Collection<dw.campaign.Coupon>;
      /**
       * Returns the custom attributes for this extensible object.
       *
       */
      getCustom(): PromotionCustomAttributes;
      /**
       * Returns the customer groups directly assigned to the promotion or assigned to the campaign of the promotion.
       *  If the promotion is not based on customer groups (see isBasedOnCustomerGroups()), or no customer group is assigned to the
       *  promotion or its campaign, an empty collection is returned.
       *
       * @return Customer groups assigned to promotion in no particular order.
       */
      getCustomerGroups(): dw.util.Collection<dw.customer.CustomerGroup>;
      /**
       * Returns the description of the promotion.
       *
       *  Method is deprecated and returns the same value as getCalloutMsg().
       *
       * @return Description of the promotion.
       */
      getDescription(): dw.content.MarkupText;
      /**
       * Returns the detailed description of the promotion.
       *
       * @return Detailed promotion description.
       */
      getDetails(): dw.content.MarkupText;
      /**
       * Returns the effective end date of this instance of the promotion. If no
       *  explicit end date is defined for the promotion, the end date of the
       *  containing Campaign or AB-test is returned.
       *
       * @return End date of the promotion, or null if no end date is defined.
       */
      getEndDate(): Date;
      /**
       * Returns the promotion's exclusivity specifying how the promotion can be
       *  combined with other promotions.
       *  Possible values are EXCLUSIVITY_NO, EXCLUSIVITY_CLASS
       *  and EXCLUSIVITY_GLOBAL.
       *
       * @return Promotion exclusivity
       */
      getExclusivity(): string;
      /**
       * Returns the unique ID of the promotion.
       *
       * @return ID of the promotion.
       */
      getID(): string;
      /**
       * Returns the reference to the promotion image.
       *
       * @return Image of the promotion.
       */
      getImage(): dw.content.MediaFile;
      /**
       * Returns the date that this object was last modified.
       *
       * @return the date that this object was last modified.
       */
      getLastModified(): Date;
      /**
       * Returns the promotion's mutually exclusive Promotions. Mutually exclusive Promotions is a set of promotions or
       *  groups this promotion cannot be combined with.
       *
       * @return The promotion's set of mutually exclusive Promotions.
       */
      getMutuallyExclusivePromotions(): String[];
      /**
       * Returns the name of the promotion.
       *
       * @return Name of the promotion.
       */
      getName(): string;
      /**
       * Returns the promotional price for the specified product. The promotional
       *  price is only returned if the following conditions are met:
       *
       *
       *  this promotion is a product promotion without purchase conditions,
       *  i.e. is of type 'Without qualifying products'.
       *  this promotion's discount is Discount.TYPE_AMOUNT,
       *  Discount.TYPE_PERCENTAGE, Discount.TYPE_FIXED_PRICE, or
       *  Discount.TYPE_PRICEBOOK_PRICE.
       *  specified product is one of the discounted products of the
       *  promotion.
       *  the product has a valid sales price for quantity 1.0.
       *
       *
       *  In all other cases, the method will return Money.NOT_AVAILABLE. It is
       *  not required that this promotion be an active customer
       *  promotion.
       *
       *  NOTE: the method might be extended in the future to support more
       *  promotion types.
       *
       *  To calculate the promotional price, the method uses the current sales
       *  price of the product for quantity 1.0, and applies the discount
       *  associated with the promotion to this price. For example, if the product
       *  price is $14.99, and the promotion discount is 10%, the method will
       *  return $13.49. If the discount is $2 off, the method will return $12.99.
       *  If the discount is $10.00 fixed price, the method will return $10.00.
       * @param product the product to calculate the discount for
       * @return the price of the passed product after promotional discount is applied, or Money.NOT_AVAILABLE if any of the restrictions on product or promotion are not met.
       */
      getPromotionalPrice(product: dw.catalog.Product): dw.value.Money;
      /**
       * This method follows the same logic as
       *  getPromotionalPrice(Product) but prices are calculated based
       *  on the option values selected in the specified option model.
       * @param product the product to calculate the discount for
       * @param optionModel the option model to use when calculating
       * @return the price of the passed product after promotional discount is applied, or Money.NOT_AVAILABLE if any of the restrictions on product or promotion are not met.
       */
      getPromotionalPrice(
        product: dw.catalog.Product,
        optionModel: dw.catalog.ProductOptionModel
      ): dw.value.Money;
      /**
       * Returns the promotion class indicating the general type of the promotion.
       *  Possible values are PROMOTION_CLASS_PRODUCT,
       *  PROMOTION_CLASS_ORDER, and PROMOTION_CLASS_SHIPPING.
       *
       * @return Promotion class or null if the promotion rule has not been configured.
       */
      getPromotionClass(): string;
      /**
       * Returns the qualifier matching mode specified by this promotion. A
       *  promotion may have up to 3 qualifier conditions based on whether it is
       *  customer-group based, coupon based, and/or source-code based. A promotion
       *  may require for example that a customer belong to a certain customer
       *  group and also have a certain coupon in the cart in order for the
       *  promotion to apply. This method returns QUALIFIER_MATCH_MODE_ALL if it is
       *  necessary that all the qualifier conditions are satisfied in order for
       *  this promotion to apply for a given customer. Otherwise, this method
       *  returns QUALIFIER_MATCH_MODE_ANY indicating that at least of the
       *  qualifier conditions must be satisfied.
       *
       *  Note: currently QUALIFIER_MATCH_MODE_ALL is only supported for promotions
       *  assigned to campaigns, and not those assigned to AB-tests.
       *
       * @return the qualifier matching mode specified by this promotion, either QUALIFIER_MATCH_MODE_ALL or QUALIFIER_MATCH_MODE_ANY.
       */
      getQualifierMatchMode(): string;
      /**
       * Returns the promotion's rank. Rank is a numeric attribute that you can specify.
       *  Promotions with a defined rank are calculated before promotions without a defined rank.
       *  If two promotions have a rank, the one with the lowest rank is calculated first.
       *  For example, a promotion with rank 10 is calculated before one with rank 30.
       *
       * @return The promotion's rank.
       */
      getRank(): number;
      /**
       * Returns the source code groups directly assigned to the promotion or assigned to the campaign of the promotion.
       *  If the promotion is not based on source code groups (see isBasedOnSourceCodes()), or no source code group is assigned to the
       *  promotion or its campaign, an empty collection is returned.
       *
       * @return Source code groups assigned to promotion in no particular order.
       */
      getSourceCodeGroups(): dw.util.Collection<dw.campaign.SourceCodeGroup>;
      /**
       * Returns the effective start date of this instance of the promotion. If no
       *  explicit start date is defined for this instance, the start date of the
       *  containing Campaign or AB-test is returned.
       *
       * @return Start date of the promotion, or null if no start date is defined.
       */
      getStartDate(): Date;
      /**
       * Returns the promotion's tags. Tags are a way of categorizing and organizing promotions. A promotion can have many
       *  tags. Tags will be returned in alphabetical order.
       *
       * @return The promotion's set of tags.
       */
      getTags(): String[];
      /**
       * Returns 'true' if promotion is active, otherwise 'false'.
       *  A promotion is active if its campaign is active, and the promotion
       *  is enabled, and it is scheduled for now.
       *
       * @return true if promotion is active, otherwise false.
       */
      isActive(): boolean;
      /**
       * Returns 'true' if the promotion is triggered by a coupon,
       *  false otherwise.
       *
       * @return true if promotion is triggered by coupon, otherwise false.
       */
      isBasedOnCoupon(): boolean;
      /**
       * Returns 'true' if the promotion is triggered by coupons,
       *  false otherwise.
       *
       * @return true if promotion is triggered by coupons, otherwise false.
       */
      isBasedOnCoupons(): boolean;
      /**
       * Returns 'true' if the promotion is triggered by customer groups,
       *  false otherwise.
       *
       * @return true if promotion is triggered by customer groups, otherwise false.
       */
      isBasedOnCustomerGroups(): boolean;
      /**
       * Returns 'true' if the promotion is triggered by source codes,
       *  false otherwise.
       *
       * @return true if promotion is triggered by source codes, otherwise false.
       */
      isBasedOnSourceCodes(): boolean;
      /**
       * Returns true if promotion is enabled, otherwise false.
       *
       * @return true if promotion is enabled, otherwise false.
       */
      isEnabled(): boolean;
      /**
       * Returns true if promotion is refinable, otherwise false.
       *
       * @return true if promotion is refinable, otherwise false.
       */
      isRefinable(): boolean;
    }

    /**
     * <a href="class_dw_campaign_PromotionMgr.html">PromotionMgr</a> is used to access campaigns and promotion
     *  definitions, display active or upcoming promotions in a storefront, and to
     *  calculate and apply promotional discounts to line item containers.
     *  <p>
     *  To access campaign and promotion definitions, use methods
     *  <a href="class_dw_campaign_PromotionMgr.html#dw_campaign_PromotionMgr_getCampaigns_DetailAnchor">getCampaigns()</a>, <a href="class_dw_campaign_PromotionMgr.html#dw_campaign_PromotionMgr_getCampaign_String_DetailAnchor">getCampaign(String)</a>,
     *  <a href="class_dw_campaign_PromotionMgr.html#dw_campaign_PromotionMgr_getPromotions_DetailAnchor">getPromotions()</a> and <a href="class_dw_campaign_PromotionMgr.html#dw_campaign_PromotionMgr_getPromotion_String_DetailAnchor">getPromotion(String)</a>.
     *  </p><p>
     *  To display active or upcoming promotions in the storefront, e.g. on product
     *  pages, various methods are provided. <a href="class_dw_campaign_PromotionMgr.html#dw_campaign_PromotionMgr_getActivePromotions_DetailAnchor">getActivePromotions()</a> returns
     *  a <a href="class_dw_campaign_PromotionPlan.html">PromotionPlan</a> with all enabled promotions scheduled for <i>now</i>.
     *  <a href="class_dw_campaign_PromotionMgr.html#dw_campaign_PromotionMgr_getActiveCustomerPromotions_DetailAnchor">getActiveCustomerPromotions()</a> returns a <a href="class_dw_campaign_PromotionPlan.html">PromotionPlan</a> with
     *  all enabled promotions scheduled for <i>now</i> and applicable for the
     *  session currency, current customer and active source code.
     *  <a href="class_dw_campaign_PromotionMgr.html#dw_campaign_PromotionMgr_getUpcomingPromotions_Number_DetailAnchor">getUpcomingPromotions(Number)</a> returns a <a href="class_dw_campaign_PromotionPlan.html">PromotionPlan</a> with all
     *  promotions that are enabled, not scheduled for <i>now</i>, but scheduled for
     *  any time between <i>now</i> and <i>now + previewTime(hours)</i>.
     *  </p><p>
     *  Applying promotions to line item containers is a 3-step process, and
     *  <a href="class_dw_campaign_PromotionMgr.html">PromotionMgr</a> provides methods supporting each of these steps.
     *  Convenience methods can be used that execute all three steps at once,
     *  or the steps can be executed individually if you need to customize
     *  the output of the steps due to specific business rules. <br>
     *  </p><ul>
     *  <li>Step 1 - calculate active customer promotions: Determine the active
     *  promotions for the session currency, current customer, source code and redeemed coupons.</li>
     *  <li>Step 2 - calculate applicable discounts: Based on the active promotions
     *  determined in step 1, applicable discounts are calculated.</li>
     *  <li>Step 3 - apply discounts: applicable discounts are applied to a line
     *  item container by creating price adjustment line items.</li>
     *  </ul>
     *  <p>
     *  The simpliest way to execute steps 1-3 is to use method
     *  <a href="class_dw_campaign_PromotionMgr.html#dw_campaign_PromotionMgr_applyDiscounts_LineItemCtnr_DetailAnchor">applyDiscounts(LineItemCtnr)</a>. The method identifies all active
     *  customer promotions, calculates and applies applicable discounts.
     *  </p><p>
     *  Due to specific business rules it might be necessary to manipulate
     *  the set of applicable discounts calculated by the promotion engine
     *  before applying them to the line item container. To implement such a scenario,
     *  you want to use method <a href="class_dw_campaign_PromotionMgr.html#dw_campaign_PromotionMgr_getDiscounts_LineItemCtnr_DetailAnchor">getDiscounts(LineItemCtnr)</a>, which
     *  identifies all active customer promotions, and calculates and returns
     *  applicable discounts in an instance of <a href="class_dw_campaign_DiscountPlan.html">DiscountPlan</a>. The discount
     *  plan contains a description for all applicable discounts for the specified line
     *  item container, and you can remove discounts from it if necessary.
     *  The customized discount plan can then be passed on for application by
     *  using method <a href="class_dw_campaign_PromotionMgr.html#dw_campaign_PromotionMgr_applyDiscounts_DiscountPlan_DetailAnchor">applyDiscounts(DiscountPlan)</a>.
     *  </p><p>
     *  Due to specific business rules it might be necessary to manipulate the
     *  set of active customer promotions before calculating applicable discounts
     *  from it. For example, you might want to add promotions to the
     *  plan or remove promotions from it.
     *  You want to use method <a href="class_dw_campaign_PromotionMgr.html#dw_campaign_PromotionMgr_getActiveCustomerPromotions_DetailAnchor">getActiveCustomerPromotions()</a>, which
     *  identifies all active customer promotions and returns an instance of
     *  <a href="class_dw_campaign_PromotionPlan.html">PromotionPlan</a>. You can add promotions to the promotion plan
     *  or remove promotions from the plan. The customized promotion plan can then be
     *  passed on to calculate applicable discounts by using method
     *  <a href="class_dw_campaign_PromotionMgr.html#dw_campaign_PromotionMgr_getDiscounts_LineItemCtnr_PromotionPlan_DetailAnchor">getDiscounts(LineItemCtnr, PromotionPlan)</a>.<br>
     *  </p><p></p>
     */
    class PromotionMgr {
      /**
       * All promotions scheduled for now and applicable for the
       *  session currency, current customer, source code, or presented coupons.
       *
       *  The active promotions are returned in an instance of
       *  PromotionPlan. The promotion plan contains all
       *  promotions assigned to any customer group of the current customer, the
       *  current source code, or coupons in the current session basket.
       */
      static readonly activeCustomerPromotions: dw.campaign.PromotionPlan;
      /**
       * All promotions scheduled for now, and applicable for the
       *  session currency but regardless of current customer or source code.
       *  The active promotions are returned in an instance of PromotionPlan.
       */
      static readonly activePromotions: dw.campaign.PromotionPlan;
      /**
       * All campaigns of the current site in no specific order.
       */
      static readonly campaigns: dw.util.Collection<dw.campaign.Campaign>;
      /**
       * All promotions of the current site in no specific order.
       */
      static readonly promotions: dw.util.Collection<dw.campaign.Promotion>;

      /**
       * Identifies active promotions, calculates the applicable
       *  discounts from these promotions and applies these discounts to the
       *  specified line item container.
       *
       *  As a result of this method, the specified line item container
       *  contains price adjustments and/or bonus product line items for
       *  all applicable discounts. The method also removes price
       *  adjustment and/or bonus product line items from the line item
       *  container if the related to promotions/discounts are no longer
       *  applicable.
       * @param lineItemCtnr Line item ctnr to apply promotions on
       */
      static applyDiscounts(lineItemCtnr: dw.order.LineItemCtnr): void;
      /**
       * Applies the discounts contained in the specified discount plan
       *  to the line item container associated with the discount
       *  plan.
       *
       *  As a result of this method, the specified line item container
       *  contains price adjustments and/or bonus product line items for
       *  all discounts contained in the specified discount plan.
       *  The method also removes price adjustment and/or bonus product line items
       *  from the line item container if the specified discount plan does not
       *  contain the related discount.
       *
       *  Note that the method does not evaluate if the discounts in the specified
       *  discount plan are applicable nor that the promotions related to these
       *  discounts are active.
       * @param discountPlan Discount plan to apply to associated line item container
       */
      static applyDiscounts(discountPlan: dw.campaign.DiscountPlan): void;
      /**
       * Returns all promotions scheduled for now and applicable for the
       *  session currency, current customer, source code, or presented coupons.
       *
       *  The active promotions are returned in an instance of
       *  PromotionPlan. The promotion plan contains all
       *  promotions assigned to any customer group of the current customer, the
       *  current source code, or coupons in the current session basket.
       *
       * @return PromotionPlan with active customer promotions
       */
      static getActiveCustomerPromotions(): dw.campaign.PromotionPlan;
      /**
       * Returns all promotions assigned to the passed campaign, which are active
       *  at some point within the specified date range, and are applicable for the
       *  current customer, source code, or presented coupons. A promotion must be
       *  active for an actual time period within the passed date range, and not
       *  just a single point.
       *
       *  The passed campaign and dates must not be null or an exception is thrown.
       *  It is valid for the from and to dates to be in the past. If an invalid
       *  time range is specified (i.e. from is after to), the returned
       *  PromotionPlan will be empty.
       * @param campaign The campaign, must not be null or an exception is thrown.
       * @param from The start of the date range to consider. If null, this signifies an open ended time period.
       * @param to The end of the date range to consider. If null, this signifies an open ended time period.
       * @return PromotionPlan with promotions matching all the criteria.
       */
      static getActiveCustomerPromotionsForCampaign(
        campaign: dw.campaign.Campaign,
        from: Date,
        to: Date
      ): dw.campaign.PromotionPlan;
      /**
       * Returns all promotions scheduled for now, and applicable for the
       *  session currency but regardless of current customer or source code.
       *  The active promotions are returned in an instance of PromotionPlan.
       *
       * @return PromotionPlan with active promotions
       */
      static getActivePromotions(): dw.campaign.PromotionPlan;
      /**
       * Returns all promotions assigned to the passed campaign which are active
       *  at some point within the specified date range. A promotion must be active
       *  for an actual time period within the passed date range, and not just a
       *  single point. A promotion must be applicable for the session currency.
       *
       *  This method considers only the enabled flags and time conditions of the
       *  promotion and campaign. It does not consider whether the current customer
       *  satisfies the qualifiers of the promotion (customer group, source code,
       *  or coupon).
       *
       *  The passed campaign and dates must not be null or an exception is thrown.
       *  It is valid for the from and/or to dates to be in the past. If an invalid
       *  time range is specified (i.e. from is after to), the returned
       *  PromotionPlan will be empty.
       * @param campaign The campaign. Must not be null.
       * @param from The start of the date range to consider. Must not be null
       * @param to The end of the date range to consider. Must not be null.
       * @return PromotionPlan with promotions matching all the criteria.
       */
      static getActivePromotionsForCampaign(
        campaign: dw.campaign.Campaign,
        from: Date,
        to: Date
      ): dw.campaign.PromotionPlan;
      /**
       * Returns the campaign identified by the specified ID.
       * @param id Campaign ID
       * @return Campaign or null if not found
       */
      static getCampaign(id: string): dw.campaign.Campaign;
      /**
       * Returns all campaigns of the current site in no specific order.
       *
       * @return All campaigns of current site
       */
      static getCampaigns(): dw.util.Collection<dw.campaign.Campaign>;
      /**
       * Returns the discounts applicable for the current customer, active
       *  source code and specified line item container.
       *
       *  This method identifies all active  promotions assigned to the customer
       *  groups of the current customer, the active source code and any coupon
       *  contained in the specified line item container, and calculates applicable
       *  discounts from these promotions.
       *
       *  The applicable discounts are contained in the returned instance of
       *  DiscountPlan.
       * @param lineItemCtnr Line item container
       * @return Discount plan with applicable discounts
       */
      static getDiscounts(
        lineItemCtnr: dw.order.LineItemCtnr
      ): dw.campaign.DiscountPlan;
      /**
       * Returns the discounts applicable for the current customer, active
       *  source code and specified line item container, based on the specified
       *  promotion plan.
       *
       *  This method calculates applicable discounts from the promotions in the
       *  specified promotion plan. Note that any promotion in the promotion
       *  plan that is inactive, or not applicable for the current customer
       *  or source code, is being ignored.
       *
       *  The applicable discounts are contained in the returned instance of
       *  DiscountPlan.
       * @param lineItemCtnr Line item container
       * @param promotionPlan Promotion plan with active promotions
       * @return Discount plan with applicable discounts
       */
      static getDiscounts(
        lineItemCtnr: dw.order.LineItemCtnr,
        promotionPlan: dw.campaign.PromotionPlan
      ): dw.campaign.DiscountPlan;
      /**
       * Returns the promotion identified by the specified ID. The same logical
       *  promotion may be assigned to multiple campaigns or AB-tests. In this
       *  case, the system returns the instance of highest rank. Some attributes of
       *  the returned Promotion may vary based on exactly which instance is
       *  returned. This method returns null if there is no promotion in the system
       *  with the given ID, or if a promotion with the given ID exists but it is
       *  not assigned to any campaign or AB-test.
       * @param id Promotion ID
       * @return Promotion or null if not found
       */
      static getPromotion(id: string): dw.campaign.Promotion;
      /**
       * Returns all promotions of the current site in no specific order.
       *
       * @return All promotions of current site
       */
      static getPromotions(): dw.util.Collection<dw.campaign.Promotion>;
      /**
       * Returns all promotions currently inactive, but scheduled
       *  for any time between now and now + previewTime(hours),
       *  and which are applicable based on the current customer, source code, and
       *  coupons in the current basket.
       *  The parameter previewTime specifies for how many hours promotions
       *  should be previewed.
       * @param previewTime Preview time in hours
       * @return PromotionPlan with active promotions
       */
      static getUpcomingCustomerPromotions(
        previewTime: number
      ): dw.campaign.PromotionPlan;
      /**
       * Returns all promotions currently inactive, but scheduled
       *  for any time between now and now + previewTime(hours).
       *  The upcoming promotions are returned in an instance of
       *  PromotionPlan and might not necessarily be applicable for
       *  the current customer or source code.
       *  The parameter previewTime specifies for how many hours promotions
       *  should be previewed.
       * @param previewTime Preview time in hours
       * @return PromotionPlan with active promotions
       */
      static getUpcomingPromotions(
        previewTime: number
      ): dw.campaign.PromotionPlan;
    }

    /**
     * PromotionPlan represents a set of <a href="class_dw_campaign_Promotion.html">Promotion</a> instances and
     *  is used to display active or upcoming promotions on storefront pages, or to
     *  pass it to the <a href="class_dw_campaign_PromotionMgr.html">PromotionMgr</a> to calculate a
     *  <a href="class_dw_campaign_DiscountPlan.html">DiscountPlan</a> and subsequently apply discounts to a line
     *  item container. Instances of the class are returned by the
     *  <a href="class_dw_campaign_PromotionMgr.html#dw_campaign_PromotionMgr_getActivePromotions_DetailAnchor">PromotionMgr.getActivePromotions()</a>,
     *  <a href="class_dw_campaign_PromotionMgr.html#dw_campaign_PromotionMgr_getActiveCustomerPromotions_DetailAnchor">PromotionMgr.getActiveCustomerPromotions()</a> and
     *  <a href="class_dw_campaign_PromotionMgr.html#dw_campaign_PromotionMgr_getUpcomingPromotions_Number_DetailAnchor">PromotionMgr.getUpcomingPromotions(Number)</a>.
     *  <p>
     *  PromotionPlan provides methods to access the promotions in the plan and to
     *  remove promotions from the plan. All methods which return a collection of
     *  promotions sort them by the following ordered criteria:
     *  </p><p>
     *
     *  </p><ol>
     *  <li>Exclusivity: GLOBAL exclusive promotions first, followed by CLASS
     *  exclusive promotions, and NO exclusive promotions last.</li>
     *  <li>Rank: sorted ascending</li>
     *  <li>Promotion Class: PRODUCT promotions first, followed by ORDER promotions,
     *  and SHIPPING promotions last.</li>
     *  <li>Discount type: Fixed price promotions first, followed by free,
     *  amount-off, percentage-off, and bonus product promotions last.</li>
     *  <li>Best discount: Sorted descending. For example, 30% off comes before 20%
     *  off.</li>
     *  <li>ID: alphanumeric ascending.</li>
     *  </ol>
     */
    class PromotionPlan {
      /**
       * Constant indicating that a collection of promotions should be sorted
       *  first by exclusivity, then rank, promotion class, etc.  See class-level
       *  javadoc for details.  This is the default sort order for methods that
       *  return a collection of promotions.
       */
      static readonly SORT_BY_EXCLUSIVITY = 1;
      /**
       * Constant indicating that a collection of promotions should be sorted by
       *  start date ascending. If there is no explicit start date for a promotion
       *  the start date of its containing Campaign or AB-test is used instead.
       *  Promotions without a start date are sorted before promotions with a start
       *  date in the future and after promotions with a start date in the past. In
       *  case two promotion assignments have the same start date, they are sorted
       *  by their ID.
       */
      static readonly SORT_BY_START_DATE = 2;

      /**
       * All order promotions contained in this plan.
       */
      readonly orderPromotions: dw.util.Collection<dw.campaign.Promotion>;
      /**
       * All product promotions contained in this plan.
       */
      readonly productPromotions: dw.util.Collection<dw.campaign.Promotion>;
      /**
       * All promotions contained in this plan sorted by exclusivity.
       */
      readonly promotions: dw.util.Collection<dw.campaign.Promotion>;
      /**
       * All shipping promotions contained in this plan.
       */
      readonly shippingPromotions: dw.util.Collection<dw.campaign.Promotion>;

      /**
       * Returns all order promotions contained in this plan.
       *
       * @return The sorted collection of order promotions contained in the promotion plan.
       */
      getOrderPromotions(): dw.util.Collection<dw.campaign.Promotion>;
      /**
       * Returns the order promotions explicitly associated to the specified
       *  discounted payment card.
       *
       *  This method is usually used to display order promotions along with
       *  payment card choices.
       * @param paymentCard Discounted payment card
       * @return The sorted collection of order promotions associated with the specified payment card.
       */
      getPaymentCardPromotions(
        paymentCard: dw.order.PaymentCard
      ): dw.util.Collection<dw.campaign.Promotion>;
      /**
       * Returns the order promotions explicitly associated to the specified
       *  discounted payment method.
       *
       *  This method is usually used to display order promotions along with
       *  payment method choices.
       * @param paymentMethod Discounted payment method
       * @return The sorted collection of order promotions associated with the specified payment method.
       */
      getPaymentMethodPromotions(
        paymentMethod: dw.order.PaymentMethod
      ): dw.util.Collection<dw.campaign.Promotion>;
      /**
       * Returns all product promotions contained in this plan.
       *
       * @return The sorted collection of product promotions contained in the promotion plan.
       */
      getProductPromotions(): dw.util.Collection<dw.campaign.Promotion>;
      /**
       * Returns the promotions related to the specified product.
       *  The method returns all promotions where the product is either a
       *  qualifying product, or a discounted product, or both. It also returns
       *  promotions where the specified product is a bonus product.
       *
       *  This method is usually used to display product promotions on a product
       *  details page.
       *
       *  If a master product is passed, then this method will return promotions
       *  which are relevant for the master itself or at least one of its variants.
       * @param product Product associated with promotion
       * @return The sorted collection of promotions related to specified discounted product.
       */
      getProductPromotions(
        product: dw.catalog.Product
      ): dw.util.Collection<dw.campaign.Promotion>;
      /**
       * Returns the product promotions for which the specified product is a
       *  discounted (and possibly also a qualifying) product. It also returns
       *  promotions where the specified product is a bonus product.
       *
       *  This method is usually used to display product promotions on a product
       *  details page when separate callout messages are defined depending on if
       *  the product is a qualifying or discounted product for the promotion.
       *
       *  If a master product is passed, then this method will return promotions
       *  for which the master product itself or at least one of its product's
       *  variants is a discounted product.
       * @param product The discounted product.
       * @return Product promotions related to the specified discounted product.
       */
      getProductPromotionsForDiscountedProduct(
        product: dw.catalog.Product
      ): dw.util.Collection<dw.campaign.Promotion>;
      /**
       * Returns the product promotions for which the specified product is a
       *  qualifying but NOT a discounted product.
       *
       *  This method is usually used to display product promotions on a product
       *  details page when separate callout messages are defined depending on if
       *  the product is a qualifying or discounted product for the promotion.
       *
       *  If a master product is passed, then this method will return promotions
       *  for which the master product itself or at least one of its product's
       *  variants is a qualifying product.
       * @param product The qualifying product.
       * @return Product promotions related to the specified qualifying product.
       */
      getProductPromotionsForQualifyingProduct(
        product: dw.catalog.Product
      ): dw.util.Collection<dw.campaign.Promotion>;
      /**
       * Returns all promotions contained in this plan sorted by exclusivity.
       *
       * @return The sorted collection of promotions contained in the promotion plan.
       */
      getPromotions(): dw.util.Collection<dw.campaign.Promotion>;
      /**
       * Returns all promotions contained in this plan sorted according to the
       *  specified sort order. If the passed sort order is invalid, then the
       *  returned promotions will be sorted by exclusivity.
       * @param sortOrder the sort order to use. Must be SORT_BY_EXCLUSIVITY or SORT_BY_START_DATE. If an invalid value is passed, SORT_BY_EXCLUSIVITY is used.
       * @return The sorted collection of promotions contained in the promotion plan.
       */
      getPromotions(
        sortOrder: number
      ): dw.util.Collection<dw.campaign.Promotion>;
      /**
       * Returns the promotions related to the specified product.
       *  The method returns all promotions where the product is either
       *  a qualifying product, or a discounted product, or both. It also
       *  returns promotions where the specified product is a bonus product.
       *
       *  This method is usually used to display product promotions on a
       *  product details page.
       * @param product Product associated with promotion
       * @return The sorted collection of promotions related to the specified discounted product.
       */
      getPromotions(
        product: dw.catalog.Product
      ): dw.util.Collection<dw.campaign.Promotion>;
      /**
       * Returns all shipping promotions contained in this plan.
       *
       * @return The sorted collection of shipping promotions contained in promotion plan.
       */
      getShippingPromotions(): dw.util.Collection<dw.campaign.Promotion>;
      /**
       * Returns the shipping promotions related to the specified discounted
       *  shipping method, i.e. the returned promotions apply a discount on
       *  the specified shipping method.
       *
       *  This method is usually used to display shipping promotions along with
       *  shipping methods.
       * @param shippingMethod Discounted shipping method
       * @return The sorted collection of shipping promotions with specified method as discounted method.
       */
      getShippingPromotions(
        shippingMethod: dw.order.ShippingMethod
      ): dw.util.Collection<dw.campaign.Promotion>;
      /**
       * Remove promotion from promotion plan.
       *  Please note that this is the only way to remove promotions from the
       *  plan, i.e. removing promotions from the collections returned
       *  by methods such as getProductPromotions() has no effect
       *  on the promotion plan.
       * @param promotion Promotion to remove from promotion plan
       */
      removePromotion(promotion: dw.campaign.Promotion): void;
    }

    /**
     * Represents content for a slot.
     */
    class SlotContent {
      /**
       * The callout message for the slot.
       */
      readonly calloutMsg: dw.content.MarkupText;
      /**
       * A collection of content based on the content type
       *  for the slot. The collection will include one of the following
       *  types: Product, Content, Category, or MarkupText.
       */
      readonly content: dw.util.Collection<
        | dw.catalog.Product
        | dw.content.Content
        | dw.catalog.Category
        | dw.content.MarkupText
      >;
      /**
       * The custom attributes for the slot.
       */
      readonly custom: dw.util.Map<string, any>;
      /**
       * The recommender name for slot configurations of type 'Recommendation'
       */
      readonly recommenderName: string;
      /**
       * The unique slot ID.
       */
      readonly slotID: string;

      /**
       * Returns the callout message for the slot.
       *
       * @return Callout message of the slot.
       */
      getCalloutMsg(): dw.content.MarkupText;
      /**
       * Returns a collection of content based on the content type
       *  for the slot. The collection will include one of the following
       *  types: Product, Content, Category, or MarkupText.
       *
       * @return All content of the slot.
       */
      getContent(): dw.util.Collection<
        | dw.catalog.Product
        | dw.content.Content
        | dw.catalog.Category
        | dw.content.MarkupText
      >;
      /**
       * Returns the custom attributes for the slot.
       *
       * @return Custom attributes of the slot.
       */
      getCustom(): dw.util.Map<string, any>;
      /**
       * Returns the recommender name for slot configurations of type 'Recommendation'
       *
       * @return the recommender name for slot configurations of type 'Recommendation'
       */
      getRecommenderName(): string;
      /**
       * Returns the unique slot ID.
       *
       * @return ID of the slot.
       */
      getSlotID(): string;
    }

    /**
     * A source code group defines a collection of source codes. Source code groups
     *  are generally pattern based and any source code satisfying the pattern
     *  belongs to the group. In this way, merchants may define a large set of source
     *  codes which qualify a customer for site experiences (different prices, for
     *  example), which customers without that source code do not receive.
     *  The class <a href="class_dw_campaign_SourceCodeInfo.html">SourceCodeInfo</a> represents an individual source
     *  code.
     */
    class SourceCodeGroup extends dw.object.ExtensibleObject {
      /**
       * The ID of the SourceCodeGroup.
       */
      readonly ID: string;
      /**
       * A Collection of PriceBooks the SourceCodeGroup is assigned to.
       */
      readonly priceBooks: dw.util.Collection<dw.catalog.PriceBook>;

      /**
       * The ID of the SourceCodeGroup.
       *
       * @return the ID.
       */
      getID(): string;
      /**
       * Returns a Collection of PriceBooks the SourceCodeGroup is assigned to.
       *
       * @return Collection of PriceBooks the SourceCodeGroup is assigned to.
       */
      getPriceBooks(): dw.util.Collection<dw.catalog.PriceBook>;
    }

    /**
     * Class representing a code (i.e. a &quot;source code&quot;) that has been applied to a
     *  customer&apos;s session. Source codes can qualify customers for different
     *  campaigns, promotions, and other site experiences from those that the typical
     *  customer sees. Codes are organized into source code groups.
     *  <p>
     *  Typically, a code is applied to a customer&apos;s session automatically by
     *  Commerce Cloud Digital when a customer accesses a Digital URL with a well
     *  known request parameter in the querystring.  A code may also be explicitly
     *  applied to a customer session using the <code>SetSourceCode</code>
     *  pipelet.</p>
     */
    class SourceCodeInfo {
      /**
       * The literal source-code is found and currently active.
       */
      static readonly STATUS_ACTIVE = 2;
      /**
       * The literal source-code is found but not active.
       */
      static readonly STATUS_INACTIVE = 1;
      /**
       * The literal source-code is not found in the system.
       */
      static readonly STATUS_INVALID = 0;

      /**
       * The literal source-code.
       */
      readonly code: string;
      /**
       * The associated source-code group.
       */
      readonly group: dw.campaign.SourceCodeGroup;
      /**
       * Retrieves the redirect information from the last processed SourceCodeGroup (active or inactive). If none exists,
       *  then the redirect information is retrieved from the source-code preferences, based on the active/inactive status
       *  of the SourceCodeGroup. The redirect information is then resolved to the output URL. If the redirect information
       *  cannot be resolved to a URL, or there is an error retrieving the preferences, then null is returned.
       */
      readonly redirect: dw.web.URLRedirect;
      /**
       * The status of the source-code.  One of the following:
       *  STATUS_INVALID - The source code is not found in the system.
       *  STATUS_INACTIVE - The source code is found but not active.
       *  STATUS_INACTIVE - The source code is found and active.
       */
      readonly status: number;

      /**
       * The literal source-code.
       *
       * @return the source-code.
       */
      getCode(): string;
      /**
       * The associated source-code group.
       *
       * @return the source-code group.
       */
      getGroup(): dw.campaign.SourceCodeGroup;
      /**
       * Retrieves the redirect information from the last processed SourceCodeGroup (active or inactive). If none exists,
       *  then the redirect information is retrieved from the source-code preferences, based on the active/inactive status
       *  of the SourceCodeGroup. The redirect information is then resolved to the output URL. If the redirect information
       *  cannot be resolved to a URL, or there is an error retrieving the preferences, then null is returned.
       *
       * @return URLRedirect containing the location and status code, null in case of no redirect was found
       */
      getRedirect(): dw.web.URLRedirect;
      /**
       * The status of the source-code.  One of the following:
       *  STATUS_INVALID - The source code is not found in the system.
       *  STATUS_INACTIVE - The source code is found but not active.
       *  STATUS_INACTIVE - The source code is found and active.
       *
       * @return the status.
       */
      getStatus(): number;
    }

    /**
     * Helper class which contains error result codes returned by the SetSourceCode
     *  pipelet.
     */
    class SourceCodeStatusCodes {
      /**
       * Indicates that the specified source code was found in one or more
       *  source-code groups, none of which are active.
       */
      static readonly CODE_INACTIVE = "CODE_INACTIVE";
      /**
       * Indicates that the specified source code is not contained
       *  in any source-code group.
       */
      static readonly CODE_INVALID = "CODE_INVALID";

      constructor();
    }

    /**
     * Represents a <i>total fix price</i> discount on a group of products in the
     *  discount plan.  For example:  &quot;buy 3 products of type X for a total price
     *  of $29.99&quot;.
     */
    class TotalFixedPriceDiscount extends dw.campaign.Discount {
      /**
       * The total fixed price amount.
       */
      readonly totalFixedPrice: number;

      /**
       * Returns the total fixed price amount.
       *
       * @return Total fixed price amount
       */
      getTotalFixedPrice(): number;
    }
  }

  namespace catalog {
    /**
     * Represents a Commerce Cloud Digital Catalog. Catalogs are containers of products
     *  and other product-related information and can be shared between sites. Every
     *  product in the system is contained in (or &quot;owned by&quot;) exactly one catalog.
     *  Every site has a single &quot;site catalog&quot; which defines the products that are
     *  available to purchase on that site. The static method
     *  <a href="class_dw_catalog_CatalogMgr.html#dw_catalog_CatalogMgr_getSiteCatalog_DetailAnchor">CatalogMgr.getSiteCatalog()</a> returns the site catalog for
     *  the current site.
     *  <p>
     *  Catalogs are organized into a tree of categories with a single top-level root
     *  category. Products are assigned to categories within catalogs. They can be
     *  assigned to categories in their owning catalog, or other catalogs. They can
     *  be assigned to multiple categories within the same catalog. Products that are
     *  not assigned to any categories are considered &quot;uncategorized.&quot; A product has
     *  a single &quot;classification category&quot; in some catalog, and one
     *  &quot;primary category&quot; per catalog. The classification category defines the
     *  attribute set of the product. The primary category is used as standard
     *  presentation context within that catalog in the storefront.
     *  </p><p>
     *  While Commerce Cloud Digital does not currently distinguish different
     *  catalog types, it is common practice to have two general types of catalog:
     *
     *  </p><ul>
     *  <li>&quot;Product catalogs&quot; typically contain detailed product information and are
     *  frequently generated from some backend PIM system.</li>
     *  <li>&quot;Site Catalogs&quot; define the category structure of the storefront and
     *  contain primarily the assignments of these categories to the products defined
     *  in the product catalogs. The site catalog is assigned to the site.</li>
     *  </ul>
     *  <p>
     *  In addition to products and categories, catalogs contain recommendations,
     *  shared variation attributes which can be used by multiple master products,
     *  and shared product options which can be used by multiple option products.</p>
     */
    class Catalog extends dw.object.ExtensibleObject {
      /**
       * The value of the localized extensible object attribute
       *  "shortDescription" for the current locale.
       */
      readonly description: string;
      /**
       * The value of the localized extensible object attribute
       *  "displayName" for the current locale.
       */
      readonly displayName: string;
      /**
       * The value of attribute 'id'.
       */
      readonly ID: string;
      /**
       * The object for the relation 'root'.
       */
      readonly root: dw.catalog.Category;

      /**
       * Returns the value of the localized extensible object attribute
       *  "shortDescription" for the current locale.
       *
       * @return The value of the attribute for the current locale, or null if it wasn't found.
       */
      getDescription(): string;
      /**
       * Returns the value of the localized extensible object attribute
       *  "displayName" for the current locale.
       *
       * @return The value of the attribute for the current locale, or null if it wasn't found.
       */
      getDisplayName(): string;
      /**
       * Returns the value of attribute 'id'.
       *
       * @return the value of the attribute 'id'
       */
      getID(): string;
      /**
       * Returns the object for the relation 'root'.
       *
       * @return the object for the relation 'root'.
       */
      getRoot(): dw.catalog.Category;
    }

    /**
     * Provides helper methods for getting categories.
     */
    class CatalogMgr {
      /**
       * The catalog of the current site or null if no catalog is assigned to the site.
       */
      static readonly siteCatalog: dw.catalog.Catalog;
      /**
       * A list containing the sorting options configured for this site.
       */
      static readonly sortingOptions: dw.util.List<dw.catalog.SortingOption>;
      /**
       * A collection containing all of the sorting rules for this site, including global sorting rules.
       */
      static readonly sortingRules: dw.util.Collection<dw.catalog.SortingRule>;

      /**
       * Returns the catalog identified by the specified catalog id.
       *  Returns null if no catalog with the specified id exists in the
       *  current organization context.
       * @param id Catalog id
       * @return the catalog or null.
       */
      static getCatalog(id: string): dw.catalog.Catalog;
      /**
       * Returns the category of the site catalog identified by the specified
       *  category id. Returns null if no site catalog is defined, or no category
       *  with the specified id is found in the site catalog.
       * @param id the category identifier.
       * @return the category of the site catalog identified by the specified category id or null if no site catalog is found.
       */
      static getCategory(id: string): dw.catalog.Category;
      /**
       * Returns the catalog of the current site or null if no catalog is assigned to the site.
       *
       * @return the catalog of the current site or null.
       */
      static getSiteCatalog(): dw.catalog.Catalog;
      /**
       * Returns the sorting option with the given ID for this site, or
       *  null if there is no such option.
       * @param id the ID of the sorting option
       * @return a SortingOption or null.
       */
      static getSortingOption(id: string): dw.catalog.SortingOption;
      /**
       * Returns a list containing the sorting options configured for this site.
       *
       * @return a list of SortingOption objects
       */
      static getSortingOptions(): dw.util.List<dw.catalog.SortingOption>;
      /**
       * Returns the sorting rule with the given ID for this site,
       *  or null if there is no such rule.
       * @param id the ID of the sorting rule
       * @return a SortingRule or null.
       */
      static getSortingRule(id: string): dw.catalog.SortingRule;
      /**
       * Returns a collection containing all of the sorting rules for this site, including global sorting rules.
       *
       * @return a collection of SortingRule objects
       */
      static getSortingRules(): dw.util.Collection<dw.catalog.SortingRule>;
    }

    /**
     * Represents a category in a product catalog.
     */
    class Category extends dw.object.ExtensibleObject {
      /**
       * Constant representing the Variation Group Display Mode individual setting.
       */
      static readonly DISPLAY_MODE_INDIVIDUAL = 0;
      /**
       * Constant representing the Variation Group Display Mode merged setting.
       */
      static readonly DISPLAY_MODE_MERGED = 1;

      /**
       * All outgoing recommendations for this category.  The
       *  recommendations are sorted by their explicitly set order.
       */
      readonly allRecommendations: dw.util.Collection<
        dw.catalog.Recommendation
      >;
      /**
       * A collection of category assignments of the category.
       */
      readonly categoryAssignments: dw.util.Collection<
        dw.catalog.CategoryAssignment
      >;
      /**
       * The default sorting rule configured for this category,
       *  or null if there is no default rule to be applied for it.
       *
       *  This method returns the default rule for the parent category if this
       *  category inherits one.  The parent category may inherit its default
       *  rule from its parent, and so on, up to the root category.
       *
       *  This method returns null if no ancestor category for this
       *  category has a default rule.
       */
      readonly defaultSortingRule: dw.catalog.SortingRule;
      /**
       * The description of the catalog category for the current locale.
       */
      readonly description: string;
      /**
       * The Variation Groups Display Mode of the category or null if no display mode is defined.
       */
      displayMode: number;
      /**
       * The display name of the of the catalog category for the current locale.
       *
       *  This value is intended to be used as the
       *  external visible name of the catalog category.
       */
      readonly displayName: string;
      /**
       * The id of the category.
       */
      readonly ID: string;
      /**
       * The image reference of this catalog category.
       */
      readonly image: dw.content.MediaFile;
      /**
       * The collection of CategoryLink objects for which this category
       *  is the target.  If the source category of a link belongs to a different
       *  catalog than the catalog owning this category, it is not returned.
       */
      readonly incomingCategoryLinks: dw.util.Collection<
        dw.catalog.CategoryLink
      >;
      /**
       * The value indicating whether the catalog category is "currently
       *  online".  A category is currently online if its online flag equals true
       *  and the current site date is within the date range defined by the
       *  onlineFrom and onlineTo attributes.
       */
      readonly online: boolean;
      /**
       * A collection of category assignments of the category where the
       *  referenced product is currently online. When checking the online status
       *  of the product, the online flag and the online from & to dates are taken
       *  into account. Online flag, online from & to dates set for the current site
       *  takes precedence over the default values.
       */
      readonly onlineCategoryAssignments: dw.util.Collection<
        dw.catalog.CategoryAssignment
      >;
      /**
       * The online status flag of the category.
       */
      readonly onlineFlag: boolean;
      /**
       * The date from which the category is online or valid.
       */
      readonly onlineFrom: Date;
      /**
       * The collection of CategoryLink objects for
       *  which this category is the target. If the source category of a link
       *  belongs to a different catalog than the catalog owning this category, it
       *  is not returned. Additionally, this method will only return a link if the
       *  source category is currently online. A category is currently online if
       *  its online flag equals true and the current site date is within the date
       *  range defined by the onlineFrom and onlineTo attributes.
       */
      readonly onlineIncomingCategoryLinks: dw.util.Collection<
        dw.catalog.CategoryLink
      >;
      /**
       * The collection of CategoryLink objects for
       *  which this category is the source. If the target category of a link
       *  belongs to a different catalog than the catalog owning this category, it
       *  is not returned. Additionally, this method will only return a link if the
       *  target category is currently online. A category is currently online if
       *  its online flag equals true and the current site date is within the date
       *  range defined by the onlineFrom and onlineTo attributes.
       */
      readonly onlineOutgoingCategoryLinks: dw.util.Collection<
        dw.catalog.CategoryLink
      >;
      /**
       * Returns online products assigned to this category.
       *  Offline products are not included in the returned collection.
       *  When checking the online status of the product,
       *  the online flag and the online from & to dates are taken into account.
       *  Online flag, online from & to dates set for the current site takes precedence
       *  over the default values.
       *
       *  The order of products in the returned collection corresponds to the
       *  defined explicit sorting of products in this category.
       */
      readonly onlineProducts: dw.util.Collection<dw.catalog.Product>;
      /**
       * A sorted collection of currently online subcategories of this
       *  catalog category.
       *
       *
       *    A category is currently online if its online flag
       *    equals true and the current site date is within the date range defined by
       *    the onlineFrom and onlineTo attributes.
       *
       *
       *    The returned collection is sorted by position. Subcategories marked as
       *    "unsorted" always appear after those marked as "sorted" but are otherwise
       *    not in any guaranteed order.
       *
       *
       *     The returned collection contains direct subcategories only.
       */
      readonly onlineSubCategories: dw.util.Collection<dw.catalog.Category>;
      /**
       * The date until which the category is online or valid.
       */
      readonly onlineTo: Date;
      /**
       * A list of outgoing recommendations for this category. This method
       *  behaves similarly to getRecommendations() but additionally filters out
       *  recommendations for which the target product is unorderable according to
       *  its product availability model.
       */
      readonly orderableRecommendations: dw.util.Collection<
        dw.catalog.Recommendation
      >;
      /**
       * The collection of CategoryLink objects for which this category
       *  is the source.  If the target category of a link belongs to a different
       *  catalog than the catalog owning this category, it is not returned.
       *  The collection of links is sorted by the explicitly defined order
       *  for this category with unsorted links appearing at the end.
       */
      readonly outgoingCategoryLinks: dw.util.Collection<
        dw.catalog.CategoryLink
      >;
      /**
       * The page description of this category for the default locale or null if not defined.
       */
      readonly pageDescription: string;
      /**
       * The page keywords of this category for the default locale or null if not defined.
       */
      readonly pageKeywords: string;
      /**
       * The page title of this category for the default locale or null if not defined.
       */
      readonly pageTitle: string;
      /**
       * The page URL property of this category or null if not defined.
       */
      readonly pageURL: string;
      /**
       * The parent of this category.
       */
      readonly parent: dw.catalog.Category;
      /**
       * Returns this category's ProductAttributeModel, which makes access to the
       *  category's attribute information convenient. The model is calculated
       *  based on the attribute definitions assigned to this category and the
       *  global attribute definitions for the object type 'Product'.
       */
      readonly productAttributeModel: dw.catalog.ProductAttributeModel;
      /**
       * All products assigned to this category.
       *  The order of products in the returned collection corresponds to the
       *  defined explicit sorting of products in this category.
       */
      readonly products: dw.util.Collection<dw.catalog.Product>;
      /**
       * The outgoing recommendations for this category.  If this category
       *  is not in the site catalog, or there is no site catalog, an empty
       *  collection is returned.  Only recommendations for which the target
       *  product exists and is assigned to the site catalog are returned.  The
       *  recommendations are sorted by their explicitly set order.
       */
      readonly recommendations: dw.util.Collection<dw.catalog.Recommendation>;
      /**
       * Identifies if the category is the root category of its catalog.
       */
      readonly root: boolean;
      /**
       * The search placement of the category or null of no search placement is defined.
       */
      searchPlacement: number;
      /**
       * The search rank of the category or null of no search rank is defined.
       */
      searchRank: number;
      /**
       * The category's sitemap change frequency.
       */
      readonly siteMapChangeFrequency: string;
      /**
       * The category's sitemap inclusion.
       */
      readonly siteMapIncluded: number;
      /**
       * The category's sitemap priority.
       */
      readonly siteMapPriority: number;
      /**
       * A sorted collection of the subcategories of this catalog category,
       *  including both online and offline subcategories.
       *
       *
       *    The returned collection is sorted by position. Subcategories marked as
       *    "unsorted" always appear after those marked as "sorted" but are otherwise
       *    not in any guaranteed order.
       *
       *
       *    The returned collection contains direct subcategories only.
       */
      readonly subCategories: dw.util.Collection<dw.catalog.Category>;
      /**
       * The template property value , which is the file name of the template
       *  used to display the catalog category.
       */
      readonly template: string;
      /**
       * The thumbnail image reference of this catalog category.
       */
      readonly thumbnail: dw.content.MediaFile;
      /**
       * Returns true if the category is a top level category, but not the root
       *  category.
       */
      readonly topLevel: boolean;

      /**
       * Returns all outgoing recommendations for this category.  The
       *  recommendations are sorted by their explicitly set order.
       *
       * @return the sorted collection of recommendations, never null but possibly empty.
       */
      getAllRecommendations(): dw.util.Collection<dw.catalog.Recommendation>;
      /**
       * Returns all outgoing recommendations for this category which are of the
       *  specified type. The recommendations are sorted by their explicitly set
       *  order.
       * @param type the recommendation type.
       * @return the sorted collection of recommendations, never null but possibly empty.
       */
      getAllRecommendations(
        type: number
      ): dw.util.Collection<dw.catalog.Recommendation>;
      /**
       * Returns a collection of category assignments of the category.
       *
       * @return Collection of category assignments of the category.
       */
      getCategoryAssignments(): dw.util.Collection<
        dw.catalog.CategoryAssignment
      >;
      /**
       * Returns the default sorting rule configured for this category,
       *  or null if there is no default rule to be applied for it.
       *
       *  This method returns the default rule for the parent category if this
       *  category inherits one.  The parent category may inherit its default
       *  rule from its parent, and so on, up to the root category.
       *
       *  This method returns null if no ancestor category for this
       *  category has a default rule.
       *
       * @return the default SortingRule or null.
       */
      getDefaultSortingRule(): dw.catalog.SortingRule;
      /**
       * Returns the description of the catalog category for the current locale.
       *
       * @return The value of the property for the current locale, or null if it wasn't found.
       */
      getDescription(): string;
      /**
       * Returns the Variation Groups Display Mode of the category or null if no display mode is defined.
       *
       * @return the value of the attribute 'displayMode' which is either DISPLAY_MODE_MERGED or DISPLAY_MODE_INDIVIDUAL or null if category is set to inherit the display mode.
       */
      getDisplayMode(): number;
      /**
       * Returns the display name of the of the catalog category for the current locale.
       *
       *  This value is intended to be used as the
       *  external visible name of the catalog category.
       *
       * @return The value of the property for the current locale, or null if it wasn't found.
       */
      getDisplayName(): string;
      /**
       * Returns the id of the category.
       *
       * @return the id of the category.
       */
      getID(): string;
      /**
       * Returns the image reference of this catalog category.
       *
       * @return the image reference for this category.
       */
      getImage(): dw.content.MediaFile;
      /**
       * Returns the collection of CategoryLink objects for which this category
       *  is the target.  If the source category of a link belongs to a different
       *  catalog than the catalog owning this category, it is not returned.
       *
       * @return a collection of CategoryLink objects, possibly empty but not null.
       */
      getIncomingCategoryLinks(): dw.util.Collection<dw.catalog.CategoryLink>;
      /**
       * Returns the collection of CategoryLink objects for which this category
       *  is the target and which are of the specified type.  If the source
       *  category of a link belongs to a different catalog than the catalog owning
       *  this category, it is not returned.
       * @param type the link type type.
       * @return a collection of CategoryLink objects, possibly empty but not null.
       */
      getIncomingCategoryLinks(
        type: number
      ): dw.util.Collection<dw.catalog.CategoryLink>;
      /**
       * Returns a collection of category assignments of the category where the
       *  referenced product is currently online. When checking the online status
       *  of the product, the online flag and the online from & to dates are taken
       *  into account. Online flag, online from & to dates set for the current site
       *  takes precedence over the default values.
       *
       * @return Collection of online category assignments of the category.
       */
      getOnlineCategoryAssignments(): dw.util.Collection<
        dw.catalog.CategoryAssignment
      >;
      /**
       * Returns the online status flag of the category.
       *
       * @return the online status flag of the category.
       */
      getOnlineFlag(): boolean;
      /**
       * Returns the date from which the category is online or valid.
       *
       * @return the date from which the category is online or valid.
       */
      getOnlineFrom(): Date;
      /**
       * Returns the collection of CategoryLink objects for
       *  which this category is the target. If the source category of a link
       *  belongs to a different catalog than the catalog owning this category, it
       *  is not returned. Additionally, this method will only return a link if the
       *  source category is currently online. A category is currently online if
       *  its online flag equals true and the current site date is within the date
       *  range defined by the onlineFrom and onlineTo attributes.
       *
       * @return a collection of CategoryLink objects, possibly empty but not null.
       */
      getOnlineIncomingCategoryLinks(): dw.util.Collection<
        dw.catalog.CategoryLink
      >;
      /**
       * Returns the collection of CategoryLink objects for
       *  which this category is the source. If the target category of a link
       *  belongs to a different catalog than the catalog owning this category, it
       *  is not returned. Additionally, this method will only return a link if the
       *  target category is currently online. A category is currently online if
       *  its online flag equals true and the current site date is within the date
       *  range defined by the onlineFrom and onlineTo attributes.
       *
       * @return a collection of CategoryLink objects, possibly empty but not null.
       */
      getOnlineOutgoingCategoryLinks(): dw.util.Collection<
        dw.catalog.CategoryLink
      >;
      /**
       * Returns online products assigned to this category.
       *  Offline products are not included in the returned collection.
       *  When checking the online status of the product,
       *  the online flag and the online from & to dates are taken into account.
       *  Online flag, online from & to dates set for the current site takes precedence
       *  over the default values.
       *
       *  The order of products in the returned collection corresponds to the
       *  defined explicit sorting of products in this category.
       *
       * @return a sorted collection of online products of this category.
       */
      getOnlineProducts(): dw.util.Collection<dw.catalog.Product>;
      /**
       * Returns a sorted collection of currently online subcategories of this
       *  catalog category.
       *
       *
       *    A category is currently online if its online flag
       *    equals true and the current site date is within the date range defined by
       *    the onlineFrom and onlineTo attributes.
       *
       *
       *    The returned collection is sorted by position. Subcategories marked as
       *    "unsorted" always appear after those marked as "sorted" but are otherwise
       *    not in any guaranteed order.
       *
       *
       *     The returned collection contains direct subcategories only.
       *
       * @return a sorted collection of currently online subcategories.
       */
      getOnlineSubCategories(): dw.util.Collection<dw.catalog.Category>;
      /**
       * Returns the date until which the category is online or valid.
       *
       * @return the date until which the category is online or valid.
       */
      getOnlineTo(): Date;
      /**
       * Returns a list of outgoing recommendations for this category. This method
       *  behaves similarly to getRecommendations() but additionally filters out
       *  recommendations for which the target product is unorderable according to
       *  its product availability model.
       *
       * @return the sorted collection of recommendations, never null but possibly empty.
       */
      getOrderableRecommendations(): dw.util.Collection<
        dw.catalog.Recommendation
      >;
      /**
       * Returns a list of outgoing recommendations for this category. This method
       *  behaves similarly to getRecommendations(Number) but additionally
       *  filters out recommendations for which the target product is unorderable
       *  according to its product availability model.
       * @param type the recommendation type.
       * @return the sorted collection of recommendations, never null but possibly empty.
       */
      getOrderableRecommendations(
        type: number
      ): dw.util.Collection<dw.catalog.Recommendation>;
      /**
       * Returns the collection of CategoryLink objects for which this category
       *  is the source.  If the target category of a link belongs to a different
       *  catalog than the catalog owning this category, it is not returned.
       *  The collection of links is sorted by the explicitly defined order
       *  for this category with unsorted links appearing at the end.
       *
       * @return a collection of CategoryLink objects, possibly empty but not null.
       */
      getOutgoingCategoryLinks(): dw.util.Collection<dw.catalog.CategoryLink>;
      /**
       * Returns the collection of CategoryLink objects for which this category
       *  is the source and which are of the specified type.  If the target
       *  category of a link belongs to a different catalog than the catalog owning
       *  this category, it is not returned.  The collection of links is sorted by
       *  the explicitly defined order for this category with unsorted links
       *  appearing at the end.
       * @param type the link type type.
       * @return a collection of CategoryLink objects, possibly empty but not null.
       */
      getOutgoingCategoryLinks(
        type: number
      ): dw.util.Collection<dw.catalog.CategoryLink>;
      /**
       * Returns the page description of this category for the default locale or null if not defined.
       *
       * @return the value of the attribute 'pageDescription'.
       */
      getPageDescription(): string;
      /**
       * Returns the page keywords of this category for the default locale or null if not defined.
       *
       * @return the value of the attribute 'pageKeywords'.
       */
      getPageKeywords(): string;
      /**
       * Returns the page title of this category for the default locale or null if not defined.
       *
       * @return the value of the attribute 'pageTitle'.
       */
      getPageTitle(): string;
      /**
       * Returns the page URL property of this category or null if not defined.
       *
       * @return the value of the attribute 'pageURL'.
       */
      getPageURL(): string;
      /**
       * Returns the parent of this category.
       *
       * @return a CatalogCategory instance representing the parent of this CatalogCategory or null.
       */
      getParent(): dw.catalog.Category;
      /**
       * Returns this category's ProductAttributeModel, which makes access to the
       *  category's attribute information convenient. The model is calculated
       *  based on the attribute definitions assigned to this category and the
       *  global attribute definitions for the object type 'Product'.
       *
       * @return the ProductAttributeModel for this category.
       */
      getProductAttributeModel(): dw.catalog.ProductAttributeModel;
      /**
       * Returns all products assigned to this category.
       *  The order of products in the returned collection corresponds to the
       *  defined explicit sorting of products in this category.
       *
       * @return a sorted collection of all products of this category.
       */
      getProducts(): dw.util.Collection<dw.catalog.Product>;
      /**
       * Returns the outgoing recommendations for this category.  If this category
       *  is not in the site catalog, or there is no site catalog, an empty
       *  collection is returned.  Only recommendations for which the target
       *  product exists and is assigned to the site catalog are returned.  The
       *  recommendations are sorted by their explicitly set order.
       *
       * @return the sorted collection of recommendations, never null but possibly empty.
       */
      getRecommendations(): dw.util.Collection<dw.catalog.Recommendation>;
      /**
       * Returns the outgoing recommendations for this category which are of the
       *  specified type.  Behaves the same as getRecommendations() but
       *  additionally filters by recommendation type.
       * @param type the recommendation type.
       * @return the sorted collection of recommendations, never null but possibly empty.
       */
      getRecommendations(
        type: number
      ): dw.util.Collection<dw.catalog.Recommendation>;
      /**
       * Returns the search placement of the category or null of no search placement is defined.
       *
       * @return the value of the attribute 'searchPlacement'.
       */
      getSearchPlacement(): number;
      /**
       * Returns the search rank of the category or null of no search rank is defined.
       *
       * @return the value of the attribute 'searchRank'.
       */
      getSearchRank(): number;
      /**
       * Returns the category's sitemap change frequency.
       *
       * @return the value of the attribute 'siteMapChangeFrequency'.
       */
      getSiteMapChangeFrequency(): string;
      /**
       * Returns the category's sitemap inclusion.
       *
       * @return the value of the attribute 'siteMapIncluded'.
       */
      getSiteMapIncluded(): number;
      /**
       * Returns the category's sitemap priority.
       *
       * @return the value of the attribute 'siteMapPriority'.
       */
      getSiteMapPriority(): number;
      /**
       * Returns a sorted collection of the subcategories of this catalog category,
       *  including both online and offline subcategories.
       *
       *
       *    The returned collection is sorted by position. Subcategories marked as
       *    "unsorted" always appear after those marked as "sorted" but are otherwise
       *    not in any guaranteed order.
       *
       *
       *    The returned collection contains direct subcategories only.
       *
       * @return a sorted collection of the subcategories.
       */
      getSubCategories(): dw.util.Collection<dw.catalog.Category>;
      /**
       * Returns the template property value , which is the file name of the template
       *  used to display the catalog category.
       *
       * @return the value of the property 'template'.
       */
      getTemplate(): string;
      /**
       * Returns the thumbnail image reference of this catalog category.
       *
       * @return the thumbnail image reference for this category.
       */
      getThumbnail(): dw.content.MediaFile;
      /**
       * Returns true if this catalog category has any online products assigned.
       *  When checking the online status of the product,
       *  the online flag and the online from & to dates are taken into account.
       *  Online flag, online from & to dates set for the current site takes precedence
       *  over the default values.
       *
       * @return true, if this category has at least one online product assigned, false otherwise.
       */
      hasOnlineProducts(): boolean;
      /**
       * Returns true if this catalog category has any online subcategories.
       *
       *
       *    A category is currently online if its online flag
       *    equals true and the current site date is within the date range defined by
       *    the onlineFrom and onlineTo attributes.
       *
       *
       *    Only direct subcategories are considered.
       *
       * @return true, if this category has at least one online subcategory, false otherwise.
       */
      hasOnlineSubCategories(): boolean;
      /**
       * Returns true if this category is a direct sub-category of the provided
       *  category.
       * @param parent The parent category, must not be null.
       * @return True if this category is a direct sub-category of parent, false otherwise.
       */
      isDirectSubCategoryOf(parent: dw.catalog.Category): boolean;
      /**
       * Returns the value indicating whether the catalog category is "currently
       *  online".  A category is currently online if its online flag equals true
       *  and the current site date is within the date range defined by the
       *  onlineFrom and onlineTo attributes.
       *
       * @return true if the category is currently online, false otherwise.
       */
      isOnline(): boolean;
      /**
       * Identifies if the category is the root category of its catalog.
       *
       * @return 'true' if the category is the root category of its catalog, 'false' otherwise.
       */
      isRoot(): boolean;
      /**
       * Returns true if this category is a sub-category of the provided category.
       *  This can be either a direct or an indirect sub-category.
       * @param ancestor The ancestor category, must not be null.
       * @return true if this category is a sub-category of ancestor, false otherwise.
       */
      isSubCategoryOf(ancestor: dw.catalog.Category): boolean;
      /**
       * Returns true if the category is a top level category, but not the root
       *  category.
       *
       * @return True if the category is a direct sub-category of the root category, false otherwise.
       */
      isTopLevel(): boolean;
      /**
       * Set the category's Variation Groups Display Mode.
       * @param displayMode The category's variation groups display mode which is either DISPLAY_MODE_MERGED or DISPLAY_MODE_INDIVIDUAL or null if category is set to inherit the display mode.
       */
      setDisplayMode(displayMode: number): void;
      /**
       * Set the category's search placement.
       * @param placement The category's search placement.
       */
      setSearchPlacement(placement: number): void;
      /**
       * Set the category's search rank.
       * @param rank The category's search rank.
       */
      setSearchRank(rank: number): void;
    }

    /**
     * Represents a category assignment in Commerce Cloud Digital.
     */
    class CategoryAssignment extends dw.object.ExtensibleObject {
      /**
       * The category assignment's callout message in the current locale.
       */
      readonly calloutMsg: dw.content.MarkupText;
      /**
       * The category to which this category assignment is bound.
       */
      readonly category: dw.catalog.Category;
      /**
       * The category assignment's image.
       */
      readonly image: dw.content.MediaFile;
      /**
       * The category assignment's long description in the current locale.
       */
      readonly longDescription: dw.content.MarkupText;
      /**
       * The name of the category assignment in the current locale.
       */
      readonly name: string;
      /**
       * The product to which this category assignment is bound.
       */
      readonly product: dw.catalog.Product;
      /**
       * The category assignment's short description in the current locale.
       */
      readonly shortDescription: dw.content.MarkupText;

      /**
       * Returns the category assignment's callout message in the current locale.
       *
       * @return the category assignment's callout message in the current locale, or null if it wasn't found.
       */
      getCalloutMsg(): dw.content.MarkupText;
      /**
       * Returns the category to which this category assignment is bound.
       *
       * @return The category to which this category assignment is bound.
       */
      getCategory(): dw.catalog.Category;
      /**
       * Returns the category assignment's image.
       *
       * @return the category assignment's image.
       */
      getImage(): dw.content.MediaFile;
      /**
       * Returns the category assignment's long description in the current locale.
       *
       * @return The category assignment's long description in the current locale, or null if it wasn't found.
       */
      getLongDescription(): dw.content.MarkupText;
      /**
       * Returns the name of the category assignment in the current locale.
       *
       * @return The name of the category assignment for the current locale, or null if it wasn't found.
       */
      getName(): string;
      /**
       * Returns the product to which this category assignment is bound.
       *
       * @return The product to which this category assignment is bound.
       */
      getProduct(): dw.catalog.Product;
      /**
       * Returns the category assignment's short description in the current locale.
       *
       * @return the category assignment's short description in the current locale, or null if it wasn't found.
       */
      getShortDescription(): dw.content.MarkupText;
    }

    /**
     * A CategoryLink represents a directed relationship between two catalog
     *  categories.  Merchants create category links in order to market similar or
     *  related groups of products.
     */
    class CategoryLink {
      /**
       * Represents an accessory category link.
       */
      static readonly LINKTYPE_ACCESSORY = 2;
      /**
       * Represents a cross-sell category link.
       */
      static readonly LINKTYPE_CROSS_SELL = 4;
      /**
       * Represents a miscellaneous category link.
       */
      static readonly LINKTYPE_OTHER = 1;
      /**
       * Represents a spare part category link.
       */
      static readonly LINKTYPE_SPARE_PART = 6;
      /**
       * Represents an up-sell category link.
       */
      static readonly LINKTYPE_UP_SELL = 5;

      /**
       * The object for the relation 'sourceCategory'.
       */
      readonly sourceCategory: dw.catalog.Category;
      /**
       * The object for the relation 'targetCategory'.
       */
      readonly targetCategory: dw.catalog.Category;
      /**
       * The type of this category link (see constants).
       */
      readonly typeCode: number;

      /**
       * Returns the object for the relation 'sourceCategory'.
       *
       * @return the object for the relation 'sourceCategory'
       */
      getSourceCategory(): dw.catalog.Category;
      /**
       * Returns the object for the relation 'targetCategory'.
       *
       * @return the object for the relation 'targetCategory'
       */
      getTargetCategory(): dw.catalog.Category;
      /**
       * Returns the type of this category link (see constants).
       *
       * @return the type of the link.
       */
      getTypeCode(): number;
    }

    /**
     * Represents a price book.
     */
    class PriceBook extends dw.object.ExtensibleObject {
      /**
       * The currency code of the price book.
       */
      readonly currencyCode: string;
      /**
       * The description of the price book.
       */
      readonly description: string;
      /**
       * The display name of the price book.
       */
      readonly displayName: string;
      /**
       * The ID of the price book.
       */
      readonly ID: string;
      /**
       * The online status of the price book. The online status
       *  is calculated from the online status flag and the onlineFrom
       *  onlineTo dates defined for the price book.
       */
      readonly online: boolean;
      /**
       * The online status flag of the price book.
       */
      readonly onlineFlag: boolean;
      /**
       * The date from which the price book is online or valid.
       */
      readonly onlineFrom: Date;
      /**
       * The date until which the price book is online or valid.
       */
      readonly onlineTo: Date;
      /**
       * The parent price book.
       */
      readonly parentPriceBook: dw.catalog.PriceBook;

      /**
       * Returns the currency code of the price book.
       *
       * @return Currency code of the price book
       */
      getCurrencyCode(): string;
      /**
       * Returns the description of the price book.
       *
       * @return Currency code of the price book
       */
      getDescription(): string;
      /**
       * Returns the display name of the price book.
       *
       * @return Display name of the price book
       */
      getDisplayName(): string;
      /**
       * Returns the ID of the price book.
       *
       * @return ID of the price book
       */
      getID(): string;
      /**
       * Returns the online status flag of the price book.
       *
       * @return the online status flag of the price book.
       */
      getOnlineFlag(): boolean;
      /**
       * Returns the date from which the price book is online or valid.
       *
       * @return the date from which the price book is online or valid.
       */
      getOnlineFrom(): Date;
      /**
       * Returns the date until which the price book is online or valid.
       *
       * @return the date until which the price book is online or valid.
       */
      getOnlineTo(): Date;
      /**
       * Returns the parent price book.
       *
       * @return Parent price book
       */
      getParentPriceBook(): dw.catalog.PriceBook;
      /**
       * Returns the online status of the price book. The online status
       *  is calculated from the online status flag and the onlineFrom
       *  onlineTo dates defined for the price book.
       *
       * @return The online status of the price book.
       */
      isOnline(): boolean;
    }

    /**
     * Price book manager provides methods to access price books.
     */
    class PriceBookMgr {
      /**
       * All price books defined for the organization.
       */
      static readonly allPriceBooks: dw.util.Collection<dw.catalog.PriceBook>;
      /**
       * A collection of price books that are set in the user session.
       */
      static applicablePriceBooks: dw.util.Collection<dw.catalog.PriceBook>;
      /**
       * All price books assigned to the current site.
       *
       *  Please note that this doesn't include parent price books not assigned
       *  to the site, but considered by the price lookup.
       */
      static readonly sitePriceBooks: dw.util.Collection<dw.catalog.PriceBook>;

      /**
       * Returns all price books defined for the organization.
       *
       * @return All price books of the organization.
       */
      static getAllPriceBooks(): dw.util.Collection<dw.catalog.PriceBook>;
      /**
       * Returns a collection of price books that are set in the user session.
       *
       * @return Collection of applicable price books set in the session.
       */
      static getApplicablePriceBooks(): dw.util.Collection<
        dw.catalog.PriceBook
      >;
      /**
       * Returns the price book of the current organization matching the
       *  specified ID.
       * @param priceBookID The price book id.
       * @return Price book or null of not found
       */
      static getPriceBook(priceBookID: string): dw.catalog.PriceBook;
      /**
       * Returns all price books assigned to the current site.
       *
       *  Please note that this doesn't include parent price books not assigned
       *  to the site, but considered by the price lookup.
       *
       * @return All price books assigned to the current site.
       */
      static getSitePriceBooks(): dw.util.Collection<dw.catalog.PriceBook>;
      /**
       * Sets one or more price books to be considered by the product price lookup. The information is
       *  stored in the user session. If no price book is set in the user session, all active and valid price books assigned to
       *  the site are used for the price lookup. If price books are set, only those price books are considered by the price
       *  lookup. Note that the system does not assure that a price book set by this API is assigned to the current
       *  site.
       * @param priceBooks The price books that are set in the session as applicable price books.
       */
      static setApplicablePriceBooks(
        ...priceBooks: dw.catalog.PriceBook[]
      ): void;
    }

    /**
     * Represents a product in Commerce Cloud Digital. Products are identified by
     *  a unique product ID, sometimes called the SKU. There are several different
     *  types of product:
     *
     *  <ul>
     *  <li><b>Simple product</b></li>
     *  <li><b>Master products:</b> This type of product defines a template for a set
     *  of related products which differ only by a set of defined
     *  &quot;variation attributes&quot;, such as size or color. Master products are not
     *  orderable themselves. The variation information for a master product is
     *  available through its <a href="class_dw_catalog_ProductVariationModel.html">ProductVariationModel</a>.</li>
     *  <li><b>Variant:</b> Variants are the actual orderable products that are
     *  related to a master product. Each variant of a master product has a unique
     *  set of values for the defined variation attributes. Variants are said to be
     *  &quot;mastered&quot; by the corresponding master product.</li>
     *  <li><b>Option products:</b> Option products define additional options, such
     *  as a warranty, which can be purchased for a defined price at the time the
     *  product is purchased. The option information for an option product is
     *  available through its <a href="class_dw_catalog_ProductOptionModel.html">ProductOptionModel</a>.</li>
     *  <li><b>Product-sets:</b> A product-set is a set of products which the
     *  merchant can sell as a collection in the storefront, for example an outfit of
     *  clothes. Product-sets are not orderable and therefore do not define prices.
     *  They exist only to group the products together in the storefront UI. Members
     *  of the set are called &quot;product-set-products&quot;.</li>
     *  <li><b>Products bundles:</b> A collection of products which can be ordered as
     *  a single unit and therefore can define its own price and inventory record.</li>
     *  </ul>
     *
     *  <p>
     *  Product price and availability information are retrievable through
     *  <a href="class_dw_catalog_Product.html#dw_catalog_Product_getPriceModel_DetailAnchor">getPriceModel()</a> and <a href="class_dw_catalog_Product.html#dw_catalog_Product_getAvailabilityModel_DetailAnchor">getAvailabilityModel()</a> respectively.
     *  Attribute information is retrievable through <a href="class_dw_catalog_Product.html#dw_catalog_Product_getAttributeModel_DetailAnchor">getAttributeModel()</a>.
     *  Products may reference other products, either as recommendations or product
     *  links. This class provides the methods for retrieving these referenced
     *  products.
     *  </p><p>
     *  Products belong to a catalog (the &quot;owning&quot; catalog) and are assigned to
     *  categories in other catalogs. Products assigned to categories in the site
     *  catalog are typically orderable on the site.
     *  </p><p>
     *  Any API method which returns products will return an instance of a
     *  <a href="class_dw_catalog_Variant.html">Variant</a> for variant products. This subclass contains
     *  methods which are specific to this type of product.</p>
     */
    class Product extends dw.object.ExtensibleObject {
      /**
       * The active data for this product, for the current site.
       */
      readonly activeData: dw.catalog.ProductActiveData;
      /**
       * A collection of all categories to which this product is assigned.
       */
      readonly allCategories: dw.util.Collection<dw.catalog.Category>;
      /**
       * All category assignments for this product in any catalog.
       */
      readonly allCategoryAssignments: dw.util.Collection<
        dw.catalog.CategoryAssignment
      >;
      /**
       * All incoming ProductLinks.
       */
      readonly allIncomingProductLinks: dw.util.Collection<
        dw.catalog.ProductLink
      >;
      /**
       * All outgoing ProductLinks.
       */
      readonly allProductLinks: dw.util.Collection<dw.catalog.ProductLink>;
      /**
       * Returns true if the product is assigned to the current site (via the site catalog), otherwise
       *  false is returned.
       *
       *  In case of the product being a variant, the variant will be considered as assigned if its master, one of the
       *  variation groups it is in or itself is assigned to the site catalog. In case this is triggered for a variation
       *  group the variation group is considered as assigned if its master or itself is assigned.
       */
      readonly assignedToSiteCatalog: boolean;
      /**
       * Returns this product's ProductAttributeModel, which makes access to the
       *  product attribute information convenient. The model is calculated based
       *  on the product attributes assigned to this product's classification
       *  category (or any of it's ancestors) and the global attribute definitions
       *  for the system object type 'Product'. If this product has no
       *  classification category, the attribute model is calculated on the global
       *  attribute definitions only. If this product is a variant, then the
       *  attribute model is calculated based on the classification category of its
       *  corresponding master product.
       */
      readonly attributeModel: dw.catalog.ProductAttributeModel;
      /**
       * The availability model, which can be used to determine availability
       *  information for a product.
       */
      readonly availabilityModel: dw.catalog.ProductAvailabilityModel;
      /**
       * Identifies if the product is available.
       */
      readonly available: boolean;
      /**
       * Identifies if the product is available.
       */
      availableFlag: boolean;
      /**
       * The Brand of the product.
       */
      readonly brand: string;
      /**
       * Identifies if this product instance is a product bundle.
       */
      readonly bundle: boolean;
      /**
       * Identifies if this product instance is bundled within at least one
       *  product bundle.
       */
      readonly bundled: boolean;
      /**
       * A collection containing all products that participate in the
       *  product bundle.
       */
      readonly bundledProducts: dw.util.Collection<dw.catalog.Product>;
      /**
       * A collection of all bundles in which this product is included.
       *  The method only returns bundles assigned to the current site.
       */
      readonly bundles: dw.util.Collection<dw.catalog.Product>;
      /**
       * A collection of all categories to which this product is assigned
       *  and which are also available through the current site.
       */
      readonly categories: dw.util.Collection<dw.catalog.Category>;
      /**
       * Identifies if this product is bound to at least one catalog category.
       */
      readonly categorized: boolean;
      /**
       * A collection of category assignments for this product in
       *  the current site catalog.
       */
      readonly categoryAssignments: dw.util.Collection<
        dw.catalog.CategoryAssignment
      >;
      /**
       * The classification category associated with this Product. A
       *  product has a single classification category which may or may not be in
       *  the site catalog. The classification category defines the attribute set
       *  of the product. See getAttributeModel() for
       *  how the classification category is used.
       */
      readonly classificationCategory: dw.catalog.Category;
      /**
       * The European Article Number of the product.
       */
      readonly EAN: string;
      /**
       * Identifies if the product is Facebook enabled.
       */
      readonly facebookEnabled: boolean;
      /**
       * The ID of the product.
       */
      readonly ID: string;
      /**
       * The product's image.
       */
      readonly image: dw.content.MediaFile;
      /**
       * Returns incoming ProductLinks, where the source product is a site product.
       */
      readonly incomingProductLinks: dw.util.Collection<dw.catalog.ProductLink>;
      /**
       * The product's long description in the current locale.
       */
      readonly longDescription: dw.content.MarkupText;
      /**
       * The name of the product manufacturer.
       */
      readonly manufacturerName: string;
      /**
       * The value of the manufacturer's stock keeping unit.
       */
      readonly manufacturerSKU: string;
      /**
       * Identifies if this product instance is a product master.
       */
      readonly master: boolean;
      /**
       * The minimum order quantity for this product.
       */
      readonly minOrderQuantity: dw.value.Quantity;
      /**
       * The name of the product in the current locale.
       */
      readonly name: string;
      /**
       * The online status of the product. The online status
       *  is calculated from the online status flag and the onlineFrom
       *  onlineTo dates defined for the product.
       */
      readonly online: boolean;
      /**
       * A collection of all currently online categories to which this
       *  product is assigned and which are also available through the current
       *  site. A category is currently online if its online flag equals true and
       *  the current site date is within the date range defined by the onlineFrom
       *  and onlineTo attributes.
       */
      readonly onlineCategories: dw.util.Collection<dw.catalog.Category>;
      /**
       * The online status flag of the product.
       */
      readonly onlineFlag: boolean;
      /**
       * The date from which the product is online or valid.
       */
      readonly onlineFrom: Date;
      /**
       * The date until which the product is online or valid.
       */
      readonly onlineTo: Date;
      /**
       * The product's option model. The option values selections are
       *  initialized with the values defined for the product, or the default values
       *  defined for the option.
       */
      readonly optionModel: dw.catalog.ProductOptionModel;
      /**
       * Identifies if the product has options.
       */
      readonly optionProduct: boolean;
      /**
       * A list of outgoing recommendations for this product. This method
       *  behaves similarly to getRecommendations() but additionally filters out
       *  recommendations for which the target product is unorderable according to
       *  its product availability model.
       */
      readonly orderableRecommendations: dw.util.Collection<
        dw.catalog.Recommendation
      >;
      /**
       * Returns product's page description in the default locale.
       */
      readonly pageDescription: string;
      /**
       * The product's page keywords in the default locale.
       */
      readonly pageKeywords: string;
      /**
       * All page meta tags, defined for this instance for which content can be generated.
       *
       *  The meta tag content is generated based on the product detail page meta tag context and rules. The rules are
       *  obtained from the current product context or inherited from variation groups, master product, the primary
       *  category, up to the root category.
       */
      readonly pageMetaTags: Array<dw.web.PageMetaTag>;
      /**
       * The product's page title in the default locale.
       */
      readonly pageTitle: string;
      /**
       * The product's page URL in the default locale.
       */
      readonly pageURL: string;
      /**
       * Identifies if the product is Pinterest enabled.
       */
      readonly pinterestEnabled: boolean;
      /**
       * The price model, which can be used to retrieve a price
       *  for this product.
       */
      readonly priceModel: dw.catalog.ProductPriceModel;
      /**
       * The primary category of the product within the current site catalog.
       */
      readonly primaryCategory: dw.catalog.Category;
      /**
       * The category assignment to the primary category in the current site
       *  catalog or null if no primary category is defined within the current site
       *  catalog.
       */
      readonly primaryCategoryAssignment: dw.catalog.CategoryAssignment;
      /**
       * Returns 'true' if the instance represents a product. Returns 'false' if
       *  the instance represents a product set.
       */
      readonly product: boolean;
      /**
       * All outgoing ProductLinks, where the target product is also
       *  available in the current site. The ProductLinks are unsorted.
       */
      readonly productLinks: dw.util.Collection<dw.catalog.ProductLink>;
      /**
       * Returns 'true' if the instance represents a product set, otherwise 'false'.
       */
      readonly productSet: boolean;
      /**
       * Returns true if this product is part of any product set, otherwise false.
       */
      readonly productSetProduct: boolean;
      /**
       * A collection of all products which are assigned to this product
       *  and which are also available through the current site.  If this product
       *  does not represent a product set then an empty collection will be
       *  returned.
       */
      readonly productSetProducts: dw.util.Collection<dw.catalog.Product>;
      /**
       * A collection of all product sets in which this product is included.
       *  The method only returns product sets assigned to the current site.
       */
      readonly productSets: dw.util.Collection<dw.catalog.Product>;
      /**
       * The outgoing recommendations for this product which
       *  belong to the site catalog.  If this product is not assigned to the site
       *  catalog, or there is no site catalog, an empty collection is returned.
       *  Only recommendations for which the target product exists and is assigned
       *  to the site catalog are returned.  The recommendations are sorted by
       *  their explicitly set order.
       */
      readonly recommendations: dw.util.Collection<dw.catalog.Recommendation>;
      /**
       * Identifies if this product instance is part of a retail set.
       */
      readonly retailSet: boolean;
      /**
       * Identifies if the product is searchable.
       */
      readonly searchable: boolean;
      /**
       * Returns, whether the product is currently searchable.
       */
      readonly searchableFlag: boolean;
      /**
       * The searchable status of the Product if unavailable.
       *
       *  Besides true or false, the return value null indicates that the value is not set.
       */
      readonly searchableIfUnavailableFlag: boolean;
      /**
       * The product's search placement classification. The higher the
       *  numeric product placement value, the more relevant is the product when
       *  sorting search results. The range of numeric placement values is
       *  defined in the meta data of object type 'Product' and can therefore be
       *  customized.
       */
      readonly searchPlacement: number;
      /**
       * The product's search rank. The higher the numeric product rank,
       *  the more relevant is the product when sorting search results. The range of
       *  numeric rank values is defined in the meta data of object type 'Product'
       *  and can therefore be customized.
       */
      readonly searchRank: number;
      /**
       * The product's short description in the current locale.
       */
      readonly shortDescription: dw.content.MarkupText;
      /**
       * The product's change frequency needed for the sitemap creation.
       */
      readonly siteMapChangeFrequency: string;
      /**
       * The status if the product is included into the sitemap.
       */
      readonly siteMapIncluded: number;
      /**
       * The product's priority needed for the sitemap creation.
       */
      readonly siteMapPriority: number;
      /**
       * Returns 'true' if the product is assigned to the current site (via the
       *  site catalog), otherwise 'false' is returned.
       */
      readonly siteProduct: boolean;
      /**
       * The steps in which the order amount of the product can be
       *  increased.
       */
      readonly stepQuantity: dw.value.Quantity;
      /**
       * The store receipt name of the product in the current locale.
       */
      readonly storeReceiptName: string;
      /**
       * The store tax class ID.
       *  This is an optional override for in-store tax calculation.
       */
      readonly storeTaxClass: string;
      /**
       * The ID of the product's tax class.
       */
      readonly taxClassID: string;
      /**
       * The name of the product's rendering template.
       */
      readonly template: string;
      /**
       * The product's thumbnail image.
       */
      readonly thumbnail: dw.content.MediaFile;
      /**
       * The product's sales unit.
       */
      readonly unit: string;
      /**
       * The Universal Product Code of the product.
       */
      readonly UPC: string;
      /**
       * Identifies if this product instance is mastered by a product master.
       */
      readonly variant: boolean;
      /**
       * A collection of all variants assigned to this variation master
       *  or variation group product. All variants are returned regardless of whether
       *  they are online or offline.
       *
       *  If this product does not represent a variation master or variation group
       *  product then an empty collection is returned.
       */
      readonly variants: dw.util.Collection<dw.catalog.Variant>;
      /**
       * Identifies if this product instance is a variation group product.
       */
      readonly variationGroup: boolean;
      /**
       * A collection of all variation groups assigned to this variation
       *  master product. All variation groups are returned regardless of whether
       *  they are online or offline.
       *
       *  If this product does not represent a variation master product then an
       *  empty collection is returned.
       */
      readonly variationGroups: dw.util.Collection<dw.catalog.VariationGroup>;
      /**
       * The variation model of this product. If this product is a master
       *  product, then the returned model will encapsulate all the information
       *  about its variation attributes and variants. If this product is a variant
       *  product, then the returned model will encapsulate all the same
       *  information, but additionally pre-select all the variation attribute
       *  values of this variant. (See ProductVariationModel for
       *  details on what "selected" means.) If this product is neither a master
       *  product or a variation product, then a model will be returned but will be
       *  essentially empty and not useful for any particular purpose.
       */
      readonly variationModel: dw.catalog.ProductVariationModel;

      /**
       * Identifies if this product is bound to the specified catalog category.
       * @param category the CatalogCategory to check.
       * @return true if the product is bound to the CatalogCategory, false otherwise.
       */
      assignedToCategory(category: dw.catalog.Category): boolean;
      /**
       * Returns the active data for this product, for the current site.
       *
       * @return the active data for this product for the current site.
       */
      getActiveData(): dw.catalog.ProductActiveData;
      /**
       * Returns a collection of all categories to which this product is assigned.
       *
       * @return Collection of categories.
       */
      getAllCategories(): dw.util.Collection<dw.catalog.Category>;
      /**
       * Returns all category assignments for this product in any catalog.
       *
       * @return Collection of category assignments of the product in any catalog.
       */
      getAllCategoryAssignments(): dw.util.Collection<
        dw.catalog.CategoryAssignment
      >;
      /**
       * Returns all incoming ProductLinks.
       *
       * @return a collection of all incoming ProductLinks.
       */
      getAllIncomingProductLinks(): dw.util.Collection<dw.catalog.ProductLink>;
      /**
       * Returns all incoming ProductLinks of a specific type.
       * @param type the type of ProductLinks to use.
       * @return a collection of all incoming ProductLinks of a specific type.
       */
      getAllIncomingProductLinks(
        type: number
      ): dw.util.Collection<dw.catalog.ProductLink>;
      /**
       * Returns all outgoing ProductLinks.
       *
       * @return a collection of all outgoing ProductLinks.
       */
      getAllProductLinks(): dw.util.Collection<dw.catalog.ProductLink>;
      /**
       * Returns all outgoing ProductLinks of a specific type.
       * @param type the type of ProductLinks to fetch.
       * @return a collection of all outgoing ProductLinks of a specific type.
       */
      getAllProductLinks(
        type: number
      ): dw.util.Collection<dw.catalog.ProductLink>;
      /**
       * Returns the outgoing recommendations for this product which belong to the
       *  specified catalog. The recommendations are sorted by their explicitly set
       *  order.
       * @param catalog the catalog containing the recommendations.
       * @return the sorted collection of recommendations, never null but possibly empty.
       */
      getAllRecommendations(
        catalog: dw.catalog.Catalog
      ): dw.util.Collection<dw.catalog.Recommendation>;
      /**
       * Returns the outgoing recommendations for this product which are of the
       *  specified type and which belong to the specified catalog.
       *  The recommendations are sorted by their explicitly set order.
       * @param catalog the catalog containing the recommendations.
       * @param type the recommendation type.
       * @return the sorted collection of recommendations, never null but possibly empty.
       */
      getAllRecommendations(
        catalog: dw.catalog.Catalog,
        type: number
      ): dw.util.Collection<dw.catalog.Recommendation>;
      /**
       * Returns this product's ProductAttributeModel, which makes access to the
       *  product attribute information convenient. The model is calculated based
       *  on the product attributes assigned to this product's classification
       *  category (or any of it's ancestors) and the global attribute definitions
       *  for the system object type 'Product'. If this product has no
       *  classification category, the attribute model is calculated on the global
       *  attribute definitions only. If this product is a variant, then the
       *  attribute model is calculated based on the classification category of its
       *  corresponding master product.
       *
       * @return the ProductAttributeModel for this product.
       */
      getAttributeModel(): dw.catalog.ProductAttributeModel;
      /**
       * Returns the availability model, which can be used to determine availability
       *  information for a product.
       *
       * @return the availability model for a product.
       */
      getAvailabilityModel(): dw.catalog.ProductAvailabilityModel;
      /**
       * Returns the availability model of the given inventory list, which can be
       *  used to determine availability information for a product.
       * @param list The inventory list to get the availability model for. Must not be null or an exception will be raised.
       * @return the availability model of the given inventory list for a product.
       */
      getAvailabilityModel(
        list: dw.catalog.ProductInventoryList
      ): dw.catalog.ProductAvailabilityModel;
      /**
       * Identifies if the product is available.
       *
       * @return the availability status flag of the product.
       */
      getAvailableFlag(): boolean;
      /**
       * Returns the Brand of the product.
       *
       * @return the Brand of the product.
       */
      getBrand(): string;
      /**
       * Returns the quantity of the specified product within the bundle. If the
       *  specified product is not part of the bundle, a 0 quantity is returned.
       * @param aProduct The product to determine the quantity for.
       * @return The quantity of the product within the bundle or 0 if the product is not part of the bundle.
       */
      getBundledProductQuantity(
        aProduct: dw.catalog.Product
      ): dw.value.Quantity;
      /**
       * Returns a collection containing all products that participate in the
       *  product bundle.
       *
       * @return A collection containing all products of the product bundle.
       */
      getBundledProducts(): dw.util.Collection<dw.catalog.Product>;
      /**
       * Returns a collection of all bundles in which this product is included.
       *  The method only returns bundles assigned to the current site.
       *
       * @return Collection of bundles in which this product is included, possibly empty.
       */
      getBundles(): dw.util.Collection<dw.catalog.Product>;
      /**
       * Returns a collection of all categories to which this product is assigned
       *  and which are also available through the current site.
       *
       * @return Collection of categories to which this product is assigned and which are also available through the current site.
       */
      getCategories(): dw.util.Collection<dw.catalog.Category>;
      /**
       * Returns the category assignment for a specific category.
       * @param category the category to use when fetching assignments.
       * @return The category assignment for a specific category.
       */
      getCategoryAssignment(
        category: dw.catalog.Category
      ): dw.catalog.CategoryAssignment;
      /**
       * Returns a collection of category assignments for this product in
       *  the current site catalog.
       *
       * @return Collection of category assignments.
       */
      getCategoryAssignments(): dw.util.Collection<
        dw.catalog.CategoryAssignment
      >;
      /**
       * Returns the classification category associated with this Product. A
       *  product has a single classification category which may or may not be in
       *  the site catalog. The classification category defines the attribute set
       *  of the product. See getAttributeModel() for
       *  how the classification category is used.
       *
       * @return the associated classification Category, or null if none is associated.
       */
      getClassificationCategory(): dw.catalog.Category;
      /**
       * Returns the European Article Number of the product.
       *
       * @return the European Article Number of the product.
       */
      getEAN(): string;
      /**
       * Returns the ID of the product.
       *
       * @return ID of the product.
       */
      getID(): string;
      /**
       * Returns the product's image.
       *
       * @return the product's image.
       */
      getImage(): dw.content.MediaFile;
      /**
       * The method calls getImages(String) and returns the image at
       *  the specific index. If no image for specified index is available the
       *  method returns null.
       * @param viewtype the view type annotated to image
       * @param index the index number of the image within image list
       * @return the MediaFile or null
       */
      getImage(viewtype: string, index: number): dw.content.MediaFile;
      /**
       * The method calls getImages(String) and returns the first image.
       *  If no image is available the method returns null.
       *
       *  When called for a variant with defined images for specified view type the
       *  method returns the first image.
       *
       *  When called for a variant without defined images for specified view type
       *  the method returns the first master product image. If no master product
       *  images are defined, the method returns null.
       * @param viewtype the view type annotated to image
       * @return the MediaFile or null
       */
      getImage(viewtype: string): dw.content.MediaFile;
      /**
       * Returns all images assigned to this product for a specific view type,
       *  e.g. all 'thumbnail' images. The images are returned in the order of
       *  their index number ascending.
       *
       *  When called for a master the method returns the images specific to the
       *  master, which are typically the fall back images.
       * @param viewtype the view type annotated to images
       * @return a list of MediaFile objects, possibly empty
       */
      getImages(viewtype: string): dw.util.List<dw.content.MediaFile>;
      /**
       * Returns incoming ProductLinks, where the source product is a site product.
       *
       * @return a collection of incoming ProductLinks, where the source product is a site product.
       */
      getIncomingProductLinks(): dw.util.Collection<dw.catalog.ProductLink>;
      /**
       * Returns incoming ProductLinks, where the source product is a site product
       *  of a specific type.
       * @param type the type of ProductLinks to fetch.
       * @return a collection of incoming ProductLinks, where the source product is a site product of a specific type.
       */
      getIncomingProductLinks(
        type: number
      ): dw.util.Collection<dw.catalog.ProductLink>;
      /**
       * Returns the product's long description in the current locale.
       *
       * @return The product's long description in the current locale, or null if it wasn't found.
       */
      getLongDescription(): dw.content.MarkupText;
      /**
       * Returns the name of the product manufacturer.
       *
       * @return the name of the product manufacturer.
       */
      getManufacturerName(): string;
      /**
       * Returns the value of the manufacturer's stock keeping unit.
       *
       * @return the value of the manufacturer's stock keeping unit.
       */
      getManufacturerSKU(): string;
      /**
       * Returns the minimum order quantity for this product.
       *
       * @return the minimum order quantity of the product.
       */
      getMinOrderQuantity(): dw.value.Quantity;
      /**
       * Returns the name of the product in the current locale.
       *
       * @return The name of the product for the current locale, or null if it wasn't found.
       */
      getName(): string;
      /**
       * Returns a collection of all currently online categories to which this
       *  product is assigned and which are also available through the current
       *  site. A category is currently online if its online flag equals true and
       *  the current site date is within the date range defined by the onlineFrom
       *  and onlineTo attributes.
       *
       * @return Collection of currently online categories to which this product is assigned and which are also available through the current site.
       */
      getOnlineCategories(): dw.util.Collection<dw.catalog.Category>;
      /**
       * Returns the online status flag of the product.
       *
       * @return the online status flag of the product.
       */
      getOnlineFlag(): boolean;
      /**
       * Returns the date from which the product is online or valid.
       *
       * @return the date from which the product is online or valid.
       */
      getOnlineFrom(): Date;
      /**
       * Returns the date until which the product is online or valid.
       *
       * @return the date until which the product is online or valid.
       */
      getOnlineTo(): Date;
      /**
       * Returns the product's option model. The option values selections are
       *  initialized with the values defined for the product, or the default values
       *  defined for the option.
       *
       * @return the products option model.
       */
      getOptionModel(): dw.catalog.ProductOptionModel;
      /**
       * Returns a list of outgoing recommendations for this product. This method
       *  behaves similarly to getRecommendations() but additionally filters out
       *  recommendations for which the target product is unorderable according to
       *  its product availability model.
       *
       * @return the sorted collection of recommendations, never null but possibly empty.
       */
      getOrderableRecommendations(): dw.util.Collection<
        dw.catalog.Recommendation
      >;
      /**
       * Returns a list of outgoing recommendations for this product. This method
       *  behaves similarly to getRecommendations(Number) but additionally
       *  filters out recommendations for which the target product is unorderable
       *  according to its product availability model.
       * @param type the recommendation type.
       * @return the sorted collection of recommendations, never null but possibly empty.
       */
      getOrderableRecommendations(
        type: number
      ): dw.util.Collection<dw.catalog.Recommendation>;
      /**
       * Returns product's page description in the default locale.
       *
       * @return The product's page description in the default locale, or null if it wasn't found.
       */
      getPageDescription(): string;
      /**
       * Returns the product's page keywords in the default locale.
       *
       * @return The product's page keywords in the default locale, or null if it wasn't found.
       */
      getPageKeywords(): string;
      /**
       * Returns the page meta tag for the specified id.
       *
       *  The meta tag content is generated based on the product detail page meta tag context and rule. The rule is
       *  obtained from the current product context or inherited from variation groups, master product, the primary
       *  category, up to the root category.
       *
       *  Null will be returned if the meta tag is undefined on the current instance, or if no rule can be found for the
       *  current context, or if the rule resolves to an empty string.
       * @param id the ID to get the page meta tag for
       * @return page meta tag containing content generated based on rules
       */
      getPageMetaTag(id: string): dw.web.PageMetaTag;
      /**
       * Returns all page meta tags, defined for this instance for which content can be generated.
       *
       *  The meta tag content is generated based on the product detail page meta tag context and rules. The rules are
       *  obtained from the current product context or inherited from variation groups, master product, the primary
       *  category, up to the root category.
       *
       * @return page meta tags defined for this instance, containing content generated based on rules
       */
      getPageMetaTags(): Array<dw.web.PageMetaTag>;
      /**
       * Returns the product's page title in the default locale.
       *
       * @return The product's page title in the default locale, or null if it wasn't found.
       */
      getPageTitle(): string;
      /**
       * Returns the product's page URL in the default locale.
       *
       * @return The product's page URL in the default locale, or null if it wasn't found.
       */
      getPageURL(): string;
      /**
       * Returns the price model, which can be used to retrieve a price
       *  for this product.
       *
       * @return the price model, which can be used to retrieve a price for this product.
       */
      getPriceModel(): dw.catalog.ProductPriceModel;
      /**
       * Returns the price model based on the specified optionModel. The
       *  price model can be used to retrieve a price
       *  for this product. Prices are calculated based on the option values
       *  selected in the specified option model.
       * @param optionModel the option model to use when fetching the price model.
       * @return the price model based on the specified optionModel.
       */
      getPriceModel(
        optionModel: dw.catalog.ProductOptionModel
      ): dw.catalog.ProductPriceModel;
      /**
       * Returns the primary category of the product within the current site catalog.
       *
       * @return The product's primary category or null.
       */
      getPrimaryCategory(): dw.catalog.Category;
      /**
       * Returns the category assignment to the primary category in the current site
       *  catalog or null if no primary category is defined within the current site
       *  catalog.
       *
       * @return The category assignment to the primary category or null.
       */
      getPrimaryCategoryAssignment(): dw.catalog.CategoryAssignment;
      /**
       * Returns all outgoing ProductLinks, where the target product is also
       *  available in the current site. The ProductLinks are unsorted.
       *
       * @return a collection of outgoing ProductLinks where the target product is also available in the current site.
       */
      getProductLinks(): dw.util.Collection<dw.catalog.ProductLink>;
      /**
       * Returns all outgoing ProductLinks of a specific type, where the target
       *  product is also available in the current site. The ProductLinks are
       *  sorted.
       * @param type the type of ProductLinks to fetch.
       * @return a collection of outgoing ProductLinks where the target product is also available in the current site.
       */
      getProductLinks(type: number): dw.util.Collection<dw.catalog.ProductLink>;
      /**
       * Returns a collection of all products which are assigned to this product
       *  and which are also available through the current site.  If this product
       *  does not represent a product set then an empty collection will be
       *  returned.
       *
       * @return Collection of products which are assigned to this product and which are also available through the current site.
       */
      getProductSetProducts(): dw.util.Collection<dw.catalog.Product>;
      /**
       * Returns a collection of all product sets in which this product is included.
       *  The method only returns product sets assigned to the current site.
       *
       * @return Collection of product sets in which this product is included, possibly empty.
       */
      getProductSets(): dw.util.Collection<dw.catalog.Product>;
      /**
       * Returns the outgoing recommendations for this product which
       *  belong to the site catalog.  If this product is not assigned to the site
       *  catalog, or there is no site catalog, an empty collection is returned.
       *  Only recommendations for which the target product exists and is assigned
       *  to the site catalog are returned.  The recommendations are sorted by
       *  their explicitly set order.
       *
       * @return the sorted collection of recommendations, never null but possibly empty.
       */
      getRecommendations(): dw.util.Collection<dw.catalog.Recommendation>;
      /**
       * Returns the outgoing recommendations for this product which are of the
       *  specified type and which belong to the site catalog.  Behaves the same as
       *  getRecommendations() but additionally filters by recommendation
       *  type.
       * @param type the recommendation type.
       * @return the sorted collection of recommendations, never null but possibly empty.
       */
      getRecommendations(
        type: number
      ): dw.util.Collection<dw.catalog.Recommendation>;
      /**
       * Returns, whether the product is currently searchable.
       *
       * @return the searchable status flag of the product.
       */
      getSearchableFlag(): boolean;
      /**
       * Returns the searchable status of the Product if unavailable.
       *
       *  Besides true or false, the return value null indicates that the value is not set.
       *
       * @return The searchable status of the product if unavailable or null if not set.
       */
      getSearchableIfUnavailableFlag(): boolean;
      /**
       * Returns the product's search placement classification. The higher the
       *  numeric product placement value, the more relevant is the product when
       *  sorting search results. The range of numeric placement values is
       *  defined in the meta data of object type 'Product' and can therefore be
       *  customized.
       *
       * @return The product's search placement classification.
       */
      getSearchPlacement(): number;
      /**
       * Returns the product's search rank. The higher the numeric product rank,
       *  the more relevant is the product when sorting search results. The range of
       *  numeric rank values is defined in the meta data of object type 'Product'
       *  and can therefore be customized.
       *
       * @return The product's search rank.
       */
      getSearchRank(): number;
      /**
       * Returns the product's short description in the current locale.
       *
       * @return the product's short description in the current locale, or null if it wasn't found.
       */
      getShortDescription(): dw.content.MarkupText;
      /**
       * Returns the product's change frequency needed for the sitemap creation.
       *
       * @return The product's sitemap change frequency.
       */
      getSiteMapChangeFrequency(): string;
      /**
       * Returns the status if the product is included into the sitemap.
       *
       * @return the value of the attribute 'siteMapIncluded'.
       */
      getSiteMapIncluded(): number;
      /**
       * Returns the product's priority needed for the sitemap creation.
       *
       * @return The product's sitemap priority.
       */
      getSiteMapPriority(): number;
      /**
       * Returns the steps in which the order amount of the product can be
       *  increased.
       *
       * @return the order amount by which the product can be increased.
       */
      getStepQuantity(): dw.value.Quantity;
      /**
       * Returns the store receipt name of the product in the current locale.
       *
       * @return The store receipt name of the product for the current locale, or null if it wasn't found.
       */
      getStoreReceiptName(): string;
      /**
       * Returns the store tax class ID.
       *  This is an optional override for in-store tax calculation.
       *
       * @return the store tax class id.
       */
      getStoreTaxClass(): string;
      /**
       * Returns the ID of the product's tax class.
       *
       * @return the ID of the product's tax class.
       */
      getTaxClassID(): string;
      /**
       * Returns the name of the product's rendering template.
       *
       * @return the name of the product's rendering template.
       */
      getTemplate(): string;
      /**
       * Returns the product's thumbnail image.
       *
       * @return the product's thumbnail image.
       */
      getThumbnail(): dw.content.MediaFile;
      /**
       * Returns the product's sales unit.
       *
       * @return the products sales unit.
       */
      getUnit(): string;
      /**
       * Returns the Universal Product Code of the product.
       *
       * @return the Universal Product Code of the product.
       */
      getUPC(): string;
      /**
       * Returns a collection of all variants assigned to this variation master
       *  or variation group product. All variants are returned regardless of whether
       *  they are online or offline.
       *
       *  If this product does not represent a variation master or variation group
       *  product then an empty collection is returned.
       *
       * @return Collection of variants associated with this variation master or variation group product.
       */
      getVariants(): dw.util.Collection<dw.catalog.Variant>;
      /**
       * Returns a collection of all variation groups assigned to this variation
       *  master product. All variation groups are returned regardless of whether
       *  they are online or offline.
       *
       *  If this product does not represent a variation master product then an
       *  empty collection is returned.
       *
       * @return Collection of variation groups associated with this variation master product.
       */
      getVariationGroups(): dw.util.Collection<dw.catalog.VariationGroup>;
      /**
       * Returns the variation model of this product. If this product is a master
       *  product, then the returned model will encapsulate all the information
       *  about its variation attributes and variants. If this product is a variant
       *  product, then the returned model will encapsulate all the same
       *  information, but additionally pre-select all the variation attribute
       *  values of this variant. (See ProductVariationModel for
       *  details on what "selected" means.) If this product is neither a master
       *  product or a variation product, then a model will be returned but will be
       *  essentially empty and not useful for any particular purpose.
       *
       * @return the variation model of the product.
       */
      getVariationModel(): dw.catalog.ProductVariationModel;
      /**
       * Identifies if the specified product participates in this product bundle.
       *  If this product does not represent a bundle at all, then false will
       *  always be returned.
       * @param product the product to check for participation.
       * @return true if the product participates in the bundle, false otherwise.
       */
      includedInBundle(product: dw.catalog.Product): boolean;
      /**
       * Returns 'true' if item is assigned to the specified
       *  category.
       * @param category the category to check.
       * @return true if item is assigned to category.
       */
      isAssignedToCategory(category: dw.catalog.Category): boolean;
      /**
       * Returns true if the product is assigned to the current site (via the site catalog), otherwise
       *  false is returned.
       *
       *  In case of the product being a variant, the variant will be considered as assigned if its master, one of the
       *  variation groups it is in or itself is assigned to the site catalog. In case this is triggered for a variation
       *  group the variation group is considered as assigned if its master or itself is assigned.
       *
       * @return 'true' if product assigned to the site catalog
       */
      isAssignedToSiteCatalog(): boolean;
      /**
       * Identifies if the product is available.
       *
       * @return the value of the attribute 'available'.
       */
      isAvailable(): boolean;
      /**
       * Identifies if this product instance is a product bundle.
       *
       * @return true if the product is a bundle, false otherwise.
       */
      isBundle(): boolean;
      /**
       * Identifies if this product instance is bundled within at least one
       *  product bundle.
       *
       * @return true if the product is bundled, false otherwise.
       */
      isBundled(): boolean;
      /**
       * Identifies if this product is bound to at least one catalog category.
       *
       * @return true if the product is bound to at least one catalog category, false otherwise.
       */
      isCategorized(): boolean;
      /**
       * Identifies if the product is Facebook enabled.
       *
       * @return the value of the attribute 'facebookEnabled'.
       */
      isFacebookEnabled(): boolean;
      /**
       * Identifies if this product instance is a product master.
       *
       * @return true if the product is a master, false otherwise.
       */
      isMaster(): boolean;
      /**
       * Returns the online status of the product. The online status
       *  is calculated from the online status flag and the onlineFrom
       *  onlineTo dates defined for the product.
       *
       * @return the online status of the product.
       */
      isOnline(): boolean;
      /**
       * Identifies if the product has options.
       *
       * @return true if product has options, false otherwise.
       */
      isOptionProduct(): boolean;
      /**
       * Identifies if the product is Pinterest enabled.
       *
       * @return the value of the attribute 'pinterestEnabled'.
       */
      isPinterestEnabled(): boolean;
      /**
       * Returns 'true' if the instance represents a product. Returns 'false' if
       *  the instance represents a product set.
       *
       * @return true if the instance is a product, false otherwise.
       */
      isProduct(): boolean;
      /**
       * Returns 'true' if the instance represents a product set, otherwise 'false'.
       *
       * @return true if the instance is a product set, false otherwise.
       */
      isProductSet(): boolean;
      /**
       * Returns true if this product is part of any product set, otherwise false.
       *
       * @return true if the product is part of any product set, false otherwise.
       */
      isProductSetProduct(): boolean;
      /**
       * Identifies if this product instance is part of a retail set.
       *
       * @return true if the product is part of a retail set, false otherwise.
       */
      isRetailSet(): boolean;
      /**
       * Identifies if the product is searchable.
       *
       * @return the value of the attribute 'searchable'.
       */
      isSearchable(): boolean;
      /**
       * Returns 'true' if the product is assigned to the current site (via the
       *  site catalog), otherwise 'false' is returned.
       *
       * @return 'true' if product assigned to site.
       */
      isSiteProduct(): boolean;
      /**
       * Identifies if this product instance is mastered by a product master.
       *
       * @return true if the product is mastered, false otherwise.
       */
      isVariant(): boolean;
      /**
       * Identifies if this product instance is a variation group product.
       *
       * @return true if the product is a variation group, false otherwise.
       */
      isVariationGroup(): boolean;
      /**
       * Set the availability status flag of the product.
       * @param available Availability status flag.
       */
      setAvailableFlag(available: boolean): void;
      /**
       * Set the online status flag of the product for the current site. If current site is not available (i.e.
       *  in case this method is called by a job that runs on organization level) the online status flag is set global,
       *  which can affect all sites.
       *  In previous versions this method set the online status flag global, instead of site specific.
       * @param online Online status flag.
       */
      setOnlineFlag(online: boolean): void;
      /**
       * Set the flag indicating whether the product is searchable or not in context of the current site. If current site
       *  is not available (i.e. in case this method is called by a job that runs on organization level) the searchable
       *  flag is set global, which can affect all sites.
       *  In previous versions this method set the searchable flag global, instead of site specific.
       * @param searchable The value of the attribute 'searchable'.
       */
      setSearchableFlag(searchable: boolean): void;
      /**
       * Set the product's search placement classification in context of the current site. If current site is not
       *  available (i.e. in case this method is called by a job that runs on organization level) the search placement is
       *  set global, which can affect all sites.
       *  In previous versions this method set the search placement classification global, instead of site specific.
       * @param placement The product's search placement classification.
       */
      setSearchPlacement(placement: number): void;
      /**
       * Set the product's search rank in context of the current site. If current site is not available (i.e. in case this
       *  method is called by a job that runs on organization level) the search rank is set global, which can affect all
       *  sites.
       *  In previous versions this method set the search rank global, instead of site specific.
       * @param rank The product's search rank.
       */
      setSearchRank(rank: number): void;
    }

    /**
     * Represents the active data for a <a href="class_dw_catalog_Product.html">Product</a> in Commerce Cloud Digital.
     */
    class ProductActiveData extends dw.object.ActiveData {
      /**
       * The date the product became available on the site, or
       *  null if none has been set.
       */
      readonly availableDate: Date;
      /**
       * The average gross margin percentage of the product,
       *  over the most recent day for the site, or null
       *  if none has been set or the value is no longer valid.
       */
      readonly avgGrossMarginPercentDay: number;
      /**
       * The average gross margin percentage of the product,
       *  over the most recent 30 days for the site, or null
       *  if none has been set or the value is no longer valid.
       */
      readonly avgGrossMarginPercentMonth: number;
      /**
       * The average gross margin percentage of the product,
       *  over the most recent 7 days for the site, or null
       *  if none has been set or the value is no longer valid.
       */
      readonly avgGrossMarginPercentWeek: number;
      /**
       * The average gross margin percentage of the product,
       *  over the most recent 365 days for the site, or null
       *  if none has been set or the value is no longer valid.
       */
      readonly avgGrossMarginPercentYear: number;
      /**
       * The average gross margin value of the product,
       *  over the most recent day for the site, or null
       *  if none has been set or the value is no longer valid.
       */
      readonly avgGrossMarginValueDay: number;
      /**
       * The average gross margin value of the product,
       *  over the most recent 30 days for the site, or null
       *  if none has been set or the value is no longer valid.
       */
      readonly avgGrossMarginValueMonth: number;
      /**
       * The average gross margin value of the product,
       *  over the most recent 7 days for the site, or null
       *  if none has been set or the value is no longer valid.
       */
      readonly avgGrossMarginValueWeek: number;
      /**
       * The average gross margin value of the product,
       *  over the most recent 365 days for the site, or null
       *  if none has been set or the value is no longer valid.
       */
      readonly avgGrossMarginValueYear: number;
      /**
       * The average sales price for the product, over the most recent day
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       */
      readonly avgSalesPriceDay: number;
      /**
       * The average sales price for the product, over the most recent 30 days
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       */
      readonly avgSalesPriceMonth: number;
      /**
       * The average sales price for the product, over the most recent 7 days
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       */
      readonly avgSalesPriceWeek: number;
      /**
       * The average sales price for the product, over the most recent 365 days
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       */
      readonly avgSalesPriceYear: number;
      /**
       * The conversion rate of the product, over the most recent day
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       */
      readonly conversionDay: number;
      /**
       * The conversion rate of the product, over the most recent 30 days
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       */
      readonly conversionMonth: number;
      /**
       * The conversion rate of the product, over the most recent 7 days
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       */
      readonly conversionWeek: number;
      /**
       * The conversion rate of the product, over the most recent 365 days
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       */
      readonly conversionYear: number;
      /**
       * The cost price for the product for the site,
       *  or null if none has been set or the value is no longer valid.
       */
      readonly costPrice: number;
      /**
       * The number of days the product has been available on the site.
       *  The number is calculated based on the current date and the date the
       *  product became available on the site, or if that date has not been set,
       *  the date the product was created in the system.
       */
      readonly daysAvailable: number;
      /**
       * The impressions of the product, over the most recent day
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       */
      readonly impressionsDay: number;
      /**
       * The impressions of the product, over the most recent 30 days
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       */
      readonly impressionsMonth: number;
      /**
       * The impressions of the product, over the most recent 7 days
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       */
      readonly impressionsWeek: number;
      /**
       * The impressions of the product, over the most recent 365 days
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       */
      readonly impressionsYear: number;
      /**
       * The look to book ratio of the product, over the most recent day
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       */
      readonly lookToBookRatioDay: number;
      /**
       * The look to book ratio of the product, over the most recent 30 days
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       */
      readonly lookToBookRatioMonth: number;
      /**
       * The look to book ratio of the product, over the most recent 7 days
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       */
      readonly lookToBookRatioWeek: number;
      /**
       * The look to book ratio of the product, over the most recent 365 days
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       */
      readonly lookToBookRatioYear: number;
      /**
       * The number of orders containing the product, over the most
       *  recent day for the site, or null if none has been set
       *  or the value is no longer valid.
       */
      readonly ordersDay: number;
      /**
       * The number of orders containing the product, over the most
       *  recent 30 days for the site, or null if none has been set
       *  or the value is no longer valid.
       */
      readonly ordersMonth: number;
      /**
       * The number of orders containing the product, over the most
       *  recent 7 days for the site, or null if none has been set
       *  or the value is no longer valid.
       */
      readonly ordersWeek: number;
      /**
       * The number of orders containing the product, over the most
       *  recent 365 days for the site, or null if none has been set
       *  or the value is no longer valid.
       */
      readonly ordersYear: number;
      /**
       * The return rate for the product for the site,
       *  or null if none has been set or the value is no longer valid.
       */
      readonly returnRate: number;
      /**
       * The revenue of the product, over the most recent day
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       */
      readonly revenueDay: number;
      /**
       * The revenue of the product, over the most recent 30 days
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       */
      readonly revenueMonth: number;
      /**
       * The revenue of the product, over the most recent 7 days
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       */
      readonly revenueWeek: number;
      /**
       * The revenue of the product, over the most recent 365 days
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       */
      readonly revenueYear: number;
      /**
       * The sales velocity of the product, over the most recent day
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       */
      readonly salesVelocityDay: number;
      /**
       * The sales velocity of the product, over the most recent 30 days
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       */
      readonly salesVelocityMonth: number;
      /**
       * The sales velocity of the product, over the most recent 7 days
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       */
      readonly salesVelocityWeek: number;
      /**
       * The sales velocity of the product, over the most recent 365 days
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       */
      readonly salesVelocityYear: number;
      /**
       * The units of the product ordered over the most recent day
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       */
      readonly unitsDay: number;
      /**
       * The units of the product ordered over the most recent 30 days
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       */
      readonly unitsMonth: number;
      /**
       * The units of the product ordered over the most recent 7 days
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       */
      readonly unitsWeek: number;
      /**
       * The units of the product ordered over the most recent 365 days
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       */
      readonly unitsYear: number;
      /**
       * The views of the product, over the most recent day
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       */
      readonly viewsDay: number;
      /**
       * The views of the product, over the most recent 30 days
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       */
      readonly viewsMonth: number;
      /**
       * The views of the product, over the most recent 7 days
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       */
      readonly viewsWeek: number;
      /**
       * The views of the product, over the most recent 365 days
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       */
      readonly viewsYear: number;

      /**
       * Returns the date the product became available on the site, or
       *  null if none has been set.
       *
       * @return the date the product became available.
       */
      getAvailableDate(): Date;
      /**
       * Returns the average gross margin percentage of the product,
       *  over the most recent day for the site, or null
       *  if none has been set or the value is no longer valid.
       *
       * @return the average gross margin percentage over the last day.
       */
      getAvgGrossMarginPercentDay(): number;
      /**
       * Returns the average gross margin percentage of the product,
       *  over the most recent 30 days for the site, or null
       *  if none has been set or the value is no longer valid.
       *
       * @return the average gross margin percentage over the last 30 days.
       */
      getAvgGrossMarginPercentMonth(): number;
      /**
       * Returns the average gross margin percentage of the product,
       *  over the most recent 7 days for the site, or null
       *  if none has been set or the value is no longer valid.
       *
       * @return the average gross margin percentage over the last 7 days.
       */
      getAvgGrossMarginPercentWeek(): number;
      /**
       * Returns the average gross margin percentage of the product,
       *  over the most recent 365 days for the site, or null
       *  if none has been set or the value is no longer valid.
       *
       * @return the average gross margin percentage over the last 365 days.
       */
      getAvgGrossMarginPercentYear(): number;
      /**
       * Returns the average gross margin value of the product,
       *  over the most recent day for the site, or null
       *  if none has been set or the value is no longer valid.
       *
       * @return the average gross margin value over the last day.
       */
      getAvgGrossMarginValueDay(): number;
      /**
       * Returns the average gross margin value of the product,
       *  over the most recent 30 days for the site, or null
       *  if none has been set or the value is no longer valid.
       *
       * @return the average gross margin value over the last 30 days.
       */
      getAvgGrossMarginValueMonth(): number;
      /**
       * Returns the average gross margin value of the product,
       *  over the most recent 7 days for the site, or null
       *  if none has been set or the value is no longer valid.
       *
       * @return the average gross margin value over the last 7 days.
       */
      getAvgGrossMarginValueWeek(): number;
      /**
       * Returns the average gross margin value of the product,
       *  over the most recent 365 days for the site, or null
       *  if none has been set or the value is no longer valid.
       *
       * @return the average gross margin value over the last 365 days.
       */
      getAvgGrossMarginValueYear(): number;
      /**
       * Returns the average sales price for the product, over the most recent day
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       *
       * @return the average sales price over the last day.
       */
      getAvgSalesPriceDay(): number;
      /**
       * Returns the average sales price for the product, over the most recent 30 days
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       *
       * @return the average sales price over the last 30 days.
       */
      getAvgSalesPriceMonth(): number;
      /**
       * Returns the average sales price for the product, over the most recent 7 days
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       *
       * @return the average sales price over the last 7 days.
       */
      getAvgSalesPriceWeek(): number;
      /**
       * Returns the average sales price for the product, over the most recent 365 days
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       *
       * @return the average sales price over the last 365 days.
       */
      getAvgSalesPriceYear(): number;
      /**
       * Returns the conversion rate of the product, over the most recent day
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       *
       * @return the conversion over the last day.
       */
      getConversionDay(): number;
      /**
       * Returns the conversion rate of the product, over the most recent 30 days
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       *
       * @return the conversion over the last 30 days.
       */
      getConversionMonth(): number;
      /**
       * Returns the conversion rate of the product, over the most recent 7 days
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       *
       * @return the conversion over the last 7 days.
       */
      getConversionWeek(): number;
      /**
       * Returns the conversion rate of the product, over the most recent 365 days
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       *
       * @return the conversion over the last 365 days.
       */
      getConversionYear(): number;
      /**
       * Returns the cost price for the product for the site,
       *  or null if none has been set or the value is no longer valid.
       *
       * @return the cost price.
       */
      getCostPrice(): number;
      /**
       * Returns the number of days the product has been available on the site.
       *  The number is calculated based on the current date and the date the
       *  product became available on the site, or if that date has not been set,
       *  the date the product was created in the system.
       *
       * @return the age in days.
       */
      getDaysAvailable(): number;
      /**
       * Returns the impressions of the product, over the most recent day
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       *
       * @return the impressions over the last day.
       */
      getImpressionsDay(): number;
      /**
       * Returns the impressions of the product, over the most recent 30 days
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       *
       * @return the impressions over the last 30 days.
       */
      getImpressionsMonth(): number;
      /**
       * Returns the impressions of the product, over the most recent 7 days
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       *
       * @return the impressions over the last 7 days.
       */
      getImpressionsWeek(): number;
      /**
       * Returns the impressions of the product, over the most recent 365 days
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       *
       * @return the impressions over the last 365 days.
       */
      getImpressionsYear(): number;
      /**
       * Returns the look to book ratio of the product, over the most recent day
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       *
       * @return the look to book ratio over the last day.
       */
      getLookToBookRatioDay(): number;
      /**
       * Returns the look to book ratio of the product, over the most recent 30 days
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       *
       * @return the look to book ratio over the last 30 days.
       */
      getLookToBookRatioMonth(): number;
      /**
       * Returns the look to book ratio of the product, over the most recent 7 days
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       *
       * @return the look to book ratio over the last 7 days.
       */
      getLookToBookRatioWeek(): number;
      /**
       * Returns the look to book ratio of the product, over the most recent 365 days
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       *
       * @return the look to book ratio over the last 365 days.
       */
      getLookToBookRatioYear(): number;
      /**
       * Returns the number of orders containing the product, over the most
       *  recent day for the site, or null if none has been set
       *  or the value is no longer valid.
       *
       * @return the orders over the last day.
       */
      getOrdersDay(): number;
      /**
       * Returns the number of orders containing the product, over the most
       *  recent 30 days for the site, or null if none has been set
       *  or the value is no longer valid.
       *
       * @return the orders over the last 30 days.
       */
      getOrdersMonth(): number;
      /**
       * Returns the number of orders containing the product, over the most
       *  recent 7 days for the site, or null if none has been set
       *  or the value is no longer valid.
       *
       * @return the orders over the last 7 days.
       */
      getOrdersWeek(): number;
      /**
       * Returns the number of orders containing the product, over the most
       *  recent 365 days for the site, or null if none has been set
       *  or the value is no longer valid.
       *
       * @return the orders over the last 365 days.
       */
      getOrdersYear(): number;
      /**
       * Returns the return rate for the product for the site,
       *  or null if none has been set or the value is no longer valid.
       *
       * @return the return rate.
       */
      getReturnRate(): number;
      /**
       * Returns the revenue of the product, over the most recent day
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       *
       * @return the revenue over the last day.
       */
      getRevenueDay(): number;
      /**
       * Returns the revenue of the product, over the most recent 30 days
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       *
       * @return the revenue over the last 30 days.
       */
      getRevenueMonth(): number;
      /**
       * Returns the revenue of the product, over the most recent 7 days
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       *
       * @return the revenue over the last 7 days.
       */
      getRevenueWeek(): number;
      /**
       * Returns the revenue of the product, over the most recent 365 days
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       *
       * @return the revenue over the last 365 days.
       */
      getRevenueYear(): number;
      /**
       * Returns the sales velocity of the product, over the most recent day
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       *
       * @return the sales velocity over the last day.
       */
      getSalesVelocityDay(): number;
      /**
       * Returns the sales velocity of the product, over the most recent 30 days
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       *
       * @return the sales velocity over the last 30 days.
       */
      getSalesVelocityMonth(): number;
      /**
       * Returns the sales velocity of the product, over the most recent 7 days
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       *
       * @return the sales velocity over the last 7 days.
       */
      getSalesVelocityWeek(): number;
      /**
       * Returns the sales velocity of the product, over the most recent 365 days
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       *
       * @return the sales velocity over the last 365 days.
       */
      getSalesVelocityYear(): number;
      /**
       * Returns the units of the product ordered over the most recent day
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       *
       * @return the units over the last day.
       */
      getUnitsDay(): number;
      /**
       * Returns the units of the product ordered over the most recent 30 days
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       *
       * @return the units over the last 30 days.
       */
      getUnitsMonth(): number;
      /**
       * Returns the units of the product ordered over the most recent 7 days
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       *
       * @return the units over the last 7 days.
       */
      getUnitsWeek(): number;
      /**
       * Returns the units of the product ordered over the most recent 365 days
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       *
       * @return the units over the last 365 days.
       */
      getUnitsYear(): number;
      /**
       * Returns the views of the product, over the most recent day
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       *
       * @return the views over the last day.
       */
      getViewsDay(): number;
      /**
       * Returns the views of the product, over the most recent 30 days
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       *
       * @return the views over the last 30 days.
       */
      getViewsMonth(): number;
      /**
       * Returns the views of the product, over the most recent 7 days
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       *
       * @return the views over the last 7 days.
       */
      getViewsWeek(): number;
      /**
       * Returns the views of the product, over the most recent 365 days
       *  for the site, or null if none has been set or the value
       *  is no longer valid.
       *
       * @return the views over the last 365 days.
       */
      getViewsYear(): number;
    }

    /**
     * Class representing the complete attribute model for products in the system.
     *  An instance of this class provides methods to access the attribute
     *  definitions and groups for the system object type &apos;Product&apos; and perhaps
     *  additional information depending on how the instance is obtained.
     *  A ProductAttributeModel can be obtained in one of three ways:
     *
     *  <ul>
     *  <li><b><a href="class_dw_catalog_ProductAttributeModel.html#dw_catalog_ProductAttributeModel_ProductAttributeModel_DetailAnchor">ProductAttributeModel()</a>:</b> When the no-arg constructor is
     *  used the model represents:
     *     <ul>
     *     <li>the attribute groups of the system object type &apos;Product&apos; (i.e. the
     *     global product attribute groups) and their bound attributes</li>
     *     </ul>
     *  </li>
     *  <li><b><a href="class_dw_catalog_Category.html#dw_catalog_Category_getProductAttributeModel_DetailAnchor">Category.getProductAttributeModel()</a>:</b> When the
     *  attribute model for a Category is retrieved, the model represents:
     *     <ul>
     *     <li>the global product attribute groups</li>
     *     <li>product attribute groups of the calling category</li>
     *     <li>product attribute groups of any parent categories of the calling category</li>
     *     </ul>
     *  </li>
     *  <li><b><a href="class_dw_catalog_Product.html#dw_catalog_Product_getAttributeModel_DetailAnchor">Product.getAttributeModel()</a>:</b> When the attribute
     *  model for a Product is retrieved, the model represents:
     *     <ul>
     *     <li>the global product attribute groups</li>
     *     <li>product attribute groups of the product&apos;s classification category</li>
     *     <li>product attribute groups of any parent categories of the product&apos;s classification category</li>
     *     </ul>
     *  In this case, the model additionally provides access to the attribute values
     *  of the product.  If the product lacks a classification category, then only
     *  the global product attribute group is considered by the model.
     *  </li>
     *  </ul>
     *
     *  The ProductAttributeModel provides a generic way to display the attribute
     *  values of a product on a product detail page organized into appropriate
     *  visual groups.  This is typically done as follows:
     *
     *  <ul>
     *  <li>On the product detail page, call
     *  <a href="class_dw_catalog_Product.html#dw_catalog_Product_getAttributeModel_DetailAnchor">Product.getAttributeModel()</a> to get the attribute model for
     *  the product.</li>
     *  <li>Call <a href="class_dw_catalog_ProductAttributeModel.html#dw_catalog_ProductAttributeModel_getVisibleAttributeGroups_DetailAnchor">getVisibleAttributeGroups()</a> to get the groups that are
     *  appropriate for this product and all other products assigned to the same
     *  classification category.</li>
     *  <li>Iterate the groups, and display each as a &quot;group&quot; in the UI.</li>
     *  <li>Call <a href="class_dw_catalog_ProductAttributeModel.html#dw_catalog_ProductAttributeModel_getVisibleAttributeDefinitions_ObjectAttributeGroup_DetailAnchor">getVisibleAttributeDefinitions(ObjectAttributeGroup)</a> for
     *  each group. Iterate and display the attribute names using
     *  <a href="class_dw_object_ObjectAttributeDefinition.html#dw_object_ObjectAttributeDefinition_getDisplayName_DetailAnchor">ObjectAttributeDefinition.getDisplayName()</a>.</li>
     *  <li>For each attribute, get the product&apos;s display value(s) for that
     *  attribute, using <code>getDisplayValue()</code>. This might require custom
     *  display logic based on the type of attribute (strings, dates, multi-value
     *  attributes, etc).</li>
     *  </ul>
     */
    class ProductAttributeModel {
      /**
       * A sorted collection of attribute groups of this model. The groups
       *  returned depends on how this model is constructed and what it represents.
       *  (See class-level documentation for details).
       *
       *  The collection of returned groups is sorted first by scope and secondly
       *  by explicit sort order. Global groups always appear before
       *  category-specific groups in the list. Groups of parent categories always
       *  appear before groups belonging to subcategories. At each scope, groups
       *  have an explicit sort order which can be managed within the Business
       *  Manager.
       *
       *  When there are multiple attribute groups with the same ID, the following
       *  rules apply:
       *
       *
       *  If this model represents the global product attribute group only
       *  (e.g. the no-arg constructor was used), duplicates cannot occur since
       *  only one group can be defined with a given ID at that scope.
       *  If this model is associated with specific categories (e.g. it is
       *  constructed from a product with a classification category), then a
       *  category product attribute group might have the same ID as a global
       *  product attribute group. In this case, the category group overrides the
       *  global one.
       *  If a category and one of its ancestor categories both define a
       *  product attribute group with the same ID, the sub-category group
       *  overrides the parent group.
       *
       *
       *  As a result of these rules, this method will never return two attribute
       *  groups with the same ID.
       */
      readonly attributeGroups: dw.util.Collection<
        dw.object.ObjectAttributeGroup
      >;
      /**
       * An unsorted collection of attribute definitions marked as
       *  order-required. Order-required attributes are usually copied into order
       *  line items.
       *
       *  The returned attribute definitions are sorted according to the explicit
       *  sort order defined for the attributes in the group. This is managed by
       *  merchant in the Business Manager.
       */
      readonly orderRequiredAttributeDefinitions: dw.util.Collection<
        dw.object.ObjectAttributeDefinition
      >;
      /**
       * A sorted collection of visible attribute groups of this model.
       *  This method is similar to getAttributeGroups() but only includes
       *  attribute groups containing at least one attribute definition that is
       *  visible. See
       *  getVisibleAttributeDefinitions(ObjectAttributeGroup).
       */
      readonly visibleAttributeGroups: dw.util.Collection<
        dw.object.ObjectAttributeGroup
      >;

      /**
       * Constructs a product attribute model that is not based on a product nor
       *  a category. Therefore, the model only describes the product attributes
       *  globally defined for the system object type 'Product'.
       *
       */
      constructor();

      /**
       * Returns the attribute definition with the given id from the product attribute
       *  model. If attribute definition does not exist, null is returned.
       * @param id the identifier of the attribute definition.
       * @return attribute definition or null if not exist
       */
      getAttributeDefinition(id: string): dw.object.ObjectAttributeDefinition;
      /**
       * Returns a sorted collection of attribute definitions for the given attribute
       *  group. If no attribute definition exist for the group, an empty collection
       *  is returned.
       *
       *  The returned attribute definitions are sorted according to the explicit
       *  sort order defined for the attributes in the group.  This is managed
       *  by merchant in the Business Manager.
       * @param group the group whose attribute definitions are returned.
       * @return a sorted collection of ObjectAttributeDefinition instances.
       */
      getAttributeDefinitions(
        group: dw.object.ObjectAttributeGroup
      ): dw.util.Collection<dw.object.ObjectAttributeDefinition>;
      /**
       * Returns the attribute group with the given id from the product attribute
       *  model. If attribute group does not exist, null is returned.
       * @param id the attribute group identifier.
       * @return the attribute group or null if not exist
       */
      getAttributeGroup(id: string): dw.object.ObjectAttributeGroup;
      /**
       * Returns a sorted collection of attribute groups of this model. The groups
       *  returned depends on how this model is constructed and what it represents.
       *  (See class-level documentation for details).
       *
       *  The collection of returned groups is sorted first by scope and secondly
       *  by explicit sort order. Global groups always appear before
       *  category-specific groups in the list. Groups of parent categories always
       *  appear before groups belonging to subcategories. At each scope, groups
       *  have an explicit sort order which can be managed within the Business
       *  Manager.
       *
       *  When there are multiple attribute groups with the same ID, the following
       *  rules apply:
       *
       *
       *  If this model represents the global product attribute group only
       *  (e.g. the no-arg constructor was used), duplicates cannot occur since
       *  only one group can be defined with a given ID at that scope.
       *  If this model is associated with specific categories (e.g. it is
       *  constructed from a product with a classification category), then a
       *  category product attribute group might have the same ID as a global
       *  product attribute group. In this case, the category group overrides the
       *  global one.
       *  If a category and one of its ancestor categories both define a
       *  product attribute group with the same ID, the sub-category group
       *  overrides the parent group.
       *
       *
       *  As a result of these rules, this method will never return two attribute
       *  groups with the same ID.
       *
       * @return collection of all attribute groups.
       */
      getAttributeGroups(): dw.util.Collection<dw.object.ObjectAttributeGroup>;
      /**
       * Returns the value that the underlying product defines for the given
       *  attribute definition in the current locale. In case the attribute definition
       *  defines localized attribute values, the product's value is used as an id
       *  to find the localized display value.
       *
       *  In case of an Image attribute this method returns a MediaFile instance.
       *  In previous versions this method returned a String with the image path.
       *  In case of an HTML attribute this method returns a MarkupText instance.
       *  In previous versions this method returned a String with the HTML source.
       * @param definition the definition to use.
       * @return The localized product attribute display value.
       */
      getDisplayValue(definition: dw.object.ObjectAttributeDefinition): any;
      /**
       * Returns an unsorted collection of attribute definitions marked as
       *  order-required. Order-required attributes are usually copied into order
       *  line items.
       *
       *  The returned attribute definitions are sorted according to the explicit
       *  sort order defined for the attributes in the group. This is managed by
       *  merchant in the Business Manager.
       *
       * @return a collection of order-required ObjectAttributeDefinition instances.
       */
      getOrderRequiredAttributeDefinitions(): dw.util.Collection<
        dw.object.ObjectAttributeDefinition
      >;
      /**
       * Returns the attribute value for the specified attribute definition. If
       *  the product does not define a value, null is returned.
       *
       *  Note: this method may only be used where the attribute model was created
       *  for a specific product; otherwise it will always return null.
       *
       *  If the attribute is localized, the value for the current session locale
       *  is returned.
       *
       *  In case of an Image attribute this method returns a MediaFile instance.
       *  In previous versions this method returned a String with the image path.
       *  In case of an HTML attribute this method returns a MarkupText instance.
       *  In previous versions this method returned a String with the HTML source.
       * @param definition the attribute definition to use when locating and returning the value.
       * @return value the value associated with the object attribute definition.
       */
      getValue(definition: dw.object.ObjectAttributeDefinition): any;
      /**
       * Returns a sorted collection of all visible attribute definitions for the
       *  given attribute group. If no visible attribute definition exist for the
       *  group, an empty collection is returned.
       *
       *  An attribute definition is considered visible if is marked as visible. If
       *  the product attribute model is created for a specific product, the
       *  product must also define a value for the attribute definition; else the
       *  attribute definition is considered as invisible.
       *
       *  The returned attribute definitions are sorted according to the explicit
       *  sort order defined for the attributes in the group. This is managed by
       *  merchant in the Business Manager.
       * @param group the group whose visible attribute definitions are returned.
       * @return a sorted collection of visible ObjectAttributeDefinition instances.
       */
      getVisibleAttributeDefinitions(
        group: dw.object.ObjectAttributeGroup
      ): dw.util.Collection<dw.object.ObjectAttributeDefinition>;
      /**
       * Returns a sorted collection of visible attribute groups of this model.
       *  This method is similar to getAttributeGroups() but only includes
       *  attribute groups containing at least one attribute definition that is
       *  visible. See
       *  getVisibleAttributeDefinitions(ObjectAttributeGroup).
       *
       * @return sorted collection of visible ObjectAttributeGroup instances.
       */
      getVisibleAttributeGroups(): dw.util.Collection<
        dw.object.ObjectAttributeGroup
      >;
    }

    /**
     * Encapsulates the quantity of items available for each availability status.
     */
    class ProductAvailabilityLevels {
      /**
       * The backorder quantity.
       */
      readonly backorder: dw.value.Quantity;
      /**
       * The number of attributes that contain non-zero quantities.
       */
      readonly count: number;
      /**
       * The quantity in stock.
       */
      readonly inStock: dw.value.Quantity;
      /**
       * The quantity that is not available.
       */
      readonly notAvailable: dw.value.Quantity;
      /**
       * The pre-order quantity.
       */
      readonly preorder: dw.value.Quantity;

      /**
       * Returns the backorder quantity.
       *
       * @return the backorder quantity.
       */
      getBackorder(): dw.value.Quantity;
      /**
       * Returns the number of attributes that contain non-zero quantities.
       *
       * @return the number of attributes that contain non-zero quantities.
       */
      getCount(): number;
      /**
       * Returns the quantity in stock.
       *
       * @return the quantity in stock.
       */
      getInStock(): dw.value.Quantity;
      /**
       * Returns the quantity that is not available.
       *
       * @return the quantity that is not available.
       */
      getNotAvailable(): dw.value.Quantity;
      /**
       * Returns the pre-order quantity.
       *
       * @return the pre-order quantity.
       */
      getPreorder(): dw.value.Quantity;
    }

    /**
     * The ProductAvailabilityModel provides methods for retrieving all information
     *  on availability of a single product.
     */
    class ProductAvailabilityModel {
      /**
       * Indicates that the product stock has run out, but will be replenished, and is therefore available for ordering.
       */
      static readonly AVAILABILITY_STATUS_BACKORDER = "BACKORDER";
      /**
       * Indicates that the product is in stock and available for ordering.
       */
      static readonly AVAILABILITY_STATUS_IN_STOCK = "IN_STOCK";
      /**
       * Indicates that the product is not currently available for ordering.
       */
      static readonly AVAILABILITY_STATUS_NOT_AVAILABLE = "NOT_AVAILABLE";
      /**
       * Indicates that the product is not yet in stock but is available for ordering.
       */
      static readonly AVAILABILITY_STATUS_PREORDER = "PREORDER";

      /**
       * The availability of the product, which roughly defined is the
       *  ratio of the original stock that is still available to sell.  The basic
       *  formula, if the current site uses an
       *  inventory list, is the ATS quantity divided by allocation
       *  amount. If the product is not orderable at all this method returns 0.
       *  The following specific rules apply for standard products:
       *
       *  If inventory lists are in use:
       *
       *      If no inventory record exists and the inventory list default-in-stock flag is true this method returns 1.
       *      If no inventory record exists the inventory list default-in-stock flag is false this method returns 0.
       *      If the product is not available this method returns 0.
       *      If the product is perpetually available this method returns 1.
       *      Otherwise this method returns the ATS / allocation.
       *
       *
       *
       *  If inventory lists are not in use the method returns 0.
       *
       *  The following rules apply for special product types:
       *
       *  For a master product this method returns the average availability
       *  of its online variations.
       *  For a master product with no online variations this method returns 0.
       *  For a master product with own inventory record the rules of the standard
       *  products apply. Note: In this case the availability of the variations is not considered.
       *  For a product set this method returns the greatest availability of
       *  the online products in the set.
       *  For a product set with no online products this method returns 0.
       *  For a product set with an inventory record the rules of the standard
       *  products apply. Note: In this case the availability of the set products is not considered.
       *  For a bundle, this method returns the least availability of the bundled
       *  products according to their bundled quantity and if it exist also from
       *  the bundle inventory record.
       */
      readonly availability: number;
      /**
       * The availability-status for the minimum-orderable-quantity (MOQ) of
       *  the product.  The MOQ essentially represents a single orderable unit, and
       *  therefore can be represented by a single availability-status.  This
       *  method is essentially a convenience method.  The same information
       *  can be retrieved by calling getAvailabilityLevels(Number)
       *  with the MOQ of the product as the parameter and then retrieving the
       *  single status from the returned map.
       *
       *  This method is typically used to display a product's availability in
       *  the catalog when the order quantity is not known.
       */
      readonly availabilityStatus: string;
      /**
       * Convenience method for isInStock(Number). Returns true, if the
       *  Product is available in the minimum-order-quantity. If the product does
       *  not have a minimum-order-quantity defined, in-stock is checked for a
       *  quantity value 1.
       */
      readonly inStock: boolean;
      /**
       * The ProductInventoryRecord for the Product associated
       *  with this model.
       */
      readonly inventoryRecord: dw.catalog.ProductInventoryRecord;
      /**
       * Convenience method for isOrderable(Number). Returns true if the
       *  Product is currently online (based on its online flag and online dates)
       *  and is orderable in its minimum-order-quantity. If the product does not
       *  have a minimum-order-quantity specified, then 1 is used. The method
       *  returns false otherwise.
       *
       *  Note: Orderable status is more general than in-stock status. A product
       *  may be out-of-stock but orderable because it is back-orderable or
       *  pre-orderable.
       */
      readonly orderable: boolean;
      /**
       * The SKU coverage of the product.  The basic formula for a
       *  master product is the ratio of online variations that are in stock
       *  to the total number of online variations.  The following specific rules
       *  apply for standard products:
       *
       *  If the product is in stock this method returns the availability of the product.
       *  If the product is out of stock this method returns 0.
       *
       *  The following rules apply for special product types:
       *
       *  For a master product this method returns the average SKU coverage
       *  of its online variations.
       *  For a master product with no online variations this method returns 0.
       *  For a product set this method returns the ratio of orderable SKUs in the product set
       *  over the total number of online SKUs in the product set.
       *  For a product set with no online products this method returns 0.
       *  For a product bundle this method returns 1 if all of the bundled
       *  products are online, and 0 otherwise.
       *  For a product bundle with no online bundled products this method
       *  returns 0.
       */
      readonly SKUCoverage: number;
      /**
       * The number of hours before the product is expected to go out
       *  of stock.  The basic formula is the ATS quantity divided by the
       *  sales velocity for the most recent day.  The following specific rules
       *  apply for standard products:
       *
       *  If the product is out of stock this method returns 0.
       *  If the product is perpetually available this method returns 1.
       *  If the sales velocity or ATS is not available this method returns 0.
       *  Otherwise this method returns ATS / sales velocity.
       *
       *  The following rules apply for special product types:
       *
       *  For a master product this method returns the greatest time to out
       *  of stock of its online variations.
       *  For a master product with no online variations this method returns 0.
       *  For a product set this method returns the greatest time to out
       *  of stock of the online products in the set.
       *  For a product set with no online products this method returns 0.
       *  For a bundle with no product inventory record, this method returns
       *  the least time to out of stock of the online bundled products.
       *  For a bundle with no product inventory record, and no online
       *  bundled products, this method returns 0.
       */
      readonly timeToOutOfStock: number;

      /**
       * Returns the availability of the product, which roughly defined is the
       *  ratio of the original stock that is still available to sell.  The basic
       *  formula, if the current site uses an
       *  inventory list, is the ATS quantity divided by allocation
       *  amount. If the product is not orderable at all this method returns 0.
       *  The following specific rules apply for standard products:
       *
       *  If inventory lists are in use:
       *
       *      If no inventory record exists and the inventory list default-in-stock flag is true this method returns 1.
       *      If no inventory record exists the inventory list default-in-stock flag is false this method returns 0.
       *      If the product is not available this method returns 0.
       *      If the product is perpetually available this method returns 1.
       *      Otherwise this method returns the ATS / allocation.
       *
       *
       *
       *  If inventory lists are not in use the method returns 0.
       *
       *  The following rules apply for special product types:
       *
       *  For a master product this method returns the average availability
       *  of its online variations.
       *  For a master product with no online variations this method returns 0.
       *  For a master product with own inventory record the rules of the standard
       *  products apply. Note: In this case the availability of the variations is not considered.
       *  For a product set this method returns the greatest availability of
       *  the online products in the set.
       *  For a product set with no online products this method returns 0.
       *  For a product set with an inventory record the rules of the standard
       *  products apply. Note: In this case the availability of the set products is not considered.
       *  For a bundle, this method returns the least availability of the bundled
       *  products according to their bundled quantity and if it exist also from
       *  the bundle inventory record.
       *
       */
      getAvailability(): number;
      /**
       * Returns an instance of ProductAvailabilityLevels,
       *  where each available quantity represents a part of the input quantity.
       *  This method is typically used to display availability information in
       *  the context of a known order quantity, e.g. a shopping cart.
       *
       *  For example, if for a given product
       *  there are 3 pieces in stock with no pre/backorder handling specified,
       *  and the order quantity is 10, then the return instance would have the
       *  following state:
       *
       *  ProductAvailabilityLevels.getInStock() - 3
       *  ProductAvailabilityLevels.getPreorder() - 0
       *  ProductAvailabilityLevels.getBackorder() - 0
       *  ProductAvailabilityLevels.getNotAvailable() - 7
       *
       *
       *  The following assertions can be made about the state of the returned instance.
       *
       *  Between 1 and 3 levels are non-zero.
       *  The sum of the levels equals the input quantity.
       *  ProductAvailabilityLevels.getPreorder() or ProductAvailabilityLevels.getBackorder() may be available, but not both.
       *
       *
       *
       *  Product bundles are handled specially:  The availability of product
       *  bundles is calculated based on the availability of the bundled products.
       *  Therefore, if a bundle contains products that are not in stock, then
       *  the bundle itself is not in stock.  If all the products in the bundle
       *  are on backorder, then the bundle itself is backordered.  If a product
       *  bundle has its own inventory record, then this record may
       *  further limit the availability.  If a bundle has no record, then
       *  only the records of the bundled products are considered.
       *
       *  Product masters and product sets without an own inventory record are
       *  handled specially too:   The availability is calculated based on the
       *  availability of the variants or set products. A product master or product
       *  set is in stock as soon as one of its variants or set products is in stock.
       *  Each product master or product set availability level reflects the sum of
       *  the variant or set product availability levels up to the specified quantity.
       *
       *  Product masters or product sets with own inventory record are handled like
       *  standard products. The availability of the variants or set products is not
       *  considered. (Such an inventory scenario should be avoided.)
       *
       *  Offline products are always unavailable and will result in returned
       *  levels that are all unavailable.
       * @param quantity The quantity to evaluate.
       * @return an instance of ProductAvailabilityLevels, which encapsulates the number of items for each relevant availability-status.
       */
      getAvailabilityLevels(
        quantity: number
      ): dw.catalog.ProductAvailabilityLevels;
      /**
       * Returns the availability-status for the minimum-orderable-quantity (MOQ) of
       *  the product.  The MOQ essentially represents a single orderable unit, and
       *  therefore can be represented by a single availability-status.  This
       *  method is essentially a convenience method.  The same information
       *  can be retrieved by calling getAvailabilityLevels(Number)
       *  with the MOQ of the product as the parameter and then retrieving the
       *  single status from the returned map.
       *
       *  This method is typically used to display a product's availability in
       *  the catalog when the order quantity is not known.
       *
       * @return the availability-status.
       */
      getAvailabilityStatus(): string;
      /**
       * Returns the ProductInventoryRecord for the Product associated
       *  with this model.
       *
       * @return the ProductInventoryRecord or null if there is none.
       */
      getInventoryRecord(): dw.catalog.ProductInventoryRecord;
      /**
       * Returns the SKU coverage of the product.  The basic formula for a
       *  master product is the ratio of online variations that are in stock
       *  to the total number of online variations.  The following specific rules
       *  apply for standard products:
       *
       *  If the product is in stock this method returns the availability of the product.
       *  If the product is out of stock this method returns 0.
       *
       *  The following rules apply for special product types:
       *
       *  For a master product this method returns the average SKU coverage
       *  of its online variations.
       *  For a master product with no online variations this method returns 0.
       *  For a product set this method returns the ratio of orderable SKUs in the product set
       *  over the total number of online SKUs in the product set.
       *  For a product set with no online products this method returns 0.
       *  For a product bundle this method returns 1 if all of the bundled
       *  products are online, and 0 otherwise.
       *  For a product bundle with no online bundled products this method
       *  returns 0.
       *
       */
      getSKUCoverage(): number;
      /**
       * Returns the number of hours before the product is expected to go out
       *  of stock.  The basic formula is the ATS quantity divided by the
       *  sales velocity for the most recent day.  The following specific rules
       *  apply for standard products:
       *
       *  If the product is out of stock this method returns 0.
       *  If the product is perpetually available this method returns 1.
       *  If the sales velocity or ATS is not available this method returns 0.
       *  Otherwise this method returns ATS / sales velocity.
       *
       *  The following rules apply for special product types:
       *
       *  For a master product this method returns the greatest time to out
       *  of stock of its online variations.
       *  For a master product with no online variations this method returns 0.
       *  For a product set this method returns the greatest time to out
       *  of stock of the online products in the set.
       *  For a product set with no online products this method returns 0.
       *  For a bundle with no product inventory record, this method returns
       *  the least time to out of stock of the online bundled products.
       *  For a bundle with no product inventory record, and no online
       *  bundled products, this method returns 0.
       *
       */
      getTimeToOutOfStock(): number;
      /**
       * Returns true if the Product is in-stock in the given quantity. This is
       *  determined as follows:
       *
       *  If the product is not currently online (based on its online flag and
       *  online dates), then return false.
       *  If there is no inventory-list for the current site, then return
       *  false.
       *  If there is no inventory-record for the product, then return the
       *  default setting on the inventory-list.
       *  If there is no allocation-amount on the inventory-record, then return
       *  the value of the perpetual-flag.
       *  If there is an allocation-amount, but the perpetual-flag is true,
       *  then return true.
       *  If the quantity is less than or equal to the stock-level, then return
       *  true.
       *  Otherwise return false.
       * @param quantity the quantity that is requested
       * @return true if the Product is in-stock.
       */
      isInStock(quantity: number): boolean;
      /**
       * Convenience method for isInStock(Number). Returns true, if the
       *  Product is available in the minimum-order-quantity. If the product does
       *  not have a minimum-order-quantity defined, in-stock is checked for a
       *  quantity value 1.
       *
       * @return true if the Product is in stock, otherwise false.
       */
      isInStock(): boolean;
      /**
       * Returns true if the Product is currently online (based on its online flag
       *  and online dates) and the specified quantity does not exceed the quantity
       *  available for sale, and returns false otherwise.
       *
       *  Note: Orderable status is more general than in-stock status. A product
       *  may be out-of-stock but orderable because it is back-orderable or
       *  pre-orderable.
       * @param quantity the quantity to test against.
       * @return true if the item can be ordered in the specified quantity.
       */
      isOrderable(quantity: number): boolean;
      /**
       * Convenience method for isOrderable(Number). Returns true if the
       *  Product is currently online (based on its online flag and online dates)
       *  and is orderable in its minimum-order-quantity. If the product does not
       *  have a minimum-order-quantity specified, then 1 is used. The method
       *  returns false otherwise.
       *
       *  Note: Orderable status is more general than in-stock status. A product
       *  may be out-of-stock but orderable because it is back-orderable or
       *  pre-orderable.
       *
       * @return true if the Product is orderable for the minimum-order-quantity of the product.
       */
      isOrderable(): boolean;
    }

    /**
     * The ProductInventoryList provides access to ID, description and defaultInStockFlag of the list.
     *  Furthermore inventory records can be accessed by product or product ID.
     */
    class ProductInventoryList extends dw.object.ExtensibleObject {
      /**
       * The default in-stock flag of the inventory list.
       */
      readonly defaultInStockFlag: boolean;
      /**
       * The description of the inventory list.
       */
      readonly description: string;
      /**
       * The ID of the inventory list.
       */
      readonly ID: string;

      /**
       * Returns the default in-stock flag of the inventory list.
       *
       * @return Default in-stock flag of inventory list.
       */
      getDefaultInStockFlag(): boolean;
      /**
       * Returns the description of the inventory list.
       *
       * @return Description of inventory list.
       */
      getDescription(): string;
      /**
       * Returns the ID of the inventory list.
       *
       * @return ID of inventory list.
       */
      getID(): string;
      /**
       * Returns the inventory record for the specified product or null
       *  if there is no record for the product in this list.
       * @param product The product to lookup inventory record.
       * @return Inventory record or null if not found.
       */
      getRecord(product: dw.catalog.Product): dw.catalog.ProductInventoryRecord;
      /**
       * Returns the inventory record for the specified product ID or null
       *  if there is no record for the product id in this list.
       * @param productID The product ID to lookup inventory record.
       * @return Inventory record or null if not found.
       */
      getRecord(productID: string): dw.catalog.ProductInventoryRecord;
    }

    /**
     * This manager provides access to inventory-related objects.
     */
    class ProductInventoryMgr {
      /**
       * The inventory list assigned to the current site or null if no
       *  inventory list is assigned to the current site.
       */
      static readonly inventoryList: dw.catalog.ProductInventoryList;

      /**
       * Returns the inventory list assigned to the current site or null if no
       *  inventory list is assigned to the current site.
       *
       * @return The ProductInventoryList assigned to the current site, or null.
       */
      static getInventoryList(): dw.catalog.ProductInventoryList;
      /**
       * Returns the inventory list with the passed ID or null if no inventory
       *  list exists with that ID.
       * @param listID The ID of the inventory list to retrieve.
       * @return The ProductInventoryList identified by listID, or null.
       */
      static getInventoryList(listID: string): dw.catalog.ProductInventoryList;
    }

    /**
     * The ProductInventoryRecord holds information about a Product&apos;s inventory, and availability.
     */
    class ProductInventoryRecord extends dw.object.ExtensibleObject {
      /**
       * The allocation quantity that is currently set. The quantity unit is the same unit as the product itself.
       */
      allocation: dw.value.Quantity;
      /**
       * The date the allocation quantity was initialized or reset.
       */
      readonly allocationResetDate: Date;
      /**
       * The quantity of items available to sell (ATS). This is calculated as the allocation
       *  (getAllocation()) plus the preorderBackorderAllocation (getPreorderBackorderAllocation()) minus
       *  the turnover (getTurnover()) minus on order (getOnOrder()).
       */
      readonly ATS: dw.value.Quantity;
      /**
       * Determines if the product is backorderable.
       */
      backorderable: boolean;
      /**
       * The date that the item is expected to be in stock.
       */
      inStockDate: Date;
      /**
       * The on-hand quantity, the actual quantity of available (on-hand) items.
       */
      readonly onHand: dw.value.Quantity;
      /**
       * The quantity that is currently on order.
       *
       *  This is only relevant when On Order Inventory is turned on for the related inventory list. On Order is a bucket
       *  of inventory used for the time between order creation and order export to external (warehouse) systems. On Order
       *  value is increased when an order is created. It will be decreased and with that turnover will be increased when
       *  the order is exported, see getTurnover(). Notice that Order.setExportStatus(Number) and
       *  OrderItem.allocateInventory(Boolean) will decrease the On Order value. On order will be included
       *  in the ATS calculation, see getATS().
       */
      readonly onOrder: dw.value.Quantity;
      /**
       * Determines if the product is perpetually in stock.
       */
      perpetual: boolean;
      /**
       * Determines if the product is preorderable.
       */
      preorderable: boolean;
      /**
       * The quantity of items that are allocated for sale, beyond the initial stock allocation.
       */
      preorderBackorderAllocation: dw.value.Quantity;
      /**
       * The quantity of items that are reserved.
       *
       *  Note, that for products with high velocity and concurrency the return value is extremely volatile and the
       *  retrieval will be expensive.
       */
      readonly reserved: dw.value.Quantity;
      /**
       * The current stock level. This is calculated as the allocation minus the turnover.
       */
      readonly stockLevel: dw.value.Quantity;
      /**
       * The sum of all inventory transactions (decrements and increments) that have been recorded subsequent to
       *  the allocation was reset date. The quantity value can be negative due to higher quantity of inventory decrements
       *  than increments.
       */
      readonly turnover: dw.value.Quantity;

      /**
       * Returns the allocation quantity that is currently set. The quantity unit is the same unit as the product itself.
       *
       * @return the allocation quantity or quantity N/A if not available.
       */
      getAllocation(): dw.value.Quantity;
      /**
       * Returns the date the allocation quantity was initialized or reset.
       *
       * @return the allocation reset date.
       */
      getAllocationResetDate(): Date;
      /**
       * Returns the quantity of items available to sell (ATS). This is calculated as the allocation
       *  (getAllocation()) plus the preorderBackorderAllocation (getPreorderBackorderAllocation()) minus
       *  the turnover (getTurnover()) minus on order (getOnOrder()).
       *
       * @return the quantity or quantity N/A if not available.
       */
      getATS(): dw.value.Quantity;
      /**
       * Returns the date that the item is expected to be in stock.
       *
       * @return the date that the item is expected to be in stock.
       */
      getInStockDate(): Date;
      /**
       * Returns the on-hand quantity, the actual quantity of available (on-hand) items.
       *
       * @return the on-hand quantity or quantity N/A if not available.
       */
      getOnHand(): dw.value.Quantity;
      /**
       * Returns the quantity that is currently on order.
       *
       *  This is only relevant when On Order Inventory is turned on for the related inventory list. On Order is a bucket
       *  of inventory used for the time between order creation and order export to external (warehouse) systems. On Order
       *  value is increased when an order is created. It will be decreased and with that turnover will be increased when
       *  the order is exported, see getTurnover(). Notice that Order.setExportStatus(Number) and
       *  OrderItem.allocateInventory(Boolean) will decrease the On Order value. On order will be included
       *  in the ATS calculation, see getATS().
       *
       * @return the quantity or quantity N/A if not available.
       */
      getOnOrder(): dw.value.Quantity;
      /**
       * Returns the quantity of items that are allocated for sale, beyond the initial stock allocation.
       *
       * @return the quantity or quantity N/A if not available.
       */
      getPreorderBackorderAllocation(): dw.value.Quantity;
      /**
       * Returns the quantity of items that are reserved.
       *
       *  Note, that for products with high velocity and concurrency the return value is extremely volatile and the
       *  retrieval will be expensive.
       *
       * @return the quantity of items reserved for this product.
       */
      getReserved(): dw.value.Quantity;
      /**
       * Returns the current stock level. This is calculated as the allocation minus the turnover.
       *
       * @return the stock level or quantity N/A if not available.
       */
      getStockLevel(): dw.value.Quantity;
      /**
       * Returns the sum of all inventory transactions (decrements and increments) that have been recorded subsequent to
       *  the allocation was reset date. The quantity value can be negative due to higher quantity of inventory decrements
       *  than increments.
       *
       * @return the turnover or quantity N/A if not available.
       */
      getTurnover(): dw.value.Quantity;
      /**
       * Determines if the product is backorderable.
       *
       * @return true if the product is backorderable.
       */
      isBackorderable(): boolean;
      /**
       * Determines if the product is perpetually in stock.
       *
       * @return true if the product is perpetually in stock.
       */
      isPerpetual(): boolean;
      /**
       * Determines if the product is preorderable.
       *
       * @return true if the product is preorderable.
       */
      isPreorderable(): boolean;
      /**
       * Sets the allocation quantity. This also updates the allocation reset date.
       * @param quantity the allocation quantity to set.
       */
      setAllocation(quantity: number): void;
      /**
       * The method is used to set whether the product is backorderable. Setting the backorderable flag to true will clear
       *  the preorderable flag. If the record's preorderable flag is set to true, calling this method with
       *  backorderableFlag==false will have no effect.
       * @param backorderableFlag the flag to set backorderable status.
       */
      setBackorderable(backorderableFlag: boolean): void;
      /**
       * Sets the date that the item is expected to be in stock.
       * @param inStockDate the date that the item is expected to be in stock.
       */
      setInStockDate(inStockDate: Date): void;
      /**
       * Sets if the product is perpetually in stock.
       * @param perpetualFlag true to set the product perpetually in stock.
       */
      setPerpetual(perpetualFlag: boolean): void;
      /**
       * The method is used to set whether the product is preorderable. Setting the preorderable flag to true will clear
       *  the backorderable flag. If the record's backorderable flag is set to true, calling this method with
       *  preorderableFlag==false will have no effect.
       * @param preorderableFlag the flag to set preorderable status.
       */
      setPreorderable(preorderableFlag: boolean): void;
      /**
       * Sets the quantity of items that are allocated for sale, beyond the initial stock allocation.
       * @param quantity the quantity to set.
       */
      setPreorderBackorderAllocation(quantity: number): void;
    }

    /**
     * The class represents a link between two products.
     */
    class ProductLink {
      /**
       * Represents an accessory product link.
       */
      static readonly LINKTYPE_ACCESSORY = 4;
      /**
       * Represents an alternative order unit product link.
       */
      static readonly LINKTYPE_ALT_ORDERUNIT = 6;
      /**
       * Represents a cross-sell product link.
       */
      static readonly LINKTYPE_CROSS_SELL = 1;
      /**
       * Represents a newer verion link.
       */
      static readonly LINKTYPE_NEWER_VERSION = 5;
      /**
       * Represents a miscellaneous product link.
       */
      static readonly LINKTYPE_OTHER = 8;
      /**
       * Represents a replacement product link.
       */
      static readonly LINKTYPE_REPLACEMENT = 2;
      /**
       * Represents a spare part product link.
       */
      static readonly LINKTYPE_SPARE_PART = 7;
      /**
       * Represents an up-sell product link.
       */
      static readonly LINKTYPE_UP_SELL = 3;

      /**
       * The source product for this link.
       */
      readonly sourceProduct: dw.catalog.Product;
      /**
       * The target product for this link.
       */
      readonly targetProduct: dw.catalog.Product;
      /**
       * The type of this link (see constants).
       */
      readonly typeCode: number;

      /**
       * Returns the source product for this link.
       *
       * @return the source product for this link.
       */
      getSourceProduct(): dw.catalog.Product;
      /**
       * Returns the target product for this link.
       *
       * @return the target product for this link.
       */
      getTargetProduct(): dw.catalog.Product;
      /**
       * Returns the type of this link (see constants).
       *
       * @return the type of the link.
       */
      getTypeCode(): number;
    }

    /**
     * Provides helper methods for getting products based on Product ID or <a href="class_dw_catalog_Catalog.html">Catalog</a>.
     */
    class ProductMgr {
      /**
       * Returns the product with the specified id.
       * @param productID the product identifier.
       * @return Product for specified id or null
       */
      static getProduct(productID: string): dw.catalog.Product;
      /**
       * Returns all products assigned to the current site.
       *
       *  A product is assigned to a site if
       *
       *  it is assigned to at least one category of the site catalog or
       *  it is a variant and it's master product is assigned to the current site
       *
       *
       *  It is strongly recommended to call close() on the returned SeekableIterator
       *  if not all of its elements are being retrieved. This will ensure the proper cleanup of system resources.
       *
       * @return Iterator of all site products
       */
      static queryAllSiteProducts(): dw.util.SeekableIterator;
      /**
       * Returns all products assigned to the current site.
       *
       *  Works like queryAllSiteProducts(), but additionally sorts the result set
       *  by product ID.
       *
       *  It is strongly recommended to call close() on the returned SeekableIterator
       *  if not all of its elements are being retrieved. This will ensure the proper cleanup of system resources.
       *
       * @return Iterator of all site products sorted by product ID.
       */
      static queryAllSiteProductsSorted(): dw.util.SeekableIterator;
      /**
       * Returns all products assigned to the the specified catalog, where
       *  assignment has the same meaning as it does for queryAllSiteProducts().
       *
       *  It is strongly recommended to call close() on the returned SeekableIterator
       *  if not all of its elements are being retrieved. This will ensure the proper cleanup of system resources.
       * @param catalog The catalog whose assigned products should be returned.
       * @return Iterator of all products assigned to specified catalog.
       */
      static queryProductsInCatalog(
        catalog: dw.catalog.Catalog
      ): dw.util.SeekableIterator;
      /**
       * Returns all products assigned to the the specified catalog.
       *  Works like queryProductsInCatalog(), but additionally sorts the result
       *  set by product ID.
       *
       *  It is strongly recommended to call close() on the returned SeekableIterator
       *  if not all of its elements are being retrieved. This will ensure the proper cleanup of system resources.
       * @param catalog The catalog whose assigned products should be returned.
       * @return Iterator of all products assigned to specified catalog sorted by product ID.
       */
      static queryProductsInCatalogSorted(
        catalog: dw.catalog.Catalog
      ): dw.util.SeekableIterator;
    }

    /**
     * Represents a product option.
     */
    class ProductOption extends dw.object.ExtensibleObject {
      /**
       * The default value for the product option.
       */
      readonly defaultValue: dw.catalog.ProductOptionValue;
      /**
       * The product option's short description in the current locale.
       */
      readonly description: string;
      /**
       * The product option's display name in the current locale.
       */
      readonly displayName: string;
      /**
       * An HTML representation of the option id.
       */
      readonly htmlName: string;
      /**
       * The product option ID.
       */
      readonly ID: string;
      /**
       * The product option's image.
       */
      readonly image: dw.content.MediaFile;
      /**
       * A collection containing the product option values.
       */
      readonly optionValues: dw.util.Collection<dw.catalog.ProductOptionValue>;

      /**
       * Returns the default value for the product option.
       *
       * @return the object for the relation 'defaultValue'
       */
      getDefaultValue(): dw.catalog.ProductOptionValue;
      /**
       * Returns the product option's short description in the current locale.
       *
       * @return The value of the short description in the current locale, or null if it wasn't found.
       */
      getDescription(): string;
      /**
       * Returns the product option's display name in the current locale.
       *
       * @return The value of the display name in the current locale, or null if it wasn't found.
       */
      getDisplayName(): string;
      /**
       * Returns an HTML representation of the option id.
       *
       * @return an HTML representation of the option id.
       */
      getHtmlName(): string;
      /**
       * Returns an HTML representation of the option id with the custom prefix.
       * @param prefix a custom prefix for the html name.
       * @return an HTML representation of the option id.
       */
      getHtmlName(prefix: string): string;
      /**
       * Returns the product option ID.
       *
       * @return the product option identifier.
       */
      getID(): string;
      /**
       * Returns the product option's image.
       *
       * @return the product option's image.
       */
      getImage(): dw.content.MediaFile;
      /**
       * Returns a collection containing the product option values.
       *
       * @return a collection containing the product option values.
       */
      getOptionValues(): dw.util.Collection<dw.catalog.ProductOptionValue>;
    }

    /**
     * This class represents the option model of a specific product and
     *  for a specific currency. It provides accessor methods to the configured
     *  options and the values of those options. It has also methods to set a
     *  specific selection of option values.
     */
    class ProductOptionModel {
      /**
       * The collection of product options.
       */
      readonly options: dw.util.Collection<dw.catalog.ProductOption>;

      /**
       * Returns the product option for the specified ID.
       * @param optionID the product option identifier.
       * @return the product option for the specified ID.
       */
      getOption(optionID: string): dw.catalog.ProductOption;
      /**
       * Returns the collection of product options.
       *
       * @return Collection of Product Options.
       */
      getOptions(): dw.util.Collection<dw.catalog.ProductOption>;
      /**
       * Returns the product option value object for the passed value id and in
       *  the context of the passed option.
       * @param option The option to get the specified value for.
       * @param valueID The id of the value to retrieve
       * @return a value for the specified product option and value id
       */
      getOptionValue(
        option: dw.catalog.ProductOption,
        valueID: string
      ): dw.catalog.ProductOptionValue;
      /**
       * Returns a collection of product option values for the
       *  specified product option.
       * @param option the option for which we want to extract the collection of product option values.
       * @return a collection of product option values for the specified product option.
       */
      getOptionValues(
        option: dw.catalog.ProductOption
      ): dw.util.Collection<dw.catalog.ProductOptionValue>;
      /**
       * Returns the effective price of the specified option value.
       * @param optionValue the product option value to use.
       * @return the effective price of the specified option value.
       */
      getPrice(optionValue: dw.catalog.ProductOptionValue): dw.value.Money;
      /**
       * Returns the selected value for the specified product option. If no
       *  option values was set as selected option explicitly, the method
       *  returns the default option value for this option.
       * @param option The option to get the selected value for.
       * @return a selected value for the specified product option.
       */
      getSelectedOptionValue(
        option: dw.catalog.ProductOption
      ): dw.catalog.ProductOptionValue;
      /**
       * Returns true if the specified option value is the one currently selected,
       *  false otherwise.
       * @param option the product option.
       * @param value the product option value.
       * @return true if the specified option value is the one currently selected, false otherwise.
       */
      isSelectedOptionValue(
        option: dw.catalog.ProductOption,
        value: dw.catalog.ProductOptionValue
      ): boolean;
      /**
       * Updates the selection of the specified option based on the specified value.
       * @param option the option to update.
       * @param value the value to use when updating the product option.
       */
      setSelectedOptionValue(
        option: dw.catalog.ProductOption,
        value: dw.catalog.ProductOptionValue
      ): void;
      /**
       * Returns a URL that can be used to select one or more option values. The
       *  optional varOptionAndValues argument can be empty, or can
       *  contain one or more option / value pairs. This variable list must be even
       *  in length, with options and values alternating. If the list is odd in
       *  length, the last argument will be ignored. Options can be specified as
       *  instances of ProductOption, or String option ID. Values can be specified
       *  as instances of ProductOptionValue or as strings representing the value
       *  ID. If a parameter is invalid, then the parameter pair is not included in
       *  the generated URL. The returned URL will contain options and values
       *  already selected in the product option model, as well as options and
       *  values specified as method parameters. This includes option values
       *  explicitly selected and implicitly selected by default.
       * @param action The pipeline action, must not be null.
       * @param varOptionAndValues Variable length list of options and values.
       * @return The constructed URL.
       */
      url(action: string, ...varOptionAndValues: any[]): dw.web.URL;
      /**
       * Returns an URL that can be used to select a specific value of a specific
       *  option.
       * @param action the action to use.
       * @param option the option to use when constructing the URL.
       * @param value the value to use when constructing the URL.
       * @return The constructed URL as string.
       */
      urlSelectOptionValue(
        action: string,
        option: dw.catalog.ProductOption,
        value: dw.catalog.ProductOptionValue
      ): string;
    }

    /**
     * Represents the value of a product option.
     */
    class ProductOptionValue extends dw.object.ExtensibleObject {
      /**
       * The the product option value's description
       *  in the current locale.
       */
      readonly description: string;
      /**
       * The the product option value's display name
       *  in the current locale.
       */
      readonly displayValue: string;
      /**
       * The product option value's ID.
       */
      readonly ID: string;
      /**
       * The product option value's product ID modifier which
       *  can be used to build the SKU for the actual product.
       */
      readonly productIDModifier: string;

      /**
       * Returns the the product option value's description
       *  in the current locale.
       *
       * @return The value of the product option value's description in the current locale, or null if it wasn't found.
       */
      getDescription(): string;
      /**
       * Returns the the product option value's display name
       *  in the current locale.
       *
       * @return The value of the product option value's display name in the current locale, or null if it wasn't found.
       */
      getDisplayValue(): string;
      /**
       * Returns the product option value's ID.
       *
       * @return the product option value's ID.
       */
      getID(): string;
      /**
       * Returns the product option value's product ID modifier which
       *  can be used to build the SKU for the actual product.
       *
       * @return the product option value's product ID modifier which can be used to build the SKU for the actual product.
       */
      getProductIDModifier(): string;
    }

    /**
     * Simple class representing a product price point.  This class is useful
     *  because it provides additional information beyond just the price.  Since the
     *  system calculates sales prices based on applicable price books, it is
     *  sometimes useful to know additional information such as which price book
     *  defined a price point, what percentage discount off the base price
     *  this value represents, and the date range for which this price point is active.
     */
    class ProductPriceInfo {
      /**
       * The date from which the associated price point is valid. If such a date doesn't exist, e.g. as in the
       *  case of a continuous price point, null will be returned.
       */
      readonly onlineFrom: Date;
      /**
       * The date until which the associated price point is valid. If such a date doesn't exist, e.g. as in the case
       *  of a continuous price point, null will be returned.
       */
      readonly onlineTo: Date;
      /**
       * The percentage off value of this price point related to the base
       *  price for the product's minimum order quantity.
       */
      readonly percentage: number;
      /**
       * The monetary price for this price point.
       */
      readonly price: dw.value.Money;
      /**
       * The price book which defined this price point.
       */
      readonly priceBook: dw.catalog.PriceBook;
      /**
       * The price info associated with this price point. This is an
       *  arbitrary string which a merchant can associate with a price entry. This
       *  can be used for example, to track which back-end system the price is
       *  derived from.
       */
      readonly priceInfo: string;

      /**
       * Returns the date from which the associated price point is valid. If such a date doesn't exist, e.g. as in the
       *  case of a continuous price point, null will be returned.
       *
       * @return the date from which the associated price point is valid
       */
      getOnlineFrom(): Date;
      /**
       * Returns the date until which the associated price point is valid. If such a date doesn't exist, e.g. as in the case
       *  of a continuous price point, null will be returned.
       *
       * @return the date to which the associated price point is valid
       */
      getOnlineTo(): Date;
      /**
       * Returns the percentage off value of this price point related to the base
       *  price for the product's minimum order quantity.
       *
       * @return the percentage off value of this price point
       */
      getPercentage(): number;
      /**
       * Returns the monetary price for this price point.
       *
       * @return the price amount
       */
      getPrice(): dw.value.Money;
      /**
       * Returns the price book which defined this price point.
       *
       * @return the price book defining this price
       */
      getPriceBook(): dw.catalog.PriceBook;
      /**
       * Returns the price info associated with this price point. This is an
       *  arbitrary string which a merchant can associate with a price entry. This
       *  can be used for example, to track which back-end system the price is
       *  derived from.
       *
       * @return the price info associated with this price point.
       */
      getPriceInfo(): string;
    }

    /**
     * ProductPriceModel provides methods to access all the
     *  <a href="class_dw_catalog_PriceBook.html">PriceBook</a> information of a product. A ProductPriceModel
     *  instance is retrieved by calling <a href="class_dw_catalog_Product.html#dw_catalog_Product_getPriceModel_DetailAnchor">Product.getPriceModel()</a>
     *  or <a href="class_dw_catalog_Product.html#dw_catalog_Product_getPriceModel_ProductOptionModel_DetailAnchor">Product.getPriceModel(ProductOptionModel)</a> for a
     *  specific product. The latter method will return a model which also includes
     *  the additional option prices of an option product.
     *  <p>
     *  When the current price of a product is accessed in the storefront via its
     *  price model, a price lookup is performed. The high-level steps of this price
     *  lookup are:
     *
     *  </p><ul>
     *  <li>Get all price books applicable in the context of the current site, time,
     *  session, customer, source code.</li>
     *  <li>Identify all prices in the applicable price books and for a requested
     *  quantity.</li>
     *  <li>Calculate the best-price of all identified prices. The best-price is the
     *  lowest price.</li>
     *  </ul>
     *
     *  In more detail:
     *  <p>
     *
     *  <b>Identify applicable price books</b><br>
     *  </p><ul>
     *  <li>If any price books are explicitly registered in the session (see pipelet
     *  SetApplicablePriceBooks), use these price books and their direct parents for
     *  price lookup. Ignore all inactive price books, price books not valid at the
     *  current time, and price books with a currency other than the session currency.</li>
     *  </ul>
     *
     *  <b>Otherwise:</b><br>
     *  <ul>
     *  <li>If a valid source code is registered with the current session, get all
     *  price books assigned to the source code and their parent price books. Ignore
     *  all inactive price books, price books not valid at the current time, and
     *  price books with a currency other than the session currency.</li>
     *  <li>Get all price books assigned to site and their parent price books. Ignore
     *  all inactive price books, price books not valid at the current time, and
     *  price books with a currency other than the session currency.</li>
     *  </ul>
     *
     *  <b>Identify all prices:</b><br>
     *  <ul>
     *  <li>Get all price definitions for the product from all applicable price
     *  books. Ignore price definitions not valid at the current time.</li>
     *  <li>Convert any percentage price definition into a monetary amount. As the
     *  base price for this calculation, the minimum product price for the minimum
     *  order quantity of the product, including product options, is used.</li>
     *  <li>Compare all prices and identify the lowest (= best) price.</li>
     *  <li>Calculate best price for each defined price cut in the price table and
     *  return price table.</li>
     *  </ul>
     *
     *  <b>Variation Price Fallback:</b><br>
     *  <ul>
     *  <li>If no applicable pricebooks for a variant is found, the price lookup gets
     *  the price books from the variant&apos;s master product</li>
     *  <li>A price books is also not applicable of the price definition for the
     *  variant in the price book is not valid at the current time.</li>
     *  </ul>
     *
     *  <p>
     *
     *  Typically, in order to do a standard price lookup, it is only necessary to
     *  call <code>Product.getPriceModel().getPrice()</code>. However, Commerce Cloud
     *  Digital also supports tiered prices, meaning that higher quantities receive
     *  a lower price. In this case, the merchant typically wants to display a table
     *  of price points on product detail pages. Therefore, the ProductPriceModel
     *  provides the method <a href="class_dw_catalog_ProductPriceModel.html#dw_catalog_ProductPriceModel_getPriceTable_DetailAnchor">getPriceTable()</a> to retrieve a table of these prices.
     *
     *  </p><p>
     *
     *  If a merchant wants to know not only what the price of a given product is,
     *  but what price book the price was derived from, this class provides the
     *  method <a href="class_dw_catalog_ProductPriceModel.html#dw_catalog_ProductPriceModel_getPriceInfo_DetailAnchor">getPriceInfo()</a>. This class also provides methods to lookup
     *  product prices in specific price books by name and quantity. See
     *  <a href="class_dw_catalog_ProductPriceModel.html#dw_catalog_ProductPriceModel_getPriceBookPrice_String_DetailAnchor">getPriceBookPrice(String)</a>.</p>
     */
    class ProductPriceModel {
      /**
       * The quantity for which the base price is defined. This
       *  is typically 1.0.
       */
      readonly basePriceQuantity: dw.value.Quantity;
      /**
       * Calculates and returns the maximum price-book price of all variants (for
       *  master products) or set-products (for product sets) for base quantity
       *  1.00. This value can be used to display a range of prices in storefront.
       *  If the product represented by this model is not a master product or
       *  product set, then this method behaves the same as getPrice().
       *  Only online products are considered. If the "orderable products only"
       *  search preference is enabled for the current site, then only orderable
       *  products are considered. For master products, only variants with all
       *  variation attributes configured are considered.
       *
       *  Warning:  If the product represented by this model is a master
       *  product with numerous variants, this method can be very expensive and
       *  should be avoided.
       */
      readonly maxPrice: dw.value.Money;
      /**
       * Calculates and returns the minimum price-book price of all variants (for
       *  master products) or set-products (for product sets) for base quantity
       *  1.00. This value can be used to display a range of prices in storefront.
       *  If the product represented by this model is not a master product or
       *  product set, then this method behaves the same as getPrice().
       *  Only online products are considered. If the "orderable products only"
       *  search preference is enabled for the current site, then only orderable
       *  products are considered. For master products, only variants with all
       *  variation attributes configured are considered.
       *
       *  Warning:  If the product represented by this model is a master
       *  product with numerous variants, this method can be very expensive and
       *  should be avoided.
       */
      readonly minPrice: dw.value.Money;
      /**
       * The price of a product, calculated based on base price quantity
       *  1.00. The price is returned for the currency of the current session.
       *
       *  The price lookup is based on the configuration of price books. It depends
       *  on various settings, such as which price books are active, or explicitly
       *  set as applicable in the current session.
       *
       *  If the product represented by this model is an option product, option
       *  prices will be added to the price book price if the price model was
       *  initialized with an option model.
       *
       *  If no price could be found, MONEY.NOT_AVAILABLE is returned.
       */
      readonly price: dw.value.Money;
      /**
       * The price info of a product, calculated based on base price
       *  quantity 1.00. The price is returned for the currency of the current
       *  session.
       *
       *  This method is similar to getPrice() but instead of just
       *  returning the price value, it returns a ProductPriceInfo
       *  which contains additional information such as the PriceBook which defined
       *  the price and the percentage discount this price point represents.
       *
       *  If the product represented by this model is an option product, option
       *  prices will be added to the price book price if the price model was
       *  initialized with an option model.
       *
       *  If no price info could be found, null is returned.
       */
      readonly priceInfo: dw.catalog.ProductPriceInfo;
      /**
       * All the price infos of a product that could have been the basis of the storefront price, calculated based
       *  on base price quantity 1.00. This will return an empty list if getPriceInfo() would return null, and if there is
       *  only one price info in the collection it will be the same price info as getPriceInfo(). Two or more price infos
       *  indicate that there are that many price books that meet the criteria for returning the price shown in the
       *  storefront.
       */
      readonly priceInfos: dw.util.Collection<dw.catalog.ProductPriceInfo>;
      /**
       * Returns true if this product is a master product (or product set) and the
       *  collection of online variants (or set products respectively) contains
       *  products of different prices.
       *
       *  Warning:  If the product represented by this model is a master
       *  product with numerous variants, this method can be very expensive and
       *  should be avoided.
       */
      readonly priceRange: boolean;
      /**
       * The product price table object. The price table represents a map
       *  between order quantities and prices, and also provides % off information
       *  to be shown to storefront customers. The price is returned for the
       *  currency of the current session.
       *
       *  Usually, the product price table is printed on product detail pages in
       *  the storefront.
       *
       *  If the product represented by this model is an option product, option
       *  prices will be added to the price book price if the price model was
       *  initialized with an option model.
       *
       *  All other methods of this class are based on the information in the
       *  product price table.
       */
      readonly priceTable: dw.catalog.ProductPriceTable;

      /**
       * Returns the quantity for which the base price is defined. This
       *  is typically 1.0.
       *
       * @return the quantity for which the base price is defined.
       */
      getBasePriceQuantity(): dw.value.Quantity;
      /**
       * Calculates and returns the maximum price-book price of all variants (for
       *  master products) or set-products (for product sets) for base quantity
       *  1.00. This value can be used to display a range of prices in storefront.
       *  If the product represented by this model is not a master product or
       *  product set, then this method behaves the same as getPrice().
       *  Only online products are considered. If the "orderable products only"
       *  search preference is enabled for the current site, then only orderable
       *  products are considered. For master products, only variants with all
       *  variation attributes configured are considered.
       *
       *  Warning:  If the product represented by this model is a master
       *  product with numerous variants, this method can be very expensive and
       *  should be avoided.
       *
       * @return Maximum price of all online variants or set-products.
       */
      getMaxPrice(): dw.value.Money;
      /**
       * Calculates and returns the maximum price in a given price book of all
       *  variants (for master products) or set-products (for product sets) for
       *  base quantity 1.00. This value can be used to display a range of prices
       *  in storefront.
       *
       *  This method follows the same rules as
       *  getPriceBookPrice(String) in determining the price book
       *  price for each variant or set-product. If the product represented by this
       *  model is not a master product or product set, then this method behaves
       *  the same as getPriceBookPrice(String).
       * @param priceBookID ID of price book the price is requested for, must not be null.
       * @return The maximum price across all subproducts in the specified price book.
       */
      getMaxPriceBookPrice(priceBookID: string): dw.value.Money;
      /**
       * Calculates and returns the minimum price-book price of all variants (for
       *  master products) or set-products (for product sets) for base quantity
       *  1.00. This value can be used to display a range of prices in storefront.
       *  If the product represented by this model is not a master product or
       *  product set, then this method behaves the same as getPrice().
       *  Only online products are considered. If the "orderable products only"
       *  search preference is enabled for the current site, then only orderable
       *  products are considered. For master products, only variants with all
       *  variation attributes configured are considered.
       *
       *  Warning:  If the product represented by this model is a master
       *  product with numerous variants, this method can be very expensive and
       *  should be avoided.
       *
       * @return Minimum price of all online variants or set-products.
       */
      getMinPrice(): dw.value.Money;
      /**
       * Calculates and returns the minimum price in a given price book of all
       *  variants (for master products) or set-products (for product sets) for
       *  base quantity 1.00. This value can be used to display a range of prices
       *  in storefront.
       *
       *  This method follows the same rules as
       *  getPriceBookPrice(String) in determining the price book
       *  price for each variant or set-product. If the product represented by this
       *  model is not a master product or product set, then this method behaves
       *  the same as getPriceBookPrice(String).
       * @param priceBookID ID of price book the price is requested for, must not be null.
       * @return The minimum price across all subproducts in the specified price book.
       */
      getMinPriceBookPrice(priceBookID: string): dw.value.Money;
      /**
       * Returns the price of a product, calculated based on base price quantity
       *  1.00. The price is returned for the currency of the current session.
       *
       *  The price lookup is based on the configuration of price books. It depends
       *  on various settings, such as which price books are active, or explicitly
       *  set as applicable in the current session.
       *
       *  If the product represented by this model is an option product, option
       *  prices will be added to the price book price if the price model was
       *  initialized with an option model.
       *
       *  If no price could be found, MONEY.NOT_AVAILABLE is returned.
       *
       * @return the product price.
       */
      getPrice(): dw.value.Money;
      /**
       * Returns the price of a product, calculated based on the passed order
       *  quantity. The price is returned for the currency of the current session.
       *
       *  The price lookup is based on the configuration of price books. It depends
       *  on various settings, such as which price books are active, or explicitly
       *  set as applicable in the current session.
       *
       *  If the product represented by this model is an option product, option
       *  prices will be added to the price book price if the price model was
       *  initialized with an option model.
       *
       *  If no price could be found, MONEY.NOT_AVAILABLE is returned.
       * @param quantity Quantity price is requested for
       * @return the product price.
       */
      getPrice(quantity: dw.value.Quantity): dw.value.Money;
      /**
       * Returns the active price of the product in the specified price book for
       *  quantity 1.00.
       *
       *  If the product represented by this model is an option product, option
       *  prices will be added to the price book price if the price model was
       *  initialized with an option model.
       *
       *  Money.NOT_AVAILABLE will be returned in any of the following cases:
       *
       *
       *  priceBookID is null or does not identify a valid price book.
       *  The price book has no price for the product.
       *  None of the prices for the product in the price book is currently
       *  active.
       *  The currently active price entry is a percentage.
       * @param priceBookID ID of price book the price is requested for.
       * @return the price of the product in the specified price book.
       */
      getPriceBookPrice(priceBookID: string): dw.value.Money;
      /**
       * Returns the active price of the product in the specified price book for
       *  the specified quantity.
       *
       *  If the product represented by this model is an option product, option
       *  prices will be added to the price book price if the price model was
       *  initialized with an option model.
       *
       *  Money.NOT_AVAILABLE will be returned in any of the following cases:
       *
       *
       *  priceBookID is null or does not identify a valid price book.
       *  quantity is null.
       *  The price book has no price for the product.
       *  None of the prices for the product in the price book is currently
       *  active.
       *  The currently active price entry is a percentage.
       * @param priceBookID ID of price book the price is requested for.
       * @param quantity the specified quantity to find the price for.
       * @return the price of the product in the specified price book.
       */
      getPriceBookPrice(
        priceBookID: string,
        quantity: dw.value.Quantity
      ): dw.value.Money;
      /**
       * This method acts similarly to getPriceBookPrice(String) but
       *  returns a ProductPriceInfo object wrapping the actual price with
       *  additional information.
       * @param priceBookID ID of price book the price is requested for, must not be null.
       * @return the product price info, or null if not found.
       */
      getPriceBookPriceInfo(priceBookID: string): dw.catalog.ProductPriceInfo;
      /**
       * This method acts similarly to
       *  getPriceBookPrice(String, Quantity) but returns a
       *  ProductPriceInfo object wrapping the actual price with additional
       *  information.
       * @param priceBookID ID of price book the price is requested for, must not be null.
       * @param quantity Quantity price is requested for.
       * @return the product price info, or null if not found.
       */
      getPriceBookPriceInfo(
        priceBookID: string,
        quantity: dw.value.Quantity
      ): dw.catalog.ProductPriceInfo;
      /**
       * Returns the price info of a product, calculated based on base price
       *  quantity 1.00. The price is returned for the currency of the current
       *  session.
       *
       *  This method is similar to getPrice() but instead of just
       *  returning the price value, it returns a ProductPriceInfo
       *  which contains additional information such as the PriceBook which defined
       *  the price and the percentage discount this price point represents.
       *
       *  If the product represented by this model is an option product, option
       *  prices will be added to the price book price if the price model was
       *  initialized with an option model.
       *
       *  If no price info could be found, null is returned.
       *
       * @return the product price info, or null if not found.
       */
      getPriceInfo(): dw.catalog.ProductPriceInfo;
      /**
       * Returns the price info of a product, calculated based on the passed order
       *  quantity. The price is returned for the currency of the current session.
       *
       *  This method is similar to getPrice(Quantity) but instead of
       *  just returning the price value, it returns a
       *  ProductPriceInfo which contains additional information such
       *  as the PriceBook which defined the price and the percentage discount this
       *  price point represents.
       *
       *  If the product represented by this model is an option product, option
       *  prices will be added to the price book price if the price model was
       *  initialized with an option model.
       *
       *  If no price info could be found, null is returned.
       * @param quantity the quantity to use.
       * @return the product price info, or null if not found.
       */
      getPriceInfo(quantity: dw.value.Quantity): dw.catalog.ProductPriceInfo;
      /**
       * Returns all the price infos of a product that could have been the basis of the storefront price, calculated based
       *  on base price quantity 1.00. This will return an empty list if getPriceInfo() would return null, and if there is
       *  only one price info in the collection it will be the same price info as getPriceInfo(). Two or more price infos
       *  indicate that there are that many price books that meet the criteria for returning the price shown in the
       *  storefront.
       *
       * @return any product price info that could be responsible for the storefront price, or empty collection if there were no product price infos this price model.
       */
      getPriceInfos(): dw.util.Collection<dw.catalog.ProductPriceInfo>;
      /**
       * Calculates and returns the percentage off amount of the passed
       *  comparePrice to the passed basePrice.
       * @param basePrice The assumed 100% price amount
       * @param comparePrice The price to compare to the basePrice
       * @return The percentage between comparePrice and basePrice (e.g. 90%).
       */
      getPricePercentage(
        basePrice: dw.value.Money,
        comparePrice: dw.value.Money
      ): number;
      /**
       * Returns the product price table object. The price table represents a map
       *  between order quantities and prices, and also provides % off information
       *  to be shown to storefront customers. The price is returned for the
       *  currency of the current session.
       *
       *  Usually, the product price table is printed on product detail pages in
       *  the storefront.
       *
       *  If the product represented by this model is an option product, option
       *  prices will be added to the price book price if the price model was
       *  initialized with an option model.
       *
       *  All other methods of this class are based on the information in the
       *  product price table.
       *
       * @return the Product price table.
       */
      getPriceTable(): dw.catalog.ProductPriceTable;
      /**
       * Returns true if this product is a master product (or product set) and the
       *  collection of online variants (or set products respectively) contains
       *  products of different prices.
       *
       *  Warning:  If the product represented by this model is a master
       *  product with numerous variants, this method can be very expensive and
       *  should be avoided.
       *
       * @return True if this product has a range of prices, false otherwise.
       */
      isPriceRange(): boolean;
      /**
       * Returns true if this product is a master product (or product set) and the
       *  collection of online variants (or set products respectively) contains
       *  products of different prices in the specified price book.
       * @param priceBookID The ID of the price book.
       * @return True if this product has a range of prices, false otherwise.
       */
      isPriceRange(priceBookID: string): boolean;
    }

    /**
     * A ProductPriceTable is a map of quantities to prices representing the
     *  potentially tiered prices of a product in Commerce Cloud Digital. The price
     *  of a product is the price associated with the largest quantity in
     *  the ProductPriceTable which does not exceed the purchase quantity.
     */
    class ProductPriceTable {
      /**
       * All quantities stored in the price table.
       */
      readonly quantities: dw.util.Collection<dw.value.Quantity>;

      /**
       * Returns the quantity following the passed quantity in the price table.
       *  If the passed quantity is the last entry in the price table, null is
       *  returned.
       * @param quantity the quantity to use to locate the next quantity in the price table.
       * @return the next quantity or null.
       */
      getNextQuantity(quantity: dw.value.Quantity): dw.value.Quantity;
      /**
       * Returns the percentage off value of the price related to the passed quantity,
       *  calculated based on the price of the products minimum order quantity.
       * @param quantity the price quantity to compute the percentage off.
       * @return the percentage off value of the price related to the passed quantity.
       */
      getPercentage(quantity: dw.value.Quantity): number;
      /**
       * Returns the monetary price for the passed order quantity. If
       *  no price is defined for the passed quantity, null is returned. This
       *  can happen if for example no price is defined for a single item.
       * @param quantity the quantity to use to determine price.
       * @return price amount for the passed quantity
       */
      getPrice(quantity: dw.value.Quantity): dw.value.Money;
      /**
       * Returns the price book which defined the monetary price for the passed
       *  order quantity. If no price is defined for the passed quantity, null is
       *  returned. This can happen if for example no price is defined for a single
       *  item.
       * @param quantity the quantity to use to determine price.
       * @return the price book defining this price, or null
       */
      getPriceBook(quantity: dw.value.Quantity): dw.catalog.PriceBook;
      /**
       * Returns all quantities stored in the price table.
       *
       * @return all price table quantities.
       */
      getQuantities(): dw.util.Collection<dw.value.Quantity>;
    }

    /**
     * ProductSearchHit is the result of a executed search query and wraps the actual product found by the search.
     *
     *  The method <a href="class_dw_catalog_ProductSearchHit.html#dw_catalog_ProductSearchHit_getRepresentedProducts_DetailAnchor">getRepresentedProducts()</a> returns the actual products that is conforming the query and is represented by the search hit.
     *  Depending on the hit typ, <a href="class_dw_catalog_ProductSearchHit.html#dw_catalog_ProductSearchHit_getRepresentedProducts_DetailAnchor">getRepresentedProducts()</a> returns:
     *   <ul>
     *       <li><a href="class_dw_catalog_ProductSearchHit.html#dw_catalog_ProductSearchHit_HIT_TYPE_SIMPLE_DetailAnchor">HIT_TYPE_SIMPLE</a> -&gt; a simple product </li>
     *       <li><a href="class_dw_catalog_ProductSearchHit.html#dw_catalog_ProductSearchHit_HIT_TYPE_PRODUCT_MASTER_DetailAnchor">HIT_TYPE_PRODUCT_MASTER</a> -&gt; a variation product</li>
     *       <li><a href="class_dw_catalog_ProductSearchHit.html#dw_catalog_ProductSearchHit_HIT_TYPE_PRODUCT_SET_DetailAnchor">HIT_TYPE_PRODUCT_SET</a> -&gt; a product part of set</li>
     *       <li><a href="class_dw_catalog_ProductSearchHit.html#dw_catalog_ProductSearchHit_HIT_TYPE_PRODUCT_BUNDLE_DetailAnchor">HIT_TYPE_PRODUCT_BUNDLE</a> -&gt; a product part of a bundle</li>
     *       <li><a href="class_dw_catalog_ProductSearchHit.html#dw_catalog_ProductSearchHit_HIT_TYPE_VARIATION_GROUP_DetailAnchor">HIT_TYPE_VARIATION_GROUP</a> -&gt; a variation product</li>
     *  </ul>
     *
     *  The ProductSearchHit type can be retrieved by method <a href="class_dw_catalog_ProductSearchHit.html#dw_catalog_ProductSearchHit_getHitType_DetailAnchor">getHitType()</a> and contains the following types:
     *  <ul>
     *       <li><a href="class_dw_catalog_ProductSearchHit.html#dw_catalog_ProductSearchHit_HIT_TYPE_SIMPLE_DetailAnchor">HIT_TYPE_SIMPLE</a></li>
     *       <li><a href="class_dw_catalog_ProductSearchHit.html#dw_catalog_ProductSearchHit_HIT_TYPE_PRODUCT_MASTER_DetailAnchor">HIT_TYPE_PRODUCT_MASTER</a></li>
     *       <li><a href="class_dw_catalog_ProductSearchHit.html#dw_catalog_ProductSearchHit_HIT_TYPE_PRODUCT_SET_DetailAnchor">HIT_TYPE_PRODUCT_SET</a></li>
     *       <li><a href="class_dw_catalog_ProductSearchHit.html#dw_catalog_ProductSearchHit_HIT_TYPE_PRODUCT_BUNDLE_DetailAnchor">HIT_TYPE_PRODUCT_BUNDLE</a></li>
     *       <li><a href="class_dw_catalog_ProductSearchHit.html#dw_catalog_ProductSearchHit_HIT_TYPE_VARIATION_GROUP_DetailAnchor">HIT_TYPE_VARIATION_GROUP</a></li>
     *  </ul>
     *
     *  The method <a href="class_dw_catalog_ProductSearchHit.html#dw_catalog_ProductSearchHit_getProduct_DetailAnchor">getProduct()</a> returns the presentation product corresponding to the <a href="class_dw_catalog_ProductSearchHit.html">ProductSearchHit</a> type.
     *  <ul>
     *       <li><a href="class_dw_catalog_ProductSearchHit.html#dw_catalog_ProductSearchHit_HIT_TYPE_SIMPLE_DetailAnchor">HIT_TYPE_SIMPLE</a> -&gt; a simple product </li>
     *       <li><a href="class_dw_catalog_ProductSearchHit.html#dw_catalog_ProductSearchHit_HIT_TYPE_PRODUCT_MASTER_DetailAnchor">HIT_TYPE_PRODUCT_MASTER</a> -&gt; a variation master product</li>
     *       <li><a href="class_dw_catalog_ProductSearchHit.html#dw_catalog_ProductSearchHit_HIT_TYPE_PRODUCT_SET_DetailAnchor">HIT_TYPE_PRODUCT_SET</a> -&gt; a product set</li>
     *       <li><a href="class_dw_catalog_ProductSearchHit.html#dw_catalog_ProductSearchHit_HIT_TYPE_PRODUCT_BUNDLE_DetailAnchor">HIT_TYPE_PRODUCT_BUNDLE</a> -&gt; a product bundle</li>
     *       <li><a href="class_dw_catalog_ProductSearchHit.html#dw_catalog_ProductSearchHit_HIT_TYPE_VARIATION_GROUP_DetailAnchor">HIT_TYPE_VARIATION_GROUP</a> -&gt;a variation group</li>
     *  </ul>
     *
     *  Example:
     *
     *  Given a product master P1 called &quot;Sweater&quot; with attributes color and size that has the following variants:
     *  <ul>
     *      <li>V1 - color: red, size: small</li>
     *      <li>V2 - color: red, size: large</li>
     *      <li>V3 - color: blue, size: small</li>
     *      <li>V4 - color: blue, size: large</li>
     *      <li>V5 - color: yellow, size: small</li>
     *      <li>V6 - color: yellow, size: large</li>
     *  </ul>
     *
     *  A search for &quot;red sweater&quot; should hit the first two variants, V1 and V2
     *  that are both red. The ProductSearchHit for this result encompass the master and the red variants but not the other
     *  non-relevant variants.
     *
     *  The variants hit by the query can be retrieved by <a href="class_dw_catalog_ProductSearchHit.html#dw_catalog_ProductSearchHit_getRepresentedProducts_DetailAnchor">getRepresentedProducts()</a>, returning a list that contains the two red sweater variants.
     *
     *  The master product &quot;Sweater&quot; is returned by <a href="class_dw_catalog_ProductSearchHit.html#dw_catalog_ProductSearchHit_getProduct_DetailAnchor">getProduct()</a>.
     *
     *  Furthermore, to get the first or last of that list of variants hit by the query we can call
     *  <a href="class_dw_catalog_ProductSearchHit.html#dw_catalog_ProductSearchHit_getFirstRepresentedProduct_DetailAnchor">getFirstRepresentedProduct()</a> or <a href="class_dw_catalog_ProductSearchHit.html#dw_catalog_ProductSearchHit_getLastRepresentedProduct_DetailAnchor">getLastRepresentedProduct()</a>. The product with the highest
     *  sort rank is returned first, and the product with the lowest sort rank is
     *  returned last. The product sort rank depends on the sorting conditions
     *  used for the search query.
     */
    class ProductSearchHit {
      /**
       * Constant representing a product search hit type based on the presentation product of a hit. This hit type is used with product bundles.
       */
      static readonly HIT_TYPE_PRODUCT_BUNDLE = "bundle";
      /**
       * Constant representing a product search hit type based on the presentation product of a hit. This hit type is used with master products.
       */
      static readonly HIT_TYPE_PRODUCT_MASTER = "master";
      /**
       * Constant representing a product search hit type based on the presentation product of a hit. This hit type is used with product sets.
       */
      static readonly HIT_TYPE_PRODUCT_SET = "set";
      /**
       * Constant representing a product search hit type based on the presentation product of a hit. This hit type is used with single, non-complex products, including product variants that
       *  are assigned to a category and are returned as the presentation product.
       */
      static readonly HIT_TYPE_SIMPLE = "product";
      /**
       * Constant representing a product search hit type based on the presentation product of a hit. This hit type is used with slicing groups.
       */
      static readonly HIT_TYPE_SLICING_GROUP = "slicing_group";
      /**
       * Constant representing a product search hit type based on the presentation product of a hit. This hit type is used with variation groups.
       */
      static readonly HIT_TYPE_VARIATION_GROUP = "variation_group";

      /**
       * Return the IDs of all searchable promotions for which at least one of the represented products of this search hit
       *  relates to the promotion, either as qualifying, discount, or bonus product. This may be used as a better
       *  performing alternative to PromotionPlan.getProductPromotions(Product) in some special cases.
       *  However be warned: this method has no additional checks and currently returns all id's which are known at
       *  indexing time. Custom code should generally filter and sort the promotions returned by this method according to
       *  PromotionMgr.getActiveCustomerPromotions() before messaging the promotions on a product tile.
       */
      readonly allPromotionIDs: dw.util.List<string>;
      /**
       * Return the IDs of all searchable promotions for which at least one of the represented products of this search hit
       *  is a bonus product. This may be used as a better performing alternative to
       *  PromotionPlan.getProductPromotions(Product) in some special cases. However be warned: this
       *  method has no additional checks and currently returns all id's which are known at indexing time. Custom code
       *  should generally filter and sort the promotions returned by this method according to
       *  PromotionMgr.getActiveCustomerPromotions() before messaging the promotions on a product tile.
       */
      readonly bonusPromotionIDs: dw.util.List<string>;
      /**
       * Return the IDs of all searchable promotions for which at least one of the represented products of this search hit
       *  satisfy the discounted product rule. This may be used as a better performing alternative to
       *  PromotionPlan.getProductPromotionsForDiscountedProduct(Product) in some special cases.
       *  However be warned: this method has no additional checks and currently returns all id's which are known at
       *  indexing time. Custom code should generally filter and sort the promotions returned by this method according to
       *  PromotionMgr.getActiveCustomerPromotions() before messaging the promotions on a product tile.
       */
      readonly discountedPromotionIDs: dw.util.List<string>;
      /**
       * The product that is actually hit by the search and has the highest
       *  sort rank according to the sorting conditions used for the search query.
       */
      readonly firstRepresentedProduct: dw.catalog.Product;
      /**
       * The ID of the product that is actually hit by the search and has the highest
       *  sort rank according to the sorting conditions used for the search query.
       */
      readonly firstRepresentedProductID: string;
      /**
       * The type of the product wrapped by this search hit. The product type returned will be one of the hit types:
       *
       *   HIT_TYPE_SIMPLE
       *   HIT_TYPE_PRODUCT_MASTER
       *   HIT_TYPE_PRODUCT_BUNDLE
       *   HIT_TYPE_PRODUCT_SET
       *   HIT_TYPE_SLICING_GROUP
       *   HIT_TYPE_VARIATION_GROUP
       */
      readonly hitType: string;
      /**
       * The product that is actually hit by the search and has the lowest
       *  sort rank according to the sorting conditions used for the search query.
       */
      readonly lastRepresentedProduct: dw.catalog.Product;
      /**
       * The ID of the product that is actually hit by the search and has the lowest
       *  sort rank according to the sorting conditions used for the search query.
       */
      readonly lastRepresentedProductID: string;
      /**
       * The maximum price of all products represented by the
       *  product hit. See getRepresentedProducts() for details on
       *  the set of products used for finding the maximum. The method returns
       *  N/A in case no price information can be found.
       *
       *  Note: The method uses price information of the search index and therefore
       *  might return different prices than the ProductPriceModel.
       */
      readonly maxPrice: dw.value.Money;
      /**
       * The minimum price of all products represented by the
       *  product hit. See getRepresentedProducts() for details on
       *  the set of products used for finding the minimum. The method returns
       *  N/A in case no price information can be found.
       *
       *  Note: the method uses price information of the search index and therefore
       *  might return different prices than the ProductPriceModel.
       */
      readonly minPrice: dw.value.Money;
      /**
       * Convenience method to check whether this ProductSearchHit represents
       *  multiple products (see getRepresentedProducts()) that have
       *  different prices.
       */
      readonly priceRange: boolean;
      /**
       * The presentation product of this ProductSearchHit corresponding to the ProductSearchHit type.
       *
       *       HIT_TYPE_SIMPLE -> a simple product
       *       HIT_TYPE_PRODUCT_MASTER -> a variation master product
       *       HIT_TYPE_PRODUCT_SET -> a product set
       *       HIT_TYPE_PRODUCT_BUNDLE -> a product bundle
       *       HIT_TYPE_VARIATION_GROUP ->a variation group
       *
       *
       *  To retrieve the product(s) actually hit by the search use getRepresentedProducts().
       */
      readonly product: dw.catalog.Product;
      /**
       * The ID of the presentation product of this ProductSearchHit corresponding to the ProductSearchHit type.
       *
       *       HIT_TYPE_SIMPLE -> a simple product
       *       HIT_TYPE_PRODUCT_MASTER -> a variation master product
       *       HIT_TYPE_PRODUCT_SET -> a product set
       *       HIT_TYPE_PRODUCT_BUNDLE -> a product bundle
       *       HIT_TYPE_VARIATION_GROUP ->a variation group
       *
       *
       *  To retrieve the ID of the product actually hit by the search use getFirstRepresentedProductID() or getLastRepresentedProductID().
       */
      readonly productID: string;
      /**
       * Return the IDs of all searchable promotions for which at least one of the represented products of this search hit
       *  satisfies the qualifying product rule. This may be used as a better performing alternative to
       *  PromotionPlan.getProductPromotionsForQualifyingProduct(Product) in some special cases.
       *  However be warned: this method has no additional checks and currently returns all id's which are known at
       *  indexing time. Custom code should generally filter and sort the promotions returned by this method according to
       *  PromotionMgr.getActiveCustomerPromotions() before messaging the promotions on a product tile.
       */
      readonly qualifyingPromotionIDs: dw.util.List<string>;
      /**
       * The method returns the actual ID of the product that is conforming the query and is represented by the search hit.
       *  Depending on the hit typ, it returns the ID of:
       *
       *       HIT_TYPE_SIMPLE -> a simple product
       *       HIT_TYPE_PRODUCT_MASTER -> a variation product
       *       HIT_TYPE_PRODUCT_SET -> a product part of set
       *       HIT_TYPE_PRODUCT_BUNDLE -> a product part of a bundle
       *       HIT_TYPE_VARIATION_GROUP ->a variation product
       *
       *
       *  If the method returns multiple products, the product with the highest
       *  sort rank is returned first, and the product with the lowest sort rank is
       *  returned last. The product sort rank depends on the sorting conditions
       *  used for the search query.
       */
      readonly representedProductIDs: dw.util.List<string>;
      /**
       * The method returns the actual product that is conforming the query and is represented by the search hit.
       *  Depending on the hit typ, getRepresentedProducts() returns:
       *
       *       HIT_TYPE_SIMPLE -> a simple product
       *       HIT_TYPE_PRODUCT_MASTER -> a variation product
       *       HIT_TYPE_PRODUCT_SET -> a product part of set
       *       HIT_TYPE_PRODUCT_BUNDLE -> a product part of a bundle
       *       HIT_TYPE_VARIATION_GROUP ->a variation product
       *
       *
       *  If the method returns multiple products, the product with the highest
       *  sort rank is returned first, and the product with the lowest sort rank is
       *  returned last. The product sort rank depends on the sorting conditions
       *  used for the search query.
       */
      readonly representedProducts: dw.util.List<dw.catalog.Product>;

      /**
       * Returns the product that is actually hit by the search and has the highest
       *  sort rank according to the sorting conditions used for the search query.
       *
       * @return the first product that is actually hit by the search
       */
      getFirstRepresentedProduct(): dw.catalog.Product;
      /**
       * Returns the ID of the product that is actually hit by the search and has the highest
       *  sort rank according to the sorting conditions used for the search query.
       *
       * @return the ID of the first product that is actually hit by the search
       */
      getFirstRepresentedProductID(): string;
      /**
       * Returns the type of the product wrapped by this search hit. The product type returned will be one of the hit types:
       *
       *   HIT_TYPE_SIMPLE
       *   HIT_TYPE_PRODUCT_MASTER
       *   HIT_TYPE_PRODUCT_BUNDLE
       *   HIT_TYPE_PRODUCT_SET
       *   HIT_TYPE_SLICING_GROUP
       *   HIT_TYPE_VARIATION_GROUP
       *
       * @return search hit type
       */
      getHitType(): string;
      /**
       * Returns the product that is actually hit by the search and has the lowest
       *  sort rank according to the sorting conditions used for the search query.
       *
       * @return the last product that is actually hit by the search
       */
      getLastRepresentedProduct(): dw.catalog.Product;
      /**
       * Returns the ID of the product that is actually hit by the search and has the lowest
       *  sort rank according to the sorting conditions used for the search query.
       *
       * @return the ID of the last product that is actually hit by the search
       */
      getLastRepresentedProductID(): string;
      /**
       * Returns the maximum price of all products represented by the
       *  product hit. See getRepresentedProducts() for details on
       *  the set of products used for finding the maximum. The method returns
       *  N/A in case no price information can be found.
       *
       *  Note: The method uses price information of the search index and therefore
       *  might return different prices than the ProductPriceModel.
       *
       * @return the maximum price of all products represented by the product hit.
       */
      getMaxPrice(): dw.value.Money;
      /**
       * Returns the minimum price of all products represented by the
       *  product hit. See getRepresentedProducts() for details on
       *  the set of products used for finding the minimum. The method returns
       *  N/A in case no price information can be found.
       *
       *  Note: the method uses price information of the search index and therefore
       *  might return different prices than the ProductPriceModel.
       *
       * @return the minimum price of all products represented by the product hit.
       */
      getMinPrice(): dw.value.Money;
      /**
       * Returns the presentation product of this ProductSearchHit corresponding to the ProductSearchHit type.
       *
       *       HIT_TYPE_SIMPLE -> a simple product
       *       HIT_TYPE_PRODUCT_MASTER -> a variation master product
       *       HIT_TYPE_PRODUCT_SET -> a product set
       *       HIT_TYPE_PRODUCT_BUNDLE -> a product bundle
       *       HIT_TYPE_VARIATION_GROUP ->a variation group
       *
       *
       *  To retrieve the product(s) actually hit by the search use getRepresentedProducts().
       *
       * @return the presentation product of this ProductSearchHit, which is possibly a representative of other related products actually hit by the search.
       */
      getProduct(): dw.catalog.Product;
      /**
       * Returns the ID of the presentation product of this ProductSearchHit corresponding to the ProductSearchHit type.
       *
       *       HIT_TYPE_SIMPLE -> a simple product
       *       HIT_TYPE_PRODUCT_MASTER -> a variation master product
       *       HIT_TYPE_PRODUCT_SET -> a product set
       *       HIT_TYPE_PRODUCT_BUNDLE -> a product bundle
       *       HIT_TYPE_VARIATION_GROUP ->a variation group
       *
       *
       *  To retrieve the ID of the product actually hit by the search use getFirstRepresentedProductID() or getLastRepresentedProductID().
       *
       * @return the ID of the presentation product of this ProductSearchHit, that possibly represents a set of related products actually hit by the search.
       */
      getProductID(): string;
      /**
       * The method returns the actual ID of the product that is conforming the query and is represented by the search hit.
       *  Depending on the hit typ, it returns the ID of:
       *
       *       HIT_TYPE_SIMPLE -> a simple product
       *       HIT_TYPE_PRODUCT_MASTER -> a variation product
       *       HIT_TYPE_PRODUCT_SET -> a product part of set
       *       HIT_TYPE_PRODUCT_BUNDLE -> a product part of a bundle
       *       HIT_TYPE_VARIATION_GROUP ->a variation product
       *
       *
       *  If the method returns multiple products, the product with the highest
       *  sort rank is returned first, and the product with the lowest sort rank is
       *  returned last. The product sort rank depends on the sorting conditions
       *  used for the search query.
       *
       * @return a sorted list of products represented by the wrapped product.
       */
      getRepresentedProductIDs(): dw.util.List<string>;
      /**
       * The method returns the actual product that is conforming the query and is represented by the search hit.
       *  Depending on the hit typ, getRepresentedProducts() returns:
       *
       *       HIT_TYPE_SIMPLE -> a simple product
       *       HIT_TYPE_PRODUCT_MASTER -> a variation product
       *       HIT_TYPE_PRODUCT_SET -> a product part of set
       *       HIT_TYPE_PRODUCT_BUNDLE -> a product part of a bundle
       *       HIT_TYPE_VARIATION_GROUP ->a variation product
       *
       *
       *  If the method returns multiple products, the product with the highest
       *  sort rank is returned first, and the product with the lowest sort rank is
       *  returned last. The product sort rank depends on the sorting conditions
       *  used for the search query.
       *
       * @return a sorted list of products represented by the wrapped product.
       */
      getRepresentedProducts(): dw.util.List<dw.catalog.Product>;
      /**
       * This method is only applicable if this ProductSearchHit represents a
       *  product variation (see getRepresentedProducts). It returns the
       *  distinct value set for the specified variation attribute for all variants
       *  represented by this ProductSearchHit. The values are returned in the same
       *  order as they are defined for the variation.
       *
       *  This method will accept a ProductVariationAttribute parameter or a String
       *  which is the ID of a variation attribute. If any other object type is
       *  passed, or null is passed, an exception will be thrown. If this
       *  ProductSearchHit does not represent a product variation, or the passed
       *  variation attribute is not associated with this product, the method
       *  returns an empty list.
       * @param va the product variation attribute, specified as either a ProductVariationAttribute or a String which is the ID of a variation attribute associated with this product.
       * @return a list containing all distinct ProductVariationAttributeValues.
       */
      getRepresentedVariationValues(
        va: any
      ): dw.util.List<dw.catalog.ProductVariationAttributeValue>;
      /**
       * Convenience method to check whether this ProductSearchHit represents
       *  multiple products (see getRepresentedProducts()) that have
       *  different prices.
       *
       * @return true if the represented products form a price range false otherwise.
       */
      isPriceRange(): boolean;
    }

    /**
     * The class is the central interface to a product search result and a product
     *  search refinement. It also provides utility methods to generate a search URL.
     */
    class ProductSearchModel extends dw.catalog.SearchModel {
      /**
       * URL Parameter for the category ID
       */
      static readonly CATEGORYID_PARAMETER = "cgid";
      /**
       * The maximum number of product IDs that can be passed to setProductIDs(List)
       */
      static readonly MAXIMUM_PRODUCT_IDS = 30;
      /**
       * URL Parameter for the maximum price
       */
      static readonly PRICE_MAX_PARAMETER = "pmax";
      /**
       * URL Parameter for the minimum price
       */
      static readonly PRICE_MIN_PARAMETER = "pmin";
      /**
       * URL Parameter for the product ID
       */
      static readonly PRODUCTID_PARAMETER = "pid";
      /**
       * constant indicating that all related products should be returned for the next product search by promotion ID
       */
      static readonly PROMOTION_PRODUCT_TYPE_ALL = "all";
      /**
       * constant indicating that only bonus products should be returned for the next product search by promotion ID. This
       *  constant should be set using setPromotionProductType(String) when using the search model to find the
       *  available list of bonus products for a Choice of Bonus Product (Rule) promotion, along with
       *  setPromotionID(String).
       */
      static readonly PROMOTION_PRODUCT_TYPE_BONUS = "bonus";
      /**
       * constant indicating that only discounted products should be returned for the next product search by promotion ID
       */
      static readonly PROMOTION_PRODUCT_TYPE_DISCOUNTED = "discounted";
      /**
       * URL Parameter for the promotion product type
       */
      static readonly PROMOTION_PRODUCT_TYPE_PARAMETER = "pmpt";
      /**
       * constant indicating that only qualifying products should be returned for the next product search by promotion ID
       */
      static readonly PROMOTION_PRODUCT_TYPE_QUALIFYING = "qualifying";
      /**
       * URL Parameter for the promotion ID
       */
      static readonly PROMOTIONID_PARAMETER = "pmid";
      /**
       * URL Parameter prefix for a refinement name
       */
      static readonly REFINE_NAME_PARAMETER_PREFIX = "prefn";
      /**
       * URL Parameter prefix for a refinement value
       */
      static readonly REFINE_VALUE_PARAMETER_PREFIX = "prefv";
      /**
       * URL Parameter prefix for a refinement value
       */
      static readonly SORT_BY_PARAMETER_PREFIX = "psortb";
      /**
       * URL Parameter prefix for a refinement value
       */
      static readonly SORT_DIRECTION_PARAMETER_PREFIX = "psortd";
      /**
       * URL Parameter prefix for a sorting option
       */
      static readonly SORTING_OPTION_PARAMETER = "sopt";
      /**
       * URL Parameter prefix for a sorting rule
       */
      static readonly SORTING_RULE_PARAMETER = "srule";

      /**
       * The category object for the category id specified in the query.
       *  If a category with that id doesn't exist or if the category is offline
       *  this method returns null.
       */
      readonly category: dw.catalog.Category;
      /**
       * The category id that was specified in the search query.
       */
      categoryID: string;
      /**
       * The method returns true, if this is a pure search for a category. The
       *  method checks, that a category ID is specified and no search phrase is
       *  specified.
       */
      readonly categorySearch: boolean;
      /**
       * The deepest common category of all products in the search result.
       *  In case of an empty search result the method returns the root category.
       */
      readonly deepestCommonCategory: dw.catalog.Category;
      /**
       * The sorting rule used to order the products in the results of this query,
       *  or null if no search has been executed yet.
       *
       *  In contrast to getSortingRule(), this method respects explicit sorting rules and sorting options and rules determined implicitly
       *  based on the refinement category, keyword sorting rule assignment, etc.
       */
      readonly effectiveSortingRule: dw.catalog.SortingRule;
      /**
       * Get the flag indicating whether unorderable products should be excluded
       *  when the next call to getProducts() is made. If this value has not been
       *  previously set, then the value returned will be based on the value of the
       *  search preference.
       */
      orderableProductsOnly: boolean;
      /**
       * All page meta tags, defined for this instance for which content can be generated.
       *
       *  The meta tag content is generated based on the product listing page meta tag context and rules.
       *  The rules are obtained from the current category context or inherited from the parent category,
       *  up to the root category.
       */
      readonly pageMetaTags: Array<dw.web.PageMetaTag>;
      /**
       * The method indicates if the search result is ordered by a personalized sorting rule.
       */
      readonly personalizedSort: boolean;
      /**
       * The maximum price by which the search result is refined.
       */
      priceMax: number;
      /**
       * The minimum price by which the search result is refined.
       */
      priceMin: number;
      /**
       * The product id that was specified in the search query.
       */
      productID: string;
      /**
       * A list of product IDs that were specified in the search query or an empty list if no product ID set.
       */
      productIDs: dw.util.List<string>;
      /**
       * All products in the search result.
       *  Note that products that were removed or went offline since the last index
       *  update are not included in the returned set.
       */
      readonly products: dw.util.Iterator<dw.catalog.Product>;
      /**
       * The product search hits in the search result.
       *  Note that method does also return search hits representing products that
       *  were removed or went offline since the last index update, i.e. you must
       *  implement appropriate checks before accessing the product related to the
       *  search hit instance (see ProductSearchHit.getProduct)
       */
      readonly productSearchHits: dw.util.Iterator<dw.catalog.ProductSearchHit>;
      /**
       * The promotion id that was specified in the search query or null if no promotion id set. If multiple
       *  promotion id's specified the method returns only the first id. See setPromotionIDs(List) and
       *  getPromotionIDs().
       */
      promotionID: string;
      /**
       * A list of promotion id's that were specified in the search query or an empty list if no promotion id set.
       */
      promotionIDs: dw.util.List<string>;
      /**
       * The promotion product type specified in the search query.
       */
      promotionProductType: string;
      /**
       * Get the flag that determines if the category search will
       *  be recursive.
       */
      recursiveCategorySearch: boolean;
      /**
       * The method returns true, if the search is refined by a category.
       *  The method checks, that a category ID is specified.
       */
      readonly refinedByCategory: boolean;
      /**
       * Identifies if this search has been refined by price.
       */
      readonly refinedByPrice: boolean;
      /**
       * Identifies if this search has been refined by promotion.
       */
      readonly refinedByPromotion: boolean;
      /**
       * Identifies if this is a category search and is refined with further
       *  criteria, like a brand refinement or an attribute refinement.
       */
      readonly refinedCategorySearch: boolean;
      /**
       * The category used to determine possible refinements for the search.
       *  If an explicit category was set for this purpose using setRefinementCategory(Category), it is returned.
       *  Otherwise, the deepest common category of all search results will be returned.
       */
      refinementCategory: dw.catalog.Category;
      /**
       * The ProductSearchRefinements associated with this search and filtered by session currency.
       *  If an explicit category was set for this purpose using setRefinementCategory(Category), it will be used to determine the refinements.
       *  Otherwise, the refinements are determined based on the deepest common category of all products in the search result.
       *  Hint: If you want to use the same refinements for all searches, consider defining them in one category (usually root) and using setRefinementCategory(Category) to avoid unnecessary calculation of the deepest common category.
       */
      readonly refinements: dw.catalog.ProductSearchRefinements;
      /**
       * This method returns the URL of the endpoint where the merchants should upload their image for visual search.
       */
      readonly searchableImageUploadURL: string;
      /**
       * Returns search phrase suggestions for the current search phrase.
       *  Search phrase suggestions may contain alternative search phrases as well
       *  as lists of corrected and completed search terms.
       */
      readonly searchPhraseSuggestions: dw.suggest.SearchPhraseSuggestions;
      /**
       * The sorting rule explicitly set on this model to be used
       *  to order the products in the results of this query, or null
       *  if no rule has been explicitly set.
       *
       *  This method does not return the sorting rule that will be used implicitly
       *  based on the context of the search, such as the refinement category.
       */
      sortingRule: dw.catalog.SortingRule;
      /**
       * The suggested search phrase with the highest accuracy provided
       *  for the current search phrase.
       */
      readonly suggestedSearchPhrase: string;
      /**
       * A list with up to 5 suggested search phrases provided for the
       *  current search phrase. It is possible that less than 5 suggestions
       *  or even no suggestions are returned.
       */
      readonly suggestedSearchPhrases: dw.util.List<dw.suggest.SuggestedPhrase>;
      /**
       * The method indicates if no-hits search should be tracked for predictive intelligence use.
       */
      readonly trackingEmptySearchesEnabled: boolean;
      /**
       * The method returns true, if this is a visual search. The
       *  method checks that a image UUID is specified.
       */
      readonly visualSearch: boolean;

      /**
       * Constructs a new ProductSearchModel.
       *
       */
      constructor();

      /**
       * Set the only search hit types to be included from the search. Values accepted are the 'hit type' constants
       *  exposed in the ProductSearchHit class. Overwrites any hit type refinements set from prior calls to
       *  addHitTypeRefinement(String...) or excludeHitType(String...).
       * @param types to be included.
       */
      addHitTypeRefinement(...types: string[]): void;
      /**
       * Set the search hit types to be excluded from the search. Values accepted are the 'hit type' constants exposed in
       *  the ProductSearchHit class. Overwrites any hit type refinements set from prior calls to
       *  addHitTypeRefinement(String...) or excludeHitType(String...).
       * @param types to be excluded.
       */
      excludeHitType(...types: string[]): void;
      /**
       * Returns the category object for the category id specified in the query.
       *  If a category with that id doesn't exist or if the category is offline
       *  this method returns null.
       *
       * @return the category object for the category id specified in the query.
       */
      getCategory(): dw.catalog.Category;
      /**
       * Returns the category id that was specified in the search query.
       *
       * @return the category id that was specified in the search query.
       */
      getCategoryID(): string;
      /**
       * Returns the deepest common category of all products in the search result.
       *  In case of an empty search result the method returns the root category.
       *
       * @return the deepest common category of all products in the search result of this search model or root for an empty search result.
       */
      getDeepestCommonCategory(): dw.catalog.Category;
      /**
       * Returns the sorting rule used to order the products in the results of this query,
       *  or null if no search has been executed yet.
       *
       *  In contrast to getSortingRule(), this method respects explicit sorting rules and sorting options and rules determined implicitly
       *  based on the refinement category, keyword sorting rule assignment, etc.
       *
       * @return a SortingRule or null.
       */
      getEffectiveSortingRule(): dw.catalog.SortingRule;
      /**
       * Get the flag indicating whether unorderable products should be excluded
       *  when the next call to getProducts() is made. If this value has not been
       *  previously set, then the value returned will be based on the value of the
       *  search preference.
       *
       * @return true if unorderable products should be excluded from product search results, false otherwise.
       */
      getOrderableProductsOnly(): boolean;
      /**
       * Returns the page meta tag for the specified id.
       *
       *  The meta tag content is generated based on the product listing page meta tag context and rule.
       *  The rule is obtained from the current category context or inherited from the parent category,
       *  up to the root category.
       *
       *  Null will be returned if the meta tag is undefined on the current instance, or if no rule can be found for the
       *  current context, or if the rule resolves to an empty string.
       * @param id the ID to get the page meta tag for
       * @return page meta tag containing content generated based on rules
       */
      getPageMetaTag(id: string): dw.web.PageMetaTag;
      /**
       * Returns all page meta tags, defined for this instance for which content can be generated.
       *
       *  The meta tag content is generated based on the product listing page meta tag context and rules.
       *  The rules are obtained from the current category context or inherited from the parent category,
       *  up to the root category.
       *
       * @return page meta tags defined for this instance, containing content generated based on rules
       */
      getPageMetaTags(): Array<dw.web.PageMetaTag>;
      /**
       * Returns the maximum price by which the search result is refined.
       *
       * @return the maximum price by which the search result is refined.
       */
      getPriceMax(): number;
      /**
       * Returns the minimum price by which the search result is refined.
       *
       * @return the minimum price by which the search result is refined.
       */
      getPriceMin(): number;
      /**
       * Returns the product id that was specified in the search query.
       *
       * @return the product id that was specified in the search.
       */
      getProductID(): string;
      /**
       * Returns a list of product IDs that were specified in the search query or an empty list if no product ID set.
       *
       * @return the list of product IDs that were specified in the search query or an empty list if no product ID set.
       */
      getProductIDs(): dw.util.List<string>;
      /**
       * Returns all products in the search result.
       *  Note that products that were removed or went offline since the last index
       *  update are not included in the returned set.
       *
       * @return Products in search result
       */
      getProducts(): dw.util.Iterator<dw.catalog.Product>;
      /**
       * Returns the underlying ProductSearchHit for a product, or null if no
       *  ProductSearchHit found for this product.
       * @param product the product to find the underlying ProductSearchHit
       * @return the underlying ProductSearchHit for a product, or null if no ProductSearchHit found for this product.
       */
      getProductSearchHit(
        product: dw.catalog.Product
      ): dw.catalog.ProductSearchHit;
      /**
       * Returns the product search hits in the search result.
       *  Note that method does also return search hits representing products that
       *  were removed or went offline since the last index update, i.e. you must
       *  implement appropriate checks before accessing the product related to the
       *  search hit instance (see ProductSearchHit.getProduct)
       *
       * @return Products hits in search result
       */
      getProductSearchHits(): dw.util.Iterator<dw.catalog.ProductSearchHit>;
      /**
       * Returns the promotion id that was specified in the search query or null if no promotion id set. If multiple
       *  promotion id's specified the method returns only the first id. See setPromotionIDs(List) and
       *  getPromotionIDs().
       *
       * @return the promotion id that was specified in the search query or null if no promotion id set.
       */
      getPromotionID(): string;
      /**
       * Returns a list of promotion id's that were specified in the search query or an empty list if no promotion id set.
       *
       * @return the list of promotion id's that was specified in the search query or an empty list if no promotion id set.
       */
      getPromotionIDs(): dw.util.List<string>;
      /**
       * Returns the promotion product type specified in the search query.
       *
       * @return the promotion product type that was specified in the search query.
       */
      getPromotionProductType(): string;
      /**
       * Returns the category used to determine possible refinements for the search.
       *  If an explicit category was set for this purpose using setRefinementCategory(Category), it is returned.
       *  Otherwise, the deepest common category of all search results will be returned.
       *
       * @return the category used to determine refinements.
       */
      getRefinementCategory(): dw.catalog.Category;
      /**
       * Returns the ProductSearchRefinements associated with this search and filtered by session currency.
       *  If an explicit category was set for this purpose using setRefinementCategory(Category), it will be used to determine the refinements.
       *  Otherwise, the refinements are determined based on the deepest common category of all products in the search result.
       *  Hint: If you want to use the same refinements for all searches, consider defining them in one category (usually root) and using setRefinementCategory(Category) to avoid unnecessary calculation of the deepest common category.
       *
       * @return the ProductSearchRefinements associated with this search.
       */
      getRefinements(): dw.catalog.ProductSearchRefinements;
      /**
       * This method returns the URL of the endpoint where the merchants should upload their image for visual search.
       *
       * @return returns the URL where the merchants should upload their image.
       */
      getSearchableImageUploadURL(): string;
      /**
       * Returns search phrase suggestions for the current search phrase.
       *  Search phrase suggestions may contain alternative search phrases as well
       *  as lists of corrected and completed search terms.
       *
       * @return search phrase suggestions for the current search phrase
       */
      getSearchPhraseSuggestions(): dw.suggest.SearchPhraseSuggestions;
      /**
       * Returns the sorting rule explicitly set on this model to be used
       *  to order the products in the results of this query, or null
       *  if no rule has been explicitly set.
       *
       *  This method does not return the sorting rule that will be used implicitly
       *  based on the context of the search, such as the refinement category.
       *
       * @return a SortingRule or null.
       */
      getSortingRule(): dw.catalog.SortingRule;
      /**
       * Returns the suggested search phrase with the highest accuracy provided
       *  for the current search phrase.
       *
       * @return the suggested search phrase.
       */
      getSuggestedSearchPhrase(): string;
      /**
       * Returns a list with up to 5 suggested search phrases provided for the
       *  current search phrase. It is possible that less than 5 suggestions
       *  or even no suggestions are returned.
       *
       * @return a list containing the suggested search phrases.
       */
      getSuggestedSearchPhrases(): dw.util.List<dw.suggest.SuggestedPhrase>;
      /**
       * The method returns true, if this is a pure search for a category. The
       *  method checks, that a category ID is specified and no search phrase is
       *  specified.
       *
       * @return True if this is a category search
       */
      isCategorySearch(): boolean;
      /**
       * The method indicates if the search result is ordered by a personalized sorting rule.
       *
       * @return true if search result is ordered by a personalized sorting rule, otherwise false.
       */
      isPersonalizedSort(): boolean;
      /**
       * Get the flag that determines if the category search will
       *  be recursive.
       *
       * @return true if the category search will be recursive, false otherwise
       */
      isRecursiveCategorySearch(): boolean;
      /**
       * The method returns true, if the search is refined by a category.
       *  The method checks, that a category ID is specified.
       *
       * @return true, if the search is refined by a category, false otherwise.
       */
      isRefinedByCategory(): boolean;
      /**
       * Identifies if this search has been refined by price.
       *
       * @return True if the search is refined by price, false otherwise.
       */
      isRefinedByPrice(): boolean;
      /**
       * Identifies if this search has been refined by the given price range.
       *  Either range parameters may be null to represent open ranges.
       * @param priceMin The lower bound of the price range.
       * @param priceMax The upper bound of the price range.
       * @return True if the search is refinemd on the given price range, false otherwise.
       */
      isRefinedByPriceRange(priceMin: number, priceMax: number): boolean;
      /**
       * Identifies if this search has been refined by promotion.
       *
       * @return True if the search is refined by promotion, false otherwise.
       */
      isRefinedByPromotion(): boolean;
      /**
       * Identifies if this search has been refined by a given promotion.
       * @param promotionID the ID of the promotion to check
       * @return True if the search is refined by the given promotionID, false otherwise.
       */
      isRefinedByPromotion(promotionID: string): boolean;
      /**
       * Identifies if this is a category search and is refined with further
       *  criteria, like a brand refinement or an attribute refinement.
       *
       * @return true if this is a category search and is refined with further criteria, false otherwise.
       */
      isRefinedCategorySearch(): boolean;
      /**
       * The method indicates if no-hits search should be tracked for predictive intelligence use.
       *
       * @return true, if no-hits search should be tracked, otherwise false.
       */
      isTrackingEmptySearchesEnabled(): boolean;
      /**
       * The method returns true, if this is a visual search. The
       *  method checks that a image UUID is specified.
       *
       * @return True if this is a visual search
       */
      isVisualSearch(): boolean;
      /**
       * Execute the search.
       *
       */
      search(): void;
      /**
       * Specifies the category id used for the search query.
       * @param categoryID the category id for the search query.
       */
      setCategoryID(categoryID: string): void;
      /**
       * Set a flag indicating whether no-hits search should be tracked for predictive intelligence use.
       * @param trackingEmptySearches true, no-hits search should be tracked, false, otherwise.
       */
      setEnableTrackingEmptySearches(trackingEmptySearches: boolean): void;
      /**
       * Set a flag indicating whether unorderable products should be excluded
       *  when the next call to getProducts() is made. This method overrides the
       *  default behavior which is controlled by the search preference.
       * @param orderableOnly true if unorderable products should be excluded from product search results, false otherwise.
       */
      setOrderableProductsOnly(orderableOnly: boolean): void;
      /**
       * Sets the maximum price by which the search result is to be refined.
       * @param priceMax sets the maximum price by which the search result is to be refined.
       */
      setPriceMax(priceMax: number): void;
      /**
       * Sets the minimum price by which the search result is to be refined.
       * @param priceMin the minimum price by which the search result is to be refined.
       */
      setPriceMin(priceMin: number): void;
      /**
       * Specifies the product id used for the search query.
       * @param productID the product id for the search query.
       */
      setProductID(productID: string): void;
      /**
       * Specifies multiple product IDs used for the search query. The specified product IDs include, but not limited to,
       *  variant product IDs, product master IDs, variation group IDs, product set IDs, or product bundle IDs. For
       *  example, this API could be used in high-traffic pages where developers need to be able to filter quickly for only
       *  available child products of a specified master product, instead of looping through all variants of a set products
       *  and checking their availabilities. The method supports up to MAXIMUM_PRODUCT_IDS product IDs. If more
       *  than MAXIMUM_PRODUCT_IDS products IDs are passed, the method throws an IllegalArgumentException.
       * @param productIDs the product IDs for the search query.
       */
      setProductIDs(productIDs: dw.util.List<any>): void;
      /**
       * Specifies the promotion id used for the search query.
       * @param promotionID the promotion id for the search query.
       */
      setPromotionID(promotionID: string): void;
      /**
       * Specifies multiple promotion id's used for the search query. The method supports up to 30 promotion id's. If more
       *  than 30 promotion id's used the method throws an IllegalArgumentException.
       * @param promotionIDs the promotion ids for the search query.
       */
      setPromotionIDs(promotionIDs: dw.util.List<any>): void;
      /**
       * Specifies the promotion product type used for the search query. This
       *  value is only relevant for searches by promotion ID.
       * @param promotionProductType The type of product to filter by when searching by promotion ID. Allowed values are PROMOTION_PRODUCT_TYPE_ALL, PROMOTION_PRODUCT_TYPE_BONUS, PROMOTION_PRODUCT_TYPE_QUALIFYING, and PROMOTION_PRODUCT_TYPE_DISCOUNTED. If null is passed, or an invalid value is passed, the search will use PROMOTION_PRODUCT_TYPE_ALL.
       */
      setPromotionProductType(promotionProductType: string): void;
      /**
       * Set a flag to indicate if the search in category should be recursive.
       * @param recurse recurse the category in the search
       */
      setRecursiveCategorySearch(recurse: boolean): void;
      /**
       * Sets an explicit category to be used when determining refinements. If this is not done, they will be determined based on the deepest common category of all search results.
       *  The explicit category must be in the site's storefront catalog, otherwise the method fails with an IllegalArgumentException.
       * @param refinementCategory the category used to determine the applicable refinements.
       */
      setRefinementCategory(refinementCategory: dw.catalog.Category): void;
      /**
       * An image ID can be retrieved by uploading an image with a multipart/form-data POST
       *  request to 'https://api.cquotient.com/v3/image/search/upload/{siteID}'. This method sets product IDs retrieved
       *  from the image ID to the ProductSearchModel. If using setProductIDs(List) in addition to this method,
       *  the ProductSearchModel will take the intersection of these sets of product IDs. If the image ID provided is
       *  invalid or expired, product IDs will not be set onto the product search model.
       * @param imageID the image ID for the visual search query.
       */
      setSearchableImageID(imageID: string): void;
      /**
       * Sets or removes a sorting condition for the specified attribute. Specify
       *  either SORT_DIRECTION_ASCENDING or SORT_DIRECTION_DESCENDING to set a
       *  sorting condition. Specify SORT_DIRECTION_NONE to remove a sorting
       *  condition from the attribute.
       * @param attributeID the attribute ID
       * @param direction SORT_DIRECTION_ASCENDING, SORT_DIRECTION_DESCENDING or SORT_DIRECTION_NONE
       */
      setSortingCondition(attributeID: string, direction: number): void;
      /**
       * Sets the sorting option to be used to order the products in the results of this query.
       *  If a sorting rule is also set, the sorting option is ignored.
       * @param option the SortingOption to use to sort the products
       */
      setSortingOption(option: dw.catalog.SortingOption): void;
      /**
       * Sets the sorting rule to be used to order the products in the
       *  results of this query.  Setting the rule in this way overrides the
       *  default behavior of choosing the sorting rule based on the context of the
       *  search, such as the refinement category.
       * @param rule the SortingRule to use to sort the products
       */
      setSortingRule(rule: dw.catalog.SortingRule): void;
      /**
       * Constructs a URL that you can use to execute a query for a specific
       *  Category.
       *
       *  The generated URL will be an absolute URL which uses the protocol of
       *  the current request.
       * @param action pipeline action, e.g. 'Search-Show'.
       * @param cgid the category ID.
       * @return the new URL.
       */
      static urlForCategory(action: string, cgid: string): dw.web.URL;
      /**
       * Constructs a URL that you can use to execute a query for a specific
       *  Category. The search specific parameters are appended to the provided
       *  URL. The URL is typically generated with one of the URLUtils methods.
       * @param url the URL to use to generate the new URL.
       * @param cgid the category ID.
       * @return the new URL.
       */
      static urlForCategory(url: dw.web.URL, cgid: string): dw.web.URL;
      /**
       * Constructs a URL that you can use to execute a query for a specific
       *  Product. The passed action is used to build an initial url. All search
       *  specific attributes are appended.
       *
       *  The generated URL will be an absolute URL which uses the protocol of
       *  the current request.
       * @param action pipeline action, e.g. 'Search-Show'.
       * @param cgid the category id or null if product is not in category context.
       * @param pid the product id.
       * @return the new URL.
       */
      static urlForProduct(
        action: string,
        cgid: string,
        pid: string
      ): dw.web.URL;
      /**
       * Constructs a URL that you can use to execute a query for a specific
       *  Product. The passed url can be either a full url or just the name for a
       *  pipeline. In the later case a relative URL is created.
       * @param url the URL to use to generate the new URL.
       * @param cgid the category id or null if product is not in category context.
       * @param pid the product id.
       * @return the new URL.
       */
      static urlForProduct(
        url: dw.web.URL,
        cgid: string,
        pid: string
      ): dw.web.URL;
      /**
       * Constructs a URL that you can use to execute a query for a specific
       *  attribute name-value pair.
       *
       *  The generated URL will be an absolute URL which uses the protocol of
       *  the current request.
       * @param action pipeline action, e.g. 'Search-Show'.
       * @param attributeID the attribute ID for the refinement.
       * @param value the attribute value for the refinement.
       * @return the new URL.
       */
      static urlForRefine(
        action: string,
        attributeID: string,
        value: string
      ): dw.web.URL;
      /**
       * Constructs a URL that you can use to execute a query for a specific
       *  attribute name-value pair. The search specific parameters are appended to
       *  the provided URL. The URL is typically generated with one of the URLUtils
       *  methods.
       * @param url the URL to use to generate the new URL.
       * @param attributeID the attribute ID for the refinement.
       * @param value the attribute value for the refinement.
       * @return the new URL.
       */
      static urlForRefine(
        url: dw.web.URL,
        attributeID: string,
        value: string
      ): dw.web.URL;
      /**
       * Constructs a URL that you can use to re-execute the query with a
       *  category refinement.
       *
       *  The generated URL will be an absolute URL which uses the protocol of
       *  the current request.
       * @param action the pipeline action, e.g. 'Search-Show'
       * @param refineCategoryID the ID of the category.
       * @return the new URL.
       */
      urlRefineCategory(action: string, refineCategoryID: string): dw.web.URL;
      /**
       * Constructs a URL that you can use to re-execute the query with a
       *  category refinement. The search specific parameters are appended to the
       *  provided URL. The URL is typically generated with one of the URLUtils
       *  methods.
       * @param url the existing URL to use to create the new URL.
       * @param refineCategoryID the ID of the category.
       * @return the new URL.
       */
      urlRefineCategory(url: dw.web.URL, refineCategoryID: string): dw.web.URL;
      /**
       * Constructs a URL that you can use to re-execute the query with an
       *  additional price filter.
       *
       *  The generated URL will be an absolute URL which uses the protocol of
       *  the current request.
       * @param action the pipeline action, e.g. 'Search-Show'.
       * @param min the minimum price.
       * @param max the maximum price.
       * @return the new URL.
       */
      urlRefinePrice(action: string, min: number, max: number): dw.web.URL;
      /**
       * Constructs a URL that you can use to re-execute the query with an
       *  additional price filter. The search specific parameters are appended to
       *  the provided URL. The URL is typically generated with one of the URLUtils
       *  methods.
       * @param url the URL to use to generate the new URL.
       * @param min the minimum price.
       * @param max the maximum price.
       * @return the new URL.
       */
      urlRefinePrice(url: dw.web.URL, min: number, max: number): dw.web.URL;
      /**
       * Constructs a URL that you can use to re-execute the query with a promotion refinement. The search specific
       *  parameters are appended to the provided URL. The URL is typically generated with one of the URLUtils methods.
       * @param url the existing URL to use to create the new URL.
       * @param refinePromotionID the ID of the promotion.
       * @return the new URL.
       */
      urlRefinePromotion(
        url: dw.web.URL,
        refinePromotionID: string
      ): dw.web.URL;
      /**
       * Constructs a URL that you can use to re-execute the query with a promotion refinement. The generated URL will be
       *  an absolute URL which uses the protocol of the current request.
       * @param action the pipeline action, e.g. 'Search-Show'
       * @param refinePromotionID the ID of the promotion.
       * @return the new URL.
       */
      urlRefinePromotion(action: string, refinePromotionID: string): dw.web.URL;
      /**
       * Constructs a URL that you can use to re-execute the query without any
       *  category refinement.
       *
       *  The generated URL will be an absolute URL which uses the protocol of
       *  the current request.
       * @param action the pipeline action, e.g. 'Search-Show'.
       * @return the new URL.
       */
      urlRelaxCategory(action: string): dw.web.URL;
      /**
       * Constructs a URL that you can use to re-execute the query without any
       *  category refinement. The search specific parameters are appended to the
       *  provided URL. The URL is typically generated with one of the URLUtils
       *  methods.
       * @param url the existing URL to use to create the new URL.
       * @return the new URL.
       */
      urlRelaxCategory(url: dw.web.URL): dw.web.URL;
      /**
       * Constructs a URL that you can use to re-execute the query with no price
       *  filter.
       *
       *  The generated URL will be an absolute URL which uses the protocol of
       *  the current request.
       * @param action the pipeline action, e.g. 'Search-Show'
       * @return the new URL.
       */
      urlRelaxPrice(action: string): dw.web.URL;
      /**
       * Constructs a URL that you can use to would re-execute the query with no
       *  price filter. The search specific parameters are appended to the provided
       *  URL. The URL is typically generated with one of the URLUtils methods.
       * @param url the existing URL to use to create the new URL.
       * @return the new URL.
       */
      urlRelaxPrice(url: dw.web.URL): dw.web.URL;
      /**
       * Constructs a URL that you can use to re-execute the query without any promotion refinement. The search specific
       *  parameters are appended to the provided URL. The URL is typically generated with one of the URLUtils methods.
       * @param url the existing URL to use to create the new URL.
       * @return the new URL.
       */
      urlRelaxPromotion(url: dw.web.URL): dw.web.URL;
      /**
       * Constructs a URL that you can use to re-execute the query without any promotion refinement. The generated URL
       *  will be an absolute URL which uses the protocol of the current request.
       * @param action the pipeline action, e.g. 'Search-Show'.
       * @return the new URL.
       */
      urlRelaxPromotion(action: string): dw.web.URL;
      /**
       * Constructs a URL that you can use to re-execute the query but sort the
       *  results by the given storefront sorting option.
       *
       *  The generated URL will be an absolute URL which uses the protocol of the
       *  current request.
       * @param action the pipeline action, e.g. 'Search-Show'.
       * @param option sorting option
       * @return the new URL.
       */
      urlSortingOption(
        action: string,
        option: dw.catalog.SortingOption
      ): dw.web.URL;
      /**
       * Constructs a URL that you can use to re-execute the query but sort
       *  the results by the given storefront sorting option. The search specific parameters are
       *  appended to the provided URL. The URL is typically generated with one of
       *  the URLUtils methods.
       * @param url the existing URL to use to create the new URL.
       * @param option sorting option
       * @return the new URL.
       */
      urlSortingOption(
        url: dw.web.URL,
        option: dw.catalog.SortingOption
      ): dw.web.URL;
      /**
       * Constructs a URL that you can use to re-execute the query but sort the
       *  results by the given rule.
       *
       *  The generated URL will be an absolute URL which uses the protocol of the
       *  current request.
       * @param action the pipeline action, e.g. 'Search-Show'.
       * @param rule sorting rule
       * @return the new URL.
       */
      urlSortingRule(action: string, rule: dw.catalog.SortingRule): dw.web.URL;
      /**
       * Constructs a URL that you can use to re-execute the query but sort
       *  the results by the given rule. The search specific parameters are
       *  appended to the provided URL. The URL is typically generated with one of
       *  the URLUtils methods.
       * @param url the existing URL to use to create the new URL.
       * @param rule sorting rule
       * @return the new URL.
       */
      urlSortingRule(url: dw.web.URL, rule: dw.catalog.SortingRule): dw.web.URL;
    }

    /**
     * This class provides an interface to refinement options for the product search.
     */
    class ProductSearchRefinementDefinition extends dw.catalog
      .SearchRefinementDefinition {
      /**
       * Identifies if this is a category refinement.
       */
      readonly categoryRefinement: boolean;
      /**
       * Identifies if this is a price refinement.
       */
      readonly priceRefinement: boolean;
      /**
       * Identifies if this is a promotion refinement.
       */
      readonly promotionRefinement: boolean;

      /**
       * Identifies if this is a category refinement.
       *
       * @return true if this is a category refinement, false otherwise.
       */
      isCategoryRefinement(): boolean;
      /**
       * Identifies if this is a price refinement.
       *
       * @return true if this is a price refinement, false otherwise.
       */
      isPriceRefinement(): boolean;
      /**
       * Identifies if this is a promotion refinement.
       *
       * @return true if this is a promotion refinement, false otherwise.
       */
      isPromotionRefinement(): boolean;
    }

    /**
     * Represents the value of a product search refinement.
     */
    class ProductSearchRefinementValue extends dw.catalog
      .SearchRefinementValue {
      /**
       * The lower bound for price refinements.  For example, 50.00
       *  for a range of $50.00 - $99.99.
       */
      readonly valueFrom: number;
      /**
       * The upper bound for price refinements.  For example, 99.99
       *  for a range of $50.00 - $99.99.
       */
      readonly valueTo: number;

      /**
       * Returns the lower bound for price refinements.  For example, 50.00
       *  for a range of $50.00 - $99.99.
       *
       * @return the lower bound for price refinements.
       */
      getValueFrom(): number;
      /**
       * Returns the upper bound for price refinements.  For example, 99.99
       *  for a range of $50.00 - $99.99.
       *
       * @return the upper bound for price refinements.
       */
      getValueTo(): number;
    }

    /**
     * This class provides an interface to refinement options for the product
     *  search. In a typical usage, the client application UI displays the search
     *  refinements along with the search results and allows customers to &quot;refine&quot;
     *  the results (i.e. limit the results that are shown) by specifying additional
     *  product criteria, or &quot;relax&quot; (i.e. broaden) the results after previously
     *  refining. The four types of product search refinements are:
     *
     *  <ul>
     *  <li><b>Refine By Category:</b> Limit the products to those assigned to
     *  specific child/ancestor categories of the search category.</li>
     *  <li><b>Refine By Attribute:</b> Limit the products to those with specific
     *  values for a given attribute. Values may be grouped into &quot;buckets&quot; so that a
     *  given set of values are represented as a single refinement option.</li>
     *  <li><b>Refine By Price:</b> Limit the products to those whose prices fall in
     *  a specific range.</li>
     *  <li><b>Refine By Promotion:</b> Limit the products to those which are related
     *  to a specific promotion.</li>
     *  </ul>
     *
     *  Rendering a product search refinement UI typically begins with iterating the
     *  refinement definitions for the search result. Call
     *  <a href="class_dw_catalog_SearchRefinements.html#dw_catalog_SearchRefinements_getRefinementDefinitions_DetailAnchor">SearchRefinements.getRefinementDefinitions()</a> or
     *  <a href="class_dw_catalog_SearchRefinements.html#dw_catalog_SearchRefinements_getAllRefinementDefinitions_DetailAnchor">SearchRefinements.getAllRefinementDefinitions()</a> to
     *  retrieve the appropriate collection of refinement definitions. For each
     *  definition, display the available refinement values by calling
     *  <a href="class_dw_catalog_ProductSearchRefinements.html#dw_catalog_ProductSearchRefinements_getAllRefinementValues_ProductSearchRefinementDefinition_DetailAnchor">getAllRefinementValues(ProductSearchRefinementDefinition)</a>. Depending
     *  on the type of the refinement definition, the application must use slightly
     *  different logic to display the refinement widgets. For all 4 types, methods
     *  in <a href="class_dw_catalog_ProductSearchModel.html">ProductSearchModel</a> are used to generate URLs to render
     *  hyperlinks in the UI. When clicked, these links trigger a call to the Search
     *  pipelet which in turn applies the appropriate filters to the native search
     *  result.
     */
    class ProductSearchRefinements extends dw.catalog.SearchRefinements {
      /**
       * The appropriate category refinement definition based on the search
       *  result. The category refinement definition returned will be the first that
       *  can be found traversing the category tree upward starting at the deepest
       *  common category of the search result.
       */
      readonly categoryRefinementDefinition: dw.catalog.ProductSearchRefinementDefinition;
      /**
       * The appropriate price refinement definition based on the search
       *  result. The price refinement definition returned will be the first that
       *  can be found traversing the category tree upward starting at the deepest
       *  common category of the search result.
       */
      readonly priceRefinementDefinition: dw.catalog.ProductSearchRefinementDefinition;
      /**
       * The appropriate promotion refinement definition based on the search
       *  result. The promotion refinement definition returned will be the first that
       *  can be found traversing the category tree upward starting at the deepest
       *  common category of the search result.
       */
      readonly promotionRefinementDefinition: dw.catalog.ProductSearchRefinementDefinition;

      /**
       * Returns the appropriate category refinement definition based on the search
       *  result. The category refinement definition returned will be the first that
       *  can be found traversing the category tree upward starting at the deepest
       *  common category of the search result.
       *
       * @return The category refinement definition or null if none can be found.
       */
      getCategoryRefinementDefinition(): dw.catalog.ProductSearchRefinementDefinition;
      /**
       * Returns category refinement values based on the current search result
       *  filtered such that only category refinements representing children of the
       *  given category are present. If no category is given, the method uses the
       *  catalog's root category. The refinement value product counts represent
       *  all hits contained in the catalog tree starting at the corresponding
       *  child category.
       * @param category The category to return child category refinement values for.
       * @return The refinement values for all child categories of the given category.
       */
      getNextLevelCategoryRefinementValues(
        category: dw.catalog.Category
      ): dw.util.Collection<dw.catalog.ProductSearchRefinementValue>;
      /**
       * Returns the appropriate price refinement definition based on the search
       *  result. The price refinement definition returned will be the first that
       *  can be found traversing the category tree upward starting at the deepest
       *  common category of the search result.
       *
       * @return The price refinement definition or null if none can be found.
       */
      getPriceRefinementDefinition(): dw.catalog.ProductSearchRefinementDefinition;
      /**
       * Returns the appropriate promotion refinement definition based on the search
       *  result. The promotion refinement definition returned will be the first that
       *  can be found traversing the category tree upward starting at the deepest
       *  common category of the search result.
       *
       * @return The promotion refinement definition or null if none can be found.
       */
      getPromotionRefinementDefinition(): dw.catalog.ProductSearchRefinementDefinition;
      /**
       * Returns the refinement value (incl. product hit count) for the given
       *  refinement definition and the given (selected) value.
       * @param definition The definition to return the refinement for.
       * @param value The value to return the refinement for.
       * @return The refinement value.
       */
      getRefinementValue(
        definition: dw.catalog.ProductSearchRefinementDefinition,
        value: string
      ): dw.catalog.ProductSearchRefinementValue;
      /**
       * Returns the refinement value (incl. product hit count) for the given
       *  refinement attribute and the given (selected) value.
       * @param name The name of the refinement attribute.
       * @param value The value to return the refinement for.
       * @return The refinement value.
       */
      getRefinementValue(
        name: string,
        value: string
      ): dw.catalog.ProductSearchRefinementValue;
    }

    /**
     * Represents a product variation attribute
     */
    class ProductVariationAttribute {
      /**
       * The ID of the product attribute defintion related to
       *  this variation attribute.  This ID matches the
       *  value returned by ObjectAttributeDefinition.getID()
       *  for the appropriate product attribute definition.
       *  This ID is generally different than the ID returned by
       *  getID().
       */
      readonly attributeID: string;
      /**
       * The display name for the product variation attribute, which can be used in the
       *  user interface.
       */
      readonly displayName: string;
      /**
       * The ID of the product variation attribute.
       */
      readonly ID: string;

      /**
       * Returns the ID of the product attribute defintion related to
       *  this variation attribute.  This ID matches the
       *  value returned by ObjectAttributeDefinition.getID()
       *  for the appropriate product attribute definition.
       *  This ID is generally different than the ID returned by
       *  getID().
       *
       * @return the ID of the product attribute definition of this variation attribute.
       */
      getAttributeID(): string;
      /**
       * Returns the display name for the product variation attribute, which can be used in the
       *  user interface.
       *
       * @return the display name for the product variation attribute, which can be used in the user interface.
       */
      getDisplayName(): string;
      /**
       * Returns the ID of the product variation attribute.
       *
       * @return the ID of the product variation attribute.
       */
      getID(): string;
    }

    /**
     * Represents a product variation attribute
     */
    class ProductVariationAttributeValue {
      /**
       * The description of the product variation attribute value in the current locale.
       */
      readonly description: string;
      /**
       * The display value for the product variation attribute value, which can be used in the
       *  user interface.
       */
      readonly displayValue: string;
      /**
       * The ID of the product variation attribute value.
       */
      readonly ID: string;
      /**
       * The value for the product variation attribute value.
       */
      readonly value: any;

      /**
       * Returns true if the specified object is equal to this object.
       * @param obj the object to test.
       * @return true if the specified object is equal to this object.
       */
      equals(obj: any): boolean;
      /**
       * Returns the description of the product variation attribute value in the current locale.
       *
       * @return the description of the product variation attribute value in the current locale, or null if it wasn't found.
       */
      getDescription(): string;
      /**
       * Returns the display value for the product variation attribute value, which can be used in the
       *  user interface.
       *
       * @return the display value for the product variation attribute value, which can be used in the user interface.
       */
      getDisplayValue(): string;
      /**
       * Returns the ID of the product variation attribute value.
       *
       * @return the ID of the product variation attribute value.
       */
      getID(): string;
      /**
       * The method calls getImages(String) and returns the image at
       *  the specific index.
       *
       *  If images are defined for this view type and variant, but not for
       *  specified index, the method returns null.
       *
       *  If no images are defined for this variant and specified view type, the
       *  image at the specified index of the master product images is returned. If
       *  no master product image for specified index is defined, the method
       *  returns null.
       * @param viewtype the view type annotated to image
       * @param index the index number of the image within image list
       * @return the MediaFile or null
       */
      getImage(viewtype: string, index: number): dw.content.MediaFile;
      /**
       * The method calls getImages(String) and returns the first image
       *  of the list. The method is specifically built for handling color
       *  swatches in an apparel site.
       *
       *  If no images are defined for this variant and specified view type, then
       *  the first image of the master product images for that view type is
       *  returned. If no master product images are defined, the method returns
       *  null.
       * @param viewtype the view type annotated to image
       * @return the MediaFile or null
       */
      getImage(viewtype: string): dw.content.MediaFile;
      /**
       * Returns all images that match the given view type and have the variant
       *  value of this value, which is typically the 'color' attribute. The images
       *  are returned in the order of their index number ascending.
       *
       *  If no images are defined for this variant, then the images of the master
       *  for that view type are returned.
       * @param viewtype the view type annotated to images
       * @return a list of MediaFile objects, possibly empty
       */
      getImages(viewtype: string): dw.util.List<dw.content.MediaFile>;
      /**
       * Returns the value for the product variation attribute value.
       *
       * @return the value for the product variation attribute value.
       */
      getValue(): any;
      /**
       * Calculates the hash code for a product variation attribute value.
       *
       * @return the hash code for a product variation attribute value.
       */
      hashCode(): number;
    }

    /**
     * Class representing the complete variation information for a master product in
     *  the system. An instance of this class provides methods to access the
     *  following information:
     *
     *  <ul>
     *  <li>The variation attributes of the master product (e.g. size and color). Use
     *  <a href="class_dw_catalog_ProductVariationModel.html#dw_catalog_ProductVariationModel_getProductVariationAttributes_DetailAnchor">getProductVariationAttributes()</a>.</li>
     *  <li>The variation attribute values (e.g. size=Small, Medium, Large and
     *  color=Red, Blue). Use <a href="class_dw_catalog_ProductVariationModel.html#dw_catalog_ProductVariationModel_getAllValues_ProductVariationAttribute_DetailAnchor">getAllValues(ProductVariationAttribute)</a>.</li>
     *  <li>The variation groups which may represent a subset of variants by defining a
     *  subset of the variation attribute values (e.g. color=Red, size=empty). Use
     *  <a href="class_dw_catalog_ProductVariationModel.html#dw_catalog_ProductVariationModel_getVariationGroups_DetailAnchor">getVariationGroups()</a>.</li>
     *  <li>The variants themselves (e.g. the products representing Small Red, Large
     *  Red, Small Blue, Large Blue, etc). Use <a href="class_dw_catalog_ProductVariationModel.html#dw_catalog_ProductVariationModel_getVariants_DetailAnchor">getVariants()</a>.</li>
     *  <li>The variation attribute values of those variants. Use
     *  <a href="class_dw_catalog_ProductVariationModel.html#dw_catalog_ProductVariationModel_getVariationValue_Product_ProductVariationAttribute_DetailAnchor">getVariationValue(Product, ProductVariationAttribute)</a>.</li>
     *  </ul>
     *
     *  This model only considers variants which are complete (i.e. the variant has a
     *  value for each variation attribute), and currently online. Incomplete or
     *  offline variants will not be returned by any method that returns Variants,
     *  and their attribute values will not be considered in any method that returns
     *  values.
     *  <p>
     *  In addition to providing access to this meta information,
     *  ProductVariationModel maintains a collection of selected variation attribute
     *  values, representing the selections that a customer makes in the storefront.
     *  If this model was constructed for a master product, then none of the
     *  attributes will have pre-selected values. If this model was constructed for a
     *  variant product, then all the attribute values of that variant will be
     *  pre-selected.
     *  </p><p>
     *  It is possible to query the current selections by calling
     *  <a href="class_dw_catalog_ProductVariationModel.html#dw_catalog_ProductVariationModel_getSelectedValue_ProductVariationAttribute_DetailAnchor">getSelectedValue(ProductVariationAttribute)</a> or
     *  <a href="class_dw_catalog_ProductVariationModel.html#dw_catalog_ProductVariationModel_isSelectedAttributeValue_ProductVariationAttribute_ProductVariationAttributeValue_DetailAnchor">isSelectedAttributeValue(ProductVariationAttribute, ProductVariationAttributeValue)</a>.
     *  </p><p>
     *  The method <a href="class_dw_catalog_ProductVariationModel.html#dw_catalog_ProductVariationModel_setSelectedAttributeValue_String_String_DetailAnchor">setSelectedAttributeValue(String, String)</a> can be used to modify
     *  the selected values. Depending on the product type, it&apos;s possible to select or modify
     *  variation attribute values:
     *
     *  </p><ul>
     *      <li>If this model was constructed for a master product, it&apos;s possible to select and modify all variation attributes.</li>
     *      <li>If this model was constructed for a variation group, it&apos;s possible to select and modify all variation attributes that are not defined by the variation group.</li>
     *      <li>If this model was constructed for a variation product, it&apos;s not possible to select or modify any of the variation attributes.</li>
     *  </ul>
     *
     *  <p>
     *  Furthermore, the model provides helper methods to generate URLs
     *  for selecting and unselecting variation attribute values. See those methods
     *  for details.
     *  </p><p>
     *  If this model was constructed for a product that is neither a
     *  master nor a variant, then none of the methods will return useful values at
     *  all.
     *  </p><p>
     *  The methods in this class which access the currently selected variation
     *  attribute values can be used on product detail pages to render information
     *  about which combinations are available or unavailable. The methods
     *  <a href="class_dw_catalog_ProductVariationModel.html#dw_catalog_ProductVariationModel_getFilteredValues_ProductVariationAttribute_DetailAnchor">getFilteredValues(ProductVariationAttribute)</a> and
     *  <a href="class_dw_catalog_ProductVariationModel.html#dw_catalog_ProductVariationModel_hasOrderableVariants_ProductVariationAttribute_ProductVariationAttributeValue_DetailAnchor">hasOrderableVariants(ProductVariationAttribute, ProductVariationAttributeValue)</a>
     *  can be used to determine this type of situation and render the appropriate
     *  message in the storefront.
     *  </p><p>
     *  NOTE: Several methods in this class have a version taking a
     *  <a href="class_dw_catalog_ProductVariationAttribute.html">ProductVariationAttribute</a> parameter, and another
     *  deprecated version accepting a <a href="class_dw_object_ObjectAttributeDefinition.html">ObjectAttributeDefinition</a>
     *  parameter instead. The former should be strictly favored. The latter are
     *  historical leftovers from when object attributes were used directly as the
     *  basis for variation, and the value lists were stored directly on the
     *  ObjectAttributeDefinition. Every ProductVariationAttribute corresponds with
     *  exactly one ObjectAttributeDefinition, but values are now stored on the
     *  ProductVariationAttribute and not the ObjectAttributeDefinition.</p>
     */
    class ProductVariationModel {
      /**
       * The object attribute definitions corresponding with the product
       *  variation attributes of the master product.
       */
      readonly attributeDefinitions: dw.util.Collection<
        dw.object.ObjectAttributeDefinition
      >;
      /**
       * Return the default variant of this model's master product. If no default
       *  variant has been defined, return an arbitrary variant.
       */
      readonly defaultVariant: dw.catalog.Variant;
      /**
       * The master of the product variation.
       */
      readonly master: dw.catalog.Product;
      /**
       * A collection of product variation attributes of the variation.
       */
      readonly productVariationAttributes: dw.util.Collection<
        dw.catalog.ProductVariationAttributeValue
      >;
      /**
       * The variant currently selected for this variation model.
       *  Returns null if no variant is selected.
       */
      readonly selectedVariant: dw.catalog.Variant;
      /**
       * The variants currently selected for this variation model.
       *  Returns an empty collection if no variant is selected.
       */
      readonly selectedVariants: dw.util.Collection<dw.catalog.Variant>;
      /**
       * The collection of product variants of this variation model.
       *  This collection only includes online variants. Offline variants are
       *  filtered out. If all variation products are required, consider using
       *  Product.getVariants().
       *
       *  The product variants are returned in no particular order.
       */
      readonly variants: dw.util.Collection<dw.catalog.Variant>;
      /**
       * The collection of variation groups of this variation model.
       *  This collection only includes online variation groups. Offline variation
       *  groups are filtered out. If all variation group products are required,
       *  consider using Product.getVariationGroups().
       *
       *  The variation groups are returned in no particular order.
       */
      readonly variationGroups: dw.util.Collection<dw.catalog.VariationGroup>;

      /**
       * Returns the value definitions for the specified attribute. Only values
       *  that actually exist for at least one of the master product's currently
       *  online and complete variants are returned.
       *
       *  Returns an empty collection if the passed attribute is not even a
       *  variation attribute of the master product.
       * @param attribute the attribute whose values will be returned.
       * @return the sorted collection of ObjectAttributeValueDefinition instances representing the value definitions defined for the specified attribute. The collection is sorted by the explicit sort order defined for the values.
       */
      getAllValues(
        attribute: dw.object.ObjectAttributeDefinition
      ): dw.util.Collection<dw.catalog.ProductVariationAttributeValue>;
      /**
       * Returns the values for the specified attribute. Only values that actually
       *  exist for at least one of the master product's currently online and
       *  complete variants are returned.
       *
       *  Returns an empty collection if the passed attribute is not even a
       *  variation attribute of the master product.
       * @param attribute the variation attribute whose values will be returned.
       * @return the sorted collection of ProductVariationAttributeValue instances representing the values defined for the specified attribute. The collection is sorted by the explicit sort order defined for the values.
       */
      getAllValues(
        attribute: dw.catalog.ProductVariationAttribute
      ): dw.util.Collection<dw.catalog.ProductVariationAttributeValue>;
      /**
       * Returns the object attribute definitions corresponding with the product
       *  variation attributes of the master product.
       *
       * @return the collection of ObjectAttributeDefinition instances corresponding with the variation attributes of the master product, sorted by explicit position.
       */
      getAttributeDefinitions(): dw.util.Collection<
        dw.object.ObjectAttributeDefinition
      >;
      /**
       * Return the default variant of this model's master product. If no default
       *  variant has been defined, return an arbitrary variant.
       *
       * @return the default value of this model's master product, an arbitrary variant if no default is defined, or null if this model does not represent a master product with variants.
       */
      getDefaultVariant(): dw.catalog.Variant;
      /**
       * Returns a collection of the value definitions defined for the specified
       *  attribute, filtered based on currently selected values.
       *
       *  A value is only returned if it at least one variant has the value and
       *  also possesses the selected values for all previous attributes. It is
       *  important to know that the filter is applied in a certain order. The
       *  method looks at all ObjectAttributeDefinition instances that appear
       *  before the passed one in the sorted collection returned by
       *  getAttributeDefinitions(). If the passed attribute is the first
       *  in this collection, then this method simply returns all its values. If an
       *  earlier attribute does not have a selected value, this method returns an
       *  empty list. Otherwise, the filter looks at all variants matching the
       *  selected value for all previous attributes, and considers the range of
       *  values possessed by these variants for the passed attribute.
       *
       *  The idea behind this method is that customers in the storefront select
       *  variation attribute values one by one in the order the variation
       *  attributes are defined and displayed. After each selection, customer only
       *  wants to see values that he can possibly order for the remaining
       *  attributes.
       *
       *  Returns an empty collection if the passed attribute is not even a
       *  variation attribute of the master product.
       * @param attribute the attribute whose values are returned by this method.
       * @return a sorted collection of ObjectAttributeDefinitionValue instances calculated based on the currently selected variation values.
       */
      getFilteredValues(
        attribute: dw.object.ObjectAttributeDefinition
      ): dw.util.Collection<dw.catalog.ProductVariationAttributeValue>;
      /**
       * Returns a collection of the value definitions defined for the specified
       *  attribute, filtered based on currently selected values.
       *
       *  A value is only returned if it at least one variant has the value and
       *  also possesses the selected values for all previous attributes. It is
       *  important to know that the filter is applied in a certain order. The
       *  method looks at all ProductVariationAttribute instances that appear
       *  before the passed one in the sorted collection returned by
       *  getProductVariationAttributes(). If the passed attribute is the
       *  first in this collection, then this method simply returns all its values.
       *  If an earlier attribute does not have a selected value, this method
       *  returns an empty list. Otherwise, the filter looks at all variants
       *  matching the selected value for all previous attributes, and considers
       *  the range of values possessed by these variants for the passed attribute.
       *
       *  The idea behind this method is that customers in the storefront select
       *  variation attribute values one by one in the order the variation
       *  attributes are defined and displayed. After each selection, customer only
       *  wants to see values that he can possibly order for the remaining
       *  attributes.
       *
       *  Returns an empty collection if the passed attribute is not even a
       *  variation attribute of the master product.
       * @param attribute the product variation attribute whose values are to be returned.
       * @return a sorted and filtered collection of product variation attribute values. The collection is sorted by the explicit sort order defined for the values.
       */
      getFilteredValues(
        attribute: dw.catalog.ProductVariationAttribute
      ): dw.util.Collection<dw.catalog.ProductVariationAttributeValue>;
      /**
       * Returns an HTML representation of the variation attribute id. This method
       *  is deprecated. You should use getHtmlName(ProductVariationAttribute)
       *  instead.
       * @param attribute the attribute whose ID is returned.
       * @return an HTML representation of the attribute id.
       */
      getHtmlName(attribute: dw.object.ObjectAttributeDefinition): string;
      /**
       * Returns an HTML representation of the variation attribute id with the
       *  custom prefix. This method is deprecated. You should use
       *  getHtmlName(String, ProductVariationAttribute) instead.
       * @param prefix a custom prefix.
       * @param attribute the attribute whose ID is returned.
       * @return an HTML representation of the attribute id.
       */
      getHtmlName(
        prefix: string,
        attribute: dw.object.ObjectAttributeDefinition
      ): string;
      /**
       * Returns an HTML representation of the product variation attribute id.
       * @param attribute the product variation attribute whose ID is returned.
       * @return an HTML representation of the product variation attribute id.
       */
      getHtmlName(attribute: dw.catalog.ProductVariationAttribute): string;
      /**
       * Returns an HTML representation of the  product variation attribute id with the custom prefix.
       * @param prefix a custom prefix.
       * @param attribute the product variation attribute whose ID is returned.
       * @return an HTML representation of the product variation attribute id.
       */
      getHtmlName(
        prefix: string,
        attribute: dw.catalog.ProductVariationAttribute
      ): string;
      /**
       * The method returns the first image appropriate for the currently selected attribute values.
       *
       *  The method first considers the most specific combination of attribute values (e.g
       *  "Red leather") and if that is not found, more general (e.g "Red").  If no image group
       *  is found for the attributes, returns null
       *
       *  The view type parameter is required, otherwise a exception is thrown.
       * @param viewtype the view type annotated to image
       * @param attribute the variation attribute
       * @param value the the variation attribute value
       * @return the first image, or null if not found
       */
      getImage(
        viewtype: string,
        attribute: dw.catalog.ProductVariationAttribute,
        value: dw.catalog.ProductVariationAttributeValue
      ): dw.content.MediaFile;
      /**
       * The method returns an image appropriate for the current selected variation values
       *  with the specific index.
       *
       *  If images are defined for this view type and variants, but not for
       *  specified index, the method returns null.
       *
       *  If no images are defined for all variants and specified view type, the
       *  image at the specified index of the master product images is returned. If
       *  no master product image for specified index is defined, the method
       *  returns null.
       *
       *  The view type parameter is required, otherwise a exception is thrown.
       * @param viewtype the view type annotated to image
       * @param index the index number of the image within image list
       * @return the MediaFile or null
       */
      getImage(viewtype: string, index: number): dw.content.MediaFile;
      /**
       * The method returns the first image appropriate for the current selected variation values
       *  with the specific index.
       *
       *  If images are defined for this view type and variants, but not for
       *  specified index, the method returns null.
       *
       *  If no images are defined for all variants and specified view type, the
       *  image at the specified index of the master product images is returned. If
       *  no master product image for specified index is defined, the method
       *  returns null.
       *
       *  The view type parameter is required, otherwise a exception is thrown.
       * @param viewtype the view type annotated to image
       * @return the MediaFile or null
       */
      getImage(viewtype: string): dw.content.MediaFile;
      /**
       * The method returns the image appropriate for the currently selected attribute values.
       *
       *  The method first considers the most specific combination of attribute values (e.g
       *  "Red leather") and if that is not found, more general (e.g "Red").  If no image group
       *  is found for the attributes, returns null
       *
       *  The view type parameter is required, otherwise a exception is thrown.
       * @param viewtype the view type annotated to image
       * @return an array of images
       */
      getImages(viewtype: string): dw.util.List<dw.content.MediaFile>;
      /**
       * Returns the master of the product variation.
       *
       * @return the master of the product variation.
       */
      getMaster(): dw.catalog.Product;
      /**
       * Returns the product variation attribute for the specific id,
       *  or null if there is no product variation attribute for that id.
       * @param id the id of the product variation attribute
       * @return the product variation attribute, or null.
       */
      getProductVariationAttribute(
        id: string
      ): dw.catalog.ProductVariationAttribute;
      /**
       * Returns a collection of product variation attributes of the variation.
       *
       * @return a collection of product variation attributes of the variation.
       */
      getProductVariationAttributes(): dw.util.Collection<
        dw.catalog.ProductVariationAttributeValue
      >;
      /**
       * Returns the selected value for the specified attribute. If no value is
       *  selected, null is returned.
       * @param attribute the attribute whose value will be returned.
       * @return the selected value for the specified attribute or null.
       */
      getSelectedValue(
        attribute: dw.object.ObjectAttributeDefinition
      ): dw.object.ObjectAttributeValueDefinition;
      /**
       * Returns the selected value for the specified product variation attribute. If no value is
       *  selected, null is returned.
       * @param attribute the product variation attribute whose value will be returned.
       * @return the selected product variation attribute value for the specified attribute or null.
       */
      getSelectedValue(
        attribute: dw.catalog.ProductVariationAttribute
      ): dw.catalog.ProductVariationAttributeValue;
      /**
       * Returns the variant currently selected for this variation model.
       *  Returns null if no variant is selected.
       *
       * @return selected variant or null.
       */
      getSelectedVariant(): dw.catalog.Variant;
      /**
       * Returns the variants currently selected for this variation model.
       *  Returns an empty collection if no variant is selected.
       *
       * @return selected variants, might be empty if no valid variant was selected by the given attribute values
       */
      getSelectedVariants(): dw.util.Collection<dw.catalog.Variant>;
      /**
       * Returns the collection of product variants of this variation model.
       *  This collection only includes online variants. Offline variants are
       *  filtered out. If all variation products are required, consider using
       *  Product.getVariants().
       *
       *  The product variants are returned in no particular order.
       *
       * @return a collection of all the product variants of the variation model.
       */
      getVariants(): dw.util.Collection<dw.catalog.Variant>;
      /**
       * Returns the variants that match the specified filter conditions. The
       *  filter conditions are specified as a hash map of <attribute_id> -
       *  <value_id>.  This method does not consider the currently selected
       *  attribute values.
       * @param filter the filters to apply when collecting the variants.
       * @return the collection of variants that match the specified filter conditions.
       */
      getVariants(
        filter: dw.util.HashMap<any, any>
      ): dw.util.Collection<dw.catalog.Variant>;
      /**
       * Returns the collection of variation groups of this variation model.
       *  This collection only includes online variation groups. Offline variation
       *  groups are filtered out. If all variation group products are required,
       *  consider using Product.getVariationGroups().
       *
       *  The variation groups are returned in no particular order.
       *
       * @return a collection of all the variation groups of the variation model.
       */
      getVariationGroups(): dw.util.Collection<dw.catalog.VariationGroup>;
      /**
       * Returns the value for the specified variant or variation group product and
       *  variation attribute. The specified product should be a Variant
       *  returned by getVariants() or a VariationGroup returned by
       *  getVariationGroups(). The variation attribute should be one returned by
       *  getProductVariationAttributes(). If an invalid product or attribute is passed,
       *  null is returned. If null is passed for either argument, an exception is thrown.
       * @param variantOrVariationGroup the variant or variation group product to retrieve a value for, must not be null.
       * @param attribute the product variation attribute to get the value for, must not be null.
       * @return the attribute value for the specified variant or variation group and attribute, or null if an invalid variant, variation group or attribute is passed or the variation group define no value for the variation attribute.
       */
      getVariationValue(
        variantOrVariationGroup: dw.catalog.Product,
        attribute: dw.catalog.ProductVariationAttribute
      ): dw.catalog.ProductVariationAttributeValue;
      /**
       * Returns true if any variant is available with the specified value of the
       *  specified variation attribute. Available means that the variant is
       *  orderable according to the variant's availability model. This method
       *  takes currently selected attribute values into consideration. The
       *  specific rules are as follows:
       *
       *  If no variation value is currently selected, the method returns true
       *  if any variant with the specified value is available, else false.
       *  if one or more variation values are selected, the method returns true
       *  if any variant with a combination of the specified value and the selected
       *  value is available, else false.
       *  if all variation values are selected, the method returns true of the
       *  variant that is represented by the current selection is available, else
       *  false.
       * @param attribute The product variation attribute whose values are to be tested for orderable variants.
       * @param value The specific attribute value to test for orderable variants.
       * @return true if any variant is available with the specified value of the specified variation attribute based on the currently selected attribute values, false otherwise.
       */
      hasOrderableVariants(
        attribute: dw.catalog.ProductVariationAttribute,
        value: dw.catalog.ProductVariationAttributeValue
      ): boolean;
      /**
       * Identifies if the specified variation value is the one currently
       *  selected.
       * @param attribute the attribute to check.
       * @param value the value to check for selection.
       * @return true if the specified variation value is currently selected, false otherwise.
       */
      isSelectedAttributeValue(
        attribute: dw.object.ObjectAttributeDefinition,
        value: dw.object.ObjectAttributeValueDefinition
      ): boolean;
      /**
       * Identifies if the specified product variation attribute value is the one
       *  currently selected.
       * @param attribute the attribute to check.
       * @param value the value to check for selection.
       * @return true if the specified variation attribute value is currently selected, false otherwise.
       */
      isSelectedAttributeValue(
        attribute: dw.catalog.ProductVariationAttribute,
        value: dw.catalog.ProductVariationAttributeValue
      ): boolean;
      /**
       * Applies a selected attribute value to this model instance.
       *  Usually this method is used to set the model state corresponding to the variation attribute values
       *  specified by a URL. The URLs can be obtained by using one of the models URL methods, like
       *  urlSelectVariationValue(String, ProductVariationAttribute, ProductVariationAttributeValue) and
       *  urlUnselectVariationValue(String, ProductVariationAttribute).
       *
       *  Anyway, there are some limitations to keep in mind when selecting variation attribute values.
       *  A Variation Model created for a Variation Group or Variant Product is bound to an initial state.
       *  Example:
       *
       *  A Variation Model created for Variation Group A can't be switched to Variation Group B.
       *  A Variation Model created for Variant A can't be switched to Variant B.
       *  The state of a Variation Model for a Variation Group that defines color = red can't be changed to color = black.
       *  The state of a Variation Model for a Variant that defines color = red / size = L can't be changed to color = black / size = S.
       *  However, the state of a Variation Model created for a Variation Group that defines color = red
       *  can be changed to a more specific state by adding another selected value, e.g. size = L.
       *
       *  The state of a Variation Model created for a Variation Master can be changed in any possible way
       *  because the initial state involves all variation values and Variants.
       * @param variationAttributeID the ID of an product variation attribute, must not be null, otherwise a exception is thrown
       * @param variationAttributeValueID the ID of the product variation attribute value to apply, this value must not be part of the initial model state (e.g. the variant or group that the model has been created for), otherwise a exception is thrown
       */
      setSelectedAttributeValue(
        variationAttributeID: string,
        variationAttributeValueID: string
      ): void;
      /**
       * Constructs a URL to select a set of variation attribute values. The
       *  optional varAttrAndValues argument can be empty, or can
       *  contain one or more variation attribute / value pairs. This variable list
       *  should be even in length, with attributes and values alternating.
       *  Attributes can be specified as instances of ProductVariationAttribute, or
       *  String variation attribute ID. (Note: ObjectAttributeDefinition IDs are
       *  not supported.) Values can be specified as instances of
       *  ProductVariationAttributeValue or String or Integer depending on the data
       *  type of the variation attribute. If a parameter type is invalid, or does
       *  not reference a valid ProductVariationAttribute or
       *  ProductVariationAttributeValue, then the parameter pair is not included
       *  in the generated URL. The returned URL will contain variation attributes
       *  and values already selected in the product variation model, as well as
       *  attributes and values specified as method parameters.
       *
       *  Sample usage:
       *
       *   master.variationModel.url("Product-Show", "color", "red", "size", "XL");
       *  master.variationModel.url("Product-Show", colorVarAttr, colorValue, sizeVarAttr, sizeValue);
       *  // --> on/demandware.store/Sites-SiteGenesis-Site/default/Product-Show?pid=master_id&dwvar_color=red&dwvar_size=XL
       * @param action The pipeline action.
       * @param varAttrAndValues Variable length list of attributes and corresponding values to select.
       * @return The constructed URL.
       */
      url(action: string, ...varAttrAndValues: any[]): dw.web.URL;
      /**
       * Constructs an URL to select the specified value of the specified
       *  variation attribute.
       *
       *  The generated URL will be an absolute URL which uses the protocol of the
       *  current request.
       * @param action the pipeline action, e.g. "Product-Show".
       * @param attribute the attribute to select a value for.
       * @param value the attribute definition value portion of the variation.
       * @return the generated URL, an absolute URL which uses the protocol of the current request.
       */
      urlSelectVariationValue(
        action: string,
        attribute: dw.object.ObjectAttributeDefinition,
        value: dw.object.ObjectAttributeValueDefinition
      ): string;
      /**
       * Generates a URL for selecting a value for a given variation attribute.
       *  This URL is intended to be used on dynamic product detail pages. When a
       *  customer selects which value he wants for one of the variation
       *  attributes, the product detail page can issue a request to the passed URL
       *  which in turn can invoke the
       *  UpdateProductVariationSelections pipelet. That pipelet reads
       *  the querystring parameters and returns an updated variation model with
       *  the desired attribute value selected.
       *
       *  The generated URL will be an absolute URL which uses the protocol of
       *  the current request.
       * @param action the pipeline action, e.g. "Product-Show".
       * @param attribute the product variation attribute to select a value for.
       * @param value the product variation attribute value to select.
       * @return the generated URL, an absolute URL which uses the protocol of the current request.
       */
      urlSelectVariationValue(
        action: string,
        attribute: dw.catalog.ProductVariationAttribute,
        value: dw.catalog.ProductVariationAttributeValue
      ): string;
      /**
       * Constructs an URL to unselect the value of the specified variation
       *  attribute.
       *
       *  The generated URL will be an absolute URL which uses the protocol of the
       *  current request.
       * @param action the pipeline action, e.g. "Product-Show".
       * @param attribute the attribute to unselect.
       * @return the generated URL, an absolute URL which uses the protocol of the current request.
       */
      urlUnselectVariationValue(
        action: string,
        attribute: dw.object.ObjectAttributeDefinition
      ): string;
      /**
       * Generates a URL for unselecting a value for a given variation attribute.
       *  This URL is intended to be used on dynamic product detail pages. When a
       *  customer deselects a value for one of the variation attributes, the
       *  product detail page can issue a request to the passed URL which in turn
       *  can invoke the UpdateProductVariationSelections pipelet.
       *  That pipelet reads the querystring parameters and returns an updated
       *  variation model with the desired attribute value unselected.
       *
       *  The generated URL will be an absolute URL which uses the protocol of
       *  the current request.
       * @param action the pipeline action, e.g. "Product-Show".
       * @param attribute the product variation attribute to unselect.
       * @return the generated URL, an absolute URL which uses the protocol of the current request.
       */
      urlUnselectVariationValue(
        action: string,
        attribute: dw.catalog.ProductVariationAttribute
      ): string;
    }

    /**
     * Represents a recommendation in Commerce Cloud Digital.
     */
    class Recommendation extends dw.object.ExtensibleObject {
      /**
       * Represents a cross-sell recommendation.
       */
      static readonly RECOMMENDATION_TYPE_CROSS_SELL = 1;
      /**
       * Represents a recommendation that is neither a cross-sell or an up-sell.
       */
      static readonly RECOMMENDATION_TYPE_OTHER = 3;
      /**
       * Represents an up-sell recommendation.
       */
      static readonly RECOMMENDATION_TYPE_UP_SELL = 2;

      /**
       * The recommendation's callout message in the current locale.
       */
      readonly calloutMsg: dw.content.MarkupText;
      /**
       * Return the catalog containing the recommendation.
       */
      readonly catalog: dw.catalog.Catalog;
      /**
       * The recommendation's image.
       */
      readonly image: dw.content.MediaFile;
      /**
       * The recommendation's long description in the current locale.
       */
      readonly longDescription: dw.content.MarkupText;
      /**
       * The name of the recommended item in the current locale.
       */
      readonly name: string;
      /**
       * The type of the recommendation.
       */
      readonly recommendationType: number;
      /**
       * Return a reference to the recommended item.  This will always be an
       *  object of type dw.catalog.Product since this is the only
       *  currently supported recommendation target type.
       */
      readonly recommendedItem: any;
      /**
       * Return the ID of the recommended item.  This will always be a product
       *  ID since this is the only currently supported recommendation target
       *  type.
       */
      readonly recommendedItemID: string;
      /**
       * The recommendation's short description in the current locale.
       */
      readonly shortDescription: dw.content.MarkupText;
      /**
       * Return a reference to the source item.  This will be an object of type
       *  dw.catalog.Product or dw.catalog.Category.
       */
      readonly sourceItem: any;
      /**
       * Return the ID of the recommendation source item.  This will either be a
       *  product ID or category name.
       */
      readonly sourceItemID: string;

      /**
       * Returns the recommendation's callout message in the current locale.
       *
       * @return the recommendation's callout message in the current locale, or null if it wasn't found.
       */
      getCalloutMsg(): dw.content.MarkupText;
      /**
       * Return the catalog containing the recommendation.
       *
       * @return the catalog containing the recommendation.
       */
      getCatalog(): dw.catalog.Catalog;
      /**
       * Returns the recommendation's image.
       *
       * @return the recommendation's image.
       */
      getImage(): dw.content.MediaFile;
      /**
       * Returns the recommendation's long description in the current locale.
       *
       * @return The recommendation's long description in the current locale, or null if it wasn't found.
       */
      getLongDescription(): dw.content.MarkupText;
      /**
       * Returns the name of the recommended item in the current locale.
       *
       * @return The name of the recommended item for the current locale, or null if it wasn't found.
       */
      getName(): string;
      /**
       * Returns the type of the recommendation.
       *
       * @return the type of the recommendation expressed as an integer.
       */
      getRecommendationType(): number;
      /**
       * Return a reference to the recommended item.  This will always be an
       *  object of type dw.catalog.Product since this is the only
       *  currently supported recommendation target type.
       *
       * @return the recommended item, possibly null if the item does not exist.
       */
      getRecommendedItem(): any;
      /**
       * Return the ID of the recommended item.  This will always be a product
       *  ID since this is the only currently supported recommendation target
       *  type.
       *
       * @return the recommended item ID.
       */
      getRecommendedItemID(): string;
      /**
       * Returns the recommendation's short description in the current locale.
       *
       * @return the recommendations's short description in the current locale, or null if it wasn't found.
       */
      getShortDescription(): dw.content.MarkupText;
      /**
       * Return a reference to the source item.  This will be an object of type
       *  dw.catalog.Product or dw.catalog.Category.
       *
       * @return the source item.
       */
      getSourceItem(): any;
      /**
       * Return the ID of the recommendation source item.  This will either be a
       *  product ID or category name.
       *
       * @return the source item ID.
       */
      getSourceItemID(): string;
    }

    /**
     * Common search model base class.
     */
    class SearchModel {
      /**
       * URL Parameter for the Search Phrase
       */
      static readonly SEARCH_PHRASE_PARAMETER = "q";
      /**
       * Sorting parameter ASCENDING
       */
      static readonly SORT_DIRECTION_ASCENDING = 1;
      /**
       * Sorting parameter DESCENDING
       */
      static readonly SORT_DIRECTION_DESCENDING = 2;
      /**
       * Sorting parameter NO_SORT - will remove a sorting condition
       */
      static readonly SORT_DIRECTION_NONE = 0;

      /**
       * The number of search results found by this search.
       */
      readonly count: number;
      /**
       * Identifies if the query is emtpy when no search term, search parameter or
       *  refinement was specified for the search. In case also no result is
       *  returned. This "empty" is different to a query with a specified query and
       *  with an empty result.
       */
      readonly emptyQuery: boolean;
      /**
       * The method returns true, if this search is refined by at least one
       *  attribute.
       */
      readonly refinedByAttribute: boolean;
      /**
       * Identifies if this was a refined search. A search is a refined search if
       *  at least one refinement is part of the query.
       */
      readonly refinedSearch: boolean;
      /**
       * The search phrase used in this search.
       */
      searchPhrase: string;

      /**
       * Adds a refinement. The method can be called to add an additional query
       *  parameter specified as name-value pair. The values string may encode
       *  multiple values delimited by the pipe symbol ('|').
       * @param attributeID The ID of the refinement attribute.
       * @param values the refinement value to set
       */
      addRefinementValues(attributeID: string, values: string): void;
      /**
       * Identifies if the search can be relaxed without creating a search for all
       *  searchable items.
       *
       * @return true if the search can be relaxed without creating a search for all searchable items, false otherwise.
       */
      canRelax(): boolean;
      /**
       * Returns the number of search results found by this search.
       *
       * @return the number of search results found by this search.
       */
      getCount(): number;
      /**
       * Returns the maximum refinement value selected in the query for the specific
       *  attribute, or null if there is no maximum refinement value or no refinement for that attribute.
       * @param attributeID the attribute whose refinement value is returned.
       * @return the maximum refinement value selected in the query for the specific attribute.
       */
      getRefinementMaxValue(attributeID: string): string;
      /**
       * Returns the minimum refinement value selected in the query for the specific
       *  attribute, or null if there is no minimum refinement value or no refinement for that attribute.
       * @param attributeID the attribute whose refinement value is returned.
       * @return the minimum refinement value selected in the query for the specific attribute.
       */
      getRefinementMinValue(attributeID: string): string;
      /**
       * Returns the refinement value selected in the query for the specific
       *  attribute, or null if there is no refinement for that attribute.
       * @param attributeID the attribute whose refinement value is returned.
       * @return the refinement value selected in the query for the specific attribute.
       */
      getRefinementValue(attributeID: string): string;
      /**
       * Returns the list of selected refinement values for the given attribute as
       *  used in the search.
       * @param attributeID The name of the refinement attribute.
       * @return A list of values currently selected for the refinement attribute.
       */
      getRefinementValues(
        attributeID: string
      ): dw.util.Collection<dw.catalog.SearchRefinementValue>;
      /**
       * Returns the search phrase used in this search.
       *
       * @return the search phrase used in this search.
       */
      getSearchPhrase(): string;
      /**
       * Returns an URLRedirect object for a search phrase.
       * @param searchPhrase a search phrase to lookup a URLRedirect for
       * @return URLRedirect containing the location and status code, null in case no redirect was found for the search phrase.
       */
      static getSearchRedirect(searchPhrase: string): dw.web.URLRedirect;
      /**
       * Returns the sorting condition for a given attribute name. A value of 0
       *  indicates that no sorting condition is set.
       * @param attributeID the attribute name
       * @return zero if no sorting order set, or the sorting order
       */
      getSortingCondition(attributeID: string): number;
      /**
       * Identifies if the query is emtpy when no search term, search parameter or
       *  refinement was specified for the search. In case also no result is
       *  returned. This "empty" is different to a query with a specified query and
       *  with an empty result.
       *
       * @return true if the query is emtpy when no search term, search parameter or refinement was specified for the search.
       */
      isEmptyQuery(): boolean;
      /**
       * Identifies if this search has been refined on the given attribute.
       * @param attributeID The ID of the refinement attribute.
       * @return True if the search is refined on the attribute, false otherwise.
       */
      isRefinedByAttribute(attributeID: string): boolean;
      /**
       * The method returns true, if this search is refined by at least one
       *  attribute.
       *
       * @return true, if the search is refined by at least one attribute, false otherwise.
       */
      isRefinedByAttribute(): boolean;
      /**
       * Identifies if this search has been refined on the given attribute and
       *  value.
       * @param attributeID The ID of the refinement attribute.
       * @param value The value to be checked for inclusion in the refinement.
       * @return True if the search is refined on the attribute and value, false otherwise.
       */
      isRefinedByAttributeValue(attributeID: string, value: string): boolean;
      /**
       * Identifies if this was a refined search. A search is a refined search if
       *  at least one refinement is part of the query.
       *
       * @return true if this is a refined search, false otherwise.
       */
      isRefinedSearch(): boolean;
      /**
       * Identifies if this search has been refined on the given attribute.
       * @param attributeID The ID of the refinement attribute.
       * @return True if the search is refined on the attribute, false otherwise.
       */
      isRefinementByValueRange(attributeID: string): boolean;
      /**
       * Identifies if this search has been refined on the given attribute and range values.
       * @param attributeID The ID of the refinement attribute.
       * @param minValue The minimum value to be checked for inclusion in the refinement.
       * @param maxValue The maximum value to be checked for inclusion in the refinement.
       * @return True if the search is refined on the attribute and range values, false otherwise.
       */
      isRefinementByValueRange(
        attributeID: string,
        minValue: string,
        maxValue: string
      ): boolean;
      /**
       * Removes a refinement. The method can be called to remove previously added
       *  refinement values. The values string may encode multiple values delimited
       *  by the pipe symbol ('|').
       * @param attributeID The ID of the refinement attribute.
       * @param values the refinement value to remove or null to remove all values
       */
      removeRefinementValues(attributeID: string, values: string): void;
      /**
       * Execute the search.
       *
       */
      search(): void;
      /**
       * Sets a refinement value range for an attribute. The method can be called to set
       *  an additional range query parameter specified as name-range-value pair. The values
       *  string can contain only a range boundary.
       *  Existing refinement values for the attribute will be removed.
       * @param attributeID The ID of the refinement attribute.
       * @param minValue the minimum refinement boundary value to set or null to remove the minimum boundary
       * @param maxValue the maximum refinement boundary value to set or null to remove the maximum boundary
       */
      setRefinementValueRange(
        attributeID: string,
        minValue: string,
        maxValue: string
      ): void;
      /**
       * Sets refinement values for an attribute. The method can be called to set
       *  an additional query parameter specified as name-value pair. The value
       *  string may encode multiple values delimited by the pipe symbol ('|').
       *  Existing refinement values for the attribute will be removed.
       * @param attributeID The ID of the refinement attribute.
       * @param values the refinement values to set (delimited by '|') or null to remove all values
       */
      setRefinementValues(attributeID: string, values: string): void;
      /**
       * Sets the search phrase used in this search. The search query parser uses
       *  the following operators:
       *
       *
       *  PHRASE operator (""), e.g. "cream cheese", "John Lennon"
       *  NOT operator (-), e.g. -cargo (will not return results containing
       *  "cargo")
       *  WILDCARD operator (*), e.g. sho* (will return results containing
       *  "shoulder", "shoes" and "shoot")
       * @param phrase the search phrase used in this search.
       */
      setSearchPhrase(phrase: string): void;
      /**
       * Sets or removes a sorting condition for the specified attribute. Specify
       *  either SORT_DIRECTION_ASCENDING or SORT_DIRECTION_DESCENDING to set a
       *  sorting condition. Specify SORT_DIRECTION_NONE to remove a sorting
       *  condition from the attribute.
       * @param attributeID the attribute ID
       * @param direction SORT_DIRECTION_ASCENDING, SORT_DIRECTION_DESCENDING or SORT_DIRECTION_NONE
       */
      setSortingCondition(attributeID: string, direction: number): void;
      /**
       * Constructs an URL that you can use to re-execute the exact same query.
       *  The provided parameter must be an action, e.g. 'Search-Show'.
       * @param action the pipeline action.
       * @return an URL that can be used to re-execute the exact same query.
       */
      url(action: string): dw.web.URL;
      /**
       * Constructs an URL that you can use to re-execute the exact same query.
       *  The search specific parameter are appended to the provided URL. The URL
       *  is typically generated with one of the URLUtils methods.
       * @param url the url to use.
       * @return a new url URL that can be used to re-execute the exact same query.
       */
      url(url: dw.web.URL): dw.web.URL;
      /**
       * Constructs an URL that you can use to re-execute the query with a default
       *  sorting. The provided parameter must be an action, e.g. 'Search-Show'.
       * @param url url or pipeline name
       * @return the new URL.
       */
      urlDefaultSort(url: string): dw.web.URL;
      /**
       * Constructs an URL that you can use to re-execute the query with a default
       *  sorting. The search specific parameters are appended to the provided URL.
       *  The URL is typically generated with one of the URLUtils methods.
       * @param url url or pipeline name
       * @return the new URL.
       */
      urlDefaultSort(url: dw.web.URL): dw.web.URL;
      /**
       * Constructs an URL that you can use to re-execute the query with an
       *  additional refinement.
       * @param action the pipeline action.
       * @param attributeID the ID of the refinement attribute.
       * @param value the value for the refinement attribute.
       * @return the new URL.
       */
      urlRefineAttribute(
        action: string,
        attributeID: string,
        value: string
      ): dw.web.URL;
      /**
       * Constructs an URL that you can use to re-execute the query with an
       *  additional refinement. The search specific parameters are appended to the
       *  provided URL. The URL is typically generated with one of the URLUtils
       *  methods.
       * @param url url
       * @param attributeID the ID of the refinement attribute
       * @param value value for the refinement attribute
       * @return the new URL.
       */
      urlRefineAttribute(
        url: dw.web.URL,
        attributeID: string,
        value: string
      ): dw.web.URL;
      /**
       * Constructs an URL that you can use to re-execute the query with an
       *  additional refinement value for a given refinement attribute. The
       *  provided value will be added to the set of allowed values for the
       *  refinement attribute. This basically broadens the search result.
       * @param action the pipeline action.
       * @param attributeID the ID of the refinement attribute.
       * @param value the additional value for the refinement attribute.
       * @return the new URL.
       */
      urlRefineAttributeValue(
        action: string,
        attributeID: string,
        value: string
      ): dw.web.URL;
      /**
       * Constructs an URL that you can use to re-execute the query with an
       *  additional refinement value for a given refinement attribute. The
       *  provided value will be added to the set of allowed values for the
       *  refinement attribute. This basically broadens the search result.
       *
       *  The search specific parameters are appended to the provided URL. The URL
       *  is typically generated with one of the URLUtils methods.
       * @param url url
       * @param attributeID ID of the refinement attribute
       * @param value the additional value for the refinement attribute
       * @return the new URL.
       */
      urlRefineAttributeValue(
        url: dw.web.URL,
        attributeID: string,
        value: string
      ): dw.web.URL;
      /**
       * Constructs an URL that you can use to re-execute the query with an additional refinement value range for a given refinement attribute. The
       *  provided value range will be replace to the existing value range for the refinement attribute.
       *
       *  The search specific parameters are appended to the provided URL. The URL is typically generated with one of the URLUtils methods.
       * @param action the pipeline action.
       * @param attributeID ID of the refinement attribute
       * @param minValue the min value for the refinement attribute
       * @param maxValue the max value for the refinement attribute
       * @return the new URL.
       */
      urlRefineAttributeValueRange(
        action: string,
        attributeID: string,
        minValue: string,
        maxValue: string
      ): dw.web.URL;
      /**
       * Constructs an URL that you can use to re-execute the query without the
       *  specified refinement. The value for the action parameter must be a
       *  pipeline action, e.g. 'Search-Show'.
       * @param action the pipeline action.
       * @param attributeID ID of the refinement attribute to be removed
       * @return the new URL.
       */
      urlRelaxAttribute(action: string, attributeID: string): dw.web.URL;
      /**
       * Constructs an URL that you can use to re-execute the query without the
       *  specified refinement. The search specific parameters are appended to the
       *  provided URL. The URL is typically generated with one of the URLUtils
       *  methods.
       * @param url the url to use.
       * @param attributeID the ID of the refinement attribute to be removed.
       * @return the new URL.
       */
      urlRelaxAttribute(url: dw.web.URL, attributeID: string): dw.web.URL;
      /**
       * Constructs an URL that you can use to re-execute the query without the
       *  specified refinement. The value for the action parameter must be a
       *  pipeline action, e.g. 'Search-Show'.
       * @param action the pipeline action.
       * @param attributeID ID of the refinement attribute to be removed
       * @param value the value that should be removed from the list of refinement values.
       * @return the new URL.
       */
      urlRelaxAttributeValue(
        action: string,
        attributeID: string,
        value: string
      ): dw.web.URL;
      /**
       * Constructs an URL that you can use to re-execute the query without the
       *  specified refinement value. The search specific parameters are appended
       *  to the provided URL. The URL is typically generated with one of the
       *  URLUtils methods.
       * @param url the url to use.
       * @param attributeID the ID of the refinement attribute to relax the value for.
       * @param value the value that should be removed from the list of refinement values.
       * @return the new URL.
       */
      urlRelaxAttributeValue(
        url: dw.web.URL,
        attributeID: string,
        value: string
      ): dw.web.URL;
      /**
       * Constructs an URL that you can use to re-execute the query with a
       *  specific sorting criteria. This criteria will overwrite all previous sort
       *  critiria. The provided parameter must be an action, e.g. 'Search-Show'.
       * @param action Pipeline action
       * @param sortBy ID of the sort attribute
       * @param sortDir Sort direction. 1 - ASCENDING (default), 2 - DESCENDING
       * @return The new URL.
       */
      urlSort(action: string, sortBy: string, sortDir: number): dw.web.URL;
      /**
       * Constructs an URL that you can use to re-execute the query with a
       *  specific sorting criteria. This criteria will overwrite all previous sort
       *  critiria. The search specific parameters are appended to the provided
       *  URL. The URL is typically generated with one of the URLUtils methods.
       * @param url URL
       * @param sortBy ID of the sort attribute
       * @param sortDir Sort direction. 1 - ASCENDING (default), 2 - DESCENDING
       * @return The new URL.
       */
      urlSort(url: dw.web.URL, sortBy: string, sortDir: number): dw.web.URL;
    }

    /**
     * Common search refinement definition base class.
     */
    class SearchRefinementDefinition extends dw.object.ExtensibleObject {
      /**
       * The attribute ID. If the refinement definition is not an
       *  attribute refinement, the method returns an empty string.
       */
      readonly attributeID: string;
      /**
       * Identifies if this is an attribute refinement.
       */
      readonly attributeRefinement: boolean;
      /**
       * The cut-off threshold.
       */
      readonly cutoffThreshold: number;
      /**
       * The display name.
       */
      readonly displayName: string;
      /**
       * A code for the data type used for this search refinement definition. See constants
       *  defined in ObjectAttributeDefinition.
       */
      readonly valueTypeCode: number;

      /**
       * Returns the attribute ID. If the refinement definition is not an
       *  attribute refinement, the method returns an empty string.
       *
       * @return the attribute ID.
       */
      getAttributeID(): string;
      /**
       * Returns the cut-off threshold.
       *
       * @return the cut-off threshold.
       */
      getCutoffThreshold(): number;
      /**
       * Returns the display name.
       *
       * @return the display name.
       */
      getDisplayName(): string;
      /**
       * Returns a code for the data type used for this search refinement definition. See constants
       *  defined in ObjectAttributeDefinition.
       *
       * @return a code for the data type used for this search refinement definition. See constants defined in ObjectAttributeDefinition.
       */
      getValueTypeCode(): number;
      /**
       * Identifies if this is an attribute refinement.
       *
       * @return true if this is an attribute refinement, false otherwise.
       */
      isAttributeRefinement(): boolean;
    }

    /**
     * Represents the value of a product or content search refinement.
     */
    class SearchRefinementValue {
      /**
       * The optional refinement value description in the current locale.
       */
      readonly description: string;
      /**
       * The refinement display value. For attribute refinements, this is
       *  the appropriate display value based on optional value display names
       *  within the object attribute definition. If no display name is defined,
       *  the value itself is returned. For category refinements, this is the
       *  display name of the category in the current locale. For price
       *  refinements, this is a string representation of the range appropriate for
       *  display.
       */
      readonly displayValue: string;
      /**
       * The hit count value.
       */
      readonly hitCount: number;
      /**
       * The refinement value's ID. For attribute refinements, this will
       *  be the ID of the corresponding
       *  ObjectAttributeDefinition. This ID is included in the
       *  querystring parameter names returned by the URL-generating methods of
       *  SearchModel. For price and category refinements, this
       *  value will be empty.
       */
      readonly ID: string;
      /**
       * The optional presentation ID associated with this refinement
       *  value. The presentation ID can be used, for example, to associate an ID
       *  with an HTML widget.
       */
      readonly presentationID: string;
      /**
       * The refinement value. For attribute refinements, this is the
       *  attribute value if the refinement values are unbucketed, or the bucket
       *  display name if the values are bucketed. This value is included in the
       *  querystring parameter values returned by the URL-generating methods of
       *  SearchModel. For price refinements, the value will be
       *  a string representation of the price range lower bound. For category
       *  refinements, the value will be a category ID.
       */
      readonly value: string;

      /**
       * Returns the optional refinement value description in the current locale.
       *
       * @return the optional refinement value description in the current locale, or null if none is defined.
       */
      getDescription(): string;
      /**
       * Returns the refinement display value. For attribute refinements, this is
       *  the appropriate display value based on optional value display names
       *  within the object attribute definition. If no display name is defined,
       *  the value itself is returned. For category refinements, this is the
       *  display name of the category in the current locale. For price
       *  refinements, this is a string representation of the range appropriate for
       *  display.
       *
       * @return the refinement display value in the current locale.
       */
      getDisplayValue(): string;
      /**
       * Returns the hit count value.
       *
       * @return the hit count value.
       */
      getHitCount(): number;
      /**
       * Returns the refinement value's ID. For attribute refinements, this will
       *  be the ID of the corresponding
       *  ObjectAttributeDefinition. This ID is included in the
       *  querystring parameter names returned by the URL-generating methods of
       *  SearchModel. For price and category refinements, this
       *  value will be empty.
       *
       * @return the refinement value's ID.
       */
      getID(): string;
      /**
       * Returns the optional presentation ID associated with this refinement
       *  value. The presentation ID can be used, for example, to associate an ID
       *  with an HTML widget.
       *
       * @return the presentation ID, or null if none is defined.
       */
      getPresentationID(): string;
      /**
       * Returns the refinement value. For attribute refinements, this is the
       *  attribute value if the refinement values are unbucketed, or the bucket
       *  display name if the values are bucketed. This value is included in the
       *  querystring parameter values returned by the URL-generating methods of
       *  SearchModel. For price refinements, the value will be
       *  a string representation of the price range lower bound. For category
       *  refinements, the value will be a category ID.
       *
       * @return the refinement value.
       */
      getValue(): string;
    }

    /**
     * Common search refinements base class.
     */
    class SearchRefinements {
      /**
       * Flag for an ascending sort.
       */
      static readonly ASCENDING = 0;
      /**
       * Flag for a descending sort.
       */
      static readonly DESCENDING = 1;
      /**
       * Flag for sorting on value count.
       */
      static readonly SORT_VALUE_COUNT = 1;
      /**
       * Flag for sorting on value name.
       */
      static readonly SORT_VALUE_NAME = 0;

      /**
       * A sorted list of refinement definitions that are appropriate for
       *  the deepest common category (or deepest common folder) of the search
       *  result. The method concatenates the sorted refinement definitions per
       *  category starting at the root category until reaching the deepest common
       *  category.
       *
       *  The method does not filter out refinement definitions that do
       *  not provide values for the current search result and can therefore also
       *  be used on empty search results.
       */
      readonly allRefinementDefinitions: dw.util.Collection<
        dw.catalog.SearchRefinementDefinition
      >;
      /**
       * A sorted list of refinement definitions that are appropriate for
       *  the deepest common category (or deepest common folder) of the search
       *  result. The method concatenates the sorted refinement definitions per category
       *  starting at the root category until reaching the deepest common category.
       *
       *  The method also filters out refinement definitions that do not provide
       *  any values for the current search result.
       */
      readonly refinementDefinitions: dw.util.Collection<
        dw.catalog.SearchRefinementDefinition
      >;

      /**
       * Returns a sorted list of refinement definitions that are appropriate for
       *  the deepest common category (or deepest common folder) of the search
       *  result. The method concatenates the sorted refinement definitions per
       *  category starting at the root category until reaching the deepest common
       *  category.
       *
       *  The method does not filter out refinement definitions that do
       *  not provide values for the current search result and can therefore also
       *  be used on empty search results.
       *
       * @return A sorted list of refinement definitions appropriate for the search result (based on its deepest common category)
       */
      getAllRefinementDefinitions(): dw.util.Collection<
        dw.catalog.SearchRefinementDefinition
      >;
      /**
       * Returns a sorted collection of refinement values for the given refinement
       *  attribute. The returned collection includes all refinement values for
       *  which the hit count is greater than 0 within the search result when the
       *  passed attribute is excluded from filtering the search hits but all other
       *  refinement filters are still applied. This method is useful for rendering
       *  broadening options for attributes that the search is currently refined
       *  by. This method does NOT return refinement values independent of the
       *  search result.
       *
       *  For product search refinements, this method may return slightly different
       *  results based on the "value set" property of the refinement definition.
       *  See
       *  ProductSearchRefinements.getAllRefinementValues(ProductSearchRefinementDefinition)
       *  for details.
       * @param attributeName The name of the attribute to return refinement values for.
       * @return The collection of SearchRefinementValue instances, sorted according to the settings of the refinement definition, or null if there is no refinement definition for the passed attribute name.
       */
      getAllRefinementValues(
        attributeName: string
      ): dw.util.Collection<dw.catalog.SearchRefinementValue>;
      /**
       * Returns a sorted collection of refinement values for the given refinement
       *  attribute. In general, the returned collection includes all refinement
       *  values for which hit count is greater than 0 within the search result
       *  assuming that:
       *
       *
       *  The passed refinement attribute is NOT used to filter the search
       *  hits.
       *  All other refinements are still applied.
       *
       *
       *  This is useful for rendering broadening options for the refinement
       *  definitions that the search is already refined by. It is important to
       *  note that this method does NOT return refinement values independent of
       *  the search result.
       *
       *  For product search refinements, this method may return slightly different
       *  results based on the "value set" of the refinement definition. See
       *  ProductSearchRefinements.getAllRefinementValues(ProductSearchRefinementDefinition)
       *  for details.
       * @param attributeName The name of the attribute to return refinement values for.
       * @param sortMode The sort mode to use to control how the collection is sorted.
       * @param sortDirection The sort direction to use.
       * @return The collection of SearchRefinementValue instances, sorted according to the passed parameters.
       */
      getAllRefinementValues(
        attributeName: string,
        sortMode: number,
        sortDirection: number
      ): dw.util.Collection<dw.catalog.SearchRefinementValue>;
      /**
       * Returns a sorted list of refinement definitions that are appropriate for
       *  the deepest common category (or deepest common folder) of the search
       *  result. The method concatenates the sorted refinement definitions per category
       *  starting at the root category until reaching the deepest common category.
       *
       *  The method also filters out refinement definitions that do not provide
       *  any values for the current search result.
       *
       * @return A sorted list of refinement definitions appropriate for the search result (based on its deepest common category)
       */
      getRefinementDefinitions(): dw.util.Collection<
        dw.catalog.SearchRefinementDefinition
      >;
      /**
       * Returns a collection of refinement values for the given refinement
       *  attribute, sorting mode and sorting direction.
       * @param attributeName The attribute name to use when collection refinement values.
       * @param sortMode The sort mode to use to control how the collection is sorted.
       * @param sortDirection The sort direction to use.
       * @return The collection of refinement values.
       */
      getRefinementValues(
        attributeName: string,
        sortMode: number,
        sortDirection: number
      ): dw.util.Collection<dw.catalog.SearchRefinementValue>;
    }

    /**
     * Represents an option for how to sort products in storefront search results.
     */
    class SortingOption extends dw.object.PersistentObject {
      /**
       * The description of the sorting option for the current locale.
       */
      readonly description: string;
      /**
       * The display name of the of the sorting option for the current locale.
       */
      readonly displayName: string;
      /**
       * The ID of the sorting option.
       */
      readonly ID: string;
      /**
       * The sorting rule for this sorting option,
       *  or null if there is no associated rule.
       */
      readonly sortingRule: dw.catalog.SortingRule;

      /**
       * Returns the description of the sorting option for the current locale.
       *
       * @return The value of the property for the current locale, or null if it wasn't found.
       */
      getDescription(): string;
      /**
       * Returns the display name of the of the sorting option for the current locale.
       *
       * @return The value of the property for the current locale, or null if it wasn't found.
       */
      getDisplayName(): string;
      /**
       * Returns the ID of the sorting option.
       *
       * @return sorting option ID
       */
      getID(): string;
      /**
       * Returns the sorting rule for this sorting option,
       *  or null if there is no associated rule.
       *
       * @return a ProductSortingRule instance representing the rule for this option or null.
       */
      getSortingRule(): dw.catalog.SortingRule;
    }

    /**
     * Represents a product sorting rule for use with the <a href="class_dw_catalog_ProductSearchModel.html">ProductSearchModel</a>.
     */
    class SortingRule extends dw.object.PersistentObject {
      /**
       * The ID of the sorting rule.
       */
      readonly ID: string;

      /**
       * Returns the ID of the sorting rule.
       *
       * @return sorting rule ID
       */
      getID(): string;
    }

    /**
     * Represents a store in Commerce Cloud Digital.
     */
    class Store extends dw.object.ExtensibleObject {
      /**
       * The address1 of the store.
       */
      readonly address1: string;
      /**
       * The address2 of the store.
       */
      readonly address2: string;
      /**
       * The city of the store.
       */
      readonly city: string;
      /**
       * The countryCode of the store.
       */
      readonly countryCode: dw.value.EnumValue;
      /**
       * The demandwarePosEnabled flag for the store.
       *  Indicates that this store uses Commerce Cloud Store for point-of-sale.
       */
      readonly demandwarePosEnabled: boolean;
      /**
       * The email of the store.
       */
      readonly email: string;
      /**
       * The fax of the store.
       */
      readonly fax: string;
      /**
       * The ID of the store.
       */
      readonly ID: string;
      /**
       * The store image.
       */
      readonly image: dw.content.MediaFile;
      /**
       * The inventory list the store is associated with. If the
       *  store is not associated with a inventory list, or the inventory list does not
       *  exist, the method returns null.
       */
      readonly inventoryList: dw.catalog.ProductInventoryList;
      /**
       * The inventory list id the store is associated with. If the
       *  store is not associated with a inventory list, or the inventory list does not
       *  exist, the method returns null.
       */
      readonly inventoryListID: string;
      /**
       * The latitude of the store.
       */
      readonly latitude: number;
      /**
       * The longitude of the store.
       */
      readonly longitude: number;
      /**
       * The name of the store.
       */
      readonly name: string;
      /**
       * The phone of the store.
       */
      readonly phone: string;
      /**
       * The posEnabled flag for the Store.
       *  Indicates that this store uses Commerce Cloud Store for point-of-sale.
       */
      readonly posEnabled: boolean;
      /**
       * The postalCode of the store.
       */
      readonly postalCode: string;
      /**
       * The stateCode of the store.
       */
      readonly stateCode: string;
      /**
       * The storeEvents of the store.
       */
      readonly storeEvents: dw.content.MarkupText;
      /**
       * All the store groups this store belongs to.
       */
      readonly storeGroups: dw.util.Collection<dw.catalog.StoreGroup>;
      /**
       * The storeHours of the store.
       */
      readonly storeHours: dw.content.MarkupText;
      /**
       * The storeLocatorEnabled flag for the store.
       */
      readonly storeLocatorEnabled: boolean;

      /**
       * Returns the address1 of the store.
       *
       * @return address1 of the store
       */
      getAddress1(): string;
      /**
       * Returns the address2 of the store.
       *
       * @return address2 of the store
       */
      getAddress2(): string;
      /**
       * Returns the city of the store.
       *
       * @return city of the store
       */
      getCity(): string;
      /**
       * Returns the countryCode of the store.
       *
       * @return countryCode of the store
       */
      getCountryCode(): dw.value.EnumValue;
      /**
       * Returns the email of the store.
       *
       * @return email of the store
       */
      getEmail(): string;
      /**
       * Returns the fax of the store.
       *
       * @return fax of the store
       */
      getFax(): string;
      /**
       * Returns the ID of the store.
       *
       * @return ID of the store
       */
      getID(): string;
      /**
       * Returns the store image.
       *
       * @return the store image.
       */
      getImage(): dw.content.MediaFile;
      /**
       * Returns the inventory list the store is associated with. If the
       *  store is not associated with a inventory list, or the inventory list does not
       *  exist, the method returns null.
       *
       * @return ProductInventoryList or null
       */
      getInventoryList(): dw.catalog.ProductInventoryList;
      /**
       * Returns the inventory list id the store is associated with. If the
       *  store is not associated with a inventory list, or the inventory list does not
       *  exist, the method returns null.
       *
       * @return the inventory list id
       */
      getInventoryListID(): string;
      /**
       * Returns the latitude of the store.
       *
       * @return latitude of the store
       */
      getLatitude(): number;
      /**
       * Returns the longitude of the store.
       *
       * @return longitude of the store
       */
      getLongitude(): number;
      /**
       * Returns the name of the store.
       *
       * @return name of the store
       */
      getName(): string;
      /**
       * Returns the phone of the store.
       *
       * @return phone of the store
       */
      getPhone(): string;
      /**
       * Returns the postalCode of the store.
       *
       * @return postalCode of the store
       */
      getPostalCode(): string;
      /**
       * Returns the stateCode of the store.
       *
       * @return stateCode of the store
       */
      getStateCode(): string;
      /**
       * Returns the storeEvents of the store.
       *
       * @return storeEvents of the store
       */
      getStoreEvents(): dw.content.MarkupText;
      /**
       * Returns all the store groups this store belongs to.
       *
       * @return collection of store groups
       */
      getStoreGroups(): dw.util.Collection<dw.catalog.StoreGroup>;
      /**
       * Returns the storeHours of the store.
       *
       * @return storeHours of the store
       */
      getStoreHours(): dw.content.MarkupText;
      /**
       * Returns the demandwarePosEnabled flag for the store.
       *  Indicates that this store uses Commerce Cloud Store for point-of-sale.
       *
       * @return the demandwarePosEnabled flag
       */
      isDemandwarePosEnabled(): boolean;
      /**
       * Returns the posEnabled flag for the Store.
       *  Indicates that this store uses Commerce Cloud Store for point-of-sale.
       *
       * @return the posEnabled flag
       */
      isPosEnabled(): boolean;
      /**
       * Returns the storeLocatorEnabled flag for the store.
       *
       * @return the storeLocatorEnabled flag
       */
      isStoreLocatorEnabled(): boolean;
    }

    /**
     * Represents a store group. Store groups can be used to group the stores for different marketing purposes.
     */
    class StoreGroup extends dw.object.ExtensibleObject {
      /**
       * The ID of the store group.
       */
      readonly ID: string;
      /**
       * The name of the store group.
       */
      readonly name: string;
      /**
       * All the stores that are assigned to the store group.
       */
      readonly stores: dw.util.Collection<dw.catalog.Store>;

      /**
       * Returns the ID of the store group.
       *
       * @return ID of the store group
       */
      getID(): string;
      /**
       * Returns the name of the store group.
       *
       * @return name of the store group
       */
      getName(): string;
      /**
       * Returns all the stores that are assigned to the store group.
       *
       * @return collection of the stores
       */
      getStores(): dw.util.Collection<dw.catalog.Store>;
    }

    /**
     * Provides helper methods for getting stores based on id and querying for
     *  stores based on geolocation.
     */
    class StoreMgr {
      /**
       * All the store groups of the current site.
       */
      static readonly allStoreGroups: dw.util.Collection<dw.catalog.StoreGroup>;

      /**
       * Returns all the store groups of the current site.
       *
       * @return The store groups of the current site.
       */
      static getAllStoreGroups(): dw.util.Collection<dw.catalog.StoreGroup>;
      /**
       * Returns the store object with the specified id or null if store with this
       *  id does not exist in the site.
       * @param storeID the store identifier.
       * @return Store for specified id or null.
       */
      static getStore(storeID: string): dw.catalog.Store;
      /**
       * Returns the store group with the specified id or null if the store group with this id does not exist in the current site.
       * @param storeGroupID the store group identifier.
       * @return The store group for specified id or null.
       */
      static getStoreGroup(storeGroupID: string): dw.catalog.StoreGroup;
      /**
       * Search for stores based on geo-coordinates. The method returns a list of
       *  stores for the current site that are within a specified distance of a
       *  location on the earth and which optionally satisfy additional filter
       *  criteria. If no additional criteria are specified, then this method
       *  behaves similar to GetNearestStores pipelet. The criteria are specified
       *  as a querystring, using the same syntax as
       *  SystemObjectMgr.querySystemObjects(String, String, String, Object...)
       *
       *  The stores and their distance from the specified location are returned as
       *  a LinkedHashMap of Store objects to distances, sorting in ascending order
       *  by distance. The distance is interpreted either in miles or kilometers
       *  depending on the "distanceUnit" parameter.
       *
       *  The latitude and longitude of each store is determined by first looking
       *  at Store.getLatitude() and
       *  Store.getLongitude(). If these are not set, then the
       *  system deduces the location of the store by looking for a configured
       *  geolocation matching the store's postal and country codes.
       * @param latitude Latitude coordinate which is the center of the search area. Must not be null or an exception is thrown.
       * @param longitude Longitude coordinate which is the center of the search area. Must not be null or an exception is thrown.
       * @param distanceUnit The distance unit to be used for the calculation. Supported values are 'mi' and 'km' (for miles and kilometers respectively). If an invalid value is passed then 'km' will be used.
       * @param maxDistance Area (radius) in DistanceUnit where Stores will be searched for. If null is passed, a system default is used.
       * @param queryString optional filter criteria specified as querystring.
       * @param args the arguments to fill in the values in the querystring.
       * @return The stores and their distance from the specified location, sorted in ascending order by distance.
       */
      static searchStoresByCoordinates(
        latitude: number,
        longitude: number,
        distanceUnit: string,
        maxDistance: number,
        queryString: string,
        ...args: any[]
      ): dw.util.LinkedHashMap<Store, number>;
      /**
       * Convenience method.  Same as searchStoresByCoordinates(latitude, longitude, distanceUnit, maxDistance, null).
       * @param latitude Latitude coordinate which is the center of the search area. Must not be null or an exception is thrown.
       * @param longitude Longitude coordinate which is the center of the search area. Must not be null or an exception is thrown.
       * @param distanceUnit The distance unit to be used for the calculation. Supported values are 'mi' and 'km' (for miles and kilometers respectively). If an invalid value is passed then 'km' will be used.
       * @param maxDistance Area (radius) in DistanceUnit where Stores will be searched for. If null is passed, a system default is used.
       * @return The stores and their distance from the specified location, sorted in ascending order by distance.
       */
      static searchStoresByCoordinates(
        latitude: number,
        longitude: number,
        distanceUnit: string,
        maxDistance: number
      ): dw.util.LinkedHashMap<Store, number>;
      /**
       * Search for stores by country/postal code and optionally by additional
       *  filter criteria. This method is analagous to
       *  searchStoresByCoordinates(Number, Number, String, Number, String, Object...)
       *  but identifies a location on the earth indirectly using country and
       *  postal code. The method will look first in the saved geolocations of the
       *  system to find a geolocation matching the passed country and postal code.
       *  If none is found, this method will return an empty map. If one is found,
       *  it will use the latitude/longitude of the found geolocation as the center
       *  of the search.
       * @param countryCode The country code for the search area, must not be null.
       * @param postalCode The postal code for the center of the search area, must not be null.
       * @param distanceUnit The distance unit to be used for the calculation. Supported values are 'mi' and 'km' (for miles and kilometers respectively). If an invalid value is passed then 'km' will be used.
       * @param maxDistance Area (radius) in DistanceUnit where Stores will be searched for. If null is passed, a system default is used.
       * @param queryString An optional search querystring which provides additional criteria to filter stores by.
       * @param args The arguments providing the dynamic values to the querystring.
       * @return The stores and their distance from the specified location, sorted in ascending order by distance.
       */
      static searchStoresByPostalCode(
        countryCode: string,
        postalCode: string,
        distanceUnit: string,
        maxDistance: number,
        queryString: string,
        ...args: any[]
      ): dw.util.LinkedHashMap<Store, number>;
      /**
       * Convenience method.  Same as searchStoresByPostalCode(countryCode, postalCode, distanceUnit, maxDistance, null).
       * @param countryCode The country code for the search area, must not be null.
       * @param postalCode The postal code for the center of the search area, must not be null.
       * @param distanceUnit The distance unit to be used for the calculation. Supported values are 'mi' and 'km' (for miles and kilometers respectively). If an invalid value is passed then 'km' will be used.
       * @param maxDistance Area (radius) in DistanceUnit where Stores will be searched for. If null is passed, a system default is used.
       * @return The stores and their distance from the specified location, sorted in ascending order by distance.
       */
      static searchStoresByPostalCode(
        countryCode: string,
        postalCode: string,
        distanceUnit: string,
        maxDistance: number
      ): dw.util.LinkedHashMap<Store, number>;
    }

    /**
     * Represents a variant of a product variation. If the variant does not define an own value,
     *  the value is retrieved by fallback from variation groups (sorted by their position) or the
     *  variation master.
     */
    class Variant extends dw.catalog.Product {
      /**
       * All product links of the product variant.
       *
       *  If the variant does not define any product links, the product links are retrieved
       *  from the assigned variation groups, sorted by their position.
       *
       *  If none of the variation groups define any product links, the product links are
       *  retrieved from the master product.
       */
      readonly allProductLinks: dw.util.Collection<dw.catalog.ProductLink>;
      /**
       * The brand of the product variant.
       *
       *  If the variant does not define an own value for 'brand', the value is retrieved
       *  from the assigned variation groups, sorted by their position.
       *
       *  If none of the variation groups define a value for 'brand', the value of
       *  the master product is returned.
       */
      readonly brand: string;
      /**
       * The classification category of the product variant.
       *
       *  Please note that the classification category is always inherited
       *  from the master and cannot be overridden by the variant.
       */
      readonly classificationCategory: dw.catalog.Category;
      /**
       * The custom attributes of the variant.
       *
       *  Custom attributes are inherited from the master product and can
       *  be overridden by the variant.
       */
      readonly custom: VariantCustomAttributes;
      /**
       * The EAN of the product variant.
       *
       *  If the variant does not define an own value for 'EAN', the value is retrieved
       *  from the assigned variation groups, sorted by their position.
       *
       *  If none of the variation groups define a value for 'EAN', the value of
       *  the master product is returned.
       */
      readonly EAN: string;
      /**
       * The image of the product variant.
       *
       *  If the variant does not define an own value for 'image', the value is retrieved
       *  from the assigned variation groups, sorted by their position.
       *
       *  If none of the variation groups define a value for 'image', the value of
       *  the master product is returned.
       */
      readonly image: dw.content.MediaFile;
      /**
       * The long description of the product variant.
       *
       *  If the variant does not define an own value for 'longDescription', the value is retrieved
       *  from the assigned variation groups, sorted by their position.
       *
       *  If none of the variation groups define a value for 'longDescription', the value of
       *  the master product is returned.
       */
      readonly longDescription: dw.content.MarkupText;
      /**
       * The manufacturer name of the product variant.
       *
       *  If the variant does not define an own value for 'manufacturerName', the value is retrieved
       *  from the assigned variation groups, sorted by their position.
       *
       *  If none of the variation groups define a value for 'manufacturerName', the value of
       *  the master product is returned.
       */
      readonly manufacturerName: string;
      /**
       * The manufacturer sku of the product variant.
       *
       *  If the variant does not define an own value for 'manufacturerSKU', the value is retrieved
       *  from the assigned variation groups, sorted by their position.
       *
       *  If none of the variation groups define a value for 'manufacturerSKU', the value of
       *  the master product is returned.
       */
      readonly manufacturerSKU: string;
      /**
       * The ProductMaster for this mastered product.
       */
      readonly masterProduct: dw.catalog.Product;
      /**
       * The name of the product variant.
       *
       *  If the variant does not define an own value for 'name', the value is retrieved
       *  from the assigned variation groups, sorted by their position.
       *
       *  If none of the variation groups define a value for 'name', the value of
       *  the master product is returned.
       */
      readonly name: string;
      /**
       * The onlineFrom date of the product variant.
       *
       *  If the variant does not define an own value for 'onlineFrom', the value is retrieved
       *  from the assigned variation groups, sorted by their position.
       *
       *  If none of the variation groups define a value for 'onlineFrom', the value of
       *  the master product is returned.
       */
      readonly onlineFrom: Date;
      /**
       * The onlineTo date of the product variant.
       *
       *  If the variant does not define an own value for 'onlineTo', the value is retrieved
       *  from the assigned variation groups, sorted by their position.
       *
       *  If none of the variation groups define a value for 'onlineTo', the value of
       *  the master product is returned.
       */
      readonly onlineTo: Date;
      /**
       * Returns 'true' if the variant has any options, otherwise 'false'.
       *  Method also returns 'true' if the variant has not any options,
       *  but the related variation groups (sorted by position) or
       *  master product has options.
       */
      readonly optionProduct: boolean;
      /**
       * The pageDescription of the product variant.
       *
       *  If the variant does not define an own value for 'pageDescription', the value is retrieved
       *  from the assigned variation groups, sorted by their position.
       *
       *  If none of the variation groups define a value for 'pageDescription', the value of
       *  the master product is returned.
       */
      readonly pageDescription: string;
      /**
       * The pageKeywords of the product variant.
       *
       *  If the variant does not define an own value for 'pageKeywords', the value is retrieved
       *  from the assigned variation groups, sorted by their position.
       *
       *  If none of the variation groups define a value for 'pageKeywords', the value of
       *  the master product is returned.
       */
      readonly pageKeywords: string;
      /**
       * The pageTitle of the product variant.
       *
       *  If the variant does not define an own value for 'pageTitle', the value is retrieved
       *  from the assigned variation groups, sorted by their position.
       *
       *  If none of the variation groups define a value for 'pageTitle', the value of
       *  the master product is returned.
       */
      readonly pageTitle: string;
      /**
       * The pageURL of the product variant.
       *
       *  If the variant does not define an own value for 'pageURL', the value is retrieved
       *  from the assigned variation groups, sorted by their position.
       *
       *  If none of the variation groups define a value for 'pageURL', the value of
       *  the master product is returned.
       */
      readonly pageURL: string;
      /**
       * All product links of the product variant for which the target
       *  product is assigned to the current site catalog.
       *
       *  If the variant does not define any product links, the product links are retrieved
       *  from the assigned variation groups, sorted by their position
       *
       *  If none of the variation groups define any product links, the product links are retrieved
       *  from the master product.
       */
      readonly productLinks: dw.util.Collection<dw.catalog.ProductLink>;
      /**
       * The short description of the product variant.
       *
       *  If the variant does not define an own value for 'shortDescription', the value is retrieved
       *  from the assigned variation groups, sorted by their position.
       *
       *  If none of the variation groups define a value for 'shortDescription', the value of
       *  the master product is returned.
       */
      readonly shortDescription: dw.content.MarkupText;
      /**
       * The tax class id of the product variant.
       *
       *  If the variant does not define an own value for 'taxClassID', the value is retrieved
       *  from the assigned variation groups, sorted by their position.
       *
       *  If none of the variation groups define a value for 'taxClassID', the value of
       *  the master product is returned.
       */
      readonly taxClassID: string;
      /**
       * The rendering template name of the product variant.
       *
       *  If the variant does not define an own value for 'template', the value is retrieved
       *  from the assigned variation groups, sorted by their position.
       *
       *  If none of the variation groups define a value for 'template', the value of
       *  the master product is returned.
       */
      readonly template: string;
      /**
       * The thumbnail image of the product variant.
       *
       *  If the variant does not define an own value for 'thumbnail', the value is retrieved
       *  from the assigned variation groups, sorted by their position.
       *
       *  If none of the variation groups define a value for 'thumbnail', the value of
       *  the master product is returned.
       */
      readonly thumbnail: dw.content.MediaFile;
      /**
       * The sales unit of the product variant as defined by the
       *  master product.
       *
       *  If the variant does not define an own value for 'unit', the value is retrieved
       *  from the assigned variation groups, sorted by their position.
       *
       *  If none of the variation groups define a value for 'unit', the value of
       *  the master product is returned.
       */
      readonly unit: string;
      /**
       * The UPC of the product variant.
       *
       *  If the variant does not define an own value for 'UPC', the value is retrieved
       *  from the assigned variation groups, sorted by their position.
       *
       *  If none of the variation groups define a value for 'UPC', the value of
       *  the master product is returned.
       */
      readonly UPC: string;

      /**
       * Returns all product links of the product variant.
       *
       *  If the variant does not define any product links, the product links are retrieved
       *  from the assigned variation groups, sorted by their position.
       *
       *  If none of the variation groups define any product links, the product links are
       *  retrieved from the master product.
       *
       * @return All product links of the variant, variation group or master
       */
      getAllProductLinks(): dw.util.Collection<dw.catalog.ProductLink>;
      /**
       * Returns all product links of the specified type of the product variant.
       *
       *  If the variant does not define any product links of the specified type,
       *  the product links are retrieved for the specified type from the assigned
       *  variation groups, sorted by their position.
       *
       *  If none of the variation groups define any product links of the specified type,
       *  the product links are retrieved for the specified type from the master product.
       * @param type Type of the product link
       * @return Product links of specified type of the variant, variation group or master
       */
      getAllProductLinks(
        type: number
      ): dw.util.Collection<dw.catalog.ProductLink>;
      /**
       * Returns the brand of the product variant.
       *
       *  If the variant does not define an own value for 'brand', the value is retrieved
       *  from the assigned variation groups, sorted by their position.
       *
       *  If none of the variation groups define a value for 'brand', the value of
       *  the master product is returned.
       *
       * @return The brand of the variant, variation group or master
       */
      getBrand(): string;
      /**
       * Returns the classification category of the product variant.
       *
       *  Please note that the classification category is always inherited
       *  from the master and cannot be overridden by the variant.
       *
       * @return The classification category as defined for the master product of the variant
       */
      getClassificationCategory(): dw.catalog.Category;
      /**
       * Returns the custom attributes of the variant.
       *
       *  Custom attributes are inherited from the master product and can
       *  be overridden by the variant.
       *
       * @return the custom attributes of the variant.
       */
      getCustom(): VariantCustomAttributes;
      /**
       * Returns the EAN of the product variant.
       *
       *  If the variant does not define an own value for 'EAN', the value is retrieved
       *  from the assigned variation groups, sorted by their position.
       *
       *  If none of the variation groups define a value for 'EAN', the value of
       *  the master product is returned.
       *
       * @return The EAN of the variant, variation group or master
       */
      getEAN(): string;
      /**
       * Returns the image of the product variant.
       *
       *  If the variant does not define an own value for 'image', the value is retrieved
       *  from the assigned variation groups, sorted by their position.
       *
       *  If none of the variation groups define a value for 'image', the value of
       *  the master product is returned.
       *
       * @return The image of the variant, variation group or master
       */
      getImage(): dw.content.MediaFile;
      /**
       * Returns the long description of the product variant.
       *
       *  If the variant does not define an own value for 'longDescription', the value is retrieved
       *  from the assigned variation groups, sorted by their position.
       *
       *  If none of the variation groups define a value for 'longDescription', the value of
       *  the master product is returned.
       *
       * @return The long description of the variant, variation group or master
       */
      getLongDescription(): dw.content.MarkupText;
      /**
       * Returns the manufacturer name of the product variant.
       *
       *  If the variant does not define an own value for 'manufacturerName', the value is retrieved
       *  from the assigned variation groups, sorted by their position.
       *
       *  If none of the variation groups define a value for 'manufacturerName', the value of
       *  the master product is returned.
       *
       * @return The manufacturer name of the variant, variation group or master
       */
      getManufacturerName(): string;
      /**
       * Returns the manufacturer sku of the product variant.
       *
       *  If the variant does not define an own value for 'manufacturerSKU', the value is retrieved
       *  from the assigned variation groups, sorted by their position.
       *
       *  If none of the variation groups define a value for 'manufacturerSKU', the value of
       *  the master product is returned.
       *
       * @return The manufacturer sku of the variant, variation group or master
       */
      getManufacturerSKU(): string;
      /**
       * Returns the ProductMaster for this mastered product.
       *
       * @return the ProductMaster of this mastered product
       */
      getMasterProduct(): dw.catalog.Product;
      /**
       * Returns the name of the product variant.
       *
       *  If the variant does not define an own value for 'name', the value is retrieved
       *  from the assigned variation groups, sorted by their position.
       *
       *  If none of the variation groups define a value for 'name', the value of
       *  the master product is returned.
       *
       * @return The name of the variant, variation group or master
       */
      getName(): string;
      /**
       * Returns the onlineFrom date of the product variant.
       *
       *  If the variant does not define an own value for 'onlineFrom', the value is retrieved
       *  from the assigned variation groups, sorted by their position.
       *
       *  If none of the variation groups define a value for 'onlineFrom', the value of
       *  the master product is returned.
       *
       * @return The onlineFrom date of the variant, variation group or master
       */
      getOnlineFrom(): Date;
      /**
       * Returns the onlineTo date of the product variant.
       *
       *  If the variant does not define an own value for 'onlineTo', the value is retrieved
       *  from the assigned variation groups, sorted by their position.
       *
       *  If none of the variation groups define a value for 'onlineTo', the value of
       *  the master product is returned.
       *
       * @return The onlineTo date of the variant, variation group or master
       */
      getOnlineTo(): Date;
      /**
       * Returns the pageDescription of the product variant.
       *
       *  If the variant does not define an own value for 'pageDescription', the value is retrieved
       *  from the assigned variation groups, sorted by their position.
       *
       *  If none of the variation groups define a value for 'pageDescription', the value of
       *  the master product is returned.
       *
       * @return The pageDescription of the variant, variation group or master
       */
      getPageDescription(): string;
      /**
       * Returns the pageKeywords of the product variant.
       *
       *  If the variant does not define an own value for 'pageKeywords', the value is retrieved
       *  from the assigned variation groups, sorted by their position.
       *
       *  If none of the variation groups define a value for 'pageKeywords', the value of
       *  the master product is returned.
       *
       * @return The pageKeywords of the variant, variation group or master
       */
      getPageKeywords(): string;
      /**
       * Returns the pageTitle of the product variant.
       *
       *  If the variant does not define an own value for 'pageTitle', the value is retrieved
       *  from the assigned variation groups, sorted by their position.
       *
       *  If none of the variation groups define a value for 'pageTitle', the value of
       *  the master product is returned.
       *
       * @return The pageTitle of the variant, variation group or master
       */
      getPageTitle(): string;
      /**
       * Returns the pageURL of the product variant.
       *
       *  If the variant does not define an own value for 'pageURL', the value is retrieved
       *  from the assigned variation groups, sorted by their position.
       *
       *  If none of the variation groups define a value for 'pageURL', the value of
       *  the master product is returned.
       *
       * @return The pageURL of the variant, variation group or master
       */
      getPageURL(): string;
      /**
       * Returns all product links of the product variant for which the target
       *  product is assigned to the current site catalog.
       *
       *  If the variant does not define any product links, the product links are retrieved
       *  from the assigned variation groups, sorted by their position
       *
       *  If none of the variation groups define any product links, the product links are retrieved
       *  from the master product.
       *
       * @return Product links of the variant, variation group or master
       */
      getProductLinks(): dw.util.Collection<dw.catalog.ProductLink>;
      /**
       * Returns all product links of the specified type of the product variant
       *  for which the target product is assigned to the current site catalog.
       *
       *  If the variant does not define any product links of the specified type,
       *  the product links are retrieved for the specified type from the assigned
       *  variation groups, sorted by their position
       *
       *  If none of the variation groups define any product links of the specified type,
       *  the product links are retrieved for the specified type from the master product.
       * @param type Type of the product link
       * @return Product links of specified type of the variant, variation group or master
       */
      getProductLinks(type: number): dw.util.Collection<dw.catalog.ProductLink>;
      /**
       * Returns the short description of the product variant.
       *
       *  If the variant does not define an own value for 'shortDescription', the value is retrieved
       *  from the assigned variation groups, sorted by their position.
       *
       *  If none of the variation groups define a value for 'shortDescription', the value of
       *  the master product is returned.
       *
       * @return The short description of the variant, variation group or master
       */
      getShortDescription(): dw.content.MarkupText;
      /**
       * Returns the tax class id of the product variant.
       *
       *  If the variant does not define an own value for 'taxClassID', the value is retrieved
       *  from the assigned variation groups, sorted by their position.
       *
       *  If none of the variation groups define a value for 'taxClassID', the value of
       *  the master product is returned.
       *
       * @return The tax class id of the variant, variation group or master
       */
      getTaxClassID(): string;
      /**
       * Returns the rendering template name of the product variant.
       *
       *  If the variant does not define an own value for 'template', the value is retrieved
       *  from the assigned variation groups, sorted by their position.
       *
       *  If none of the variation groups define a value for 'template', the value of
       *  the master product is returned.
       *
       * @return The rendering template name of the variant, variation group or master
       */
      getTemplate(): string;
      /**
       * Returns the thumbnail image of the product variant.
       *
       *  If the variant does not define an own value for 'thumbnail', the value is retrieved
       *  from the assigned variation groups, sorted by their position.
       *
       *  If none of the variation groups define a value for 'thumbnail', the value of
       *  the master product is returned.
       *
       * @return The thumbnail image of the variant, variation group or master
       */
      getThumbnail(): dw.content.MediaFile;
      /**
       * Returns the sales unit of the product variant as defined by the
       *  master product.
       *
       *  If the variant does not define an own value for 'unit', the value is retrieved
       *  from the assigned variation groups, sorted by their position.
       *
       *  If none of the variation groups define a value for 'unit', the value of
       *  the master product is returned.
       *
       * @return The sales unit of the variant, variation group or master
       */
      getUnit(): string;
      /**
       * Returns the UPC of the product variant.
       *
       *  If the variant does not define an own value for 'UPC', the value is retrieved
       *  from the assigned variation groups, sorted by their position.
       *
       *  If none of the variation groups define a value for 'UPC', the value of
       *  the master product is returned.
       *
       * @return The UPC of the variant, variation group or master
       */
      getUPC(): string;
      /**
       * Returns 'true' if the variant has any options, otherwise 'false'.
       *  Method also returns 'true' if the variant has not any options,
       *  but the related variation groups (sorted by position) or
       *  master product has options.
       *
       * @return true if the variant has any options, false otherwise.
       */
      isOptionProduct(): boolean;
    }

    /**
     * Class representing a group of variants within a master product who share a
     *  common value for one or more variation attribute values. Variation groups are
     *  used to simplify merchandising of products.
     *  <p>
     *  From a more technical perspective, variation groups are defined by two things:
     *
     *  </p><ul>
     *  <li>A relation to a master product.</li>
     *  <li>A set of variation attributes which have fixed values.</li>
     *  </ul>
     *  A variant of the related master product is considered in the group if and
     *  only if it matches on the fixed variation attribute values.
     *  <p>
     *  Similar to a Variant, a VariationGroup does a fallback to the master product
     *  for all attributes (name, description, etc) and relations (recommendations,
     *  etc).</p>
     */
    class VariationGroup extends dw.catalog.Product {
      /**
       * All product links of the product variation group.
       *
       *  If the variation group does not define any product links, but the master product
       *  does, the product links of the master are returned.
       */
      readonly allProductLinks: dw.util.Collection<dw.catalog.ProductLink>;
      /**
       * The brand of the product variation group.
       *
       *  If the variation group does not define an own value for 'brand', the value of
       *  the master product is returned.
       */
      readonly brand: string;
      /**
       * The classification category of the product variation group.
       *
       *  Please note that the classification category is always inherited
       *  from the master and cannot be overridden by the variation group.
       */
      readonly classificationCategory: dw.catalog.Category;
      /**
       * The custom attributes of the variation group.
       *
       *  Custom attributes are inherited from the master product and can
       *  be overridden by the variation group.
       */
      readonly custom: VariationGroupCustomAttributes;
      /**
       * The EAN of the product variation group.
       *
       *  If the variation group does not define an own value for 'EAN', the value of
       *  the master product is returned.
       */
      readonly EAN: string;
      /**
       * The image of the product variation group.
       *
       *  If the variation group does not define an own value for 'image', the value of
       *  the master product is returned.
       */
      readonly image: dw.content.MediaFile;
      /**
       * The long description of the product variation group.
       *
       *  If the variation group does not define an own value for 'longDescription', the value of
       *  the master product is returned.
       */
      readonly longDescription: dw.content.MarkupText;
      /**
       * The manufacturer name of the product variation group.
       *
       *  If the variation group does not define an own value for 'manufacturerName', the value of
       *  the master product is returned.
       */
      readonly manufacturerName: string;
      /**
       * The manufacturer sku of the product variation group.
       *
       *  If the variation group does not define an own value for 'manufacturerSKU', the value of
       *  the master product is returned.
       */
      readonly manufacturerSKU: string;
      /**
       * The ProductMaster for this mastered product.
       */
      readonly masterProduct: dw.catalog.Product;
      /**
       * The name of the product variation group.
       *
       *  If the variation group does not define an own value for 'name', the value of
       *  the master product is returned.
       */
      readonly name: string;
      /**
       * The onlineFrom date of the product variation group.
       *
       *  If the variation group does not define an own value for 'onlineFrom', the value of
       *  the master product is returned.
       */
      readonly onlineFrom: Date;
      /**
       * The onlineTo date of the product variation group.
       *
       *  If the variation group does not define an own value for 'onlineTo', the value of
       *  the master product is returned.
       */
      readonly onlineTo: Date;
      /**
       * Returns 'true' if the variation group has any options, otherwise 'false'.
       *  Method also returns 'true' if the variation group has not any options,
       *  but the related master product has options.
       */
      readonly optionProduct: boolean;
      /**
       * The pageDescription of the product variation group.
       *
       *  If the variation group does not define an own value for 'pageDescription', the value of
       *  the master product is returned.
       */
      readonly pageDescription: string;
      /**
       * The pageKeywords of the product variation group.
       *
       *  If the variation group does not define an own value for 'pageKeywords', the value of
       *  the master product is returned.
       */
      readonly pageKeywords: string;
      /**
       * The pageTitle of the product variation group.
       *
       *  If the variation group does not define an own value for 'pageTitle', the value of
       *  the master product is returned.
       */
      readonly pageTitle: string;
      /**
       * The pageURL of the product variation group.
       *
       *  If the variation group does not define an own value for 'pageURL', the value of
       *  the master product is returned.
       */
      readonly pageURL: string;
      /**
       * All product links of the product variation group for which the target
       *  product is assigned to the current site catalog.
       *
       *  If the variation group does not define any product links, but the master product
       *  does, the product links of the master are returned.
       */
      readonly productLinks: dw.util.Collection<dw.catalog.ProductLink>;
      /**
       * The short description of the product variation group.
       *
       *  If the variation group does not define an own value for 'shortDescription', the value of
       *  the master product is returned.
       */
      readonly shortDescription: dw.content.MarkupText;
      /**
       * The tax class id of the product variation group.
       *
       *  If the variation group does not define an own value for 'taxClassID', the value of
       *  the master product is returned.
       */
      readonly taxClassID: string;
      /**
       * The rendering template name of the product variation group.
       *
       *  If the variation group does not define an own value for 'template', the value of
       *  the master product is returned.
       */
      readonly template: string;
      /**
       * The thumbnail image of the product variation group.
       *
       *  If the variation group does not define an own value for 'thumbnailImage', the value of
       *  the master product is returned.
       */
      readonly thumbnail: dw.content.MediaFile;
      /**
       * The sales unit of the product variation group as defined by the
       *  master product.
       *
       *  If the variation group does not define an own value for 'unit', the value of
       *  the master product is returned.
       */
      readonly unit: string;
      /**
       * The UPC of the product variation group.
       *
       *  If the variation group does not define an own value for 'UPC', the value of
       *  the master product is returned.
       */
      readonly UPC: string;

      /**
       * Returns all product links of the product variation group.
       *
       *  If the variation group does not define any product links, but the master product
       *  does, the product links of the master are returned.
       *
       * @return All product links of the variation group or master
       */
      getAllProductLinks(): dw.util.Collection<dw.catalog.ProductLink>;
      /**
       * Returns all product links of the specified type of the product variation group.
       *
       *  If the variation group does not define any product links, but the master product
       *  does, the product links of the master are returned.
       * @param type Type of the product link
       * @return Product links of specified type of the variation group or master
       */
      getAllProductLinks(
        type: number
      ): dw.util.Collection<dw.catalog.ProductLink>;
      /**
       * Returns the brand of the product variation group.
       *
       *  If the variation group does not define an own value for 'brand', the value of
       *  the master product is returned.
       *
       * @return The brand of the variation group or master
       */
      getBrand(): string;
      /**
       * Returns the classification category of the product variation group.
       *
       *  Please note that the classification category is always inherited
       *  from the master and cannot be overridden by the variation group.
       *
       * @return The classification category as defined for the master product of the variation group
       */
      getClassificationCategory(): dw.catalog.Category;
      /**
       * Returns the custom attributes of the variation group.
       *
       *  Custom attributes are inherited from the master product and can
       *  be overridden by the variation group.
       *
       * @return the custom attributes of the variation group.
       */
      getCustom(): VariationGroupCustomAttributes;
      /**
       * Returns the EAN of the product variation group.
       *
       *  If the variation group does not define an own value for 'EAN', the value of
       *  the master product is returned.
       *
       * @return The EAN of the variation group or master
       */
      getEAN(): string;
      /**
       * Returns the image of the product variation group.
       *
       *  If the variation group does not define an own value for 'image', the value of
       *  the master product is returned.
       *
       * @return The image of the variation group or master
       */
      getImage(): dw.content.MediaFile;
      /**
       * Returns the long description of the product variation group.
       *
       *  If the variation group does not define an own value for 'longDescription', the value of
       *  the master product is returned.
       *
       * @return The long description name of the variation group or master
       */
      getLongDescription(): dw.content.MarkupText;
      /**
       * Returns the manufacturer name of the product variation group.
       *
       *  If the variation group does not define an own value for 'manufacturerName', the value of
       *  the master product is returned.
       *
       * @return The manufacturer name of the variation group or master
       */
      getManufacturerName(): string;
      /**
       * Returns the manufacturer sku of the product variation group.
       *
       *  If the variation group does not define an own value for 'manufacturerSKU', the value of
       *  the master product is returned.
       *
       * @return The manufacturer sku of the variation group or master
       */
      getManufacturerSKU(): string;
      /**
       * Returns the ProductMaster for this mastered product.
       *
       * @return the ProductMaster of this mastered product
       */
      getMasterProduct(): dw.catalog.Product;
      /**
       * Returns the name of the product variation group.
       *
       *  If the variation group does not define an own value for 'name', the value of
       *  the master product is returned.
       *
       * @return The name of the variation group or master
       */
      getName(): string;
      /**
       * Returns the onlineFrom date of the product variation group.
       *
       *  If the variation group does not define an own value for 'onlineFrom', the value of
       *  the master product is returned.
       *
       * @return The onlineFrom date of the variation group or master
       */
      getOnlineFrom(): Date;
      /**
       * Returns the onlineTo date of the product variation group.
       *
       *  If the variation group does not define an own value for 'onlineTo', the value of
       *  the master product is returned.
       *
       * @return The onlineTo date of the variation group or master
       */
      getOnlineTo(): Date;
      /**
       * Returns the pageDescription of the product variation group.
       *
       *  If the variation group does not define an own value for 'pageDescription', the value of
       *  the master product is returned.
       *
       * @return The pageDescription of the variation group or master
       */
      getPageDescription(): string;
      /**
       * Returns the pageKeywords of the product variation group.
       *
       *  If the variation group does not define an own value for 'pageKeywords', the value of
       *  the master product is returned.
       *
       * @return The pageKeywords of the variation group or master
       */
      getPageKeywords(): string;
      /**
       * Returns the pageTitle of the product variation group.
       *
       *  If the variation group does not define an own value for 'pageTitle', the value of
       *  the master product is returned.
       *
       * @return The pageTitle of the variation group or master
       */
      getPageTitle(): string;
      /**
       * Returns the pageURL of the product variation group.
       *
       *  If the variation group does not define an own value for 'pageURL', the value of
       *  the master product is returned.
       *
       * @return The pageURL of the variation group or master
       */
      getPageURL(): string;
      /**
       * Returns all product links of the product variation group for which the target
       *  product is assigned to the current site catalog.
       *
       *  If the variation group does not define any product links, but the master product
       *  does, the product links of the master are returned.
       *
       * @return Product links of the variation group or master
       */
      getProductLinks(): dw.util.Collection<dw.catalog.ProductLink>;
      /**
       * Returns all product links of the specified type of the product variation group
       *  for which the target product is assigned to the current site catalog.
       *
       *  If the variation group does not define any product links of the specified type,
       *  but the master product does, the product links of the master are returned.
       * @param type Type of the product link
       * @return Product links of specified type of the variation group or master
       */
      getProductLinks(type: number): dw.util.Collection<dw.catalog.ProductLink>;
      /**
       * Returns the short description of the product variation group.
       *
       *  If the variation group does not define an own value for 'shortDescription', the value of
       *  the master product is returned.
       *
       * @return The short description name of the variation group or master
       */
      getShortDescription(): dw.content.MarkupText;
      /**
       * Returns the tax class id of the product variation group.
       *
       *  If the variation group does not define an own value for 'taxClassID', the value of
       *  the master product is returned.
       *
       * @return The tax class id of the variation group or master
       */
      getTaxClassID(): string;
      /**
       * Returns the rendering template name of the product variation group.
       *
       *  If the variation group does not define an own value for 'template', the value of
       *  the master product is returned.
       *
       * @return The rendering template name of the variation group or master
       */
      getTemplate(): string;
      /**
       * Returns the thumbnail image of the product variation group.
       *
       *  If the variation group does not define an own value for 'thumbnailImage', the value of
       *  the master product is returned.
       *
       * @return The thumbnail image of the variation group or master
       */
      getThumbnail(): dw.content.MediaFile;
      /**
       * Returns the sales unit of the product variation group as defined by the
       *  master product.
       *
       *  If the variation group does not define an own value for 'unit', the value of
       *  the master product is returned.
       *
       * @return The sales unit of the variation group or master
       */
      getUnit(): string;
      /**
       * Returns the UPC of the product variation group.
       *
       *  If the variation group does not define an own value for 'UPC', the value of
       *  the master product is returned.
       *
       * @return The UPC of the variation group or master
       */
      getUPC(): string;
      /**
       * Returns 'true' if the variation group has any options, otherwise 'false'.
       *  Method also returns 'true' if the variation group has not any options,
       *  but the related master product has options.
       *
       * @return true if the variation group has any options, false otherwise.
       */
      isOptionProduct(): boolean;
    }
  }

  namespace content {
    /**
     * Class representing a Content asset in Commerce Cloud Digital.
     */
    class Content extends dw.object.ExtensibleObject {
      /**
       * The Folder associated with this Content. The folder is
       *  used to determine the classification of the content.
       */
      readonly classificationFolder: dw.content.Folder;
      /**
       * The description in the current locale or null.
       */
      readonly description: string;
      /**
       * All folders to which this content is assigned.
       */
      readonly folders: dw.util.Collection<dw.content.Folder>;
      /**
       * The ID of the content asset.
       */
      readonly ID: string;
      /**
       * The name of the content asset.
       */
      readonly name: string;
      /**
       * The online status of the content.
       */
      readonly online: boolean;
      /**
       * The online status flag of the content.
       */
      readonly onlineFlag: boolean;
      /**
       * The page description for the content in the current locale
       *  or null if there is no page description.
       */
      readonly pageDescription: string;
      /**
       * The page keywords for the content in the current locale
       *  or null if there is no page title.
       */
      readonly pageKeywords: string;
      /**
       * All page meta tags, defined for this instance for which content can be generated.
       *
       *  The meta tag content is generated based on the content detail page meta tag context and rules.
       *  The rules are obtained from the current content or inherited from the default folder,
       *  up to the root folder.
       */
      readonly pageMetaTags: Array<dw.web.PageMetaTag>;
      /**
       * The page title for the content in the current locale
       *  or null if there is no page title.
       */
      readonly pageTitle: string;
      /**
       * The page URL for the content in the current locale
       *  or null if there is no page URL.
       */
      readonly pageURL: string;
      /**
       * The search status of the content.
       */
      readonly searchable: boolean;
      /**
       * The online status flag of the content.
       */
      readonly searchableFlag: boolean;
      /**
       * The contents change frequency needed for the sitemap creation.
       */
      readonly siteMapChangeFrequency: string;
      /**
       * The status if the content is included into the sitemap.
       */
      readonly siteMapIncluded: number;
      /**
       * The contents priority needed for the sitemap creation.
       *  If no priority is defined, the method returns 0.0.
       */
      readonly siteMapPriority: number;
      /**
       * The value of attribute 'template'.
       */
      readonly template: string;

      /**
       * Returns the Folder associated with this Content. The folder is
       *  used to determine the classification of the content.
       *
       * @return the classification Folder.
       */
      getClassificationFolder(): dw.content.Folder;
      /**
       * Returns the description in the current locale or null.
       *
       * @return the description in the current locale or null.
       */
      getDescription(): string;
      /**
       * Returns all folders to which this content is assigned.
       *
       * @return Collection of Folder objects.
       */
      getFolders(): dw.util.Collection<dw.content.Folder>;
      /**
       * Returns the ID of the content asset.
       *
       * @return the ID of the content asset.
       */
      getID(): string;
      /**
       * Returns the name of the content asset.
       *
       * @return the name of the content asset.
       */
      getName(): string;
      /**
       * Returns the online status flag of the content.
       *
       * @return true if the content is online, false otherwise.
       */
      getOnlineFlag(): boolean;
      /**
       * Returns the page description for the content in the current locale
       *  or null if there is no page description.
       *
       * @return the page description for the content in the current locale or null if there is no page description.
       */
      getPageDescription(): string;
      /**
       * Returns the page keywords for the content in the current locale
       *  or null if there is no page title.
       *
       * @return the page keywords for the content in the current locale or null if there is no page title.
       */
      getPageKeywords(): string;
      /**
       * Returns the page meta tag for the specified id.
       *
       *  The meta tag content is generated based on the content detail page meta tag context and rule.
       *  The rule is obtained from the current content or inherited from the default folder,
       *  up to the root folder.
       *
       *  Null will be returned if the meta tag is undefined on the current instance, or if no rule can be found for the
       *  current context, or if the rule resolves to an empty string.
       * @param id the ID to get the page meta tag for
       * @return page meta tag containing content generated based on rules
       */
      getPageMetaTag(id: string): dw.web.PageMetaTag;
      /**
       * Returns all page meta tags, defined for this instance for which content can be generated.
       *
       *  The meta tag content is generated based on the content detail page meta tag context and rules.
       *  The rules are obtained from the current content or inherited from the default folder,
       *  up to the root folder.
       *
       * @return page meta tags defined for this instance, containing content generated based on rules
       */
      getPageMetaTags(): Array<dw.web.PageMetaTag>;
      /**
       * Returns the page title for the content in the current locale
       *  or null if there is no page title.
       *
       * @return the page title for the content in the current locale or null if there is no page title.
       */
      getPageTitle(): string;
      /**
       * Returns the page URL for the content in the current locale
       *  or null if there is no page URL.
       *
       * @return the page URL for the content in the current locale or null if there is no page URL.
       */
      getPageURL(): string;
      /**
       * Returns the online status flag of the content.
       *
       * @return true if the content is searchable, false otherwise.
       */
      getSearchableFlag(): boolean;
      /**
       * Returns the contents change frequency needed for the sitemap creation.
       *
       * @return The contents sitemap change frequency.
       */
      getSiteMapChangeFrequency(): string;
      /**
       * Returns the status if the content is included into the sitemap.
       *
       * @return the value of the attribute 'siteMapIncluded'
       */
      getSiteMapIncluded(): number;
      /**
       * Returns the contents priority needed for the sitemap creation.
       *  If no priority is defined, the method returns 0.0.
       *
       * @return The contents sitemap priority.
       */
      getSiteMapPriority(): number;
      /**
       * Returns the value of attribute 'template'.
       *
       * @return the value of the attribute 'template'
       */
      getTemplate(): string;
      /**
       * Returns the online status of the content.
       *
       * @return true if the content is online, false otherwise.
       */
      isOnline(): boolean;
      /**
       * Returns the search status of the content.
       *
       * @return true if the content is searchable, false otherwise.
       */
      isSearchable(): boolean;
    }

    /**
     * Provides helper methods for getting content assets, library folders and the
     *  content library of the current site.
     */
    class ContentMgr {
      /**
       * The input string to identify that the library is a private site library when invoking getLibrary(String).
       */
      static readonly PRIVATE_LIBRARY = "PrivateLibrary";

      /**
       * The content library of the current site.
       */
      static readonly siteLibrary: dw.content.Library;

      /**
       * Returns the content with the corresponding identifier within the current
       *  site's site library.
       * @param id the ID of the content asset to find.
       * @return the content if found, or null if not found.
       */
      static getContent(id: string): dw.content.Content;
      /**
       * Returns the content with the corresponding identifier within the specified library.
       * @param library the content library to look for the content in
       * @param id the ID of the content asset to find.
       * @return the content if found, or null if not found.
       */
      static getContent(
        library: dw.content.Library,
        id: string
      ): dw.content.Content;
      /**
       * Returns the folder identified by the specified id within the current
       *  site's site library.
       * @param id the ID of the folder to find.
       * @return the folder, or null if not found.
       */
      static getFolder(id: string): dw.content.Folder;
      /**
       * Returns the folder identified by the specified id within the specified library.
       * @param library the content library to look for the folder in
       * @param id the ID of the folder to find.
       * @return the folder, or null if not found.
       */
      static getFolder(
        library: dw.content.Library,
        id: string
      ): dw.content.Folder;
      /**
       * Returns the content library specified by the given id. If PRIVATE_LIBRARY is used, then the current
       *  site's private library will be returned.
       * @param libraryId the id of the library to return.
       * @return the library for the passed id. Returns null if there is no content library with that id.
       */
      static getLibrary(libraryId: string): dw.content.Library;
      /**
       * Returns the content library of the current site.
       *
       * @return the content library of the current site, or null if there is not content library assigned to the current site.
       */
      static getSiteLibrary(): dw.content.Library;
    }

    /**
     * The class is the central interface to a content search result and a content
     *  search refinement. It also provides utility methods to generate a search URL.
     */
    class ContentSearchModel extends dw.catalog.SearchModel {
      /**
       * URL Parameter for the content ID
       */
      static readonly CONTENTID_PARAMETER = "cid";
      /**
       * URL Parameter for the folder ID
       */
      static readonly FOLDERID_PARAMETER = "fdid";

      /**
       * An Iterator containing all Content Assets that are the result of the
       *  search.
       */
      readonly content: dw.util.Iterator<dw.content.Content>;
      /**
       * The content ID against which the search results apply.
       */
      contentID: string;
      /**
       * The deepest common folder of all content assets in the search result.
       */
      readonly deepestCommonFolder: dw.content.Folder;
      /**
       * The method returns true, if the content search result is filtered by the folder and it is not subsequently
       *  possible to search for content assets that belong to no folder (e.g. those for Page Designer).
       */
      filteredByFolder: boolean;
      /**
       * The folder against which the search results apply.
       */
      readonly folder: dw.content.Folder;
      /**
       * The folder ID against which the search results apply.
       */
      folderID: string;
      /**
       * The method returns true, if this is a pure search for a folder. The
       *  method checks, that a folder ID is specified and no search phrase is
       *  specified.
       */
      readonly folderSearch: boolean;
      /**
       * All page meta tags, defined for this instance for which content can be generated.
       *
       *  The meta tag content is generated based on the content listing page meta tag context and rules.
       *  The rules are obtained from the current folder context or inherited from the parent folder,
       *  up to the root folder.
       */
      readonly pageMetaTags: Array<dw.web.PageMetaTag>;
      /**
       * Get the flag that determines if the folder search will
       *  be recursive.
       */
      recursiveFolderSearch: boolean;
      /**
       * The method returns true, if the search is refined by a folder.
       *  The method checks, that a folder ID is specified.
       */
      readonly refinedByFolder: boolean;
      /**
       * Identifies if this is a folder search and is refined with further
       *  criteria, like a name refinement or an attribute refinement.
       */
      readonly refinedFolderSearch: boolean;
      /**
       * The set of search refinements used in this search.
       */
      readonly refinements: dw.content.ContentSearchRefinements;

      /**
       * Constructs a new ContentSearchModel.
       *
       */
      constructor();

      /**
       * Returns an Iterator containing all Content Assets that are the result of the
       *  search.
       *
       * @return an Iterator containing all Content Assets that are the result of the search.
       */
      getContent(): dw.util.Iterator<dw.content.Content>;
      /**
       * Returns the content ID against which the search results apply.
       *
       * @return the content ID against which the search results apply.
       */
      getContentID(): string;
      /**
       * Returns the deepest common folder of all content assets in the search result.
       *
       * @return the deepest common folder of all content assets in the search result of this search model.
       */
      getDeepestCommonFolder(): dw.content.Folder;
      /**
       * Returns the folder against which the search results apply.
       *
       * @return the folder against which the search results apply.
       */
      getFolder(): dw.content.Folder;
      /**
       * Returns the folder ID against which the search results apply.
       *
       * @return the folder ID against which the search results apply.
       */
      getFolderID(): string;
      /**
       * Returns the page meta tag for the specified id.
       *
       *  The meta tag content is generated based on the content listing page meta tag context and rule.
       *  The rule is obtained from the current folder context or inherited from the parent folder,
       *  up to the root folder.
       *
       *  Null will be returned if the meta tag is undefined on the current instance, or if no rule can be found for the
       *  current context, or if the rule resolves to an empty string.
       * @param id the ID to get the page meta tag for
       * @return page meta tag containing content generated based on rules
       */
      getPageMetaTag(id: string): dw.web.PageMetaTag;
      /**
       * Returns all page meta tags, defined for this instance for which content can be generated.
       *
       *  The meta tag content is generated based on the content listing page meta tag context and rules.
       *  The rules are obtained from the current folder context or inherited from the parent folder,
       *  up to the root folder.
       *
       * @return page meta tags defined for this instance, containing content generated based on rules
       */
      getPageMetaTags(): Array<dw.web.PageMetaTag>;
      /**
       * Returns the set of search refinements used in this search.
       *
       * @return the set of search refinements used in this search.
       */
      getRefinements(): dw.content.ContentSearchRefinements;
      /**
       * The method returns true, if the content search result is filtered by the folder and it is not subsequently
       *  possible to search for content assets that belong to no folder (e.g. those for Page Designer).
       *
       * @return True if this is filtered by the folder of the content asset.
       */
      isFilteredByFolder(): boolean;
      /**
       * The method returns true, if this is a pure search for a folder. The
       *  method checks, that a folder ID is specified and no search phrase is
       *  specified.
       *
       * @return True if this is a folder search.
       */
      isFolderSearch(): boolean;
      /**
       * Get the flag that determines if the folder search will
       *  be recursive.
       *
       * @return true if the folder search will be recursive, false otherwise
       */
      isRecursiveFolderSearch(): boolean;
      /**
       * The method returns true, if the search is refined by a folder.
       *  The method checks, that a folder ID is specified.
       *
       * @return true, if the search is refined by a folder, false otherwise.
       */
      isRefinedByFolder(): boolean;
      /**
       * Identifies if this is a folder search and is refined with further
       *  criteria, like a name refinement or an attribute refinement.
       *
       * @return true if this is a folder search and is refined with further criteria, false otherwise.
       */
      isRefinedFolderSearch(): boolean;
      /**
       * Execute the search.
       *
       */
      search(): void;
      /**
       * Sets the contentID used in this search.
       * @param contentID the contentID used in this search.
       */
      setContentID(contentID: string): void;
      /**
       * Set a flag to indicate if the search is filtered by the folder. Must be set to false to return content assets that
       *  do not belong to any folder.
       * @param filteredByFolder filter the search result by folder
       */
      setFilteredByFolder(filteredByFolder: boolean): void;
      /**
       * Sets the folderID used in this search.
       * @param folderID the folderID used in this search.
       */
      setFolderID(folderID: string): void;
      /**
       * Set a flag to indicate if the search in folder should be recursive.
       * @param recurse recurse the folder in the search
       */
      setRecursiveFolderSearch(recurse: boolean): void;
      /**
       * Returns an URL that you can use to execute a query for a specific
       *  Content. The passed action is used to build an initial url. All search
       *  specific attributes are appended.
       * @param action the pipeline action to use.
       * @param cid the content id.
       * @return an URL that you can use to execute a query for a specific Content. The passed action is used to build an initial url. All search specific attributes are appended.
       */
      static urlForContent(action: string, cid: string): dw.web.URL;
      /**
       * Returns an URL that you can use to execute a query for a specific
       *  Content. The passed url can be either a full url or just the name for a
       *  pipeline. In the later case a relative URL is created.
       * @param url the URL to use when constructing the new URL.
       * @param cid the content id.
       * @return an URL that you can use to execute a query for a specific Content. The passed url can be either a full url or just the name for a pipeline. In the later case a relative URL is created.
       */
      static urlForContent(url: dw.web.URL, cid: string): dw.web.URL;
      /**
       * Returns an URL that you can use to execute a query for a specific
       *  Folder.
       * @param action the pipeline action to use.
       * @param fid the id of the Folder to use.
       * @return an URL that you can use to execute a query for a specific Folder.
       */
      static urlForFolder(action: string, fid: string): dw.web.URL;
      /**
       * Returns an URL that you can use to execute a query for a specific
       *  Folder.
       * @param url the URL to use in constructing the new URL.
       * @param fid the id of the Folder to use.
       * @return an URL that you can use to execute a query for a specific Folder.
       */
      static urlForFolder(url: dw.web.URL, fid: string): dw.web.URL;
      /**
       * Returns an URL that you can use to execute a query for a specific
       *  attribute name-value pair.
       * @param action the pipeline action to use.
       * @param name the name of the attribute.
       * @param value the value for the attribute.
       * @return an URL that you can use to execute a query for a specific attribute name-value pair.
       */
      static urlForRefine(
        action: string,
        name: string,
        value: string
      ): dw.web.URL;
      /**
       * Returns an URL that you can use to execute a query for a specific
       *  attribute name-value pair.
       * @param url the URL to use when constructing the new URL.
       * @param name the name of the attribute.
       * @param value the value for the attribute.
       * @return an URL that you can use to execute a query for a specific attribute name-value pair.
       */
      static urlForRefine(
        url: dw.web.URL,
        name: string,
        value: string
      ): dw.web.URL;
      /**
       * Returns an URL that you can use to re-execute the query using the
       *  specified pipeline action and folder refinement.
       * @param action the action to use.
       * @param refineFolderID the folder ID to use as a refinement.
       * @return an URL that you can use to re-execute the exact same query using the specified pipeline action and folder refinement.
       */
      urlRefineFolder(action: string, refineFolderID: string): dw.web.URL;
      /**
       * Returns an URL that you can use to re-execute the query using the
       *  specified URL and folder refinement.
       * @param url the existing URL to use when constructing the new URL.
       * @param refineFolderID the ID of the folder refinement to use.
       * @return an URL that you can use to re-execute the query using the specified URL and folder refinement.
       */
      urlRefineFolder(url: dw.web.URL, refineFolderID: string): dw.web.URL;
      /**
       * Returns an URL that you can use to re-execute the query with no folder
       *  refinement.
       * @param action the pipeline action to use in the URL.
       * @return an URL that you can use to re-execute the query with no folder refinement.
       */
      urlRelaxFolder(action: string): dw.web.URL;
      /**
       * Returns an URL that you can use to re-execute the query with no folder
       *  refinement.
       * @param url the existing URL to use when constructing the new URL.
       * @return an URL that you can use to re-execute the query with no folder refinement.
       */
      urlRelaxFolder(url: dw.web.URL): dw.web.URL;
    }

    /**
     * This class provides an interface to refinement options for content search.
     */
    class ContentSearchRefinementDefinition extends dw.catalog
      .SearchRefinementDefinition {
      /**
       * Identifies if this is a folder refinement.
       */
      readonly folderRefinement: boolean;

      /**
       * Identifies if this is a folder refinement.
       *
       * @return true if this is a category refinement, false otherwise.
       */
      isFolderRefinement(): boolean;
    }

    /**
     * Represents the value of a content search refinement.
     */
    class ContentSearchRefinementValue extends dw.catalog
      .SearchRefinementValue {}

    /**
     * This class provides an interface to refinement options for the content asset
     *  search. In a typical usage, the client application UI displays the search
     *  refinements along with the search results and allows customers to &quot;refine&quot;
     *  the results (i.e. limit the results that are shown) by specifying additional
     *  criteria, or &quot;relax&quot; (i.e. broaden) the results after previously refining.
     *  The two types of content search refinements are:
     *
     *  <ul>
     *  <li><b>Refine By Folder:</b> Limit the content assets to those assigned to
     *  specific child/ancestor folder of the search folder.</li>
     *  <li><b>Refine By Attribute:</b> Limit the content assets to those with
     *  specific values for a given attribute. Values may be grouped into &quot;buckets&quot;
     *  so that a given set of values are represented as a single refinement option.</li>
     *  </ul>
     *
     *  Rendering a content search refinement UI typically begins with iterating the
     *  refinement definitions for the search result. Call
     *  <a href="class_dw_catalog_SearchRefinements.html#dw_catalog_SearchRefinements_getRefinementDefinitions_DetailAnchor">SearchRefinements.getRefinementDefinitions()</a> or
     *  <a href="class_dw_catalog_SearchRefinements.html#dw_catalog_SearchRefinements_getAllRefinementDefinitions_DetailAnchor">SearchRefinements.getAllRefinementDefinitions()</a> to
     *  retrieve the appropriate collection of refinement definitions. For each
     *  definition, display the available refinement values by calling
     *  <a href="class_dw_content_ContentSearchRefinements.html#dw_content_ContentSearchRefinements_getAllRefinementValues_ContentSearchRefinementDefinition_DetailAnchor">getAllRefinementValues(ContentSearchRefinementDefinition)</a>. Depending
     *  on the type of the refinement definition, the application must use slightly
     *  different logic to display the refinement widgets. For all 2 types, methods
     *  in <a href="class_dw_content_ContentSearchModel.html">ContentSearchModel</a> are used to generate URLs to render
     *  hyperlinks in the UI. When clicked, these links trigger a call to the Search
     *  pipelet which in turn applies the appropriate filters to the native search
     *  result.
     */
    class ContentSearchRefinements extends dw.catalog.SearchRefinements {
      /**
       * The appropriate folder refinement definition based on the search
       *  result. The folder refinement definition returned will be the first that
       *  can be found traversing the folder tree upward starting at the deepest
       *  common folder of the search result.
       */
      readonly folderRefinementDefinition: dw.content.ContentSearchRefinementDefinition;
      /**
       * A collection of matching folders.
       */
      readonly matchingFolders: dw.util.Collection<dw.content.Folder>;

      /**
       * Returns the number of search hits for the passed folder object.
       * @param folder Folder object.
       * @return Number of search hits.
       */
      getFolderHits(folder: dw.content.Folder): number;
      /**
       * Returns the appropriate folder refinement definition based on the search
       *  result. The folder refinement definition returned will be the first that
       *  can be found traversing the folder tree upward starting at the deepest
       *  common folder of the search result.
       *
       * @return The folder refinement definition or null if none can be found.
       */
      getFolderRefinementDefinition(): dw.content.ContentSearchRefinementDefinition;
      /**
       * Returns a collection of matching folders.
       *
       * @return Collection of matching folders.
       */
      getMatchingFolders(): dw.util.Collection<dw.content.Folder>;
      /**
       * Returns folder refinement values based on the current search result
       *  filtered such that only folder refinements representing children of the
       *  given folder are present. If no folder is given, the method uses the
       *  library's root folder. The refinement value content counts represent all
       *  hits contained in the library tree starting at the corresponding child
       *  folder.
       * @param folder The folder to return child folder refinement values for.
       * @return The refinement values for all child folders of the given folder.
       */
      getNextLevelFolderRefinementValues(
        folder: dw.content.Folder
      ): dw.util.Collection<dw.content.ContentSearchRefinementValue>;
      /**
       * Returns the refinement value (incl. content hit count) for the given
       *  refinement definition and the given (selected) value.
       * @param definition The definition to return the refinement for.
       * @param value The value to return the refinement value for.
       * @return The refinement value.
       */
      getRefinementValue(
        definition: dw.content.ContentSearchRefinementDefinition,
        value: string
      ): dw.content.ContentSearchRefinementValue;
      /**
       * Returns the refinement value (incl. content hit count) for the given
       *  attribute refinement and the given (selected) value.
       * @param name The name of the refinement attribute.
       * @param value The value to return the refinement value for.
       * @return The refinement value.
       */
      getRefinementValue(
        name: string,
        value: string
      ): dw.content.ContentSearchRefinementValue;
    }

    /**
     * Class representing a folder for organizing content assets in Commerce Cloud Digital.
     */
    class Folder extends dw.object.ExtensibleObject {
      /**
       * The content objects for this folder, sorted by position.
       */
      readonly content: dw.util.Collection<dw.content.Content>;
      /**
       * The description for the folder as known in the current
       *  locale or null if it cannot be found.
       */
      readonly description: string;
      /**
       * The display name for the folder as known in the current
       *  locale or null if it cannot be found.
       */
      readonly displayName: string;
      /**
       * The ID of the folder. The ID can be used to uniquely
       *  identify a folder within any given library. This folder ID provides
       *  an alternative lookup mechanism for folders frequently used in
       *  the storefront.
       */
      readonly ID: string;
      /**
       * Indicates if the folder is set online or
       *  offline. Initially, all folders are set online.
       */
      readonly online: boolean;
      /**
       * The online content objects for this folder, sorted by position.
       */
      readonly onlineContent: dw.util.Collection<dw.content.Content>;
      /**
       * The online subfolders of this folder, sorted by position.
       */
      readonly onlineSubFolders: dw.util.Collection<dw.content.Folder>;
      /**
       * The page description for this folder using the value in
       *  the current locale, or returns null if no value was found.
       */
      readonly pageDescription: string;
      /**
       * The page keywords for this folder using the value in
       *  the current locale, or returns null if no value was found.
       */
      readonly pageKeywords: string;
      /**
       * The page title for this folder using the value in
       *  the current locale, or returns null if no value was found.
       */
      readonly pageTitle: string;
      /**
       * The page URL for this folder using the value in
       *  the current locale, or returns null if no value was found.
       */
      readonly pageURL: string;
      /**
       * The parent folder of this folder.
       */
      readonly parent: dw.content.Folder;
      /**
       * Indicates if this is the root folder.
       */
      readonly root: boolean;
      /**
       * The folder's sitemap change frequency.
       */
      readonly siteMapChangeFrequency: string;
      /**
       * The folder's sitemap inclusion.
       */
      readonly siteMapIncluded: number;
      /**
       * The folder's sitemap priority.
       */
      readonly siteMapPriority: number;
      /**
       * The subfolders of this folder, sorted by position.
       */
      readonly subFolders: dw.util.Collection<dw.content.Folder>;
      /**
       * The name of the template used to render the folder
       *  in the store front.
       */
      readonly template: string;

      /**
       * Returns the content objects for this folder, sorted by position.
       *
       * @return the content objects for this folder, sorted by position.
       */
      getContent(): dw.util.Collection<dw.content.Content>;
      /**
       * Returns the description for the folder as known in the current
       *  locale or null if it cannot be found.
       *
       * @return the description for the folder as known in the current locale or null if it cannot be found.
       */
      getDescription(): string;
      /**
       * Returns the display name for the folder as known in the current
       *  locale or null if it cannot be found.
       *
       * @return the display name for the folder as known in the current locale or null if it cannot be found.
       */
      getDisplayName(): string;
      /**
       * Returns the ID of the folder. The ID can be used to uniquely
       *  identify a folder within any given library. This folder ID provides
       *  an alternative lookup mechanism for folders frequently used in
       *  the storefront.
       *
       * @return the ID of the folder.
       */
      getID(): string;
      /**
       * Returns the online content objects for this folder, sorted by position.
       *
       * @return the online content objects for this folder, sorted by position.
       */
      getOnlineContent(): dw.util.Collection<dw.content.Content>;
      /**
       * Returns the online subfolders of this folder, sorted by position.
       *
       * @return the online subfolders of this folder, sorted by position.
       */
      getOnlineSubFolders(): dw.util.Collection<dw.content.Folder>;
      /**
       * Returns the page description for this folder using the value in
       *  the current locale, or returns null if no value was found.
       *
       * @return the page description for this folder using the value in the current locale, or returns null if no value was found.
       */
      getPageDescription(): string;
      /**
       * Returns the page keywords for this folder using the value in
       *  the current locale, or returns null if no value was found.
       *
       * @return the page keywords for this folder using the value in the current locale, or returns null if no value was found.
       */
      getPageKeywords(): string;
      /**
       * Returns the page title for this folder using the value in
       *  the current locale, or returns null if no value was found.
       *
       * @return the page title for this folder using the value in the current locale, or returns null if no value was found.
       */
      getPageTitle(): string;
      /**
       * Returns the page URL for this folder using the value in
       *  the current locale, or returns null if no value was found.
       *
       * @return the page URL for this folder using the value in the current locale, or returns null if no value was found.
       */
      getPageURL(): string;
      /**
       * Returns the parent folder of this folder.
       *
       * @return the parent folder of this folder.
       */
      getParent(): dw.content.Folder;
      /**
       * Returns the folder's sitemap change frequency.
       *
       * @return the value of the attribute 'siteMapChangeFrequency'.
       */
      getSiteMapChangeFrequency(): string;
      /**
       * Returns the folder's sitemap inclusion.
       *
       * @return the value of the attribute 'siteMapIncluded'.
       */
      getSiteMapIncluded(): number;
      /**
       * Returns the folder's sitemap priority.
       *
       * @return the value of the attribute 'siteMapPriority'.
       */
      getSiteMapPriority(): number;
      /**
       * Returns the subfolders of this folder, sorted by position.
       *
       * @return the subfolders of this folder, sorted by position.
       */
      getSubFolders(): dw.util.Collection<dw.content.Folder>;
      /**
       * Returns the name of the template used to render the folder
       *  in the store front.
       *
       * @return the name of the template used to render the folder.
       */
      getTemplate(): string;
      /**
       * Indicates if the folder is set online or
       *  offline. Initially, all folders are set online.
       *
       * @return true if the folder is online, false otherwise.
       */
      isOnline(): boolean;
      /**
       * Indicates if this is the root folder.
       *
       * @return true if this is the root folder, false otherwise.
       */
      isRoot(): boolean;
    }

    /**
     * Class representing a collection of <a href="class_dw_content_Content.html">Content</a> assets, and a
     *  <a href="class_dw_content_Folder.html">Folder</a> hierarchy organizing these content assets.
     *  Currently only one library is allowed per site. An instance of this library
     *  can be obtained by calling <a href="class_dw_content_ContentMgr.html#dw_content_ContentMgr_getSiteLibrary_DetailAnchor">ContentMgr.getSiteLibrary()</a>.
     */
    class Library extends dw.object.ExtensibleObject {
      /**
       * The CMS channel of the library.
       */
      readonly CMSChannelID: string;
      /**
       * The display name for the library as known in the current
       *  locale or null if it cannot be found.
       */
      readonly displayName: string;
      /**
       * The ID of this library.
       */
      readonly ID: string;
      /**
       * The root folder for this library.
       */
      readonly root: dw.content.Folder;

      /**
       * Returns the CMS channel of the library.
       *
       * @return the CMS channel of the library
       */
      getCMSChannelID(): string;
      /**
       * Returns the display name for the library as known in the current
       *  locale or null if it cannot be found.
       *
       * @return the display name for the library as known in the current locale or null if it cannot be found.
       */
      getDisplayName(): string;
      /**
       * Returns the ID of this library.
       *
       * @return the ID of this library.
       */
      getID(): string;
      /**
       * Returns the root folder for this library.
       *
       * @return the root Folder for this library.
       */
      getRoot(): dw.content.Folder;
    }

    /**
     * The class represents a content snippet with markup. This is typically a
     *  HTML content snippet. The class also processes the special links from
     *  Commerce Cloud Digital content management and automatically rewrites them into
     *  links for use in the storefront.
     *  <p>
     *  The following special links can be used inside of a MarkupText:
     *
     *  </p><ul>
     *  <p>
     *  </p><li><code><b>$url(&apos;&lt;pipeline&gt;&apos; [, &apos;&lt;key1&gt;&apos;, &apos;&lt;value1&gt;&apos;, &apos;&lt;key2&gt;&apos;, &apos;&lt;value2&gt;&apos;, ...])$</b></code></li>
     *  <p>
     *  <u>Description:</u><br>
     *  The <code>$url()$</code> function creates and absolute URL and retains the protocol incoming
     *  request.
     *
     *  </p><p>
     *  <u>Example:</u><br>
     *  MarkupText:<br>
     *  &#xA0;&#xA0;&#xA0;<code>$url(&apos;MyLinkPipeline-Start&apos;, &apos;key1&apos;, &apos;value1&apos;, &apos;key2&apos;, &apos;value2&apos;)$</code><br>
     *  is rewritten to:<br>
     *  &#xA0;&#xA0;&#xA0;<code>http://&lt;host&gt;:&lt;port&gt;/on/demandware.store/&lt;current site&gt;/default/MyLinkPipeline-Start?key1=value1&amp;key2=value2</code><br>
     *  Note that the incoming protocol was http in the example above.
     *
     *
     *  </p><p>
     *  </p><li><code><b>$httpUrl(&apos;&lt;pipeline&gt;&apos; [, &apos;&lt;key1&gt;&apos;, &apos;&lt;value1&gt;&apos;, &apos;&lt;key2&gt;&apos;, &apos;&lt;value2&gt;&apos;, ...])$</b></code></li>
     *  <p>
     *  <u>Description:</u><br>
     *  The <code>$httpUrl()$</code> function creates an absolute URL but always with the fix protocol
     *  &quot;http&quot;. The protocol type of the incomming request is ignored.<br>
     *
     *  </p><p>
     *  <u>Example:</u><br>
     *  MarkupText:<br>
     *  &#xA0;&#xA0;&#xA0;<code>$httpUrl(&apos;MyLinkPipeline-Start&apos;, &apos;key1&apos;, &apos;value1&apos;, &apos;key2&apos;, &apos;value2&apos;)$</code><br>
     *  is rewritten to:<br>
     *  &#xA0;&#xA0;&#xA0;<code>http://&lt;host&gt;:&apos;&lt;port&gt;/on/demandware.store/&lt;current site&gt;/default/MyLinkPipeline-Start?key1=value1&amp;key2=value2</code>
     *
     *
     *  </p><p>
     *  </p><li><code><b>$httpsUrl(&apos;&lt;pipeline&gt;&apos; [, &apos;&lt;key1&gt;&apos;, &apos;&lt;value1&gt;&apos;, &apos;&lt;key2&gt;&apos;, &apos;&lt;value2&gt;&apos;, ...])$</b></code></li>
     *  <p>
     *  <u>Description:</u><br>
     *  The <code>$httpsUrl()$</code> function creates an absolute URL but always with the fix protocol
     *  &quot;https&quot;. The protocol type of the incomming request is ignored.
     *
     *  </p><p>
     *  <u>Example:</u><br>
     *  MarkupText:<br>
     *  &#xA0;&#xA0;&#xA0;<code>$httpsUrl(&apos;MyLinkPipeline-Start&apos;, &apos;key1&apos;, &apos;value1&apos;, &apos;key2&apos;, &apos;value2&apos;)$</code><br>
     *  is rewritten to:<br>
     *  &#xA0;&#xA0;&#xA0;<code>https://&lt;host&gt;:&lt;port&gt;/on/demandware.store/&lt;current site&gt;/default/MyLinkPipeline-Start?key1=value1&amp;key2=value2</code>
     *  </p><p>
     *
     *  </p><p>
     *  </p><li><code><b>$include(&apos;&lt;pipeline&gt;&apos; [, &apos;&lt;key1&gt;&apos;, &apos;&lt;value1&gt;&apos;, &apos;&lt;key2&gt;&apos;, &apos;&lt;value2&gt;&apos;, ...])$</b></code></li>
     *  <p>
     *  <u>Description:</u><br>
     *  The <code>$include()$</code> function creates a relative URL which is post processed by the
     *  Commerce Cloud Digital Webadapter. The result is the content generated by the given pipeline call.
     *
     *  </p><p>
     *  <u>Example:</u><br>
     *  MarkupText:<br>
     *  &#xA0;&#xA0;&#xA0;<code>$include(&apos;MyIncludePipeline-Start&apos;,&apos;key1&apos;, &apos;value1&apos;, &apos;key2&apos; ,&apos;value2&apos;)$</code><br>
     *  results in the content delivered by the &apos;MyIncludePipeline-Start&apos; pipeline.
     *
     *
     *  </p><p>
     *  </p><li><code><b>...?$staticlink$</b></code></li>
     *  <p>
     *  <u>Description:</u><br>
     *  The <code>$staticlink$</code> function can be used to create a URL to a static resource
     *  (such as an image). The URL being generated depends on the owner of the MarkupText instance.
     *  For example, a product&apos;s long description (which is a MarkupText) will generate
     *  links to static resources within the catalog. Possible URL targets are catalogs
     *  (for catalog related objects like products and categories), the content library
     *  (for library related objects like folders and assets) or the organization
     *  (for all objects that are not catalog or library related).
     *
     *  </p><p>
     *  <u>Example:</u><br>
     *  MarkupText: (owned by a content asset)<br>
     *  &#xA0;&#xA0;&#xA0;<code>&lt;img src=&quot;demo/content/bullet.gif?$staticlink$&quot;&gt;</code><br>
     *  is rewritten to:<br>
     *  &#xA0;&#xA0;&#xA0;<code>&lt;img src=&quot;/on/demandware.static/&lt;current site&gt;/&lt;library&gt;/default/v1178201405900/demo/content/bullet.gif&quot;&gt;</code>
     *
     *  </p></ul>
     */
    class MarkupText {
      /**
       * The content with all links rewritten for storefront use.
       */
      readonly markup: string;
      /**
       * The original content source, without any links re-written.
       */
      readonly source: string;

      /**
       * Returns the content with all links rewritten for storefront use.
       *
       * @return the content with all links rewritten for storefront use.
       */
      getMarkup(): string;
      /**
       * Returns the original content source, without any links re-written.
       *
       * @return the original content source, without any links re-written.
       */
      getSource(): string;
      /**
       * Returns a string representation of this class, the same as getMarkup().
       *
       * @return a string representation of this class, the same as getMarkup().
       */
      toString(): string;
    }

    /**
     * This class represents references to media content (such as images)
     *  located within Commerce Cloud Digital or on external systems.<p>
     *
     *  Parameter <code>transform</code>:</p><p>
     *
     *  Some methods allow the specification of image transformation parameters. Image
     *  transformation is only performed if the Dynamic Imaging Service (DIS) is available
     *  for the Commerce Cloud Digital instance, otherwise a standard static content URL
     *  is returned. The to-be-transformed image needs to be hosted on Commerce Cloud
     *  Digital.</p><p>
     *
     *  Image transformation parameters are specified as JavaScript object literal. They
     *  are translated into URL parameters. See <a href="https://documentation.b2c.commercecloud.salesforce.com/DOC1/topic/com.demandware.dochelp/ImageManagement/CreatingImageTransformationURLs.html?cp=0_3_0_5_6_1">Create Image Transformation URLs.</a></p><p>
     *
     *  <table>
     *  <tbody><tr>
     *      <th>Type of transformation</th>
     *      <th>Parameters</th>
     *      <th>Description</th>
     *  </tr>
     *  <tr>
     *      <td>Scale an image</td>
     *      <td>
     *          <code>scaleWidth</code><br>
     *          <code>scaleHeight</code><br>
     *          <code>scaleMode</code>
     *      </td>
     *      <td>
     *          The <code>scaleWidth</code> and <code>scaleHeight</code> parameters
     *          are both integers; setting one of these parameters triggers a
     *          scaling operation. If both are provided, the one that scales the
     *          image less is used to calculate the scale factor. The image is then
     *          automatically cropped accord to the second dimension, with a
     *          centered position of the cropped area. If the parameter would scale
     *          the image larger, only this operation is applied, if the image
     *          remains within acceptable pixel dimensions.<p>
     *
     *          Note: <code>scaleMode</code> can only be used in combination with <code>scaleHeight</code> and <code>scaleWidth</code>.</p><p>
     *
     *          The <code>scaleMode</code> parameter can be set to <code>cut</code>
     *          or <code>fit</code>. The default <code>scaleMode</code> is
     *          <code>cut</code>, the behavior of which is explained above. If you
     *          specify <code>fit</code> as the <code>scaleMode</code>, the system
     *          scales the image into the given box of dimensions while keeping the
     *          aspect ratio (possibly resulting in a smaller image in one
     *          dimension).
     *      </p></td>
     *  </tr>
     *  <tr>
     *      <td>Overlay an image</td>
     *      <td>
     *          <code>imageX</code><br>
     *          <code>imageY</code><br>
     *          <code>imageURI</code>
     *      </td>
     *      <td>
     *          The <code>imageX</code> and <code>imageY</code> parameters are both
     *          integers. Valid values for these parameters are 0 or greater.<p>
     *
     *          Supported formats are <code>png</code>, <code>jpg</code>, <code>jp2</code>, and
     *          <code>gif</code>.</p><p>
     *
     *          The <code>imageURI</code> parameter can be set to the absolute path
     *          of the overlaid image. The value of the <code>imageURI</code>
     *          parameter must be given in proper URL encoding, and it cannot exceed
     *          400 characters in length. The path may include query string
     *          parameters, which supports dynamically generating the overlaid image
     *          itself through this service; that is, the overlaid image can itself
     *          be a transformed image.</p><p>
     *
     *          If the overlaid image extends over the primary image&apos;s boundaries,
     *          the overlaid image is cropped so that it fits directly over the
     *          primary image.
     *      </p></td>
     *  </tr>
     *  <tr>
     *      <td>Crop an image</td>
     *      <td>
     *          <code>cropX</code><br>
     *          <code>cropY</code><br>
     *          <code>cropWidth</code><br>
     *          <code>cropHeight</code>
     *      </td>
     *      <td>
     *          The <code>cropX</code>, <code>cropY</code>, <code>cropWidth</code>,
     *          <code>cropHeight</code> parameters are integers. All four parameters
     *          must be specified to trigger a cropping operation.<p>
     *
     *          Valid values for the <code>cropX</code> and <code>cropY</code>
     *          parameters are 0 or greater. If the crop location defined by
     *          <code>cropX</code> and <code>cropY</code> is outside the image area,
     *          nothing is cropped.</p><p>
     *
     *          Valid values for the <code>cropWidth</code> and
     *          <code>cropHeight</code> parameters are 10 or greater. If the
     *          <code>cropWidth</code> and <code>cropHeight</code> parameters
     *          specify a size that is greater than the original image, the crop
     *          area is reduced to the actual image area. If <code>cropWidth</code>
     *          and <code>cropHeight</code> are 0 or less, no transformation is
     *          applied.
     *      </p></td>
     *  </tr>
     *  <tr>
     *      <td>Format an image</td>
     *      <td><code>format</code></td>
     *      <td>
     *          The <code>format</code> parameter specifies the target format of
     *          image. Supported formats are <code>png</code>, <code>jpg</code>, <code>jp2</code>, and
     *          <code>gif</code>. If no target format is specified, no format
     *          conversion is performed.<p>
     *
     *          The attribute value must reference the source image. Source image&apos;s
     *          format is recognized by the file extension which must be
     *          <code>tif</code>, <code>tiff</code>, <code>jpg</code>,
     *          <code>jpeg</code>, <code>png</code>, or <code>gif</code>.</p><p>
     *
     *          In the generated URL the file extension of the target format is used
     *          in the URL path. This is to make sure the image is loaded from an
     *          URL with a matching file extension. The source format is provided as
     *          URL parameter.
     *      </p></td>
     *  </tr>
     *  <tr>
     *      <td>Adjust image compression quality</td>
     *      <td><code>quality</code></td>
     *      <td>
     *          The <code>quality</code> parameter specifies a quality setting for <code>jpg</code> and <code>jp2</code> images,
     *          and specifies the compression level for <code>png</code> images.<p>
     *
     *          For <code>jpg</code> and <code>jp2</code> images, you can set values from 1&#x2013;100 for the highest quality.
     *          The default quality is 80. If you&apos;re not changing the default quality, you don&apos;t need to pass in a value.</p><p>
     *
     *          For <code>png</code> images, the quality setting has no effect on the appearance of the <code>png</code>, since the compression is always lossless.
     *          Instead you can use the quality setting to set the zlib compression level and filter-type for PNG images.
     *          The tens digit sets the zlib compression level(1-9). The ones digit sets the filter type.</p><p>
     *
     *          If the <code>png</code> setting is not present or set to 0, it uses a default value of 75.
     *          If this setting is set to 100, it actually equals the quality setting 90.
     *      </p></td>
     *  </tr>
     *  <tr>
     *      <td>Adjust Metadata stripping</td>
     *      <td><code>strip</code></td>
     *      <td>
     *          The <code>strip</code> parameter specifies if metadata like EXIF and color profiles is
     *          stripped from the image during transformation.<p>
     *
     *          Valid values for the <code>strip</code> parameter are between <code>true</code> and <code>false</code>.
     *          The default is <code>true</code>
     *      </p></td>
     *  </tr>
     *  <tr>
     *      <td>Change background color</td>
     *      <td><code>bgcolor(color) or bgcolor(color+alpha)</code></td>
     *      <td>
     *          The <code>bgcolor</code> parameter specifies the background color for images that support transparency
     *          as well as JPEG images when being converted from a format that supports transparency.
     *          Optionally, alpha setting for PNG images are also supported.<p>
     *
     *          <code>bgcolor</code> expects a 6 digit hexadecimal value of RGB with an optional
     *          two hexadecimal characters representing alpha value that determines transparency.</p><p>
     *
     *          FF0000 = Red</p><p>
     *
     *          FF000077 = Red with 50% transparency</p><p>
     *
     *          Alpha values are optional. When the alpha value is omitted, the resulting color is opaque.
     *          Alpha values are only valid when the image output format is PNG.
     *      </p></td>
     *  </tr>
     *  </tbody></table>
     *
     *  Example:</p><p>
     *     The following code</p><p>
     *     <code>var url = product.getImage(&apos;thumbnail&apos;, 0).getImageURL({scaleWidth: 100, format: &apos;jpg&apos;});</code></p><p>
     *     will produce an image transformation URL like</p><p>
     *     <code>http://&lt;image server host name&gt;/.../on/demandware.static/.../&lt;path to image&gt;/image.jpg?sw=100&amp;sfrm=png</code>.</p>
     */
    class MediaFile {
      /**
       * An absolute URL to the referenced media file. The
       *  protocol for the reference is the current protocol of the current
       *  HTTP request.
       */
      readonly absURL: dw.web.URL;
      /**
       * The alternative text assigned to the media file in current
       *  requests locale. If no alternative text was assigned or if no defaulting
       *  rule was defined, the method returns null.
       */
      readonly alt: string;
      /**
       * An absolute URL to the referenced media file. The
       *  protocol is https.
       */
      readonly httpsURL: dw.web.URL;
      /**
       * An absolute URL to the referenced media file. The
       *  protocol is http.
       */
      readonly httpURL: dw.web.URL;
      /**
       * The title assigned to the media file in current requests locale.
       *  If no title was assigned or if no defaulting rule was defined, the
       *  method returns null.
       */
      readonly title: string;
      /**
       * An URL to the referenced media file. The
       *  returned URL is a relative URL.
       */
      readonly url: dw.web.URL;
      /**
       * An URL to the referenced media file. The
       *  returned URL is a relative URL.
       */
      readonly URL: dw.web.URL;
      /**
       * The view type annotation for the media file. The method returns
       *  null, if the media file has no view type annotation.
       */
      readonly viewType: string;

      /**
       * Returns an URL to the referenced image file. Image transformation
       *  can be applied to the image. The protocol for the reference is the
       *  current protocol of the current HTTP request.
       *
       *  Image transformation can only be applied to images that are hosted on
       *  Commerce Cloud Digital.
       * @param transform Object with transformation parameters (see class header)
       * @return an absolute URL to the referenced media file. The protocol for the reference is the current protocol of the current HTTP request. If the referenced media file is hosted externally, an URL to the external file is returned.
       */
      getAbsImageURL(transform: any): dw.web.URL;
      /**
       * Returns an absolute URL to the referenced media file. The
       *  protocol for the reference is the current protocol of the current
       *  HTTP request.
       *
       * @return an absolute URL to the referenced media file. The protocol for the reference is the current protocol of the current HTTP request.
       */
      getAbsURL(): dw.web.URL;
      /**
       * Returns the alternative text assigned to the media file in current
       *  requests locale. If no alternative text was assigned or if no defaulting
       *  rule was defined, the method returns null.
       *
       * @return the alternative text annotated to this media file or null
       */
      getAlt(): string;
      /**
       * Returns an URL to the referenced image file. Image transformation
       *  can be applied to the image. The protocol is http.
       *
       *  Image transformation can only be applied to images that are hosted on
       *  Commerce Cloud Digital.
       * @param transform Object with transformation parameters (see class header)
       * @return an absolute URL to the referenced media file. The protocol is http. If the referenced media file is hosted externally, an URL to the external file is returned.
       */
      getHttpImageURL(transform: any): dw.web.URL;
      /**
       * Returns an URL to the referenced image file. Image transformation
       *  can be applied to the image. The protocol is https.
       *
       *  Image transformation can only be applied to images that are hosted on
       *  Commerce Cloud Digital.
       * @param transform Object with transformation parameters (see class header)
       * @return an absolute URL to the referenced media file. The protocol is https. If the referenced media file is hosted externally, an URL to the external file is returned.
       */
      getHttpsImageURL(transform: any): dw.web.URL;
      /**
       * Returns an absolute URL to the referenced media file. The
       *  protocol is https.
       *
       * @return an absolute URL to the referenced media file. The protocol is https.
       */
      getHttpsURL(): dw.web.URL;
      /**
       * Returns an absolute URL to the referenced media file. The
       *  protocol is http.
       *
       * @return an absolute URL to the referenced media file. The protocol is http.
       */
      getHttpURL(): dw.web.URL;
      /**
       * Returns an URL to the referenced image file. Image transformation
       *  can be applied to the image.
       *
       *  Image transformation can only be applied to images that are hosted on
       *  Commerce Cloud Digital.
       * @param transform Object with transformation parameters (see class header)
       * @return an URL to the referenced media file. The returned URL is a relative URL. If the referenced media file is hosted externally, an URL to the external file is returned.
       */
      getImageURL(transform: any): dw.web.URL;
      /**
       * Returns the title assigned to the media file in current requests locale.
       *  If no title was assigned or if no defaulting rule was defined, the
       *  method returns null.
       *
       * @return the title annotated to this media file or null
       */
      getTitle(): string;
      /**
       * Returns an URL to the referenced media file. The
       *  returned URL is a relative URL.
       *
       * @return an URL to the referenced media file. The returned URL is a relative URL.
       */
      getUrl(): dw.web.URL;
      /**
       * Returns an URL to the referenced media file. The
       *  returned URL is a relative URL.
       *
       * @return an URL to the referenced media file. The returned URL is a relative URL.
       */
      getURL(): dw.web.URL;
      /**
       * Returns the view type annotation for the media file. The method returns
       *  null, if the media file has no view type annotation.
       *
       * @return the view type annotated to this media file or null
       */
      getViewType(): string;
    }
  }

  namespace crypto {
    /**
     * This class is used as a reference to a certificate in the keystore
     *  which can be managed in the Business Manager.
     *  <p>
     *  <b>Note:</b> this class handles sensitive security-related data.
     *  Pay special attention to PCI DSS v3. requirements 2, 4, and 12.</p>
     */
    class CertificateRef {
      /**
       * Creates a CertificateRef from the passed alias. No check
       *  is made whether the alias is actually referring to a certificate in the keystore,
       *  this check is made when the CertificateRef is used.
       * @param alias an alias that should refer to a certificate in the keystore.
       */
      constructor(alias: string);

      /**
       * Returns the string representation of this CertificateRef.
       *
       * @return The string representation of this CertificateRef.
       */
      toString(): string;
    }

    /**
     * This class allows access to encryption services offered through the Java
     *  Cryptography Architecture (JCA). At this time the implementation of the
     *  encryption/decryption methods is based on the default JCE provider of the JDK.
     *  See the Java documentation for a reference guide to the underlying security
     *  provider and information about the Secure Sockets Extension. <p>
     *  You can find a good overview of the essential purposes of cryptography and
     *  some common implementations in the Wikipedia article on cryptography.
     *  Also see the website of the National Institute of Standards and Technology.
     *  The format of various files used to hold keys, certificate signing requests,
     *  and the like, as well as some related algorithms, are defined in the PKCS series of
     *  documents published by RSALabs (the research arm of RSA Security).</p><p>
     *  Many internet standards documenting security protocols and concepts are described
     *  in documents originally described as &quot;Request For Comment&quot; and thus widely known
     *  as RFCs. Many of them are available on the Internet FAQ Archives website.</p><p>
     *
     *  dw.crypto.Cipher is intentionally an Adapter to the full cryptography power supplied
     *  in the security provider implementation.
     *  </p><p>
     *  <b>Note:</b> this class handles sensitive security-related data.
     *  Pay special attention to PCI DSS v3 requirements 2, 4, and 12.</p>
     */
    class Cipher {
      /**
       * Strings containing keys, plain texts, cipher texts etc. are internally
       *  converted into byte arrays using this encoding (currently UTF8).
       */
      static readonly CHAR_ENCODING = "UTF8";

      constructor();

      /**
       * Decrypts the passed Base-64 encoded message using the passed key and
       *  applying the transformations described by the passed parameters.
       *
       *  Decryption is the process of getting back the original data from the
       *  cipher-text using a decryption key.
       * @param base64Msg the base64 encoded cipher bytes
       * @param key Use the same key to decrypt as was used to encrypt the message. If the cryptographic algorithm is symmetric (e.g. AES) or asymmetric (e.g. RSA), the key needs to be passed as base64 encoded string. The only exception is the symmetric cryptographic algorithms Password Based Encryption (PBE). With PBE the key needs to be passed as plain string (without any encoding).
       * @param transformation The transformation has to be in "algorithm/mode/padding" format. See the corresponding encrypt method for supported transformations.
       * @param salt Initialization value appropriate for the algorithm, this might be a Binary Salt or AlgorithmParameter or InitializationVector (see the corresponding encrypt method for details). Should be appropriate for the algorithm being used. If this value is null, a default initialization value will be used by the engine. The same value used to Encrypt needs to be supplied to the Decrypt function for many algorithms to successfully decrypt the data, so it is best practice to specify an appropriate value.
       * @param iterations The number of passes to make when turning a passphrase into a key. This is only applicable for some types of algorithm. Password Based Encryption (PBE) algorithms use this parameter, and Block Encryption algorithms do not. If this value is relevant to the algorithm it would be best practice to supply it, as the same value would be needed to decrypt the data that was used to encrypt the data.
       * @return the original plaintext message.
       */
      decrypt(
        base64Msg: string,
        key: string,
        transformation: string,
        salt: string,
        iterations: number
      ): string;
      /**
       * Alternative method to decrypt(String, String, String, String, Number), which allows
       *  to use a key in the keystore for the decryption.
       *
       *
       *  Note: Only asymmetric (public/private key pair) algorithms can be used
       *  with this method, since only those keys can be added to a keystore.
       * @param base64Msg (see decrypt(String, String, String, String, Number))
       * @param privateKey A reference to a private key in the key store.
       * @param transformation (see decrypt(String, String, String, String, Number))
       * @param salt (see decrypt(String, String, String, String, Number))
       * @param iterations (see decrypt(String, String, String, String, Number))
       * @return (see decrypt(String, String, String, String, Number))
       */
      decrypt(
        base64Msg: string,
        privateKey: dw.crypto.KeyRef,
        transformation: string,
        salt: string,
        iterations: number
      ): string;
      /**
       * Decrypts the passed Base-64 encoded message using the passed key and
       *  applying the transformations described by the passed parameters.
       *
       *  Decryption is the process of getting back the original data from the
       *  cipher-text using a decryption key.
       * @param base64Msg the base64 encoded cipher bytes
       * @param key Use the same key to decrypt as was used to encrypt the message. If the cryptographic algorithm is symmetric (e.g. AES) or asymmetric (e.g. RSA), the key needs to be passed as base64 encoded string. The only exception is the symmetric cryptographic algorithms Password Based Encryption (PBE). With PBE the key needs to be passed as plain string (without any encoding).
       * @param transformation The transformation has to be in "algorithm/mode/padding" format. See the corresponding encrypt method for supported transformations.
       * @param salt Initialization value appropriate for the algorithm, this might be a Binary Salt or AlgorithmParameter or InitializationVector (see the corresponding encrypt method for details). Should be appropriate for the algorithm being used. The same value used to Encrypt needs to be supplied to the Decrypt function for many algorithms to successfully decrypt the data, so it is best practice to specify an appropriate value.
       * @param iterations The number of passes to make when turning a passphrase into a key. This is only applicable for some types of algorithm. Password Based Encryption (PBE) algorithms use this parameter, and Block Encryption algorithms do not. If this value is relevant to the algorithm it would be best practice to supply it, as the same value would be needed to decrypt the data that was used to encrypt the data.
       * @return the original plaintext message.
       */
      decrypt(
        base64Msg: string,
        key: string,
        transformation: string,
        salt: string,
        iterations: number
      ): string;
      /**
       * Alternative method to decrypt_3(String, String, String, String, Number), which allows
       *  to use a key in the keystore for the decryption.
       *
       *
       *  Note: Only asymmetric (public/private key pair) algorithms can be used
       *  with this method, since only those keys can be added to a keystore.
       * @param base64Msg (see decrypt_3(String, String, String, String, Number))
       * @param privateKey A reference to a private key in the key store.
       * @param transformation (see decrypt_3(String, String, String, String, Number))
       * @param salt (see decrypt_3(String, String, String, String, Number))
       * @param iterations (see decrypt_3(String, String, String, String, Number))
       * @return (see decrypt_3(String, String, String, String, Number))
       */
      decrypt(
        base64Msg: string,
        privateKey: dw.crypto.KeyRef,
        transformation: string,
        salt: string,
        iterations: number
      ): string;
      /**
       * Lower-level decryption API. Decrypts the passed bytes using the specified
       *  key and applying the transformations described by the specified
       *  parameters.
       *
       *  Typical usage:
       *
       *   var base64Msg : String = "some_encoded_encrypted_message";
       *  var charset : String = "UTF8";  // or "windows-1252", etc.
       *
       *  var encryptedBytes : Bytes = Encoding.fromBase64(base64Msg);
       *  var messageBytes : Bytes = Cipher.decryptBytes(encryptedBytes, key, transformation, salt, iterations);
       *  var message : String = messageBytes.toString(charset);
       * @param encryptedBytes The bytes to decrypt.
       * @param key The key to use for decryption.
       * @param transformation The transformation used to originally encrypt.
       * @param salt the salt to use.
       * @param iterations the iterations to use.
       * @return The decrypted bytes.
       */
      decryptBytes(
        encryptedBytes: dw.util.Bytes,
        key: string,
        transformation: string,
        salt: string,
        iterations: number
      ): dw.util.Bytes;
      /**
       * Alternative method to decryptBytes(Bytes, String, String, String, Number), which allows
       *  to use a key in the keystore for the decryption.
       * @param encryptedBytes (see decryptBytes(Bytes, String, String, String, Number))
       * @param privateKey A reference to a private key in the key store.
       * @param transformation (see decryptBytes(Bytes, String, String, String, Number))
       * @param salt (see decryptBytes(Bytes, String, String, String, Number))
       * @param iterations (see decryptBytes(Bytes, String, String, String, Number))
       * @return (see decryptBytes(Bytes, String, String, String, Number))
       */
      decryptBytes(
        encryptedBytes: dw.util.Bytes,
        privateKey: dw.crypto.KeyRef,
        transformation: string,
        salt: string,
        iterations: number
      ): dw.util.Bytes;
      /**
       * Lower-level decryption API. Decrypts the passed bytes using the specified
       *  key and applying the transformations described by the specified
       *  parameters.
       *
       *  Typical usage:
       *
       *   var base64Msg : String = "some_encoded_encrypted_message";
       *  var charset : String = "UTF8";  // or "windows-1252", etc.
       *
       *  var encryptedBytes : Bytes = Encoding.fromBase64(base64Msg);
       *  var messageBytes : Bytes = Cipher.decryptBytes(encryptedBytes, key, transformation, salt, iterations);
       *  var message : String = messageBytes.toString(charset);
       * @param encryptedBytes The bytes to decrypt.
       * @param key The key to use for decryption.
       * @param transformation The transformation used to originally encrypt.
       * @param salt the salt to use.
       * @param iterations the iterations to use.
       * @return The decrypted bytes.
       */
      decryptBytes(
        encryptedBytes: dw.util.Bytes,
        key: string,
        transformation: string,
        salt: string,
        iterations: number
      ): dw.util.Bytes;
      /**
       * Alternative method to decryptBytes_3(Bytes, String, String, String, Number), which allows
       *  to use a key in the keystore for the decryption.
       * @param encryptedBytes (see decryptBytes_3(Bytes, String, String, String, Number))
       * @param privateKey A reference to a private key in the key store.
       * @param transformation (see decryptBytes_3(Bytes, String, String, String, Number))
       * @param salt (see decryptBytes_3(Bytes, String, String, String, Number))
       * @param iterations (see decryptBytes_3(Bytes, String, String, String, Number))
       * @return (see decryptBytes_3(Bytes, String, String, String, Number))
       */
      decryptBytes(
        encryptedBytes: dw.util.Bytes,
        privateKey: dw.crypto.KeyRef,
        transformation: string,
        salt: string,
        iterations: number
      ): dw.util.Bytes;
      /**
       * Encrypt the passed message by using the specified key and applying the
       *  transformations described by the specified parameters.
       *
       *  Encryption is the process of converting normal data or plain text to
       *  something incomprehensible or cipher-text by applying transformations,
       *  which are the operation (or set of operations) to be performed on given input
       *  to produce some output. A transformation always includes the name of a
       *  cryptographic algorithm (e.g. RSA) and may be followed by a mode and padding scheme.
       *  The supported algorithms are listed in the parameter description below.
       *  The cryptographic algorithms can be partitioned into symmetric
       *  and asymmetric (or public key/private key).
       *
       *  Symmetric or "secret key" algorithms use the same key to encrypt
       *  and to decrypt the data. Symmetric algorithms are what most people think
       *  of as codes: using a well-known algorithm and a secret key to encode information,
       *  which can be decoded using the same algorithm and the same key. The algorithm
       *  is not secret, the secrecy is inherent to guarding the key. A significant
       *  problem with symmetric ciphers is that it is difficult to transfer the keys
       *  themselves securely. Symmetric algorithms include password-based algorithms.
       *  AES with key length of 256 bits is the preferred choice for symmetric encryption going forward.
       *  Please consider switching to it if you are using any other scheme or if using AES with a
       *  shorter key length. The rest of the symmetric algorithms will be deprecated in the future.
       *
       *  Asymmetric or "public key" cryptography uses a public/private key pair, and then publishes the public key.
       *  Only the holder of the private key will be able to decrypt.
       *  The public key and private key together are also called a "key pair".
       *  Data encrypted with one key can only be decrypted using the other key
       *  from the pair, and it is not possible to deduce one key from the other.
       *  This helps to solve the key distribution problem since it is possible to
       *  publicise one of the keys widely (the "public key") and keep the other
       *  a closely guarded secret (the "private key"). Many partners can then
       *  send data encrypted with the public key, but only the holder of the
       *  corresponding private key can decrypt it.
       *
       *   Key pairs for asymmetric ciphers can be generated with an arbitrary tool.
       *   One of the most popular options is the open source tool OpenSSL.
       *   OpenSSL has a command-line syntax and is available on major platforms.
       *   The following steps are involved in creating an RSA key pair:
       *
       *   1. openssl genrsa -out rsaprivatekey.pem 2048
       *   2. openssl rsa -in rsaprivatekey.pem -out publickey.pem -pubout
       *   3. openssl pkcs8 -topk8 -in rsaprivatekey.pem -out privatekey.pem -nocrypt
       *
       *   1. Generates an RSA private key with keylength of 2048 bits. Store this key in a safe place.
       *   2. Generates a public key from the private key. You use the public key to encrypt messages with Cipher.encrypt. OpenSSL saves the key PEM-encoded; this means the key is saved with a base64 encoding. After you removed the header and footer lines you can pass the content directly to the API method.
       *   3. Generates a private key in PKCS#8 format. You use that key to decrypt messages with Cipher.decrypt. OpenSSL saves the key PEM-encoded; this means the key is saved with a base64 encoding. After you removed the header and footer lines you can pass the content directly to the API method.
       *  Modes
       *   The following modes of operation are block cipher operations that
       *      are used with some algorithms.
       *
       *           "NONE" no mode
       *           "CBC" Cipher Block Chaining (defined in FIPS PUB 81)
       *           "CTR" Counter mode or Segmented Integer Counter mode (defined in FIPS PUB 81)
       *           "CTS" CipherText Streaming mode
       *           "CFB" Cipher Feedback Mode,  can be referred to with key
       *           length referenced as "CFB8","CFB16","CFB24".."CFB64" (defined in FIPS PUB 81)
       *           "ECB" Electronic Cook book  as defined in: The National
       *           Institute of Standards and Technology (NIST) Federal Information
       *           Processing Standard (FIPS) PUB 81, "DES Modes of Operation,"
       *           U.S. Department of Commerce, Dec 1980.
       *           "OFB" Output Feedback Mode, can be referred to with key
       *           length referenced as "OFB8","OFB16","OFB24".."OFB64" (defined in FIPS PUB 81)
       *           "PCBC" Propagating Cipher Block Chaining (defined in Kerberos V4)
       *
       * Paddings
       *
       *           "NoPadding": No padding.
       *           OAEPWith<digest>And<mgf>Padding: Optimal Asymmetric Encryption
       *           Padding scheme defined in PKCS#1, where <digest> should be replaced
       *           by the message digest and <mgf> by the mask generation function.
       *           Examples: OAEPWITHMD5ANDMGF1PADDING, OAEPWITHSHA1ANDMGF1PADDING,
       *           OAEPWITHSHA-1ANDMGF1PADDING, OAEPWITHSHA-256ANDMGF1PADDING,
       *           OAEPWITHSHA-384ANDMGF1PADDING, OAEPWITHSHA-512ANDMGF1PADDING
       *           ISO10126PADDING the ISO10126-2:1991 DEA padding scheme
       *           PKCS1Padding: Public Key Cryptography Standard #1, a standard
       *           for padding from RSA Laboratories that can encrypt messages up
       *           to 11 bytes smaller than the modulus size in bytes.
       *           PKCS5Padding: Public Key Cryptography Standard #1, a standard
       *           for padding from RSA Laboratories, "PKCS#5: Password-Based Encryption Standard," version 1.5, November 1993.
       *           SSL3Padding: The padding scheme defined in the SSL Protocol Version 3.0, November 18, 1996, section 5.2.3.2 (CBC block cipher)
       * @param message A string to encrypt (will be first converted with UTF-8 encoding into a byte stream)
       * @param key A string ready for use with the algorithm. The key's format depends on the algorithm specified and the keys are assumed to be correctly formulated for the algorithm used, for example that the lengths are correct. Keys are not checked for validity. The cryptographic algorithms can be partitioned into symmetric and asymmetric (or public key/private key). Symmetric algorithms include password-based algorithms. Symmetric keys are usually base64 encodings of an array of bytes. Asymmetric keys are "key pairs" with a public key and a private key. For asymmetric algorithms the private key needs to be passed. Please provide the private key in PKCS#8 format, base64 encoded. See class documentation on how to generate a key pair. If the cryptographic algorithm is symmetric (e.g. AES) or asymmetric (e.g. RSA), the key needs to be passed as base64 encoded string. The only exception is the symmetric cryptographic algorithms Password Based Encryption (PBE). With PBE the key needs to be passed as plain string (without any encoding).
       * @param transformation The transformation has to be in "algorithm/mode/padding" format. Symmetric or "secret key" algorithms use the same key to encrypt and to decrypt the data. Asymmetric or "public key" cryptography uses a public/private key pair, and then publishes the public key. Only the holder of the private key will be able to decrypt. The public key and private key are also known as a "key pair". Supported Symmetric transformations include:  "AES" or Rijndael, Advanced Encryption Standard as specified by NIST AES with key length of 256 is the preferred choice for symmetric encryption Keysizes: 128, 192, or 256 Modes: "ECB","CBC","PCBC","CTR" Padding: "NOPADDING", "PKCS5Padding", "ISO10126PADDING"   Supported Asymmetric transformations include:  "RSA" Mode: "ECB" Padding: "NOPADDING", PKCS1PADDING", "OAEPWITHMD5ANDMGF1PADDING", "OAEPWITHSHA1ANDMGF1PADDING", "OAEPWITHSHA-1ANDMGF1PADDING", "OAEPWITHSHA-256ANDMGF1PADDING", "OAEPWITHSHA-384ANDMGF1PADDING", "OAEPWITHSHA-512ANDMGF1PADDING"  Note that for RSA the key length should be at least 2048 bits.
       * @param salt Initialization value appropriate for the algorithm, this might be a Binary Salt or AlgorithmParameter or InitializationVector. (As binary values cannot be passed, the equivalent Base64 String should be passed for any binary salt value). Should be appropriate for the algorithm being used. If this value is null, a default initialization value will be used by the engine. The same value used to Encrypt needs to be supplied to the Decrypt function for many algorithms to successfully decrypt the data, so it is best practice to specify an appropriate value. Requirements for the size and generation of DES initialization vectors (IV) are derived from FIPS 74 and FIPS 81 from the National Institute of Standards and Technology. CBC mode requires an IV with length 64 bits; CFB uses 48-64 bits; OFB uses 64 bits. If the IV is to be used with DES in the OFB mode, then it is not acceptable for the IV to remain fixed for multiple encryptions, if the same key is used for those encryptions. For Block Encryption algorithms this is the encoded Base64 String equivalent to the a random number to use as a "salt" to use with the algorithm. The algorithm must contain a Feedback Mode other than ECB. This must be a binary value that is exactly the same size as the algorithm block size. RC5 uses an optional 8-byte initialization vector (IV), but only in feedback mode (see CFB above). For Password Based Encryption algorithms, the salt is the encoded Base64 String equivalent to a random number value to transform the password into a key. PBE derives an encryption key from a password. In order to make the task of getting from password to key very time-consuming for an attacker, most PBE implementations will mix in a random number, known as a salt, to create the key. The salt value and the iteration count are then combined into a PBEParameterSpecification to initialize the cipher.  The PKCS#5 spec from RSA Labs defines the parameters for password-based encryption (PBE). The RSA algorithm requires a salt with length as defined in PKCS#1. DSA has a specific initialization that uses three integers to build a DSAParameterSpec (a prime, a sub-prime and a base). To use this algorithm you should use the JCE or another provider to supply a DSAParameterSpec and then supply the Base64 equivalent string as the "salt". Please see the documentation from the provider for additional restrictions.
       * @param iterations The number of passes to make when turning a passphrase into a key. This is only applicable for some types of algorithm. Password Based Encryption (PBE) algorithms use this parameter, and Block Encryption algorithms do not. If this value is relevant to the algorithm it would be best practice to supply it, as the same value would be needed to decrypt the data.
       * @return the encrypted message encoded as a String using base 64 encoding.
       */
      encrypt(
        message: string,
        key: string,
        transformation: string,
        salt: string,
        iterations: number
      ): string;
      /**
       * Alternative method to
       *  encrypt(String, String, String, String, Number), which allows you to
       *  use a key in the keystore for encryption.
       *
       *  Note: Only asymmetric (public/private key pair) algorithms can be used
       *  with this method, since only those keys can be added to a keystore.
       *
       *
       *  For asymmetric algorithms a private/public key pair is required.
       *  Commerce Cloud Digital only allows you to add private keys in the format *.p12 and *.pfx.
       *  You can assign private keys an extra password in Business Manager. Public keys
       *  can only be imported as trusted certificates in the format *.crt, *.pem,
       *  *.der, and *.cer.
       *
       *  Key pairs for asymmetric ciphers can be generated with an arbitrary tool.
       *  One of the most popular options is the open source tool OpenSSL.
       *  OpenSSL has a command-line syntax and is available on major platforms.
       *  The following steps are involved in creating an RSA key pair:
       *
       *  1. Generate a public and a non-protected private key ( *.crt and *.key ).< br/>
       *  openssl req -x509 -newkey rsa:2048 -keyout nopass.key -out nopass.crt -days 365 -nodes
       *  2. Generate a keystore that contains the public and private keys ( *.p12 ). < br/>
       *  openssl pkcs12 -export -out nopass.p12 -inkey nopass.key -in nopass.crt
       *
       *  To import a private or public key into the Digital keystore, navigate to
       *  Administration > Operations > Private Keys and Certificates
       *  Use a .p12 file to import a private key and a *.crt to import a public key.
       *
       *  Typical usage:
       *
       *   var plain : String = "some_plain_text";
       *  var publicKeyRef = new CertificateRef("rsa-certificate-2048");
       *  var cipher : Cipher = new Cipher();
       *  var encrypted : String = cipher.encrypt(plain, publicKeyRef, "RSA", null, 0);
       * @param message (see encrypt(String, String, String, String, Number))
       * @param publicKey A reference to a public key in the key store.
       * @param transformation (see encrypt(String, String, String, String, Number))
       * @param salt (see encrypt(String, String, String, String, Number))
       * @param iterations (see encrypt(String, String, String, String, Number))
       * @return (see encrypt(String, String, String, String, Number))
       */
      encrypt(
        message: string,
        publicKey: dw.crypto.CertificateRef,
        transformation: string,
        salt: string,
        iterations: number
      ): string;
      /**
       * Encrypt the passed message by using the specified key and applying the
       *  transformations described by the specified parameters.
       *
       *  Encryption is the process of converting normal data or plain text to
       *  something incomprehensible or cipher-text by applying transformations,
       *  which are the operation (or set of operations) to be performed on given input
       *  to produce some output. A transformation always includes the name of a
       *  cryptographic algorithm (e.g. RSA) and may be followed by a mode and padding scheme.
       *  The supported algorithms are listed in the parameter description below.
       *  The cryptographic algorithms can be partitioned into symmetric
       *  and asymmetric (or public key/private key).
       *
       *  Symmetric or "secret key" algorithms use the same key to encrypt
       *  and to decrypt the data. Symmetric algorithms are what most people think
       *  of as codes: using a well-known algorithm and a secret key to encode information,
       *  which can be decoded using the same algorithm and the same key. The algorithm
       *  is not secret, the secrecy is inherent to guarding the key. A significant
       *  problem with symmetric ciphers is that it is difficult to transfer the keys
       *  themselves securely. Symmetric algorithms include password-based algorithms.
       *  AES with key length of 256 bits is the preferred choice for symmetric encryption going forward.
       *  Please consider switching to it if you are using any other scheme or if using AES with a
       *  shorter key length. The rest of the symmetric algorithms will be deprecated in the future.
       *
       *  Asymmetric or "public key" cryptography uses a public/private key pair, and then publishes the public key.
       *  Only the holder of the private key will be able to decrypt.
       *  The public key and private key together are also called a "key pair".
       *  Data encrypted with one key can only be decrypted using the other key
       *  from the pair, and it is not possible to deduce one key from the other.
       *  This helps to solve the key distribution problem since it is possible to
       *  publicise one of the keys widely (the "public key") and keep the other
       *  a closely guarded secret (the "private key"). Many partners can then
       *  send data encrypted with the public key, but only the holder of the
       *  corresponding private key can decrypt it.
       *
       *   Key pairs for asymmetric ciphers can be generated with an arbitrary tool.
       *   One of the most popular options is the open source tool OpenSSL.
       *   OpenSSL has a command-line syntax and is available on major platforms.
       *   The following steps are involved in creating an RSA key pair:
       *
       *   1. openssl genrsa -out rsaprivatekey.pem 2048
       *   2. openssl rsa -in rsaprivatekey.pem -out publickey.pem -pubout
       *   3. openssl pkcs8 -topk8 -in rsaprivatekey.pem -out privatekey.pem -nocrypt
       *
       *   1. Generates an RSA private key with keylength of 2048 bits. Store this key in a safe place.
       *   2. Generates a public key from the private key. You use the public key to encrypt messages with Cipher.encrypt. OpenSSL saves the key PEM-encoded; this means the key is saved with a base64 encoding. After you removed the header and footer lines you can pass the content directly to the API method.
       *   3. Generates a private key in PKCS#8 format. You use that key to decrypt messages with Cipher.decrypt. OpenSSL saves the key PEM-encoded; this means the key is saved with a base64 encoding. After you removed the header and footer lines you can pass the content directly to the API method.
       *  Modes
       *   The following modes of operation are block cipher operations that
       *      are used with some algorithms.
       *
       *           "NONE" no mode
       *           "CBC" Cipher Block Chaining (defined in FIPS PUB 81)
       *           "CTR" Counter mode or Segmented Integer Counter mode (defined in FIPS PUB 81)
       *           "CTS" CipherText Streaming mode
       *           "CFB" Cipher Feedback Mode,  can be referred to with key
       *           length referenced as "CFB8","CFB16","CFB24".."CFB64" (defined in FIPS PUB 81)
       *           "ECB" Electronic Cook book  as defined in: The National
       *           Institute of Standards and Technology (NIST) Federal Information
       *           Processing Standard (FIPS) PUB 81, "DES Modes of Operation,"
       *           U.S. Department of Commerce, Dec 1980.
       *           "OFB" Output Feedback Mode, can be referred to with key
       *           length referenced as "OFB8","OFB16","OFB24".."OFB64" (defined in FIPS PUB 81)
       *           "PCBC" Propagating Cipher Block Chaining (defined in Kerberos V4)
       *
       * Paddings
       *
       *           "NoPadding": No padding.
       *           OAEPWith<digest>And<mgf>Padding: Optimal Asymmetric Encryption
       *           Padding scheme defined in PKCS#1, where <digest> should be replaced
       *           by the message digest and <mgf> by the mask generation function.
       *           Examples: OAEPWITHMD5ANDMGF1PADDING, OAEPWITHSHA1ANDMGF1PADDING,
       *           OAEPWITHSHA-1ANDMGF1PADDING, OAEPWITHSHA-256ANDMGF1PADDING,
       *           OAEPWITHSHA-384ANDMGF1PADDING, OAEPWITHSHA-512ANDMGF1PADDING
       *           ISO10126PADDING the ISO10126-2:1991 DEA padding scheme
       *           PKCS1Padding: Public Key Cryptography Standard #1, a standard
       *           for padding from RSA Laboratories that can encrypt messages up
       *           to 11 bytes smaller than the modulus size in bytes.
       *           PKCS5Padding: Public Key Cryptography Standard #1, a standard
       *           for padding from RSA Laboratories, "PKCS#5: Password-Based Encryption Standard," version 1.5, November 1993.
       *           SSL3Padding: The padding scheme defined in the SSL Protocol Version 3.0, November 18, 1996, section 5.2.3.2 (CBC block cipher)
       * @param message A string to encrypt (will be first converted with UTF-8 encoding into a byte stream)
       * @param key A string ready for use with the algorithm. The key's format depends on the algorithm specified and the keys are assumed to be correctly formulated for the algorithm used, for example that the lengths are correct. Keys are not checked for validity. The cryptographic algorithms can be partitioned into symmetric and asymmetric (or public key/private key). Symmetric algorithms include password-based algorithms. Symmetric keys are usually base64 encodings of an array of bytes. Asymmetric keys are "key pairs" with a public key and a private key. For asymmetric algorithms the private key needs to be passed. Please provide the private key in PKCS#8 format, base64 encoded. See class documentation on how to generate a key pair. If the cryptographic algorithm is symmetric (e.g. AES) or asymmetric (e.g. RSA), the key needs to be passed as base64 encoded string. The only exception is the symmetric cryptographic algorithms Password Based Encryption (PBE). With PBE the key needs to be passed as plain string (without any encoding).
       * @param transformation The transformation has to be in "algorithm/mode/padding" format. Symmetric or "secret key" algorithms use the same key to encrypt and to decrypt the data. Asymmetric or "public key" cryptography uses a public/private key pair, and then publishes the public key. Only the holder of the private key will be able to decrypt. The public key and private key are also known as a "key pair". Supported Symmetric transformations include:  "AES" or Rijndael, Advanced Encryption Standard as specified by NIST AES with key length of 256 is the preferred choice for symmetric encryption Keysizes: 128, 192, or 256 Modes: "ECB","CBC","PCBC","CTR" Padding: "NOPADDING", "PKCS5Padding", "ISO10126PADDING"   Supported Asymmetric transformations include:  "RSA" Mode: "ECB" Padding: "NOPADDING", PKCS1PADDING", "OAEPWITHMD5ANDMGF1PADDING", "OAEPWITHSHA1ANDMGF1PADDING", "OAEPWITHSHA-1ANDMGF1PADDING", "OAEPWITHSHA-256ANDMGF1PADDING", "OAEPWITHSHA-384ANDMGF1PADDING", "OAEPWITHSHA-512ANDMGF1PADDING"  Note that for RSA the key length should be at least 2048 bits.
       * @param salt Initialization value appropriate for the algorithm, this might be a Binary Salt or AlgorithmParameter or InitializationVector. (As binary values cannot be passed, the equivalent Base64 String should be passed for any binary salt value). Should be appropriate for the algorithm being used. The same value used to Encrypt needs to be supplied to the Decrypt function for many algorithms to successfully decrypt the data, so it is best practice to specify an appropriate value. Requirements for the size and generation of DES initialization vectors (IV) are derived from FIPS 74 and FIPS 81 from the National Institute of Standards and Technology. CBC mode requires an IV with length 64 bits; CFB uses 48-64 bits; OFB uses 64 bits. If the IV is to be used with DES in the OFB mode, then it is not acceptable for the IV to remain fixed for multiple encryptions, if the same key is used for those encryptions. For Block Encryption algorithms this is the encoded Base64 String equivalent to the a random number to use as a "salt" to use with the algorithm. The algorithm must contain a Feedback Mode other than ECB. This must be a binary value that is exactly the same size as the algorithm block size. RC5 uses an optional 8-byte initialization vector (IV), but only in feedback mode (see CFB above). For Password Based Encryption algorithms, the salt is the encoded Base64 String equivalent to a random number value to transform the password into a key. PBE derives an encryption key from a password. In order to make the task of getting from password to key very time-consuming for an attacker, most PBE implementations will mix in a random number, known as a salt, to create the key. The salt value and the iteration count are then combined into a PBEParameterSpecification to initialize the cipher.  The PKCS#5 spec from RSA Labs defines the parameters for password-based encryption (PBE). The RSA algorithm requires a salt with length as defined in PKCS#1. DSA has a specific initialization that uses three integers to build a DSAParameterSpec (a prime, a sub-prime and a base). To use this algorithm you should use the JCE or another provider to supply a DSAParameterSpec and then supply the Base64 equivalent string as the "salt". Please see the documentation from the provider for additional restrictions.
       * @param iterations The number of passes to make when turning a passphrase into a key. This is only applicable for some types of algorithm. Password Based Encryption (PBE) algorithms use this parameter, and Block Encryption algorithms do not. If this value is relevant to the algorithm it would be best practice to supply it, as the same value would be needed to decrypt the data.
       * @return the encrypted message encoded as a String using base 64 encoding.
       */
      encrypt(
        message: string,
        key: string,
        transformation: string,
        salt: string,
        iterations: number
      ): string;
      /**
       * Alternative method to
       *  encrypt_3(String, String, String, String, Number), which allows you to
       *  use a key in the keystore for encryption.
       *
       *  Note: Only asymmetric (public/private key pair) algorithms can be used
       *  with this method, since only those keys can be added to a keystore.
       *
       *
       *  For asymmetric algorithms a private/public key pair is required.
       *  Commerce Cloud Digital only allows you to add private keys in the format *.p12 and *.pfx.
       *  You can assign private keys an extra password in Business Manager. Public keys
       *  can only be imported as trusted certificates in the format *.crt, *.pem,
       *  *.der, and *.cer.
       *
       *  Key pairs for asymmetric ciphers can be generated with an arbitrary tool.
       *  One of the most popular options is the open source tool OpenSSL.
       *  OpenSSL has a command-line syntax and is available on major platforms.
       *  The following steps are involved in creating an RSA key pair:
       *
       *  1. Generate a public and a non-protected private key ( *.crt and *.key ).< br/>
       *  openssl req -x509 -newkey rsa:2048 -keyout nopass.key -out nopass.crt -days 365 -nodes
       *  2. Generate a keystore that contains the public and private keys ( *.p12 ). < br/>
       *  openssl pkcs12 -export -out nopass.p12 -inkey nopass.key -in nopass.crt
       *
       *  To import a private or public key into the Digital keystore, navigate to
       *  Administration > Operations > Private Keys and Certificates
       *  Use a .p12 file to import a private key and a *.crt to import a public key.
       *
       *  Typical usage:
       *
       *   var plain : String = "some_plain_text";
       *  var publicKeyRef = new CertificateRef("rsa-certificate-2048");
       *  var cipher : Cipher = new Cipher();
       *  var encrypted : String = cipher.encrypt(plain, publicKeyRef, "RSA", null, 0);
       * @param message (see encrypt_3(String, String, String, String, Number))
       * @param publicKey A reference to a public key in the key store.
       * @param transformation (see encrypt_3(String, String, String, String, Number))
       * @param salt (see encrypt_3(String, String, String, String, Number))
       * @param iterations (see encrypt_3(String, String, String, String, Number))
       * @return (see encrypt_3(String, String, String, String, Number))
       */
      encrypt(
        message: string,
        publicKey: dw.crypto.CertificateRef,
        transformation: string,
        salt: string,
        iterations: number
      ): string;
      /**
       * Lower-level encryption API. Encrypts the passed bytes by using the
       *  specified key and applying the transformations described by the specified
       *  parameters.
       *
       *  Typical usage:
       *
       *   var message : String = "some_message";
       *  var charset : String = "UTF8"; // or "windows-1252", etc.
       *
       *  // encrypt the message
       *  var messageBytes : Bytes = new Bytes(message, charset);
       *  var encryptedBytes : Bytes = Cipher.encryptBytes(messageBytes, key, transformation, salt, iterations);
       *  var encrypted : String = Encoding.toBase64(encryptedBytes);
       * @param messageBytes The bytes to encrypt.
       * @param key The key to use for encryption.
       * @param transformation The transformation to apply.
       * @param salt Initialization value appropriate for the algorithm.
       * @param iterations The number of passes to make when turning a passphrase into a key.
       * @return the encrypted bytes.
       */
      encryptBytes(
        messageBytes: dw.util.Bytes,
        key: string,
        transformation: string,
        salt: string,
        iterations: number
      ): dw.util.Bytes;
      /**
       * Alternative method to encryptBytes(Bytes, String, String, String, Number), which allows
       *  to use a key in the keystore for the encryption.
       *
       *
       *  Note: Only asymmetric (public/private key pair) algorithms can be used
       *  with this method, since only those keys can be added to a keystore.
       * @param messageBytes (see encryptBytes(Bytes, String, String, String, Number))
       * @param publicKey A reference to a public key in the key store.
       * @param transformation (see encryptBytes(Bytes, String, String, String, Number))
       * @param salt (see encryptBytes(Bytes, String, String, String, Number))
       * @param iterations (see encryptBytes(Bytes, String, String, String, Number))
       * @return (see encryptBytes(Bytes, String, String, String, Number))
       */
      encryptBytes(
        messageBytes: dw.util.Bytes,
        publicKey: dw.crypto.CertificateRef,
        transformation: string,
        salt: string,
        iterations: number
      ): dw.util.Bytes;
      /**
       * Lower-level encryption API. Encrypts the passed bytes by using the
       *  specified key and applying the transformations described by the specified
       *  parameters.
       *
       *  Typical usage:
       *
       *   var message : String = "some_message";
       *  var charset : String = "UTF8"; // or "windows-1252", etc.
       *
       *  // encrypt the message
       *  var messageBytes : Bytes = new Bytes(message, charset);
       *  var encryptedBytes : Bytes = Cipher.encryptBytes(messageBytes, key, transformation, salt, iterations);
       *  var encrypted : String = Encoding.toBase64(encryptedBytes);
       * @param messageBytes The bytes to encrypt.
       * @param key The key to use for encryption.
       * @param transformation The transformation to apply.
       * @param salt Initialization value appropriate for the algorithm.
       * @param iterations The number of passes to make when turning a passphrase into a key.
       * @return the encrypted bytes.
       */
      encryptBytes(
        messageBytes: dw.util.Bytes,
        key: string,
        transformation: string,
        salt: string,
        iterations: number
      ): dw.util.Bytes;
      /**
       * Alternative method to encryptBytes_3(Bytes, String, String, String, Number), which allows
       *  to use a key in the keystore for the encryption.
       *
       *
       *  Note: Only asymmetric (public/private key pair) algorithms can be used
       *  with this method, since only those keys can be added to a keystore.
       * @param messageBytes (see encryptBytes_3(Bytes, String, String, String, Number))
       * @param publicKey A reference to a public key in the key store.
       * @param transformation (see encryptBytes_3(Bytes, String, String, String, Number))
       * @param salt (see encryptBytes_3(Bytes, String, String, String, Number))
       * @param iterations (see encryptBytes_3(Bytes, String, String, String, Number))
       * @return (see encryptBytes_3(Bytes, String, String, String, Number))
       */
      encryptBytes(
        messageBytes: dw.util.Bytes,
        publicKey: dw.crypto.CertificateRef,
        transformation: string,
        salt: string,
        iterations: number
      ): dw.util.Bytes;
    }

    /**
     * Utility class which handles several common character encodings.
     */
    class Encoding {
      /**
       * Decode the given string which represents a sequence of characters encoded
       *  in base-64 to a byte array. Characters not in the base-64 alphabet are
       *  ignored. An exception is thrown if a null value is passed.
       *
       *  Note: This decoding operation is limited to the maximum number of bytes
       *  that a Bytes object can hold. See Bytes.MAX_BYTES.
       * @param string A string consisting of characters in base-64 alphabet to decode.
       * @return The decoded array of bytes.
       */
      static fromBase64(string: string): dw.util.Bytes;
      /**
       * Converts a String representing hexadecimal values into an array of bytes
       *  of those same values. The returned byte array will be half the length of
       *  the passed, as it takes two characters to represent any given byte. An
       *  exception is thrown if the passed string has an odd number of character
       *  or if any characters in the string are not valid hexadecimal characters.
       *  An exception is thrown if a null value is passed.
       *
       *  Note: This decoding operation is limited to the maximum number of bytes
       *  that a Bytes object can hold. See Bytes.MAX_BYTES.
       * @param string A string containing only hex characters to decode.
       * @return The decoded array of bytes.
       */
      static fromHex(string: string): dw.util.Bytes;
      /**
       * Decodes a URL safe string into its original form. Escaped characters are
       *  converted back to their original representation. An exception is thrown
       *  if URL decoding is unsuccessful or if null is passed.
       * @param string The string to decode.
       * @return The decoded string.
       */
      static fromURI(string: string): string;
      /**
       * Decodes a URL safe string into its original form using the specified
       *  encoding. Escaped characters are converted back to their original
       *  representation. An exception is thrown if URL decoding is unsuccessful or
       *  if the specified encoding is unsupported or if null is passed for either
       *  argument.
       * @param string The string to decode.
       * @param encoding The name of a supported encoding.
       * @return The decoded string.
       */
      static fromURI(string: string, encoding: string): string;
      /**
       * Convert the given byte array to a string encoded in base-64.  This method
       *  does not chunk the data by adding line breaks.  An exception is thrown
       *  if a null value is passed.
       * @param bytes The array of bytes to encode.
       * @return The encoded string containing only Base64 characters.
       */
      static toBase64(bytes: dw.util.Bytes): string;
      /**
       * Converts an array of bytes into a string representing the hexadecimal
       *  values of each byte in order. The returned string will be double the
       *  length of the passed array, as it takes two characters to represent any
       *  given byte. An exception is thrown if a null value is passed.
       * @param bytes The array of bytes to encode.
       * @return The encoded string containing only hex characters.
       */
      static toHex(bytes: dw.util.Bytes): string;
      /**
       * Encodes a string into its URL safe form according to the
       *  "application/x-www-form-urlencoded" encoding scheme using the default
       *  encoding. Unsafe characters are escaped. An exception is thrown if a null
       *  value is passed.
       * @param string The string to encode.
       * @return The encoded string.
       */
      static toURI(string: string): string;
      /**
       * Encodes a string into its URL safe form according to the
       *  "application/x-www-form-urlencoded" encoding scheme using the specified
       *  encoding. Unsafe characters are escaped. An exception is thrown if the
       *  specified encoding is unsupported. An exception is thrown if either
       *  argument is null.
       * @param string The string to encode.
       * @param encoding The name of a supported encoding.
       * @return The encoded string.
       */
      static toURI(string: string, encoding: string): string;
    }

    /**
     * This class is used as a reference to a private key in the keystore
     *  which can be managed in the Business Manager.
     *  <p>
     *  <b>Note:</b> this class handles sensitive security-related data.
     *  Pay special attention to PCI DSS v3. requirements 2, 4, and 12.</p>
     */
    class KeyRef {
      /**
       * Creates a KeyRef from the passed alias. No check
       *  is made whether the alias is actually referring to a key in the keystore,
       *  this check is made when the KeyRef is used.
       * @param alias an alias that should refer to a key in the keystore.
       */
      constructor(alias: string);
      /**
       * Creates a KeyRef from the passed alias. No check
       *  is made whether the alias is actually referring to a key in the keystore,
       *  this check is made when the KeyRef is used.
       * @param alias an alias that should refer to a key in the keystore.
       * @param password the password that should be used to get the key from the keystore.
       */
      constructor(alias: string, password: string);

      /**
       * Returns the string representation of this KeyRef.
       *
       * @return The string representation of this KeyRef.
       */
      toString(): string;
    }

    /**
     * This class provides the functionality of a &quot;Message Authentication Code&quot; (MAC) algorithm.
     *  A MAC provides a way to check the integrity of information transmitted over or
     *  stored in an unreliable medium, based on a secret key.
     *  Typically, message authentication codes are used between two parties
     *  that share a secret key in order to validate information transmitted between these parties.
     *  A MAC mechanism that is based on cryptographic hash functions is referred to as HMAC.
     *  HMAC can be used with any cryptographic hash function, e.g., SHA256,
     *  in combination with a secret shared key. HMAC is specified in RFC 2104.
     *  <p>
     *  <b>Note:</b> this class handles sensitive security-related data.
     *  Pay special attention to PCI DSS v3. requirements 2, 4, and 12.</p>
     */
    class Mac {
      /**
       * Constant representing the HMAC-MD5 keyed-hashing algorithm as defined in RFC 2104 "HMAC: Keyed-Hashing for Message Authentication" (February 1997).
       *  This algorithm uses as MD5 cryptographic hash function.
       */
      static readonly HMAC_MD5 = "HmacMD5";
      /**
       * Constant representing the HmacSHA1 algorithms as defined in RFC 2104 "HMAC: Keyed-Hashing for Message Authentication" (February 1997)
       *  with SHA-1 as the message digest algorithm.
       */
      static readonly HMAC_SHA_1 = "HmacSHA1";
      /**
       * Constant representing the HmacSHA256 algorithms as defined in RFC 2104 "HMAC: Keyed-Hashing for Message Authentication" (February 1997)
       *  with SHA-256 as the message digest algorithm.
       */
      static readonly HMAC_SHA_256 = "HmacSHA256";
      /**
       * Constant representing the HmacSHA384 algorithms as defined in RFC 2104 "HMAC: Keyed-Hashing for Message Authentication" (February 1997)
       *  with SHA-384 as the message digest algorithm.
       */
      static readonly HMAC_SHA_384 = "HmacSHA384";
      /**
       * Constant representing the HmacSHA512 algorithms as defined in RFC 2104 "HMAC: Keyed-Hashing for Message Authentication" (February 1997)
       *  with SHA-512 as the message digest algorithm.
       */
      static readonly HMAC_SHA_512 = "HmacSHA512";

      /**
       * Construct a Mac encryption instance with the specified algorithm name. The
       *  supported algorithms are:
       *
       *
       *  SHA 256
       *  SHA 384
       *  SHA 512
       * @param algorithm the standard name of the digest algorithm, must not be null.
       */
      constructor(algorithm: string);

      /**
       * Computes the hash value for the passed string input using the passed secret key.
       *  Given input and the given key will be first converted with UTF-8 encoding into a byte array.
       *  The resulting hash is typically converted with base64 back into a string.
       * @param input A string to calculate a RFC 2104 compliant HMAC hash value for.
       * @param key The secret key ready for use with the algorithm. The key's format depends on the chosen algorithm and the keys are assumed to be correctly formulated for the algorithm used, for example that the lengths are correct. Keys are not checked for validity. Only such keys that have no key parameters associated with them.
       * @return The resulting hash value as bytes.
       */
      digest(input: string, key: string): dw.util.Bytes;
      /**
       * Computes the hash value for the passed string input using the passed secret key.
       *  Given input will be first converted with UTF-8 encoding into a byte array.
       *  The resulting hash is typically converted with base64 back into a string.
       * @param input A string to calculate a RFC 2104 compliant HMAC hash value for.
       * @param key The secret key as bytes ready for use with the algorithm. The key's format depends on the chosen algorithm and the keys are assumed to be correctly formulated for the algorithm used, for example that the lengths are correct. Keys are not checked for validity. Only such keys that have no key parameters associated with them.
       * @return The resulting hash value as bytes.
       */
      digest(input: string, key: dw.util.Bytes): dw.util.Bytes;
      /**
       * Computes the hash value for the passed bytes input using the passed secret key.
       * @param input The bytes to calculate a RFC 2104 compliant HMAC hash value.
       * @param key The secret key as byte array ready for use with the algorithm. The key's format depends on the chosen algorithm and the keys are assumed to be correctly formulated for the algorithm used, for example that the lengths are correct. Keys are not checked for validity. Only such keys that have no key parameters associated with them.
       * @return The resulting hash value as bytes.
       */
      digest(input: dw.util.Bytes, key: dw.util.Bytes): dw.util.Bytes;
    }

    /**
     * This class provides the functionality of a message digest algorithm, such as
     *  MD5 or SHA. Message digests are secure one-way hash functions that take
     *  arbitrary-sized data and output a fixed-length hash value. This
     *  implementation offers only stateless digest() methods. A Bytes object or
     *  String is passed to a digest() method and the computed hash is returned.
     *  <p>
     *  <b>Note:</b> this class handles sensitive security-related data.
     *  Pay special attention to PCI DSS v3. requirements 2, 4, and 12.</p>
     */
    class MessageDigest {
      /**
       * Constant representing the MD2 algorithm.
       */
      static readonly DIGEST_MD2 = "MD2";
      /**
       * Constant representing the MD5 algorithm.
       */
      static readonly DIGEST_MD5 = "MD5";
      /**
       * Constant representing the SHA algorithm.
       */
      static readonly DIGEST_SHA = "SHA";
      /**
       * Constant representing the SHA 1 algorithm.
       */
      static readonly DIGEST_SHA_1 = "SHA-1";
      /**
       * Constant representing the SHA 256 algorithm
       */
      static readonly DIGEST_SHA_256 = "SHA-256";
      /**
       * Constant representing the SHA 512 algorithm
       */
      static readonly DIGEST_SHA_512 = "SHA-512";

      /**
       * Construct a MessageDigest with the specified algorithm name. The
       *  supported algorithms are:
       *
       *
       *  SHA-256
       *  SHA-512
       * @param algorithm The standard name of the digest algorithm, must not be null and must be a supported algorithm.
       */
      constructor(algorithm: string);

      /**
       * Digests the passed string and returns a computed hash value as a string.
       *  The passed String is first encoded into a sequence of bytes using the
       *  platform's default encoding. The digest then performs any prerequisite
       *  padding, before computing the hash value. The hash is then converted into
       *  a string by converting all digits to hexadecimal.
       * @param input The value to hash as String, must not be null.
       * @return The resulting hash value as hex-encoded string.
       */
      digest(input: string): string;
      /**
       * Computes the hash value for the passed array of bytes. The algorithm
       *  argument is optional. If null, then the algorithm established at
       *  construction time is used.
       *
       *  The binary representation of the message is typically derived from a
       *  string and the resulting hash is typically converted with base64 back
       *  into a string. Example:
       *
       *
       *  Encoding.toBase64( digest( "MD5", new Bytes( "my password", "UTF-8" ) ) );
       * @param algorithm The standard name of the digest algorithm, or null if the algorithm passed at construction time is to be used. The algorithm must be a supported algorithm.
       * @param input The value to hash, must not be null.
       * @return The resulting hash value.
       */
      digest(algorithm: string, input: dw.util.Bytes): dw.util.Bytes;
      /**
       * Completes the hash computation by performing final operations such as
       *  padding.
       *
       *  The binary representation of the message is typically derived from a
       *  string and the resulting hash is typically converted with base64 back
       *  into a string. Example:
       *
       *
       *  Encoding.toBase64( digest() );
       *
       * @return The resulting hash value.
       */
      digest(): dw.util.Bytes;
      /**
       * Computes the hash value for the passed Bytes.
       *
       *  The binary representation of the message is typically derived from a
       *  string and the resulting hash is typically converted with base64 back
       *  into a string. Example:
       *
       *
       *  Encoding.toBase64( digest( new Bytes( "my password", "UTF-8" ) ) );
       * @param input The value to hash, must not be null.
       * @return The resulting hash value.
       */
      digestBytes(input: dw.util.Bytes): dw.util.Bytes;
      /**
       * Updates the digest using the passed Bytes.
       * @param input The value to hash, must not be null.
       */
      updateBytes(input: dw.util.Bytes): void;
    }

    /**
     * The SecureRandom class provides a cryptographically strong random number generator (RNG).
     *  See the Internet Engineering Task Force (IETF) RFC 1750: <i>Randomness Recommendations for
     *  Security</i> for more information.
     *
     *  <p> Typical callers of SecureRandom invoke the following methods to retrieve random bytes:
     *
     *  </p><pre>      Bytes bytes...
     *       SecureRandom random = new SecureRandom();
     *       Bytes nextBytes = random.nextBytes(bytes);
     *  </pre>
     *
     *  or more convenient to get a Bytes with the demanded length
     *
     *  <pre>      int length = 32;
     *       SecureRandom random = new SecureRandom();
     *       Bytes nextBytes = random.nextBytes(length);
     *  </pre>
     *
     *  dw.crypto.SecureRandom is intentionally an adapter for generating cryptographic hard random numbers.
     */
    class SecureRandom {
      /**
       * Instantiates a new secure random.
       *
       */
      constructor();

      /**
       * Returns the given number of seed bytes, computed using the seed
       *  generation algorithm that this class uses to seed itself.  This
       *  call may be used to seed other random number generators.
       * @param numBytes the number of seed bytes to generate.
       * @return the seed bytes.
       */
      generateSeed(numBytes: number): dw.util.Bytes;
      /**
       * Generates a user-specified number of random bytes.
       *
       *   If a call to setSeed had not occurred previously,
       *  the first call to this method forces this SecureRandom object
       *  to seed itself.  This self-seeding will not occur if
       *  setSeed was previously called.
       * @param numBits the demanded number of bits
       * @return a randomly filled Bytes
       */
      nextBytes(numBits: number): dw.util.Bytes;
      /**
       * Returns the next pseudorandom, uniformly distributed int value from this random number generator's sequence. The general
       *  contract of nextInt is that one int value is pseudorandomly generated and returned. All 232
       *   possible int values are produced with (approximately) equal probability.
       *
       * @return the next pseudorandom, uniformly distributed int value from this random number generator's sequence
       */
      nextInt(): number;
      /**
       * Returns a pseudorandom, uniformly distributed int value
       *  between 0 (inclusive) and the specified value (exclusive), drawn from
       *  this random number generator's sequence.
       * @param upperBound the bound on the random number to be returned. Must be positive.
       * @return the next pseudorandom, uniformly distributed int value between 0 (inclusive) and upperBound (exclusive) from this random number generator's sequence
       */
      nextInt(upperBound: number): number;
      /**
       * Returns the next pseudorandom, uniformly distributed
       *  Number value between 0.0 (inclusive) and 1.0 (exclusive) from this random number generator's sequence.
       *
       * @return the next pseudorandom, uniformly distributed Number value between 0.0 and 1.0 from this random number generator's sequence
       */
      nextNumber(): number;
      /**
       * Reseeds this random object. The given seed supplements, rather than replaces, the existing seed. Thus, repeated calls are guaranteed never to reduce randomness.
       * @param seed the seed.
       */
      setSeed(seed: dw.util.Bytes): void;
    }

    /**
     * <p>This class allows access to signature services offered through the Java
     *  Cryptography Architecture (JCA). At this time the signature/verification implementation of the
     *  methods is based on the default RSA JCE provider of the JDK - sun.security.rsa.SunRsaSign</p>
     *
     *  <p>dw.crypto.Signature is an adapter to the security provider implementation
     *  and covers several digest algorithms:
     *  </p><ul>
     *   <li>SHA1withRSA (deprecated)</li>
     *   <li>SHA256withRSA</li>
     *   <li>SHA384withRSA</li>
     *   <li>SHA512withRSA</li>
     *   <li>SHA256withRSA/PSS</li>
     *   <li>SHA384withRSA/PSS</li>
     *   <li>SHA512withRSA/PSS</li>
     *  </ul>
     *  <p></p>
     *
     *  <p>Key size generally ranges between 512 and 65536 bits (the latter of which is unnecessarily large).<br>
     *  Default key size for RSA is 1024. SHA384withRSA and SHA512withRSA require a key with length of at least 1024 bits.<br>
     *  When choosing a key size - beware of the tradeoff between security and processing time:<br>
     *  The longer the key, the harder to break it but also it takes more time for the two sides to sign and verify the signature.<br>
     *  An exception will be thrown for keys shorter than 2048 bits in this version of the API.
     *  </p><p>
     *  <b>Note:</b> this class handles sensitive security-related data.
     *  Pay special attention to PCI DSS v3. requirements 2, 4, 12, and other relevant requirements.
     *  </p>
     */
    class Signature {
      /**
       * Supported digest algorithms exposed as a string array
       */
      static readonly SUPPORTED_DIGEST_ALGORITHMS_AS_ARRAY: string;

      constructor();

      /**
       * Checks to see if a digest algorithm is supported
       * @param digestAlgorithm the digest algorithm name
       * @return a boolean indicating success (true) or failure (false)
       */
      isDigestAlgorithmSupported(digestAlgorithm: string): boolean;
      /**
       * Signs a string and returns a string
       * @param contentToSign base64 encoded content to sign
       * @param privateKey base64 encoded private key
       * @param digestAlgorithm must be one of the currently supported ones
       * @return the base64 encoded signature
       */
      sign(
        contentToSign: string,
        privateKey: string,
        digestAlgorithm: string
      ): string;
      /**
       * Signs a string and returns a string
       * @param contentToSign base64 encoded content to sign
       * @param privateKey a reference to a private key entry in the keystore
       * @param digestAlgorithm must be one of the currently supported ones
       * @return the base64 encoded signature
       */
      sign(
        contentToSign: string,
        privateKey: dw.crypto.KeyRef,
        digestAlgorithm: string
      ): string;
      /**
       * Signs bytes and returns bytes
       * @param contentToSign transformed with UTF-8 encoding into a byte stream
       * @param privateKey base64 encoded private key
       * @param digestAlgorithm must be one of the currently supported ones
       * @return signature
       */
      signBytes(
        contentToSign: dw.util.Bytes,
        privateKey: string,
        digestAlgorithm: string
      ): dw.util.Bytes;
      /**
       * Signs bytes and returns bytes
       * @param contentToSign transformed with UTF-8 encoding into a byte stream
       * @param privateKey a reference to a private key entry in the keystore
       * @param digestAlgorithm must be one of the currently supported ones
       * @return signature
       */
      signBytes(
        contentToSign: dw.util.Bytes,
        privateKey: dw.crypto.KeyRef,
        digestAlgorithm: string
      ): dw.util.Bytes;
      /**
       * Verifies a signature supplied as bytes
       * @param signature signature to check as bytes
       * @param contentToVerify as bytes
       * @param publicKey base64 encoded public key
       * @param digestAlgorithm must be one of the currently supported ones
       * @return a boolean indicating success (true) or failure (false)
       */
      verifyBytesSignature(
        signature: dw.util.Bytes,
        contentToVerify: dw.util.Bytes,
        publicKey: string,
        digestAlgorithm: string
      ): boolean;
      /**
       * Verifies a signature supplied as bytes
       * @param signature signature to check as bytes
       * @param contentToVerify as bytes
       * @param certificate a reference to a trusted certificate entry in the keystore
       * @param digestAlgorithm must be one of the currently supported ones
       * @return a boolean indicating success (true) or failure (false)
       */
      verifyBytesSignature(
        signature: dw.util.Bytes,
        contentToVerify: dw.util.Bytes,
        certificate: dw.crypto.CertificateRef,
        digestAlgorithm: string
      ): boolean;
      /**
       * Verifies a signature supplied as string
       * @param signature base64 encoded signature
       * @param contentToVerify base64 encoded content to verify
       * @param publicKey base64 encoded public key
       * @param digestAlgorithm must be one of the currently supported ones
       * @return a boolean indicating success (true) or failure (false)
       */
      verifySignature(
        signature: string,
        contentToVerify: string,
        publicKey: string,
        digestAlgorithm: string
      ): boolean;
      /**
       * Verifies a signature supplied as string
       * @param signature base64 encoded signature
       * @param contentToVerify base64 encoded content to verify
       * @param certificate a reference to a trusted certificate entry in the keystore
       * @param digestAlgorithm must be one of the currently supported ones
       * @return a boolean indicating success (true) or failure (false)
       */
      verifySignature(
        signature: string,
        contentToVerify: string,
        certificate: dw.crypto.CertificateRef,
        digestAlgorithm: string
      ): boolean;
    }
  }

  namespace customer {
    /**
     * Represents a set of addresses associated with a specific customer.
     *  The AddressBook object gets its data from the Profile object for the customer.
     *  When scripting, this class allows AddressBook to be treated as a separate object
     *  from the Profile. However, data is only stored in the platform in the Profile object
     *  and there is no separate AddressBook object. For this reason, the AddressBook ID is
     *  always the customer profile ID.
     *  <p>
     *  <b>Note:</b> this class allows access to sensitive personal and private information.
     *  Pay attention to appropriate legal and regulatory requirements when developing.</p>
     */
    class AddressBook {
      /**
       * A sorted list of addresses in the address book.  The addresses
       *  are sorted so that the preferred address is always sorted first.  The
       *  remaining addresses are sorted alphabetically by ID.
       */
      readonly addresses: dw.util.List<dw.customer.CustomerAddress>;
      /**
       * The address that has been defined as the customer's preferred
       *  address.
       */
      preferredAddress: dw.customer.CustomerAddress;

      /**
       * Creates a new, empty address object with the specified name.
       * @param name the ID of the address to create, must not be null.
       * @return the new address object or null if an address with the given name already exists in the address book.
       */
      createAddress(name: string): dw.customer.CustomerAddress;
      /**
       * Returns the address with the given name from the address book. The name
       *  is a unique identifier of the address within the address book.
       * @param id An address ID, must not be null.
       * @return The Address object or null if the address does not exist.
       */
      getAddress(id: string): dw.customer.CustomerAddress;
      /**
       * Returns a sorted list of addresses in the address book.  The addresses
       *  are sorted so that the preferred address is always sorted first.  The
       *  remaining addresses are sorted alphabetically by ID.
       *
       * @return Sorted List of customer addresses in the address book.
       */
      getAddresses(): dw.util.List<dw.customer.CustomerAddress>;
      /**
       * Returns the address that has been defined as the customer's preferred
       *  address.
       *
       * @return the default CustomerAddress object, or null if there is no preferred address.
       */
      getPreferredAddress(): dw.customer.CustomerAddress;
      /**
       * Removes the specified address from the address book. Because an address
       *  can be associated with a product list, you may want to verify if the
       *  address is being used by a product list. See ProductListMgr.findAddress().
       * @param address the address to remove, must not be null.
       */
      removeAddress(address: dw.customer.CustomerAddress): void;
      /**
       * Sets the specified address as the customer's preferred address. If null
       *  is passed, and there is an existing preferred address, then the address
       *  book will have no preferred address.
       * @param anAddress the address to be set as preferred, or null if the goal is to unset the existing preferred address.
       */
      setPreferredAddress(anAddress: dw.customer.CustomerAddress): void;
    }

    /**
     * Provides helper methods for handling agent user functionality (login and logout)
     *  Pay attention to appropriate legal and regulatory requirements related to this functionality.
     */
    class AgentUserMgr {
      /**
       * Logs in an agent user (which for example is authorized to login on-behalf of a customer for
       *  instance to place an order). The login is only allowed during a secure protocol
       *  request (https) and only in the storefront context. The user must have the permission 'Login_Agent'.
       *
       *  When the login is successful, a new session will be created. Any objects that need
       *  to be preserved in the session need to bet set on the session afterwards.
       *
       *  A Status object is returned which signals whether the login was successful or not.
       *  In case of a login failure the status object contains the reason for this.
       *  See AgentUserStatusCodes for more information.
       * @param login the login name for the agent user.
       * @param password the password for the agent user.
       * @return the login status (OK if successful, error code otherwise).
       */
      static loginAgentUser(login: string, password: string): dw.system.Status;
      /**
       * This method logs the specified customer into the current session if the
       *  current agent user has the functional permission 'Login_On_Behalf' in the
       *  current site.
       *
       *  The dwcustomer cookie will not be set.
       *  The login is only allowed during a secure protocol request (https).
       *  A Status object is returned indicating whether the login was successful or not (and indicating the
       *  failure reason). See AgentUserStatusCodes for more information.
       *  Error conditions include:
       *
       *    if the method is not called in the storefront context
       *    if the given customer is not a registered customer (anonymous)
       *    if the given customer is not registered for the current site
       *    if the given customer is disabled
       *    if there is no agent user at the current session
       *    if the agent user is not logged in
       *    if the agent user has not the functional permission 'Login_On_Behalf'
       * @param customer The customer, which should be logged instead of the agent user
       * @return the login status (OK if successful, error code otherwise).
       */
      static loginOnBehalfOfCustomer(
        customer: dw.customer.Customer
      ): dw.system.Status;
      /**
       * Performs a logout of the agent user and the current customer which are attached to the current session.
       *  The logout is only allowed during a secure protocol request (https) and only in the storefront context.
       *
       * @return the logout status (OK if successful, error code otherwise).
       */
      static logoutAgentUser(): dw.system.Status;
    }

    /**
     * AgentUserStatusCodes contains constants representing status codes that can be
     *  used with a <a href="class_dw_system_Status.html">Status</a> object to indicate the success or failure of the agent
     *  user login process.
     */
    class AgentUserStatusCodes {
      /**
       * Indicates that the agent user is not available.
       */
      static readonly AGENT_USER_NOT_AVAILABLE = "AGENT_USER_NOT_AVAILABLE";
      /**
       * Indicates that the agent user is not logged in.
       */
      static readonly AGENT_USER_NOT_LOGGED_IN = "AGENT_USER_NOT_LOGGED_IN";
      /**
       * Indicates that the given agent user login or password was wrong.
       */
      static readonly CREDENTIALS_INVALID = "CREDENTIALS_INVALID";
      /**
       * Indicates that the customer is disabled.
       */
      static readonly CUSTOMER_DISABLED = "CUSTOMER_DISABLED";
      /**
       * Indicates that the customer is either not registered or not registered with the current site.
       */
      static readonly CUSTOMER_UNREGISTERED = "CUSTOMER_UNREGISTERED";
      /**
       * Indicates that the current connection is not secure (HTTP instead of HTTPS)
       *  and the server is configured to require a secure connection.
       */
      static readonly INSECURE_CONNECTION = "INSECURE_CONNECTION";
      /**
       * Indicates that the given agent user does not have the permission
       *  'Login_Agent' which is required to login to the storefront as an agent
       *  user.
       */
      static readonly INSUFFICIENT_PERMISSION = "INSUFFICIENT_PERMISSION";
      /**
       * Indicates that the agent user login was successful.
       */
      static readonly LOGIN_SUCCESSFUL = "LOGIN_SUCCESSFUL";
      /**
       * Indicates that the current context is not a storefront request.
       */
      static readonly NO_STOREFRONT = "NO_STOREFRONT";
      /**
       * Indicates that the given agent user password has expired and needs to be
       *  changed in the Business Manager.
       */
      static readonly PASSWORD_EXPIRED = "PASSWORD_EXPIRED";
      /**
       * Indicates that the agent user account has been disabled in the Business
       *  Manager.
       */
      static readonly USER_DISABLED = "USER_DISABLED";
      /**
       * Indicates that the agent user account is locked, because the maximum
       *  number of failed login attempts was exceeded.
       */
      static readonly USER_LOCKED = "USER_LOCKED";
    }

    /**
     * Holds the status of an authentication process.
     */
    class AuthenticationStatus {
      /**
       * Authentication was successful
       */
      static readonly AUTH_OK = "AUTH_OK";
      /**
       * customer could be found, but is disabled. Password was not verified.
       */
      static readonly ERROR_CUSTOMER_DISABLED = "ERROR_CUSTOMER_DISABLED";
      /**
       * customer could be found, but is locked (too many failed login attempts). Password was verified before.
       */
      static readonly ERROR_CUSTOMER_LOCKED = "ERROR_CUSTOMER_LOCKED";
      /**
       * customer could not be found
       */
      static readonly ERROR_CUSTOMER_NOT_FOUND = "ERROR_CUSTOMER_NOT_FOUND";
      /**
       * Password does match, but is expired.
       */
      static readonly ERROR_PASSWORD_EXPIRED = "ERROR_PASSWORD_EXPIRED";
      /**
       * the used password is not correct
       */
      static readonly ERROR_PASSWORD_MISMATCH = "ERROR_PASSWORD_MISMATCH";
      /**
       * Any other error
       */
      static readonly ERROR_UNKNOWN = "ERROR_UNKNOWN";

      /**
       * checks whether the authentication was successful or not
       */
      readonly authenticated: boolean;
      /**
       * The customer, corresponding to the login used during authentication. This customer is not logged in after authentication.
       */
      readonly customer: dw.customer.Customer;
      /**
       * the status code (see the constants above)
       */
      readonly status: string;

      /**
       * The customer, corresponding to the login used during authentication. This customer is not logged in after authentication.
       *
       * @return the customer described by the login
       */
      getCustomer(): dw.customer.Customer;
      /**
       * the status code (see the constants above)
       *
       * @return the status code
       */
      getStatus(): string;
      /**
       * checks whether the authentication was successful or not
       *
       * @return the when the authentication was successful
       */
      isAuthenticated(): boolean;
    }

    /**
     * Represents the credentials of a customer.
     *
     *  Since 13.6 it is possible to have customers who are not authenticated through a
     *  login and password but through an external authentication provider via the OAuth2 protocol.
     *
     *  In such cases, the AuthenticationProviderID will point to an OAuth provider configured in the system
     *  and the ExternalID will be the unique identifier of the customer on the Authentication Provider&apos;s system.
     *
     *  For example, if an authentication provider with ID &quot;Google123&quot; is configured pointing to Google
     *  and the customer has a logged in into Google in the past and has created a profile there, Google
     *  assigns a unique number identifier to that customer. If the storefront is configured to allow
     *  authentication through Google and a new customer logs into the storefront using Google,
     *  the AuthenticationProviderID property of his Credentials will contain &quot;Google123&quot; and
     *  the ExternalID property will contain whatever unique identifier Google has assigned to him.
     *  In such cases the password-related properties of the Credentials will be empty.
     *  <p>
     *  <b>Note:</b> this class handles sensitive security-related data.
     *  Pay special attention to PCI DSS v3. requirements 2, 4, and 12.</p>
     */
    class Credentials {
      /**
       * The authentication provider ID.
       */
      authenticationProviderID: string;
      /**
       * Identifies if this customer is enabled and can log in.
       */
      readonly enabled: boolean;
      /**
       * Identifies if this customer is enabled and can log in - same as isEnabled().
       */
      enabledFlag: boolean;
      /**
       * The external ID of the customer.
       */
      externalID: string;
      /**
       * Identifies if this customer is temporarily locked out because of invalid
       *  login attempts.  If customer locking is not enabled, this method always
       *  returns false.
       */
      readonly locked: boolean;
      /**
       * The login of the user. It must be unique.
       */
      login: string;
      /**
       * The answer to the password question for the customer. The answer is used
       *  with the password question to confirm the identity of a customer when
       *  they are trying to fetch their password.
       */
      passwordAnswer: string;
      /**
       * The password question for the customer. The password question is
       *  used with the password answer to confirm the identity of a customer when
       *  they are trying to fetch their password.
       */
      passwordQuestion: string;
      /**
       * Returns whether the password is set. Creating externally authenticated customers
       *  results in customers with credentials for which the password is not set.
       */
      readonly passwordSet: boolean;
      /**
       * The number of consecutive failed logins after which this customer
       *  will be temporarily locked out and prevented from logging in to the
       *  current site. This value is based on the number of previous invalid
       *  logins for this customer and customer site preferences defining the
       *  limits.
       *
       *  If this customer is already locked out, this method will always return 0.
       *  If customer locking is disabled altogether, or if the system cannot
       *  determine the number of failed login attempts for this customer, then
       *  this method will return a negative number.
       */
      readonly remainingLoginAttempts: number;

      /**
       * Generate a random token which can be used for resetting the password of the underlying Customer. The token is
       *  guaranteed to be unique and will be valid for 30 minutes. Any token previously generated for this customer will
       *  be invalidated.
       *
       * @return The generated token.
       */
      createResetPasswordToken(): string;
      /**
       * Returns the authentication provider ID.
       *
       * @return the authentication provider ID.
       */
      getAuthenticationProviderID(): string;
      /**
       * Identifies if this customer is enabled and can log in - same as isEnabled().
       *
       * @return true if the customer is enabled and can log in, false otherwise.
       */
      getEnabledFlag(): boolean;
      /**
       * Returns the external ID of the customer.
       *
       * @return the external ID of the customer.
       */
      getExternalID(): string;
      /**
       * Returns the login of the user. It must be unique.
       *
       * @return the login of the user.
       */
      getLogin(): string;
      /**
       * Returns the answer to the password question for the customer. The answer is used
       *  with the password question to confirm the identity of a customer when
       *  they are trying to fetch their password.
       *
       * @return the answer to the password question for the customer.
       */
      getPasswordAnswer(): string;
      /**
       * Returns the password question for the customer. The password question is
       *  used with the password answer to confirm the identity of a customer when
       *  they are trying to fetch their password.
       *
       * @return the password question for the customer.
       */
      getPasswordQuestion(): string;
      /**
       * Returns the number of consecutive failed logins after which this customer
       *  will be temporarily locked out and prevented from logging in to the
       *  current site. This value is based on the number of previous invalid
       *  logins for this customer and customer site preferences defining the
       *  limits.
       *
       *  If this customer is already locked out, this method will always return 0.
       *  If customer locking is disabled altogether, or if the system cannot
       *  determine the number of failed login attempts for this customer, then
       *  this method will return a negative number.
       *
       * @return The number of consecutive failed logins after which this customer will be locked out.
       */
      getRemainingLoginAttempts(): number;
      /**
       * Identifies if this customer is enabled and can log in.
       *
       * @return true if the customer is enabled and can log in, false otherwise.
       */
      isEnabled(): boolean;
      /**
       * Identifies if this customer is temporarily locked out because of invalid
       *  login attempts.  If customer locking is not enabled, this method always
       *  returns false.
       *
       * @return true if the customer is locked, false otherwise.
       */
      isLocked(): boolean;
      /**
       * Returns whether the password is set. Creating externally authenticated customers
       *  results in customers with credentials for which the password is not set.
       *
       * @return true if the password is set.
       */
      isPasswordSet(): boolean;
      /**
       * Sets the authentication provider ID corresponding to an OAuth provider configured in the system.
       * @param authenticationProviderID the authentication Provider ID to set.
       */
      setAuthenticationProviderID(authenticationProviderID: string): void;
      /**
       * Sets the enabled status of the customer.
       * @param enabledFlag controls if a customer is enabled or not.
       */
      setEnabledFlag(enabledFlag: boolean): void;
      /**
       * Sets the external ID of the customer at the authentication provider.
       *  The value is provided by the authentication provider during the
       *  OAuth authentication and is unique within that provider.
       * @param externalID the external ID to set.
       */
      setExternalID(externalID: string): void;
      /**
       * Sets the login value for the customer.
       *
       *  IMPORTANT: This method should no longer be used for the following
       *  reasons:
       *
       *
       *  It changes the login without re-encrypting the password. (The
       *  customer password is stored internally using a one-way encryption scheme
       *  which uses the login as one of its inputs. Therefore changing the login
       *  requires re-encrypting the password.)
       *  It does not validate the structure of the login to ensure that it
       *  only uses acceptable characters.
       *  It does not correctly prevent duplicate logins. If the passed login
       *  matches a different customer's login exactly, then this method will throw
       *  an exception. However, it does not prevent the creation of inexact matches,
       *  where two customers have a login differing only by alphabetic case (e.g.
       *  "JaneDoe" and "janedoe")
       * @param login The login value for the customer.
       */
      setLogin(login: string): void;
      /**
       * Sets the login value for the customer, and also re-encrypt the customer
       *  password based on the new login. Customer login must be a sequence of
       *  letters, numbers, and the following characters: space, period, ampersand,
       *  underscore and dash.
       *
       *  This method fails to set the login and returns false in the following
       *  cases:
       *
       *
       *  newLogin is of an invalid form (e.g. contains invalid characters).
       *  currentPassword is not the customer's correct password.
       *  newLogin is already in use by another customer (i.e. there is another
       *  customer in the system with the exact same login name or a name differing
       *  only by alphabetic case.)
       *
       *
       *  If newLogin is the same as the existing login, the method does nothing and
       *  returns true, regardless of whether currentPassword is the correct
       *  password.
       * @param newLogin The login value for the customer.
       * @param currentPassword The customer's current password in plain-text.
       * @return true if setting the login succeeded, false otherwise.
       */
      setLogin(newLogin: string, currentPassword: string): boolean;
      /**
       * Sets the password of an authenticated customer.
       *
       *  The method can be called for externally authenticated customers as well but
       *  these customers will still be externally authenticated so calling the method
       *  for such customers does not have an immediate practical benefit. If such customers
       *  are converted back to regularly authenticated (via login and password) the new password
       *  will be used.
       *
       *  Method call will fail under any of these conditions:
       *
       *   customer is not registered
       *   customer is not authenticated
       *   verifyOldPassword=true && oldPassword is empty
       *   verifyOldPassword=true and oldPassword does not match the existing password
       *   newPassword is empty
       *   newPassword does not meet acceptance criteria
       * @param newPassword the new password
       * @param oldPassword the old password (optional, only needed if 'verifyOldPassword' is set to 'true'
       * @param verifyOldPassword whether the oldPassword should be verified
       * @return Status the status of the operation (OK or ERROR). If status is Error, there will be additional information in the Status message
       */
      setPassword(
        newPassword: string,
        oldPassword: string,
        verifyOldPassword: boolean
      ): dw.system.Status;
      /**
       * Sets the answer to the password question for the customer.
       * @param answer the answer to the password question.
       */
      setPasswordAnswer(answer: string): void;
      /**
       * Sets the password question for the customer.
       * @param question the password question.
       */
      setPasswordQuestion(question: string): void;
      /**
       * Set the password of the specified customer to the specified value. This operation will fail if the specified
       *  token is invalid (i.e. not associated with the specified Customer), the token is expired, or the password does
       *  not satisfy system password requirements.
       * @param token The token required for performing the password reset.
       * @param newPassword The new password. Must meet all requirements for passwords
       * @return Status the status of the operation (OK or ERROR). If status is Error, there will be additional information in the Status message
       */
      setPasswordWithToken(
        token: string,
        newPassword: string
      ): dw.system.Status;
    }

    /**
     * Represents a customer.
     */
    class Customer {
      /**
       * The active data for this customer.
       */
      readonly activeData: dw.customer.CustomerActiveData;
      /**
       * The address book for the profile of this customer,
       *  or null if this customer has no profile, such as for an
       *  anonymous customer.
       */
      readonly addressBook: dw.customer.AddressBook;
      /**
       * Identifies if the customer is anonymous. An anonymous
       *  customer is the opposite of a registered customer.
       */
      readonly anonymous: boolean;
      /**
       * Identifies if the customer is authenticated. This method checks whether
       *  this customer is the customer associated with the session and than checks
       *  whether the session in an authenticated state.
       *
       *  Note: The pipeline debugger will always show 'false' for this value
       *  regardless of whether the customer is authenticated or not.
       */
      readonly authenticated: boolean;
      /**
       * The customer groups this customer is member of.
       *
       *  Result contains static customer groups in storefront and job session
       *  Result contains dynamic customer groups in storefront  and job session.
       *  Dynamic customer groups referring session or request data are not available
       *  when processing the customer in a job session, or when this customer is not the customer assigned to the current session.
       *
       *  Result contains system groups 'Everyone', 'Unregistered', 'Registered' for all customers in storefront and job sessions
       */
      readonly customerGroups: dw.util.Collection<dw.customer.CustomerGroup>;
      /**
       * Identifies if the customer is externally authenticated. An externally
       *  authenticated customer does not have the password stored in our system
       *  but logs in through an external OAuth provider (Google, Facebook, LinkedIn, etc.)
       */
      readonly externallyAuthenticated: boolean;
      /**
       * A collection of any external profiles the customer may have
       */
      readonly externalProfiles: dw.util.Collection<
        dw.customer.ExternalProfile
      >;
      /**
       * The Global Party ID for the customer, if there is one.
       *  Global Party ID is created by Customer 360 and identifies a person across multiple systems.
       */
      readonly globalPartyID: string;
      /**
       * The unique, system generated ID of the customer.
       */
      readonly ID: string;
      /**
       * The note for this customer, or null if this customer has no note, such as for an anonymous
       *  customer or when note has 0 length.
       */
      note: string;
      /**
       * The customer order history.
       */
      readonly orderHistory: dw.customer.OrderHistory;
      /**
       * The customer profile.
       */
      readonly profile: dw.customer.Profile;
      /**
       * Identifies if the customer is registered. A registered customer
       *  may or may not be authenticated. This method checks whether
       *  the user has a profile.
       */
      readonly registered: boolean;

      /**
       * Creates an externalProfile and attaches it to the list of external profiles for the customer
       * @param authenticationProviderId the authenticationProviderId for the externalProfile
       * @param externalId the externalId for the external Profile
       * @return the new externalProfile
       */
      createExternalProfile(
        authenticationProviderId: string,
        externalId: string
      ): dw.customer.ExternalProfile;
      /**
       * Returns the active data for this customer.
       *
       * @return the active data for this customer.
       */
      getActiveData(): dw.customer.CustomerActiveData;
      /**
       * Returns the address book for the profile of this customer,
       *  or null if this customer has no profile, such as for an
       *  anonymous customer.
       *
       */
      getAddressBook(): dw.customer.AddressBook;
      /**
       * Returns the customer groups this customer is member of.
       *
       *  Result contains static customer groups in storefront and job session
       *  Result contains dynamic customer groups in storefront  and job session.
       *  Dynamic customer groups referring session or request data are not available
       *  when processing the customer in a job session, or when this customer is not the customer assigned to the current session.
       *
       *  Result contains system groups 'Everyone', 'Unregistered', 'Registered' for all customers in storefront and job sessions
       *
       * @return Collection of customer groups of this customer
       */
      getCustomerGroups(): dw.util.Collection<dw.customer.CustomerGroup>;
      /**
       * A convenience method for finding an external profile among the customer's external profiles collection
       * @param authenticationProviderId the authenticationProviderId to look for
       * @param externalId the externalId to look for
       * @return the externalProfile found among the customer's external profile or null if not found
       */
      getExternalProfile(
        authenticationProviderId: string,
        externalId: string
      ): dw.customer.ExternalProfile;
      /**
       * Returns a collection of any external profiles the customer may have
       *
       * @return a collection of any external profiles the customer may have
       */
      getExternalProfiles(): dw.util.Collection<dw.customer.ExternalProfile>;
      /**
       * Returns the Global Party ID for the customer, if there is one.
       *  Global Party ID is created by Customer 360 and identifies a person across multiple systems.
       *
       * @return The global party ID
       */
      getGlobalPartyID(): string;
      /**
       * Returns the unique, system generated ID of the customer.
       *
       * @return the ID of the customer.
       */
      getID(): string;
      /**
       * Returns the note for this customer, or null if this customer has no note, such as for an anonymous
       *  customer or when note has 0 length.
       *
       * @return the note for this customer.
       */
      getNote(): string;
      /**
       * Returns the customer order history.
       *
       * @return the customer order history.
       */
      getOrderHistory(): dw.customer.OrderHistory;
      /**
       * Returns the product lists of the specified type.
       * @param type the type of product lists to return.
       * @return the product lists of the specified type.
       */
      getProductLists(
        type: number
      ): dw.util.Collection<dw.customer.ProductList>;
      /**
       * Returns the customer profile.
       *
       * @return the customer profile.
       */
      getProfile(): dw.customer.Profile;
      /**
       * Identifies if the customer is anonymous. An anonymous
       *  customer is the opposite of a registered customer.
       *
       * @return true if the customer is anonymous, false otherwise.  Note: this method handles sensitive security-related data. Pay special attention to PCI DSS v3. requirements 2, 4, and 12.
       */
      isAnonymous(): boolean;
      /**
       * Identifies if the customer is authenticated. This method checks whether
       *  this customer is the customer associated with the session and than checks
       *  whether the session in an authenticated state.
       *
       *  Note: The pipeline debugger will always show 'false' for this value
       *  regardless of whether the customer is authenticated or not.
       *
       * @return true if the customer is authenticated, false otherwise.
       */
      isAuthenticated(): boolean;
      /**
       * Identifies if the customer is externally authenticated. An externally
       *  authenticated customer does not have the password stored in our system
       *  but logs in through an external OAuth provider (Google, Facebook, LinkedIn, etc.)
       *
       * @return true if the customer is externally authenticated, false otherwise.  Note: this method handles sensitive security-related data. Pay special attention to PCI DSS v3. requirements 2, 4, and 12.
       */
      isExternallyAuthenticated(): boolean;
      /**
       * Returns true if there exist CustomerGroup for all of the given IDs and the customer is member of at least one of that groups.
       * @param groupIDs A list of unique semantic customer group IDs.
       * @return True if customer groups exist for the given IDs and the customer is member of at least one of that existing groups. False if none of customer groups exist or if the customer is not a member of any of that existing groups.
       */
      isMemberOfAnyCustomerGroup(...groupIDs: string[]): boolean;
      /**
       * Returns true if the customer is member of the specified
       *  CustomerGroup.
       * @param group Customer group
       * @return True if customer is member of the group, otherwise false.
       */
      isMemberOfCustomerGroup(group: dw.customer.CustomerGroup): boolean;
      /**
       * Returns true if there is a CustomerGroup with such an ID and the customer is member of that group.
       * @param groupID The unique semantic customer group ID.
       * @return True if a customer group with such an ID exist and the customer is member of that group. False if no such customer group exist or, if the group exist, the customer is not member of that group.
       */
      isMemberOfCustomerGroup(groupID: string): boolean;
      /**
       * Returns true if there exist CustomerGroup for all of the given IDs and the customer is member of all that groups.
       * @param groupIDs A list of unique semantic customer group IDs.
       * @return True if customer groups exist for all of the given IDs and the customer is member of all that groups. False if there is at least one ID for which no customer group exist or, if all groups exist, the customer is not member of all that groups.
       */
      isMemberOfCustomerGroups(...groupIDs: string[]): boolean;
      /**
       * Identifies if the customer is registered. A registered customer
       *  may or may not be authenticated. This method checks whether
       *  the user has a profile.
       *
       * @return true if the customer is registered, false otherwise.
       */
      isRegistered(): boolean;
      /**
       * Removes an external profile from the customer
       * @param externalProfile the externalProfile to be removed
       */
      removeExternalProfile(externalProfile: dw.customer.ExternalProfile): void;
      /**
       * Sets the note for this customer. This is a no-op for an anonymous customer.
       * @param aValue the value of the note
       */
      setNote(aValue: string): void;
    }

    /**
     * Represents the active data for a <a href="class_dw_customer_Customer.html">Customer</a> in Commerce Cloud Digital.
     *  <p>
     *  <b>Note:</b> this class allows access to sensitive personal and private information.
     *  Pay attention to appropriate legal and regulatory requirements when developing.</p>
     */
    class CustomerActiveData extends dw.object.ActiveData {
      /**
       * The average order value of the customer, or null
       *  if none has been set or the value is no longer valid.
       */
      readonly avgOrderValue: number;
      /**
       * The discount value resulting from coupons, that has been applied
       *  to orders of the customer, or null if none has been set or
       *  the value is no longer valid.
       */
      readonly discountValueWithCoupon: number;
      /**
       * The discount value resulting from promotions other than coupons,
       *  that has been applied to orders of the customer, or null
       *  if none has been set or the value is no longer valid.
       */
      readonly discountValueWithoutCoupon: number;
      /**
       * The number of orders for the Customer that contained at least
       *  one product unit marked as a gift, or null if none has been
       *  set or the value is no longer valid.
       */
      readonly giftOrders: number;
      /**
       * The number of product units in orders for the customer
       *  that were marked as a gift, or null if none has been set
       *  or the value is no longer valid.
       */
      readonly giftUnits: number;
      /**
       * The date of the last order for the customer, or null
       *  if there are no orders for the customer.
       */
      readonly lastOrderDate: Date;
      /**
       * The orders of the customer, or null if none
       *  has been set or the value is no longer valid.
       */
      readonly orders: number;
      /**
       * The lifetime order value of the customer, or null
       *  if none has been set or the value is no longer valid.
       */
      readonly orderValue: number;
      /**
       * The order value of the customer, over the most recent 30 days,
       *  or null if none has been set or the value is no longer valid.
       */
      readonly orderValueMonth: number;
      /**
       * An array containing the master product SKUs of variation products
       *  in orders for the customer, or an empty collection if no SKUs have been
       *  set or the collection of SKUs is no longer valid. There is no specific
       *  limit on the number of SKUs that will be returned in the collection, but
       *  there is also no guarantee that it will contain the SKUs for all products
       *  ordered by the customer.
       */
      readonly productMastersOrdered: string;
      /**
       * An array containing the SKUs of products in baskets abandoned
       *  by the customer in the last 30 days, or an empty collection if no SKUs
       *  have been set or the collection is no longer valid.  There is no specific
       *  limit on the number of SKUs that will be returned in the collection, but
       *  there is also no guarantee that it will contain the SKUs for all products
       *  in baskets abandoned by the customer.
       */
      readonly productsAbandonedMonth: string;
      /**
       * An array containing the SKUs of products in orders
       *  for the customer, or an empty collection if no SKUs have been set or the
       *  collection of SKUs is no longer valid.  There is no specific limit on the
       *  number of SKUs that will be returned in the collection, but there is also
       *  no guarantee that it will contain the SKUs for all products ordered by
       *  the customer.
       */
      readonly productsOrdered: string;
      /**
       * An array containing the SKUs of products viewed by the
       *  customer in the last 30 days, or an empty collection if no SKUs have been
       *  set or the collection is no longer valid.  There is no specific limit on
       *  the number of SKUs that will be returned in the collection, but there is
       *  also no guarantee that it will contain the SKUs for all products viewed
       *  by the customer.
       */
      readonly productsViewedMonth: string;
      /**
       * The number of returns of the customer, or null
       *  if none has been set or the value is no longer valid.
       */
      readonly returns: number;
      /**
       * The returned revenue of the customer, or null
       *  if none has been set or the value is no longer valid.
       */
      readonly returnValue: number;
      /**
       * The number of orders for the customer where a source code was
       *  in effect, or null if none has been set or the value
       *  is no longer valid.
       */
      readonly sourceCodeOrders: number;
      /**
       * An array containing the IDs of up to the top 20 categories for
       *  customer orders, or an empty list if no categories have been set or the
       *  list of categories is no longer valid. The top category is the one for
       *  which the most orders for the customer contained at least one product
       *  found in that category.
       */
      readonly topCategoriesOrdered: string;
      /**
       * The visits of the customer, over the most recent 30 days,
       *  or null if none has been set or the value
       *  is no longer valid.
       */
      readonly visitsMonth: number;
      /**
       * The visits of the customer, over the most recent 7 days,
       *  or null if none has been set or the value
       *  is no longer valid.
       */
      readonly visitsWeek: number;
      /**
       * The visits of the customer, over the most recent 365 days,
       *  or null if none has been set or the value
       *  is no longer valid.
       */
      readonly visitsYear: number;

      /**
       * Returns the average order value of the customer, or null
       *  if none has been set or the value is no longer valid.
       *
       * @return the average order size.
       */
      getAvgOrderValue(): number;
      /**
       * Returns the discount value resulting from coupons, that has been applied
       *  to orders of the customer, or null if none has been set or
       *  the value is no longer valid.
       *
       * @return the discount value resulting from coupons.
       */
      getDiscountValueWithCoupon(): number;
      /**
       * Returns the discount value resulting from promotions other than coupons,
       *  that has been applied to orders of the customer, or null
       *  if none has been set or the value is no longer valid.
       *
       * @return the discount value resulting from promotions other than coupons.
       */
      getDiscountValueWithoutCoupon(): number;
      /**
       * Returns the number of orders for the Customer that contained at least
       *  one product unit marked as a gift, or null if none has been
       *  set or the value is no longer valid.
       *
       * @return the number of gift orders.
       */
      getGiftOrders(): number;
      /**
       * Returns the number of product units in orders for the customer
       *  that were marked as a gift, or null if none has been set
       *  or the value is no longer valid.
       *
       * @return the number of gift product units.
       */
      getGiftUnits(): number;
      /**
       * Returns the date of the last order for the customer, or null
       *  if there are no orders for the customer.
       *
       * @return the date of the last order for the customer.
       */
      getLastOrderDate(): Date;
      /**
       * Returns the orders of the customer, or null if none
       *  has been set or the value is no longer valid.
       *
       * @return the orders.
       */
      getOrders(): number;
      /**
       * Returns the lifetime order value of the customer, or null
       *  if none has been set or the value is no longer valid.
       *
       * @return the lifetime value.
       */
      getOrderValue(): number;
      /**
       * Returns the order value of the customer, over the most recent 30 days,
       *  or null if none has been set or the value is no longer valid.
       *
       * @return the value over the last 30 days.
       */
      getOrderValueMonth(): number;
      /**
       * Returns an array containing the master product SKUs of variation products
       *  in orders for the customer, or an empty collection if no SKUs have been
       *  set or the collection of SKUs is no longer valid. There is no specific
       *  limit on the number of SKUs that will be returned in the collection, but
       *  there is also no guarantee that it will contain the SKUs for all products
       *  ordered by the customer.
       *
       * @return a collection containing the master product SKUs of variation products that were ordered.
       */
      getProductMastersOrdered(): String[];
      /**
       * Returns an array containing the SKUs of products in baskets abandoned
       *  by the customer in the last 30 days, or an empty collection if no SKUs
       *  have been set or the collection is no longer valid.  There is no specific
       *  limit on the number of SKUs that will be returned in the collection, but
       *  there is also no guarantee that it will contain the SKUs for all products
       *  in baskets abandoned by the customer.
       *
       * @return a collection containing the SKUs of products that were abandoned.
       */
      getProductsAbandonedMonth(): String[];
      /**
       * Returns an array containing the SKUs of products in orders
       *  for the customer, or an empty collection if no SKUs have been set or the
       *  collection of SKUs is no longer valid.  There is no specific limit on the
       *  number of SKUs that will be returned in the collection, but there is also
       *  no guarantee that it will contain the SKUs for all products ordered by
       *  the customer.
       *
       * @return a collection containing the SKUs of products that were ordered.
       */
      getProductsOrdered(): String[];
      /**
       * Returns an array containing the SKUs of products viewed by the
       *  customer in the last 30 days, or an empty collection if no SKUs have been
       *  set or the collection is no longer valid.  There is no specific limit on
       *  the number of SKUs that will be returned in the collection, but there is
       *  also no guarantee that it will contain the SKUs for all products viewed
       *  by the customer.
       *
       * @return a collection containing the SKUs of products that were ordered.
       */
      getProductsViewedMonth(): String[];
      /**
       * Returns the number of returns of the customer, or null
       *  if none has been set or the value is no longer valid.
       *
       * @return the returns.
       */
      getReturns(): number;
      /**
       * Returns the returned revenue of the customer, or null
       *  if none has been set or the value is no longer valid.
       *
       * @return the returned revenue.
       */
      getReturnValue(): number;
      /**
       * Returns the number of orders for the customer where a source code was
       *  in effect, or null if none has been set or the value
       *  is no longer valid.
       *
       * @return the number of orders with source codes in effect.
       */
      getSourceCodeOrders(): number;
      /**
       * Returns an array containing the IDs of up to the top 20 categories for
       *  customer orders, or an empty list if no categories have been set or the
       *  list of categories is no longer valid. The top category is the one for
       *  which the most orders for the customer contained at least one product
       *  found in that category.
       *
       * @return a list containing the top 20 categories.
       */
      getTopCategoriesOrdered(): String[];
      /**
       * Returns the visits of the customer, over the most recent 30 days,
       *  or null if none has been set or the value
       *  is no longer valid.
       *
       * @return the visits over the last 30 days.
       */
      getVisitsMonth(): number;
      /**
       * Returns the visits of the customer, over the most recent 7 days,
       *  or null if none has been set or the value
       *  is no longer valid.
       *
       * @return the visits over the last 7 days.
       */
      getVisitsWeek(): number;
      /**
       * Returns the visits of the customer, over the most recent 365 days,
       *  or null if none has been set or the value
       *  is no longer valid.
       *
       * @return the visits over the last 365 days.
       */
      getVisitsYear(): number;
    }

    /**
     * The Address class represents a customer&apos;s address.
     *  <p>
     *  <b>Note:</b> this class allows access to sensitive personal and private information.
     *  Pay attention to appropriate legal and regulatory requirements.</p>
     */
    class CustomerAddress extends dw.object.ExtensibleObject {
      /**
       * The customer's first address.
       */
      address1: string;
      /**
       * The customer's second address value.
       */
      address2: string;
      /**
       * The customer's city.
       */
      city: string;
      /**
       * The customer's company name.
       */
      companyName: string;
      /**
       * The customer's country code. Commerce Cloud Digital supports two-character
       *  country codes per ISO 3166-1 alpha-2. See
       *  http://www.iso.org/iso/country_codes/iso_3166-faqs/iso_3166_faqs_general.htm
       *  for additional information.
       */
      countryCode: dw.value.EnumValue;
      /**
       * The customer's first name.
       */
      firstName: string;
      /**
       * A concatenation of the customer's first, middle,
       *  and last names and its suffix.
       */
      readonly fullName: string;
      /**
       * The name of the address.
       */
      ID: string;
      /**
       * The customer's job title.
       */
      jobTitle: string;
      /**
       * The customer's last name.
       */
      lastName: string;
      /**
       * The customer's phone number.
       */
      phone: string;
      /**
       * The customer's postal code.
       */
      postalCode: string;
      /**
       * The customer's post box.
       */
      postBox: string;
      /**
       * The customer's salutation.
       */
      salutation: string;
      /**
       * The customer's second name.
       */
      secondName: string;
      /**
       * The customer's state.
       */
      stateCode: string;
      /**
       * The customer's suffix.
       */
      suffix: string;
      /**
       * The customer's suite.
       */
      suite: string;
      /**
       * The customer's title.
       */
      title: string;

      /**
       * Returns the customer's first address.
       *
       * @return the first address value.
       */
      getAddress1(): string;
      /**
       * Returns the customer's second address value.
       *
       * @return the value of the second address.
       */
      getAddress2(): string;
      /**
       * Returns the customer's city.
       *
       * @return the customer's city.
       */
      getCity(): string;
      /**
       * Returns the customer's company name.
       *
       * @return the company name.
       */
      getCompanyName(): string;
      /**
       * Returns the customer's country code. Commerce Cloud Digital supports two-character
       *  country codes per ISO 3166-1 alpha-2. See
       *  http://www.iso.org/iso/country_codes/iso_3166-faqs/iso_3166_faqs_general.htm
       *  for additional information.
       *
       * @return the two-digit country code.
       */
      getCountryCode(): dw.value.EnumValue;
      /**
       * Returns the customer's first name.
       *
       * @return the customer first name.
       */
      getFirstName(): string;
      /**
       * Returns a concatenation of the customer's first, middle,
       *  and last names and its suffix.
       *
       * @return a concatenation of the customer's first, middle, and last names and its suffix.
       */
      getFullName(): string;
      /**
       * Returns the name of the address.
       *
       * @return the address name.
       */
      getID(): string;
      /**
       * Returns the customer's job title.
       *
       * @return the job title.
       */
      getJobTitle(): string;
      /**
       * Returns the customer's last name.
       *
       * @return the last name.
       */
      getLastName(): string;
      /**
       * Returns the customer's phone number.
       *
       * @return the phone number.
       */
      getPhone(): string;
      /**
       * Returns the customer's postal code.
       *
       * @return the postal code.
       */
      getPostalCode(): string;
      /**
       * Returns the customer's post box.
       *
       * @return the post box.
       */
      getPostBox(): string;
      /**
       * Returns the customer's salutation.
       *
       * @return the salutation.
       */
      getSalutation(): string;
      /**
       * Returns the customer's second name.
       *
       * @return the second name.
       */
      getSecondName(): string;
      /**
       * Returns the customer's state.
       *
       * @return the state.
       */
      getStateCode(): string;
      /**
       * Returns the customer's suffix.
       *
       * @return the suffix.
       */
      getSuffix(): string;
      /**
       * Returns the customer's suite.
       *
       * @return the suite.
       */
      getSuite(): string;
      /**
       * Returns the customer's title.
       *
       * @return the title.
       */
      getTitle(): string;
      /**
       * Returns true if the specified address is equivalent to
       *  this address. An equivalent address is an address whose
       *  core attributes contain the same values. The core attributes
       *  are:
       *
       *  address1
       *  address2
       *  city
       *  companyName
       *  countryCode
       *  firstName
       *  lastName
       *  postalCode
       *  postBox
       *  stateCode
       * @param address the address to test.
       * @return true if the specified address is equivalent to this address, false otherwise.
       */
      isEquivalentAddress(address: any): boolean;
      /**
       * Sets the value of the customer's first address.
       * @param value The value to set.
       */
      setAddress1(value: string): void;
      /**
       * Sets the customer's second address value.
       * @param value The value to set.
       */
      setAddress2(value: string): void;
      /**
       * Sets the customer's city.
       * @param city the customer's city to set.
       */
      setCity(city: string): void;
      /**
       * Sets the customer's company name.
       * @param companyName the name of the company.
       */
      setCompanyName(companyName: string): void;
      /**
       * Sets the customer's country code. Commerce Cloud Digital supports two-character
       *  country codes per ISO 3166-1 alpha-2. See
       *  http://www.iso.org/iso/country_codes/iso_3166-faqs/iso_3166_faqs_general.htm
       *  for additional information.
       * @param countryCode the country code, must be no more than 2 characters or will be truncated.
       */
      setCountryCode(countryCode: string): void;
      /**
       * Sets the customer's first name.
       * @param firstName the customer's first name to set.
       */
      setFirstName(firstName: string): void;
      /**
       * Sets the address name.
       * @param value the name to use.
       */
      setID(value: string): void;
      /**
       * Sets the customer's job title.
       * @param jobTitle The jobTitle to set.
       */
      setJobTitle(jobTitle: string): void;
      /**
       * Sets the customer's last name.
       * @param lastName The last name to set.
       */
      setLastName(lastName: string): void;
      /**
       * Sets the customer's phone number. The length is restricted to 32 characters.
       * @param phoneNumber The phone number to set.
       */
      setPhone(phoneNumber: string): void;
      /**
       * Sets the customer's postal code.
       * @param postalCode The postal code to set.
       */
      setPostalCode(postalCode: string): void;
      /**
       * Sets the customer's post box.
       * @param postBox The post box to set.
       */
      setPostBox(postBox: string): void;
      /**
       * Sets the customer's salutation.
       * @param value the salutation.
       */
      setSaluation(value: string): void;
      /**
       * Sets the customer's salutation.
       * @param value the salutation.
       */
      setSalutation(value: string): void;
      /**
       * Sets the customer's second name.
       * @param secondName The second name to set.
       */
      setSecondName(secondName: string): void;
      /**
       * Sets the customer's state.
       * @param state The state to set.
       */
      setStateCode(state: string): void;
      /**
       * Sets the customer's suffix.
       * @param suffix The suffix to set.
       */
      setSuffix(suffix: string): void;
      /**
       * Sets the customer's suite. The length is restricted to 32 characters.
       * @param value the suite to set.
       */
      setSuite(value: string): void;
      /**
       * Sets the customer's title.
       * @param title The title to set.
       */
      setTitle(title: string): void;
    }

    /**
     * CustomerGroups provide a means to segment customers by various criteria. A
     *  merchant can then provide different site experiences (e.g. promotions,
     *  prices, sorting rules) to each customer segment. Customer groups can consist
     *  of either an explicit list of customers or a business rule that dynamically
     *  determines whether a customer is a member. The former type is called
     *  &quot;explicit&quot; and the latter type is called &quot;dynamic&quot;.
     *
     *  <ul>
     *  <li><b>Explicit customer group:</b> Consists of an explicit list of
     *  customers. Only registered customers can be member of such a group.
     *  isRuleBased==false.</li>
     *  <li><b>Dynamic customer group:</b> Memberships are evaluated by a business
     *  rule that is attached to the customer group. Registered as well as anonymous
     *  customers can be member of such a group. isRuleBased==true.</li>
     *  </ul>
     *  <p>
     *  <b>Note:</b> this class might allow access to sensitive personal and private
     *  information, depending on how you segment your customers and the names given to
     *  your custoemer groups. Pay attention to appropriate legal and regulatory requirements
     *  when developing with this data.</p>
     */
    class CustomerGroup extends dw.object.ExtensibleObject {
      /**
       * Gets the value of the description of the customer group.
       */
      readonly description: string;
      /**
       * The unique ID of the customer group.
       */
      readonly ID: string;
      /**
       * Returns true if the group determines the membership of customers
       *  based on rules. Returns false if the group provides explicit assignement
       *  of customers.
       */
      readonly ruleBased: boolean;

      /**
       * Assigns the specified customer to this group.
       *  The customer must be registered and the group must not be rule-based.
       * @param customer Registered customer, must not be null.
       */
      assignCustomer(customer: dw.customer.Customer): void;
      /**
       * Gets the value of the description of the customer group.
       *
       * @return the description of the customer group
       */
      getDescription(): string;
      /**
       * Returns the unique ID of the customer group.
       *
       * @return The unique semantic ID of the customer group.
       */
      getID(): string;
      /**
       * Returns true if the group determines the membership of customers
       *  based on rules. Returns false if the group provides explicit assignement
       *  of customers.
       *
       * @return True, if the customer group is rule based.
       */
      isRuleBased(): boolean;
      /**
       * Unassigns the specified customer from this group.
       *  The customer must be registered and the group must not be rule-based.
       * @param customer Registered customer, must not be null.
       */
      unassignCustomer(customer: dw.customer.Customer): void;
    }

    /**
     * Object representing the collection of customers who are registered
     *  for a given site. In Commerce Cloud Digital, every site has exactly
     *  one assigned customer list but multiple sites may share a customer
     *  list.
     */
    class CustomerList {
      /**
       * Get the optional description of the customer list.
       */
      readonly description: string;
      /**
       * Get the ID of the customer list.  For customer lists that were created automatically
       *  for a given site, this is equal to the ID of the site itself.
       */
      readonly ID: string;

      /**
       * Get the optional description of the customer list.
       *
       * @return The optional description of the list.
       */
      getDescription(): string;
      /**
       * Get the ID of the customer list.  For customer lists that were created automatically
       *  for a given site, this is equal to the ID of the site itself.
       *
       * @return The ID of the customer list.
       */
      getID(): string;
    }

    /**
     * Provides helper methods for managing customers and customer
     *  profiles.
     *  <b>Note:</b> this class allows access to sensitive information through
     *  operations that retrieve the Profile object.
     *  Pay attention to appropriate legal and regulatory requirements related to this data.
     */
    class CustomerMgr {
      /**
       * The customer groups of the current site.
       */
      static readonly customerGroups: dw.util.Collection<
        dw.customer.CustomerGroup
      >;
      /**
       * An instance of CustomerPasswordConstraints
       *  for the customer list assigned to the current site.
       */
      static readonly passwordConstraints: dw.customer.CustomerPasswordConstraints;
      /**
       * The number of registered customers in the system. This number can be used for reporting
       *  purposes.
       */
      static readonly registeredCustomerCount: number;
      /**
       * The customer list of the current site.
       */
      static readonly siteCustomerList: dw.customer.CustomerList;

      /**
       * This method authenticates a customer using the supplied login and password. It will not log in the customer into
       *  the current session, but returns only a status indicating success or failure (with different error codes for the failure cases).
       *  Upon successful authentication (status code 'AUTH_OK') the status object also holds the authenticated customer.
       *  To continue the login process, call the loginCustomer(AuthenticationStatus, boolean) method.
       *
       *  This method verifies that the password for the customer is not expired. If it is expired the authentication will fail, with a status code of
       *  ERROR_PASSWORD_EXPIRED. This allows the storefront to require the customer to change the password, and then the login can proceed.
       * @param login Login name, must not be null.
       * @param password Password, must not be null.
       * @return the status of the authentication process
       */
      static authenticateCustomer(
        login: string,
        password: string
      ): dw.customer.AuthenticationStatus;
      /**
       * Creates a new Customer using the supplied login, password. The system automatically assigns a customer number based on
       *  the customer sequence numbers configured for the site and/or organization.
       *
       *  The method throws an exception if any of the following conditions are encountered:
       *
       *    A Customer with the supplied Login already exists
       *    The Login is not acceptable.
       *    The Password is not acceptable.
       *    The system cannot create the Customer.
       *
       *
       *  A valid login name is between 1 and 256 characters in length (not counting leading or trailing whitespace), and may contain only the
       *  following characters:
       *
       *    alphanumeric (Unicode letters or decimal digits)
       *    space
       *    period
       *    dash
       *    underscore
       *    @
       *
       *
       * Note: a storefront can be customized to provide further constraints on characters in a login name, but it cannot remove any constraints described above.
       * @param login The unique login name associated with the new customer and its profile, must not be null. If login is already in use, an exception will be thrown.
       * @param password Customer plain customer password, which is encrypted before it is stored at the profile, must not be null.
       * @return customer The new customer object.
       */
      static createCustomer(
        login: string,
        password: string
      ): dw.customer.Customer;
      /**
       * Creates a new Customer using the supplied login, password, and a customerNo. If the customerNo is not specified,
       *  the system automatically assigns a customer number based on the customer sequence numbers configured for the site and/or organization.
       *
       *  The method throws an exception if any of the following conditions are encountered:
       *
       *    A Customer with the supplied Login already exists
       *    A Customer with the explicitly provided or calculated customer number already exists.
       *    The Login is not acceptable.
       *    The Password is not acceptable.
       *    The system cannot create the Customer.
       *
       *
       *  A valid login name is between 1 and 256 characters in length (not counting leading or trailing whitespace), and may contain only the
       *  following characters:
       *
       *    alphanumeric (Unicode letters or decimal digits)
       *    space
       *    period
       *    dash
       *    underscore
       *    @
       *
       *
       *  Note: a storefront can be customized to provide further constraints on characters in a login name, but it cannot remove any constraints described above.
       *
       *  A valid CustomerNo is between 1 and 100 characters in length (not counting leading or trailing whitespace). Commerce Cloud Digital recommends that a CustomerNo only
       *  contain characters valid for URLs.
       * @param login The unique login name associated with the new customer and its profile, must not be null. If login is already in use, an exception will be thrown.
       * @param password Customer plain customer password, which is encrypted before it is stored at the profile, must not be null.
       * @param customerNo The unique customerNo can be null, the system will then automatically assign a new value. If provided explicitly, the system will make sure that no other customer uses the same value and will throw an exception otherwise.
       * @return customer The new customer object.
       */
      static createCustomer(
        login: string,
        password: string,
        customerNo: string
      ): dw.customer.Customer;
      /**
       * Given an authentication provider Id and an external Id: creates a Customer record in the system if one does not
       *  exist already for the same 'authenticationProviderId' and 'externalId' pair. If one already exists - it is returned.
       * @param authenticationProviderId the Id of the authentication provider as configured in Commerce Cloud Digital.
       * @param externalId the Id of the customer at the authentication provider. Each authentication provider generates these in a different way, they are unique within their system
       * @return On success: the created customer. On failure - null
       */
      static createExternallyAuthenticatedCustomer(
        authenticationProviderId: string,
        externalId: string
      ): dw.customer.Customer;
      /**
       * Returns the meta data for profiles.
       *
       * @return the meta data for profiles.
       */
      static describeProfileType(): dw.object.ObjectTypeDefinition;
      /**
       * Returns the customer with the specified customer number. If no customer with this customer number exists, null is returned.
       * @param customerNumber the customer number associated with the customer, must not be null.
       * @return The customer if found, null otherwise
       */
      static getCustomerByCustomerNumber(
        customerNumber: string
      ): dw.customer.Customer;
      /**
       * Returns the customer for the specified login name. If no customer with this login name exists, null is returned.
       * @param login the unique login name associated with the customer, must not be null.
       * @return The customer if found, null otherwise
       */
      static getCustomerByLogin(login: string): dw.customer.Customer;
      /**
       * Returns the customer associated with the specified password reset token. A valid token is one that is associated
       *  with a customer record and is not expired. Such a token can be generated by
       *  Credentials.createResetPasswordToken(). If the passed token is valid, the associated customer
       *  is returned. Otherwise null is returned
       * @param token password reset token
       * @return The customer associated with the token. Null if the token is invalid.
       */
      static getCustomerByToken(token: string): dw.customer.Customer;
      /**
       * Returns the customer group with the specified ID or null if group
       *  does not exists.
       * @param id the customer group identifier.
       * @return Customer group for ID or null
       */
      static getCustomerGroup(id: string): dw.customer.CustomerGroup;
      /**
       * Returns the customer groups of the current site.
       *
       * @return Customer groups of current site.
       */
      static getCustomerGroups(): dw.util.Collection<dw.customer.CustomerGroup>;
      /**
       * Returns the customer list identified by the specified ID.
       *  Returns null if no customer list with the specified id exists.
       *
       *  Note: Typically the ID of an automatically created customer
       *  list is equal to the ID of the site.
       * @param id The ID of the customer list.
       * @return The CustomerList, or null if not found.
       */
      static getCustomerList(id: string): dw.customer.CustomerList;
      /**
       * Given an authentication provider Id and external Id returns the Customer Profile
       *  in our system.
       * @param authenticationProviderId the Id of the authentication provider as configured in Commerce Cloud Digital.
       * @param externalId the Id of the customer at the authentication provider. Each authentication provider generates these in a different way, they are unique within their system
       * @return The Profile of the customer if found, null otherwise
       */
      static getExternallyAuthenticatedCustomerProfile(
        authenticationProviderId: string,
        externalId: string
      ): dw.customer.Profile;
      /**
       * Returns an instance of CustomerPasswordConstraints
       *  for the customer list assigned to the current site.
       *
       * @return customer password constraints for current site
       */
      static getPasswordConstraints(): dw.customer.CustomerPasswordConstraints;
      /**
       * Returns the profile with the specified customer number.
       * @param customerNumber the customer number of the customer of the to be retrieved profile
       * @return Profile for specified customer number
       */
      static getProfile(customerNumber: string): dw.customer.Profile;
      /**
       * Returns the number of registered customers in the system. This number can be used for reporting
       *  purposes.
       *
       * @return the number of registered customers in the system.
       */
      static getRegisteredCustomerCount(): number;
      /**
       * Returns the customer list of the current site.
       *
       * @return The customer list assigned to the current site.
       */
      static getSiteCustomerList(): dw.customer.CustomerList;
      /**
       * Checks if the given password matches the password constraints (for example password length) of
       *  the current site's assigned customerlist.
       * @param password the to be checked password
       * @return true if the given password matches all required criteria
       */
      static isAcceptablePassword(password: string): boolean;
      /**
       * Checks if the password for the given customer is expired
       * @param login the login for the customer to be checked
       * @return true if the password is expired
       */
      static isPasswordExpired(login: string): boolean;
      /**
       * This method authenticates the current session using the supplied login and password. If a different customer is currently authenticated in the session, then this
       *  customer is "logged out" and her/his privacy and form data are deleted. If the authentication with the given credentials fails, then null is returned and no changes
       *  to the session are made. The authentication will be sucessful even when the password of the customer is already expired (according to the customer list settings).
       *
       *   If the input value "RememberMe" is set to true, this method stores a cookie on the customer's machine which will be used to identify the customer when the next
       *  session is initiated.  The cookie is set to expire in 180 days (i.e. 6 months). Note that a customer who is remembered is not automatically authenticated and will
       *  have to explicitly log in to access any personal information.
       * @param login Login name, must not be null.
       * @param password Password, must not be null.
       * @param rememberMe Boolean value indicating if the customer wants to be remembered on the current computer. If a value of true is supplied a cookie identifying the customer is stored upon successful login. If a value of false, or a null value, is supplied, then no cookie is stored and any existing cookie is removed.
       * @return Customer successfully authenticated customer. Null if the authentication with the given credentials fails.
       */
      static loginCustomer(
        login: string,
        password: string,
        rememberMe: boolean
      ): dw.customer.Customer;
      /**
       * This method logs in the authenticated customer (from a previous authenticateCustomer() call). If a different customer is currently authenticated in the session, then this
       *  customer is "logged out" and all privacy-relevant data and all form data are deleted. If the previous authentication was not successful, then null is returned and no changes
       *  to the session are made.
       *
       *   If the input value "RememberMe" is set to true, this method stores a cookie on the customer's machine which will be used to identify the customer when the next
       *  session is initiated.  The cookie is set to expire in 180 days (i.e. 6 months). Note that a customer who is remembered is not automatically authenticated and will
       *  have to explicitly log in to access any personal information.
       * @param authStatus the authentication status from the previous authenticateCustomer call
       * @param rememberMe Boolean value indicating if the customer wants to be remembered on the current computer. If a value of true is supplied a cookie identifying the customer is stored upon successful login. If a value of false, or a null value, is supplied, then no cookie is stored and any existing cookie is removed.
       * @return Customer successfully authenticated customer. Null if the authentication status was not indicating success of the authentication.
       */
      static loginCustomer(
        authStatus: dw.customer.AuthenticationStatus,
        rememberMe: boolean
      ): dw.customer.Customer;
      /**
       * Logs in externally authenticated customer if it has already been created in the system and the profile is not disabled or locked
       * @param authenticationProviderId the Id of the authentication provider as configured in Commerce Cloud Digital.
       * @param externalId the Id of the customer at the authentication provider.
       * @param rememberMe whether to drop the remember me cookie
       * @return Customer if found in the system and not disabled or locked. getExternallyAuthenticatedCustomerProfile(String, String)
       */
      static loginExternallyAuthenticatedCustomer(
        authenticationProviderId: string,
        externalId: string,
        rememberMe: boolean
      ): dw.customer.Customer;
      /**
       * Logs out the customer currently logged into the storefront. The boolean value "RememberMe" indicates, if the customer would like to be remembered on the current
       *  browser. If a value of true is supplied, the customer authentication state is set to "not logged in" and additionally the following session data is removed: the customer
       *  session private data, the form status data, dictionary information of interaction continue nodes, basket reference information, the secure token cookie. If the value is set
       *  to false or null, the complete session dictionary is cleaned up. The customer and anonymous cookie are removed and a new session cookie is set.
       * @param rememberMe Boolean value indicating if the customer wants to be remembered on the current browser. If a value of true is supplied, the customer authentication state is set to "not logged in" and additionally the following session data is removed: the customer session private data, the form status data, dictionary information of interaction continue nodes, basket reference information, the secure token cookie. If the value is set to false or null, the complete session dictionary is cleaned up. The customer and anonymous cookie are removed and a new session cookie is set.
       * @return the new customer identity after logout. If rememberMe is true, null is returned.
       */
      static logoutCustomer(rememberMe: boolean): dw.customer.Customer;
      /**
       * Executes a user-definable function on a set of customer profiles. This method is intended to be used in batch processes and jobs,
       *  since it allows efficient processing of large result sets (which might take a while to process).
       *
       *  First, a search with the given parameters is executed. Then the given function is executed once for each profile of the search result.
       *  The profile is handed over as the only parameter to this function.
       *
       *  The search can be configured using a simple query language, which
       *  provides most common filter and operator functionality.
       *
       *  For a description of this query language, see the queryProfile(String, Object...) method.
       *
       *  The callback function will be supplied with a single argument of type 'Profile'. When the callback function defines
       *  additional arguments, they will be undefined when the function is called. When the callback function doesn't define
       *  any arguments at all, it will be called anyway (no error will happen, but the function won't get a profile as parameter).
       *
       *  Error during execution of the callback function will be logged, and execution will continue with the next element from the
       *  result set.
       *
       *  This method can be used as in this example (which counts the number of men):
       *
       *           var count=0;
       *          function callback(profile: Profile)
       *          {
       *              count++;
       *              dw.system.Logger.debug("customer found: "+profile.customerNo)
       *          }
       *         CustomerMgr.processProfiles(callback, "gender=1");
       *         dw.system.Logger.debug("found "+count+" men in customer list");
       * @param processFunction the function to execute for each profile
       * @param queryString the query string to use when searching for a profile.
       * @param args the query string arguments.
       */
      static processProfiles(
        processFunction: Function,
        queryString: string,
        ...args: any[]
      ): void;
      /**
       * Searches for a single profile instance.
       *
       *  The search can be configured using a simple query language, which
       *  provides most common filter and operator functionality.
       *
       *  The identifier for an attribute  to use in a query condition is always the
       *  ID of the  attribute as defined in the type definition. For custom defined attributes
       *  the prefix custom is required in the search term (e.g. custom.color = {1}),
       *  while for system attributes no prefix is used (e.g. name = {4}).
       *
       *  Supported attribute value types with sample expression values:
       *  String 'String', 'Str*', 'Strin?'
       *  Integer 1, 3E4
       *  Number 1.0, 3.99E5
       *  Date yyyy-MM-dd e.g. 2007-05-31 (Default TimeZone = UTC)
       *  DateTime yyyy-MM-dd'T'hh:mm:ss+Z e.g. 2007-05-31T00:00+Z (Z TimeZone = UTC) or 2007-05-31T00:00:00
       *  Boolean true, false
       *  Email '[emailprotected]', '*@demandware.com'
       *  Set of String 'String', 'Str*', 'Strin?'
       *  Set of Integer 1, 3E4
       *  Set of Number 1.0, 3.99E5
       *  Enum of String 'String', 'Str*', 'Strin?'
       *  Enum of Integer 1, 3E4
       *  The following types of attributes are not queryable:
       *  Image
       *  HTML
       *  Text
       *  Quantity
       *  Password
       *  Note, that some system attributes are not queryable by default regardless of the
       *  actual value type code.
       *
       *
       *  The following operators are supported in a condition:
       *  = Equals - All types; supports NULL value (thumbnail = NULL)
       *  != Not equals - All types; supports NULL value (thumbnail != NULL)
       *  < Less than  - Integer, Number and Date types only
       *  > Greater than - Integer, Number and Date types only
       *  <= Less or equals than - Integer, Number and Date types only
       *  >= Greater or equals than  - Integer, Number and Date types only
       *  LIKE Like - String types and Email only; use if leading or trailing
       *  wildcards will be used to support substring search(custom.country LIKE 'US*')
       *  ILIKE Caseindependent Like - String types and Email only, use to support
       *  case insensitive query (custom.country ILIKE 'usa'), does also support wildcards for
       *  substring matching
       *
       *  Conditions can be combined using logical expressions 'AND', 'OR' and 'NOT'
       *  and nested using parenthesis e.g.
       *  gender = {1} AND (age >= {2} OR (NOT profession LIKE {3})).
       *
       *
       *  The query language provides a placeholder syntax to pass objects as
       *  additional search parameters. Each passed object is related to a
       *  placeholder in the query string. The placeholder must be an Integer that
       *  is surrounded by braces. The first Integer value must be '0', the second
       *  '1' and so on, e.g.
       *  querySystemObjects("sample", "age = {0} or creationDate >= {1}", 18, date)
       *
       *
       *  If there is more than one object matching the specified query criteria, the
       *  result is not deterministic. In order to retrieve a single object from a sorted result
       *  set it is recommended to use the following code:
       *  queryProfiles("", "custom.myAttr asc", null).first().
       *  The method first() returns only the next element and closes the
       *  iterator.
       *
       *  This method will be deprecated in a future release. We recommend to use methods searchProfile(String, Object...),
       *  searchProfiles(Map, String) and searchProfiles(String, String, Object...)
       *  to search for customers, and to use method processProfiles(Function, String, Object...) to search and process customers in jobs.
       * @param queryString the query string to use when searching for a profile.
       * @param args the query string arguments.
       * @return the profile which was found when executing the queryString.
       */
      static queryProfile(
        queryString: string,
        ...args: any[]
      ): dw.customer.Profile;
      /**
       * Searches for profile instances.
       *
       *  The search can be configured using a simple query language, which
       *  provides most common filter and operator functionality.
       *
       *  For a description of this query language, see the queryProfile(String, Object...) method.
       *
       *  This method will be deprecated in a future release. We recommend to use methods searchProfile(String, Object...),
       *  searchProfiles(Map, String) and searchProfiles(String, String, Object...)
       *  to search for customers, and to use method processProfiles(Function, String, Object...) to search and process customers in jobs.
       * @param queryString the actual query.
       * @param sortString an optional sorting or null if no sorting is necessary.
       * @param args optional parameters for the query string.
       * @return SeekableIterator containing the result set of the query.
       */
      static queryProfiles(
        queryString: string,
        sortString: string,
        ...args: any[]
      ): dw.util.SeekableIterator;
      /**
       * Searches for profile instances.
       *
       *  The search can be configured with a map, which key-value pairs are
       *  converted into a query expression. The key-value pairs are turned into a
       *  sequence of '=' or 'like' conditions, which are combined with AND
       *  statements.
       *
       *  Example:
       *  A map with the key/value pairs: 'name'/'tom*', 'age'/66
       *  will be converted as follows: "name like 'tom*' and age = 66"
       *
       *  The identifier for an attribute  to use in a query condition is always the
       *  ID of the  attribute as defined in the type definition. For custom defined attributes
       *  the prefix custom is required in the search term (e.g. custom.color = {1}),
       *  while for system attributes no prefix is used (e.g. name = {4}).
       *
       *  Supported attribute value types with sample expression values:
       *  String 'String', 'Str*', 'Strin?'
       *  Integer 1, 3E4
       *  Number 1.0, 3.99E5
       *  Date yyyy-MM-dd e.g. 2007-05-31 (Default TimeZone = UTC)
       *  DateTime yyyy-MM-dd'T'hh:mm:ss+Z e.g. 2007-05-31T00:00+Z (Z TimeZone = UTC) or 2007-05-31T00:00:00
       *  Boolean true, false
       *  Email '[emailprotected]', '*@demandware.com'
       *  Set of String 'String', 'Str*', 'Strin?'
       *  Set of Integer 1, 3E4
       *  Set of Number 1.0, 3.99E5
       *  Enum of String 'String', 'Str*', 'Strin?'
       *  Enum of Integer 1, 3E4
       *  The following types of attributes are not queryable:
       *  Image
       *  HTML
       *  Text
       *  Quantity
       *  Password
       *  Note, that some system attributes are not queryable by default regardless of the
       *  actual value type code.
       *
       *
       *  The sorting parameter is optional and may contain a comma separated list of
       *  attribute names to sort by. Each sort attribute name may be followed by an
       *  optional sort direction specifier ('asc' | 'desc'). Default sorting directions is
       *  ascending, if no direction was specified.
       *  Example: age desc, name
       *  Please note that specifying a localized custom attribute as the sorting attribute is
       *  currently not supported.
       *
       *  It is strongly recommended to call close() on the returned SeekableIterator
       *  if not all of its elements are being retrieved. This will ensure the proper cleanup of system resources.
       *  See SeekableIterator.close()
       *
       *  This method will be deprecated in a future release. We recommend to use methods searchProfile(String, Object...),
       *  searchProfiles(Map, String) and searchProfiles(String, String, Object...)
       *  to search for customers, and to use method processProfiles(Function, String, Object...) to search and process customers in jobs.
       * @param queryAttributes key-value pairs that define the query.
       * @param sortString an optional sorting or null if no sorting is necessary.
       * @return SeekableIterator containing the result set of the query.
       */
      static queryProfiles(
        queryAttributes: dw.util.Map<any, any>,
        sortString: string
      ): dw.util.SeekableIterator;
      /**
       * Logs out the supplied customer and deletes the customer record. The customer must be a registered customer and the customer must currently be logged in. The customer must be
       *  logged in for security reasons to ensure that only the customer itself can remove itself from the system. While logout the customers session is reset to an anonymous session and, if present, the "Remember me" cookie of the customer is removed.
       *  Deleting the customer record includes the customer credentials, profile, address-book with all addresses, customer payment instruments, product lists and memberships in
       *  customer groups. Orders placed by this customer won't be deleted. If the supplied customer is not a registered customer or is not logged in, the API throws an exception
       * @param customer The customer to remove, must not be null.
       */
      static removeCustomer(customer: dw.customer.Customer): void;
      /**
       * Removes (asynchronously) tracking data for this customer (from external systems or data stores). This will not remove the
       *  customer from the database, nor will it prevent tracking to start again in the future for this customer.
       *
       *  The customer is identified by login / email /customerNo / cookie when its a registered customer, and by cookie
       *  when its an anonymous customer.
       * @param customer the customer
       */
      static removeCustomerTrackingData(customer: dw.customer.Customer): void;
      /**
       * Searches for a single profile instance.
       *
       *  The search can be configured using a simple query language, which
       *  provides most common filter and operator functionality.
       *
       *  The identifier for an attribute  to use in a query condition is always the
       *  ID of the  attribute as defined in the type definition. For custom defined attributes
       *  the prefix custom is required in the search term (e.g. custom.color = {1}),
       *  while for system attributes no prefix is used (e.g. name = {4}).
       *
       *  Supported attribute value types with sample expression values:
       *  String 'String', 'Str*', 'Strin?'
       *  Integer 1, 3E4
       *  Number 1.0, 3.99E5
       *  Date yyyy-MM-dd e.g. 2007-05-31 (Default TimeZone = UTC)
       *  DateTime yyyy-MM-dd'T'hh:mm:ss+Z e.g. 2007-05-31T00:00+Z (Z TimeZone = UTC) or 2007-05-31T00:00:00
       *  Boolean true, false
       *  Email '[emailprotected]', '*@demandware.com'
       *  Set of String 'String', 'Str*', 'Strin?'
       *  Set of Integer 1, 3E4
       *  Set of Number 1.0, 3.99E5
       *  Enum of String 'String', 'Str*', 'Strin?'
       *  Enum of Integer 1, 3E4
       *  The following types of attributes are not queryable:
       *  Image
       *  HTML
       *  Text
       *  Quantity
       *  Password
       *  Note, that some system attributes are not queryable by default regardless of the
       *  actual value type code.
       *
       *
       *  The following operators are supported in a condition:
       *  = Equals - All types; supports NULL value (thumbnail = NULL)
       *  != Not equals - All types; supports NULL value (thumbnail != NULL)
       *  < Less than  - Integer, Number and Date types only
       *  > Greater than - Integer, Number and Date types only
       *  <= Less or equals than - Integer, Number and Date types only
       *  >= Greater or equals than  - Integer, Number and Date types only
       *  LIKE Like - String types and Email only; use if leading or trailing
       *  wildcards will be used to support substring search(custom.country LIKE 'US*')
       *  ILIKE Caseindependent Like - String types and Email only, use to support
       *  case insensitive query (custom.country ILIKE 'usa'), does also support wildcards for
       *  substring matching
       *
       *  Conditions can be combined using logical expressions 'AND', 'OR' and 'NOT'
       *  and nested using parenthesis e.g.
       *  gender = {1} AND (age >= {2} OR (NOT profession LIKE {3})).
       *
       *
       *  The query language provides a placeholder syntax to pass objects as
       *  additional search parameters. Each passed object is related to a
       *  placeholder in the query string. The placeholder must be an Integer that
       *  is surrounded by braces. The first Integer value must be '0', the second
       *  '1' and so on, e.g.
       *  querySystemObjects("sample", "age = {0} or creationDate >= {1}", 18, date)
       *
       *
       *  If there is more than one object matching the specified query criteria, the
       *  result is not deterministic. In order to retrieve a single object from a sorted result
       *  set it is recommended to use the following code:
       *  queryProfiles("", "custom.myAttr asc", null).first().
       *  The method first() returns only the next element and closes the
       *  iterator.
       *
       *  If the customer search API is configured to use the new Search Service, the following differences apply:
       *
       *      newly created customers might not be found immediately via the search service, and changes to existing
       *      customers might also not be in effect immediately (there is a slight delay in updating the index)
       *      wildcards will be filtered from the query (*, %, +) and replaced by spaces
       *      LIKE and ILIKE queries will be executed as fulltext queries (working on whole words), not as substring searches
       *      LIKE queries will always be case insensitive
       *      using logical operators may change the execution of LIKE/ILIKE clauses to exact string comparison, depending on how they are combined
       *      using logical operators may result in degraded performance, depending on how they are combined
       * @param queryString the query string to use when searching for a profile.
       * @param args the query string arguments.
       * @return the profile which was found when executing the queryString.
       */
      static searchProfile(
        queryString: string,
        ...args: any[]
      ): dw.customer.Profile;
      /**
       * Searches for profile instances.
       *
       *  The search can be configured using a simple query language, which
       *  provides most common filter and operator functionality.
       *
       *  For a description of this query language, see the searchProfile(String, Object...) method.
       *
       *  If the customer search API is configured to use the new Search Service, the following differences apply:
       *
       *      newly created customers might not be found immediately via the search service, and changes to existing
       *      customers might also not be in effect immediately (there is a slight delay in updating the index)
       *      the search will return only the first 1000 hits from the search result
       * @param queryString the actual query.
       * @param sortString an optional sorting or null if no sorting is necessary.
       * @param args optional parameters for the query string.
       * @return SeekableIterator containing the result set of the query.
       */
      static searchProfiles(
        queryString: string,
        sortString: string,
        ...args: any[]
      ): dw.util.SeekableIterator;
      /**
       * Searches for profile instances.
       *
       *  The search can be configured with a map, which key-value pairs are
       *  converted into a query expression. The key-value pairs are turned into a
       *  sequence of '=' or 'like' conditions, which are combined with AND
       *  statements.
       *
       *  Example:
       *  A map with the key/value pairs: 'name'/'tom*', 'age'/66
       *  will be converted as follows: "name like 'tom*' and age = 66"
       *
       *  The identifier for an attribute  to use in a query condition is always the
       *  ID of the  attribute as defined in the type definition. For custom defined attributes
       *  the prefix custom is required in the search term (e.g. custom.color = {1}),
       *  while for system attributes no prefix is used (e.g. name = {4}).
       *
       *  Supported attribute value types with sample expression values:
       *  String 'String', 'Str*', 'Strin?'
       *  Integer 1, 3E4
       *  Number 1.0, 3.99E5
       *  Date yyyy-MM-dd e.g. 2007-05-31 (Default TimeZone = UTC)
       *  DateTime yyyy-MM-dd'T'hh:mm:ss+Z e.g. 2007-05-31T00:00+Z (Z TimeZone = UTC) or 2007-05-31T00:00:00
       *  Boolean true, false
       *  Email '[emailprotected]', '*@demandware.com'
       *  Set of String 'String', 'Str*', 'Strin?'
       *  Set of Integer 1, 3E4
       *  Set of Number 1.0, 3.99E5
       *  Enum of String 'String', 'Str*', 'Strin?'
       *  Enum of Integer 1, 3E4
       *  The following types of attributes are not queryable:
       *  Image
       *  HTML
       *  Text
       *  Quantity
       *  Password
       *  Note, that some system attributes are not queryable by default regardless of the
       *  actual value type code.
       *
       *
       *  The sorting parameter is optional and may contain a comma separated list of
       *  attribute names to sort by. Each sort attribute name may be followed by an
       *  optional sort direction specifier ('asc' | 'desc'). Default sorting directions is
       *  ascending, if no direction was specified.
       *  Example: age desc, name
       *  Please note that specifying a localized custom attribute as the sorting attribute is
       *  currently not supported.
       *
       *  It is strongly recommended to call close() on the returned SeekableIterator
       *  if not all of its elements are being retrieved. This will ensure the proper cleanup of system resources.
       *  SeekableIterator.close()
       *
       *  If the customer search API is configured to use the new Search Service, the following differences apply:
       *
       *      newly created customers might not be found immediately via the search service, and changes to existing
       *      customers might also not be in effect immediately (there is a slight delay in updating the index)
       *      wildcards will be filtered from the query (*, %, +) and replaced by spaces
       *      LIKE and ILIKE queries will be executed as fulltext queries (working on whole words), not as substring searches
       *      LIKE queries will always be case insensitive
       *      using logical operators may change the execution of LIKE/ILIKE clauses to exact string comparison, depending on how they are combined
       *      using logical operators may result in degraded performance, depending on how they are combined
       *      the search will return only the first 1000 hits from the search result
       * @param queryAttributes key-value pairs that define the query.
       * @param sortString an optional sorting or null if no sorting is necessary.
       * @return SeekableIterator containing the result set of the query.
       */
      static searchProfiles(
        queryAttributes: dw.util.Map<any, any>,
        sortString: string
      ): dw.util.SeekableIterator;
    }

    /**
     * Provides access to the constraints of customer passwords. An instance of this class can be obtained via <a href="class_dw_customer_CustomerMgr.html#dw_customer_CustomerMgr_getPasswordConstraints_DetailAnchor">CustomerMgr.getPasswordConstraints()</a>.
     */
    class CustomerPasswordConstraints {
      /**
       * Returns true if letters are enforced.
       */
      readonly forceLetters: boolean;
      /**
       * Returns true if mixed case is enforced.
       */
      readonly forceMixedCase: boolean;
      /**
       * Returns true if numbers are enforced.
       */
      readonly forceNumbers: boolean;
      /**
       * The minimum length.
       */
      static readonly minLength: number;
      /**
       * The minimum number of special characters.
       */
      static readonly minSpecialChars: number;

      /**
       * Returns the minimum length.
       *
       * @return the minimum length
       */
      static getMinLength(): number;
      /**
       * Returns the minimum number of special characters.
       *
       * @return the minimum number of special characters
       */
      static getMinSpecialChars(): number;
      /**
       * Returns true if letters are enforced.
       *
       * @return if letters are enforced
       */
      static isForceLetters(): boolean;
      /**
       * Returns true if mixed case is enforced.
       *
       * @return if mixed case is enforced
       */
      static isForceMixedCase(): boolean;
      /**
       * Returns true if numbers are enforced.
       *
       * @return if numbers are enforced
       */
      static isForceNumbers(): boolean;
    }

    /**
     * Represents any payment instrument stored in the customers profile, such as
     *  credit card or bank transfer. The object defines standard methods for credit
     *  card payment, and can be extended by attributes appropriate for other
     *  payment methods.
     */
    class CustomerPaymentInstrument extends dw.order.PaymentInstrument {
      /**
       * The driver's license number of the bank account number
       *  if the calling context meets the following criteria:
       *
       *
       *  If the method call happens in the context of a storefront request and
       *  the current customer is registered and authenticated, and the payment
       *  instrument is associated to the profile of the current customer, and
       *  the current protocol is HTTPS
       *
       *
       *  Otherwise, the method returns the masked driver's license number of the bank account.
       *
       *  Note: this method handles sensitive financial and card holder data.
       *  Pay special attention to PCI DSS v3. requirements 1, 3, 7, and 9.
       */
      readonly bankAccountDriversLicense: string;
      /**
       * The bank account number if the calling context meets
       *  the following criteria:
       *
       *
       *  If the method call happens in the context of a storefront request,
       *  the current customer is registered and authenticated, the payment
       *  instrument is associated to the profile of the current customer, and
       *  the current protocol is HTTPS
       *
       *
       *  Otherwise, the method returns the masked bank account number.
       *
       *  Note: this method handles sensitive financial and card holder data.
       *  Pay special attention to PCI DSS v3. requirements 1, 3, 7, and 9.
       */
      readonly bankAccountNumber: string;
      /**
       * The decrypted credit card number if the calling context meets
       *  the following criteria:
       *
       *
       *  If the method call happens in the context of a storefront request,
       *  the current customer is registered and authenticated, the payment
       *  instrument is associated to the profile of the current customer, and
       *  the current protocol is HTTPS.
       *
       *
       *  Otherwise, the method returns the masked credit card number.
       *
       *  Note: this method handles sensitive financial and card holder data.
       *  Pay special attention to PCI DSS v3. requirements 1, 3, 7, and 9.
       */
      readonly creditCardNumber: string;

      /**
       * Returns the driver's license number of the bank account number
       *  if the calling context meets the following criteria:
       *
       *
       *  If the method call happens in the context of a storefront request and
       *  the current customer is registered and authenticated, and the payment
       *  instrument is associated to the profile of the current customer, and
       *  the current protocol is HTTPS
       *
       *
       *  Otherwise, the method returns the masked driver's license number of the bank account.
       *
       *  Note: this method handles sensitive financial and card holder data.
       *  Pay special attention to PCI DSS v3. requirements 1, 3, 7, and 9.
       *
       */
      getBankAccountDriversLicense(): string;
      /**
       * Returns the bank account number if the calling context meets
       *  the following criteria:
       *
       *
       *  If the method call happens in the context of a storefront request,
       *  the current customer is registered and authenticated, the payment
       *  instrument is associated to the profile of the current customer, and
       *  the current protocol is HTTPS
       *
       *
       *  Otherwise, the method returns the masked bank account number.
       *
       *  Note: this method handles sensitive financial and card holder data.
       *  Pay special attention to PCI DSS v3. requirements 1, 3, 7, and 9.
       *
       */
      getBankAccountNumber(): string;
      /**
       * Returns the decrypted credit card number if the calling context meets
       *  the following criteria:
       *
       *
       *  If the method call happens in the context of a storefront request,
       *  the current customer is registered and authenticated, the payment
       *  instrument is associated to the profile of the current customer, and
       *  the current protocol is HTTPS.
       *
       *
       *  Otherwise, the method returns the masked credit card number.
       *
       *  Note: this method handles sensitive financial and card holder data.
       *  Pay special attention to PCI DSS v3. requirements 1, 3, 7, and 9.
       *
       */
      getCreditCardNumber(): string;
    }

    /**
     * CustomerStatusCodes contains constants representing
     *  status codes that can be used with a Status object to
     *  indicate the success or failure of an operation.
     */
    class CustomerStatusCodes {
      /**
       * Indicates that an error occurred when trying to perform
       *  an operation on an address that is currently associated
       *  with a product list.
       */
      static readonly CUSTOMER_ADDRESS_REFERENCED_BY_PRODUCT_LIST =
        "CUSTOMER_ADDRESS_REFERENCED_BY_PRODUCT_LIST";

      constructor();
    }

    /**
     * Defines a API base class for classes containing
     *  encrypted attributes like credit cards.
     *  <p>
     *  <b>Note:</b> this method handles sensitive financial and card holder data.
     *  Pay special attention to PCI DSS v3. requirements 1, 3, 7, and 9.</p>
     */
    class EncryptedObject extends dw.object.ExtensibleObject {}

    /**
     * Represents the credentials of a customer.
     *
     *  Since 13.6 it is possible to have customers who are not authenticated through a
     *  login and password but through an external authentication provider via the OAuth2 protocol.
     *
     *  In such cases, the AuthenticationProviderID will point to an OAuth provider configured in the system
     *  and the ExternalID will be the unique identifier of the customer on the Authentication Provider&apos;s system.
     *
     *  For example, if an authentication provider with ID &quot;Google123&quot; is configured pointing to Google
     *  and the customer has a logged in into Google in the past and has created a profile there, Google
     *  assigns a unique number identifier to that customer. If the storefront is configured to allow
     *  authentication through Google and a new customer logs into the storefront using Google,
     *  the AuthenticationProviderID property of his Credentials will contain &quot;Google123&quot; and
     *  the ExternalID property will contain whatever unique identifier Google has assigned to him.
     *  <p>
     *  <b>Note:</b> this class handles sensitive security-related data.
     *  Pay special attention to PCI DSS v3. requirements 2, 4, and 12.</p>
     */
    class ExternalProfile {
      /**
       * The authentication provider ID.
       */
      readonly authenticationProviderID: string;
      /**
       * The customer object related to this profile.
       */
      readonly customer: dw.customer.Customer;
      /**
       * The customer's email address.
       */
      email: string;
      /**
       * The external ID.
       */
      readonly externalID: string;
      /**
       * The last login time of the customer through the external provider
       */
      readonly lastLoginTime: Date;

      /**
       * Returns the authentication provider ID.
       *
       * @return the authentication provider ID.
       */
      getAuthenticationProviderID(): string;
      /**
       * Returns the customer object related to this profile.
       *
       * @return customer object related to profile.
       */
      getCustomer(): dw.customer.Customer;
      /**
       * Returns the customer's email address.
       *
       * @return the customer's email address.
       */
      getEmail(): string;
      /**
       * Returns the external ID.
       *
       * @return the external ID.
       */
      getExternalID(): string;
      /**
       * Returns the last login time of the customer through the external provider
       *
       * @return the time, when the customer was last logged in through this external provider
       */
      getLastLoginTime(): Date;
      /**
       * Sets the customer's email address.
       * @param email the customer's email address.
       */
      setEmail(email: string): void;
    }

    /**
     * The class provides access to past orders of the customer.
     *  <p>
     *  <b>Note:</b> this class allows access to sensitive financial and card holder data.
     *  Pay special attention to PCI DSS v3. requirements 1, 3, 7, and 9.
     *  It also allows access to sensitive personal and private information.
     *  Pay attention to appropriate legal and regulatory requirements related to this data.</p>
     */
    class OrderHistory {
      /**
       * The number of orders the customer has placed in the store. If the
       *  customer is anonymous, this method always returns zero. If an active data
       *  record is available for this customer, the orders count will be retrieved
       *  from this, otherwise a real-time query will be used to get the count.
       */
      readonly orderCount: number;

      /**
       * Returns the number of orders the customer has placed in the store. If the
       *  customer is anonymous, this method always returns zero. If an active data
       *  record is available for this customer, the orders count will be retrieved
       *  from this, otherwise a real-time query will be used to get the count.
       *
       * @return the number of orders the customer has placed in the store.
       */
      getOrderCount(): number;
    }

    /**
     * Represents a list of products (and optionally a gift certificate) that is
     *  typically maintained by a customer.  This class can be used to implement
     *  a number of different storefront features, e.g. shopping list, wish list and gift registry.
     *  A product list is always owned by a customer. The owner can be anonymous or a registered customer.
     *  The owner can be the person for which items from that list will be purchased (wish list).
     *  Or it can be a person who maintains the list, for example a gift registry, on behalf of the bridal couple.
     *  Each product list can have a registrant and a co-registrant. A registrant is typically associated with an event related product list
     *  such as a gift registry. It holds information about a person associated with the
     *  event such as a bride or groom.
     *  A shipping address can be associated with this product list to ship the items,
     *  e.g. to an event location. A post-event shipping address can be associated to
     *  ship items to which could not be delivered on event date.
     *  The product list can also hold information about the event date and event location.
     */
    class ProductList extends dw.object.ExtensibleObject {
      /**
       * Constant for when Export Status is Exported
       */
      static readonly EXPORT_STATUS_EXPORTED = 1;
      /**
       * Constant for when Export Status is Not Exported
       */
      static readonly EXPORT_STATUS_NOTEXPORTED = 0;
      /**
       * Constant representing a custom list type attribute.
       */
      static readonly TYPE_CUSTOM_1 = 100;
      /**
       * Constant representing a custom list type attribute.
       */
      static readonly TYPE_CUSTOM_2 = 101;
      /**
       * Constant representing a custom list type attribute.
       */
      static readonly TYPE_CUSTOM_3 = 102;
      /**
       * Constant representing the gift registry type attribute.
       */
      static readonly TYPE_GIFT_REGISTRY = 11;
      /**
       * Constant representing the shopping list type attribute.
       */
      static readonly TYPE_SHOPPING_LIST = 12;
      /**
       * Constant representing the wish list registry type attribute.
       */
      static readonly TYPE_WISH_LIST = 10;

      /**
       * Returns true if this product list is owned by an anonymous customer.
       */
      readonly anonymous: boolean;
      /**
       * The ProductListRegistrant assigned to the coRegistrant attribute or null
       *  if this list has no co-registrant.
       */
      readonly coRegistrant: dw.customer.ProductListRegistrant;
      /**
       * This is a helper method typically used with an event related list.
       *  It provides the appropriate shipping address based on the eventDate.
       *  If the current date is after the eventDate, then the postEventShippingAddress
       *  is returned, otherwise the shippingAddress is returned.  If the eventDate
       *  is null, then null is returned.
       */
      readonly currentShippingAddress: dw.customer.CustomerAddress;
      /**
       * A description text that, for example, explains the purpose of this product list.
       */
      description: string;
      /**
       * For event related uses (e.g. gift registry), this holds the event city.
       */
      eventCity: string;
      /**
       * For event related uses (e.g. gift registry), this holds the event country.
       */
      eventCountry: string;
      /**
       * For event related uses (e.g. gift registry), this holds the date
       *  of the event.
       */
      eventDate: Date;
      /**
       * For event related uses (e.g. gift registry), this holds the event state.
       */
      eventState: string;
      /**
       * For event related uses (e.g. gift registry), this holds the type
       *  of event, e.g. Wedding, Baby Shower.
       */
      eventType: string;
      /**
       * The export status of the product list.
       *  Possible values are: EXPORT_STATUS_NOTEXPORTED,
       *  EXPORT_STATUS_EXPORTED.
       */
      readonly exportStatus: dw.value.EnumValue;
      /**
       * The item in the list that represents a gift certificate.
       */
      readonly giftCertificateItem: dw.customer.ProductListItem;
      /**
       * The unique system generated ID of the object.
       */
      readonly ID: string;
      /**
       * A collection containing all items in the list.
       */
      readonly items: dw.util.Collection<dw.customer.ProductListItem>;
      /**
       * The date where this product list has been exported successfully
       *  the last time.
       */
      readonly lastExportTime: Date;
      /**
       * The name of this product list given by its owner.
       */
      name: string;
      /**
       * The customer that created and owns the product list.
       */
      readonly owner: dw.customer.Customer;
      /**
       * The shipping address for purchases made after the event date.
       */
      postEventShippingAddress: dw.customer.CustomerAddress;
      /**
       * A collection containing all items in the list that reference products.
       */
      readonly productItems: dw.util.Collection<dw.customer.ProductListItem>;
      /**
       * A flag, typically used to determine if the object is searchable
       *  by other customers.
       */
      public: boolean;
      /**
       * A collection containing all items in the list that are flagged as public.
       */
      readonly publicItems: dw.util.Collection<dw.customer.ProductListItem>;
      /**
       * The aggregated purchases from all the individual items.
       */
      readonly purchases: dw.util.Collection<
        dw.customer.ProductListItemPurchase
      >;
      /**
       * The ProductListRegistrant assigned to the registrant attribute or null
       *  if this list has no registrant.
       */
      readonly registrant: dw.customer.ProductListRegistrant;
      /**
       * Return the address that should be used as the shipping address for purchases
       *  made from the list.
       */
      shippingAddress: dw.customer.CustomerAddress;
      /**
       * An int representing the type of object (e.g. wish list,
       *  gift registry). This is set at object creation time.
       */
      readonly type: number;

      /**
       * Create a ProductListRegistrant and assign it to the coRegistrant attribute
       *  of the list.  An exception is thrown if the list already has a coRegistrant
       *  assigned to it.
       *
       * @return the created ProductListRegistrant instance.
       */
      createCoRegistrant(): dw.customer.ProductListRegistrant;
      /**
       * Create an item in the list that represents a gift certificate.
       *  A list may only contain a single gift certificate, so an exception
       *  is thrown if one already exists in the list.
       *
       * @return the created item.
       */
      createGiftCertificateItem(): dw.customer.ProductListItem;
      /**
       * Create an item in the list that references the specified product.
       * @param product the product to use to create the list item.
       * @return the created item.
       */
      createProductItem(
        product: dw.catalog.Product
      ): dw.customer.ProductListItem;
      /**
       * Create a ProductListRegistrant and assign it to the registrant attribute
       *  of the list.  An exception is thrown if the list already has a registrant
       *  assigned to it.
       *
       * @return the created ProductListRegistrant instance.
       */
      createRegistrant(): dw.customer.ProductListRegistrant;
      /**
       * Returns the ProductListRegistrant assigned to the coRegistrant attribute or null
       *  if this list has no co-registrant.
       *
       * @return the ProductListRegistrant assigned to the coRegistrant attribute or null if this list has no co-registrant.
       */
      getCoRegistrant(): dw.customer.ProductListRegistrant;
      /**
       * This is a helper method typically used with an event related list.
       *  It provides the appropriate shipping address based on the eventDate.
       *  If the current date is after the eventDate, then the postEventShippingAddress
       *  is returned, otherwise the shippingAddress is returned.  If the eventDate
       *  is null, then null is returned.
       *
       * @return the appropriate address, as described above.
       */
      getCurrentShippingAddress(): dw.customer.CustomerAddress;
      /**
       * Returns a description text that, for example, explains the purpose of this product list.
       *
       * @return a description text explaining the purpose of this product list. Returns an empty string if the description is not set.
       */
      getDescription(): string;
      /**
       * For event related uses (e.g. gift registry), this holds the event city.
       *
       * @return the event city. The event city or an empty string if no event city is set.
       */
      getEventCity(): string;
      /**
       * For event related uses (e.g. gift registry), this holds the event country.
       *
       * @return the event country. The event country or an empty string if no event country is set.
       */
      getEventCountry(): string;
      /**
       * For event related uses (e.g. gift registry), this holds the date
       *  of the event.
       *
       * @return the date of the event.
       */
      getEventDate(): Date;
      /**
       * For event related uses (e.g. gift registry), this holds the event state.
       *
       * @return the event state. The event state or an empty string if no event state is set.
       */
      getEventState(): string;
      /**
       * For event related uses (e.g. gift registry), this holds the type
       *  of event, e.g. Wedding, Baby Shower.
       *
       * @return the type of event. Returns an empty string, if not set.
       */
      getEventType(): string;
      /**
       * Returns the export status of the product list.
       *  Possible values are: EXPORT_STATUS_NOTEXPORTED,
       *  EXPORT_STATUS_EXPORTED.
       *
       * @return Product list export status
       */
      getExportStatus(): dw.value.EnumValue;
      /**
       * Returns the item in the list that represents a gift certificate.
       *
       * @return the gift certificate item, or null if it doesn't exist.
       */
      getGiftCertificateItem(): dw.customer.ProductListItem;
      /**
       * Returns the unique system generated ID of the object.
       *
       * @return the ID of object.
       */
      getID(): string;
      /**
       * Returns the item from the list that has the specified ID.
       * @param ID the product list item identifier.
       * @return the specified item, or null if it's not found in the list.
       */
      getItem(ID: string): dw.customer.ProductListItem;
      /**
       * Returns a collection containing all items in the list.
       *
       * @return all items.
       */
      getItems(): dw.util.Collection<dw.customer.ProductListItem>;
      /**
       * Returns the date where this product list has been exported successfully
       *  the last time.
       *
       * @return The time of the last successful export or null if this product list was not exported yet.
       */
      getLastExportTime(): Date;
      /**
       * Returns the name of this product list given by its owner.
       *
       * @return the name of this product list. Returns an empty string if the name is not set.
       */
      getName(): string;
      /**
       * Returns the customer that created and owns the product list.
       *
       * @return Owning customer
       */
      getOwner(): dw.customer.Customer;
      /**
       * Returns the shipping address for purchases made after the event date.
       *
       * @return the shipping address for purchases made after the event date. Returns null if no post-event shipping address is associated.
       */
      getPostEventShippingAddress(): dw.customer.CustomerAddress;
      /**
       * Returns a collection containing all items in the list that reference products.
       *
       * @return all product items.
       */
      getProductItems(): dw.util.Collection<dw.customer.ProductListItem>;
      /**
       * Returns a collection containing all items in the list that are flagged as public.
       *
       * @return all public items.
       */
      getPublicItems(): dw.util.Collection<dw.customer.ProductListItem>;
      /**
       * Returns the aggregated purchases from all the individual items.
       *
       * @return purchases
       */
      getPurchases(): dw.util.Collection<dw.customer.ProductListItemPurchase>;
      /**
       * Returns the ProductListRegistrant assigned to the registrant attribute or null
       *  if this list has no registrant.
       *
       * @return the ProductListRegistrant assigned to the registrant attribute or null if this list has no registrant.
       */
      getRegistrant(): dw.customer.ProductListRegistrant;
      /**
       * Return the address that should be used as the shipping address for purchases
       *  made from the list.
       *
       * @return the shipping address. The shipping address of this list or null if no address is associated.
       */
      getShippingAddress(): dw.customer.CustomerAddress;
      /**
       * Returns an int representing the type of object (e.g. wish list,
       *  gift registry). This is set at object creation time.
       *
       * @return the type of object.
       */
      getType(): number;
      /**
       * Returns true if this product list is owned by an anonymous customer.
       *
       * @return true if the owner of this product list is anonymous, false otherwise.
       */
      isAnonymous(): boolean;
      /**
       * A flag, typically used to determine if the object is searchable
       *  by other customers.
       *
       * @return true if the product list is public. False otherwise.
       */
      isPublic(): boolean;
      /**
       * Removes the ProductListRegistrant assigned to the coRegistrant attribute.
       *
       */
      removeCoRegistrant(): void;
      /**
       * Removes the specified item from the list.  This will also cause
       *  all purchase information associated with that item to be removed.
       * @param item The item to remove.
       */
      removeItem(item: dw.customer.ProductListItem): void;
      /**
       * Removes the ProductListRegistrant assigned to the registrant attribute.
       *
       */
      removeRegistrant(): void;
      /**
       * Set the description of this product list.
       * @param description The description of this product list. The description can have up to 256 characters, longer descriptions get truncated. If an empty string is provided, the description gets set to null.
       */
      setDescription(description: string): void;
      /**
       * Set the event city to which this product list is related.
       * @param eventCity The event city can have up to 256 characters, longer event city get truncated. If an empty string is provided, the event city gets set to null.
       */
      setEventCity(eventCity: string): void;
      /**
       * Set the event country to which this product list is related.
       * @param eventCountry The event country can have up to 256 characters, longer event country get truncated. If an empty string is provided, the event country gets set to null.
       */
      setEventCountry(eventCountry: string): void;
      /**
       * Set the date of the event to which this product list is related.
       * @param eventDate The event date or null if no event date should be available.
       */
      setEventDate(eventDate: Date): void;
      /**
       * Set the event state to which this product list is related.
       * @param eventState The event state can have up to 256 characters, longer event state get truncated. If an empty string is provided, the event state gets set to null.
       */
      setEventState(eventState: string): void;
      /**
       * Set the event type for which this product list was created by the owner.
       * @param eventType The event type can have up to 256 characters, longer event type get truncated. If an empty string is provided, the event type gets set to null.
       */
      setEventType(eventType: string): void;
      /**
       * Set the name of this product list.
       * @param name The name of this product list. The name can have up to 256 characters, longer names get truncated. If an empty string is provided, the name gets set to null.
       */
      setName(name: string): void;
      /**
       * This is typically used by an event related list (e.g. gift registry) to
       *  specify a shipping address for purchases made after the event date.
       * @param address The shipping address.
       */
      setPostEventShippingAddress(address: dw.customer.CustomerAddress): void;
      /**
       * Makes this product list visible to other customers or hides it.
       * @param flag If true, this product list becomes visible to other customers. If false, this product list can only be seen and searched by its owner.
       */
      setPublic(flag: boolean): void;
      /**
       * Associate an address, used as the shipping address for purchases
       *  made from the list.
       * @param address The shipping address.
       */
      setShippingAddress(address: dw.customer.CustomerAddress): void;
    }

    /**
     * An item in a product list.  Types of items are:<br>
     *  <ul>
     *  <li>An item that references a product via the product&apos;s SKU.</li>
     *  <li>An item that represents a gift certificate.</li>
     *  </ul>
     */
    class ProductListItem extends dw.object.ExtensibleObject {
      /**
       * Constant representing a gift certificate list item type.
       */
      static readonly TYPE_GIFT_CERTIFICATE = 2;
      /**
       * Constant representing a product list item type.
       */
      static readonly TYPE_PRODUCT = 1;

      /**
       * The unique system generated ID of the object.
       */
      readonly ID: string;
      /**
       * The product list that this item belongs to.
       */
      readonly list: dw.customer.ProductList;
      /**
       * Specify the priority level for the item.  Typically the lower the
       *  number, the higher the priority. This can be used by the owner of the product list
       *  to express which items he/she likes to get purchased first.
       */
      priority: number;
      /**
       * The referenced product for this item.  The reference is made
       *  via the product ID attribute.  This method returns null if there is
       *  no such product in the system or if the product exists but is not
       *  assigned to the site catalog.
       */
      product: dw.catalog.Product;
      /**
       * The ID of the product referenced by this item.
       *  This attribute is set when a product is assigned via setProduct().
       *  It is possible for the ID to reference a product that doesn't exist
       *  anymore.  In this case getProduct() would return null.
       */
      readonly productID: string;
      /**
       * The ProductOptionModel for the product associated with this item,
       *  or null if there is no valid product associated with this item.
       */
      productOptionModel: dw.catalog.ProductOptionModel;
      /**
       * A flag, typically used to determine whether the item should display
       *  in a customer's view of the list (as opposed to the list owner's view).
       */
      public: boolean;
      /**
       * The sum of the quantities of all the individual purchase records
       *  for this item.
       */
      readonly purchasedQuantity: dw.value.Quantity;
      /**
       * The value part of the underlying purchased quantity object, as distinct
       *  from the unit.
       */
      readonly purchasedQuantityValue: number;
      /**
       * All purchases made for this item.
       */
      readonly purchases: dw.util.Collection<
        dw.customer.ProductListItemPurchase
      >;
      /**
       * The quantity of the item.
       *  The quantity is the number of products or gift certificates
       *  that get shipped when purchasing this product list item.
       */
      quantity: dw.value.Quantity;
      /**
       * The value part of the underlying quantity object, as distinct
       *  from the unit.
       */
      quantityValue: number;
      /**
       * The type of this product list item.
       */
      readonly type: number;

      /**
       * Create a purchase record for this item.
       * @param quantity The number of items purchased.
       * @param purchaserName The name of the purchaser.
       * @return the purchase record.
       */
      createPurchase(
        quantity: number,
        purchaserName: string
      ): dw.customer.ProductListItemPurchase;
      /**
       * Returns the unique system generated ID of the object.
       *
       * @return the ID of object.
       */
      getID(): string;
      /**
       * Returns the product list that this item belongs to.
       *
       * @return the list.
       */
      getList(): dw.customer.ProductList;
      /**
       * Specify the priority level for the item.  Typically the lower the
       *  number, the higher the priority. This can be used by the owner of the product list
       *  to express which items he/she likes to get purchased first.
       *
       * @return the specified priority level.
       */
      getPriority(): number;
      /**
       * Returns the referenced product for this item.  The reference is made
       *  via the product ID attribute.  This method returns null if there is
       *  no such product in the system or if the product exists but is not
       *  assigned to the site catalog.
       *
       * @return the product referenced by this item, or null.
       */
      getProduct(): dw.catalog.Product;
      /**
       * Returns the ID of the product referenced by this item.
       *  This attribute is set when a product is assigned via setProduct().
       *  It is possible for the ID to reference a product that doesn't exist
       *  anymore.  In this case getProduct() would return null.
       *
       * @return the product ID, or null if none exists.
       */
      getProductID(): string;
      /**
       * Returns the ProductOptionModel for the product associated with this item,
       *  or null if there is no valid product associated with this item.
       *
       * @return the associated ProductOptionModel or null.
       */
      getProductOptionModel(): dw.catalog.ProductOptionModel;
      /**
       * Returns the sum of the quantities of all the individual purchase records
       *  for this item.
       *
       * @return the sum of the quantities of all the individual purchase records for this item.
       */
      getPurchasedQuantity(): dw.value.Quantity;
      /**
       * Returns the value part of the underlying purchased quantity object, as distinct
       *  from the unit.
       *
       * @return the value part of the underlying purchased quantity object, as distinct from the unit.
       */
      getPurchasedQuantityValue(): number;
      /**
       * Returns all purchases made for this item.
       *
       * @return the collection of purchase records for this item. Returns an empty list if this item has not been purchased yet.
       */
      getPurchases(): dw.util.Collection<dw.customer.ProductListItemPurchase>;
      /**
       * Returns the quantity of the item.
       *  The quantity is the number of products or gift certificates
       *  that get shipped when purchasing this product list item.
       *
       * @return the quantity of the item.
       */
      getQuantity(): dw.value.Quantity;
      /**
       * Returns the value part of the underlying quantity object, as distinct
       *  from the unit.
       *
       * @return the value part of the underlying quantity object, as distinct from the unit.
       */
      getQuantityValue(): number;
      /**
       * Returns the type of this product list item.
       *
       * @return a code that specifies the type of item (i.e. product or gift certificate).
       */
      getType(): number;
      /**
       * A flag, typically used to determine whether the item should display
       *  in a customer's view of the list (as opposed to the list owner's view).
       *
       * @return true if the item is public.
       */
      isPublic(): boolean;
      /**
       * Specify the priority level for the item.  Typically the lower the
       *  number, the higher the priority. This can be used by the owner of the product list
       *  to express which items he/she likes to get purchased first.
       * @param priority The new priority level.
       */
      setPriority(priority: number): void;
      /**
       * Sets the referenced product for this item by storing the product's id.
       *  If null is specified, then the id is set to null.
       * @param product The referenced product for this item.
       */
      setProduct(product: dw.catalog.Product): void;
      /**
       * Store a product option model with this object.  This stores a copy
       *  of the specified model, rather than an assocation to the same instance.
       * @param productOptionModel The object to store.
       */
      setProductOptionModel(
        productOptionModel: dw.catalog.ProductOptionModel
      ): void;
      /**
       * Typically used to determine if the item is visible to other customers.
       * @param flag If true, this product list becomes visible to other customers. If false, this product list can only be seen by the owner of the product list.
       */
      setPublic(flag: boolean): void;
      /**
       * Sets the quantity of the item.
       * @param value the new quantity of the item.
       */
      setQuantity(value: dw.value.Quantity): void;
      /**
       * Set the value part of the underlying quantity object, as distinct from
       *  the unit.
       * @param value the value to use.
       */
      setQuantityValue(value: number): void;
    }

    /**
     * A record of the purchase of an item contained in a product list.
     */
    class ProductListItemPurchase extends dw.object.ExtensibleObject {
      /**
       * The item that was purchased.
       */
      readonly item: dw.customer.ProductListItem;
      /**
       * The number of the order in which the
       *  product list item was purchased.
       */
      readonly orderNo: string;
      /**
       * The date on which the product list item was purchased.
       */
      readonly purchaseDate: Date;
      /**
       * The name of the purchaser of the product list item.
       */
      readonly purchaserName: string;
      /**
       * The quantity of the product list item that was purchased.
       */
      readonly quantity: dw.value.Quantity;

      /**
       * Returns the item that was purchased.
       *
       * @return the item that was purchased.
       */
      getItem(): dw.customer.ProductListItem;
      /**
       * Returns the number of the order in which the
       *  product list item was purchased.
       *
       * @return the number of the order in which the product list item was purchased.
       */
      getOrderNo(): string;
      /**
       * Returns the date on which the product list item was purchased.
       *
       * @return the date on which the product list item was purchased.
       */
      getPurchaseDate(): Date;
      /**
       * Returns the name of the purchaser of the product list item.
       *
       * @return the name of the purchaser of the product list item.
       */
      getPurchaserName(): string;
      /**
       * Returns the quantity of the product list item that was purchased.
       *
       * @return the quantity of the product list item that was purchased.
       */
      getQuantity(): dw.value.Quantity;
    }

    /**
     * ProductListMgr provides methods for retrieving, creating, searching for, and
     *  removing product lists.
     */
    class ProductListMgr {
      /**
       * Creates a new instance of a product list, of the specified type.
       * @param customer The customer owning the product list, must not be null.
       * @param type The type of list (e.g. wish list, gift registry). The types are defined as constants within ProductList.
       * @return the new list instance.
       */
      static createProductList(
        customer: dw.customer.Customer,
        type: number
      ): dw.customer.ProductList;
      /**
       * Gets the product list by its ID.
       * @param ID The product list ID.
       * @return the ProductList instance, or null if a list with the specified UUID doesn't exist.
       */
      static getProductList(ID: string): dw.customer.ProductList;
      /**
       * Returns the first product list belonging to the customer with the
       *  specified profile.
       * @param profile The profile of the customer whose product list is to be retrieved.
       * @param type The type of list (e.g. wish list, gift registry). The types are defined as constants within ProductList.
       * @return the product list, or null if none exists.
       */
      static getProductList(
        profile: dw.customer.Profile,
        type: number
      ): dw.customer.ProductList;
      /**
       * Retrieve all product lists of the specified type owned by the
       *  specified customer.
       * @param customer The customer used for the query, must not be null.
       * @param type The type of list used for the query. The types are defined as constants within ProductList.
       * @return the unsorted collection of ProductList instances of the specified type belonging to the specified customer.
       */
      static getProductLists(
        customer: dw.customer.Customer,
        type: number
      ): dw.util.Collection<dw.customer.ProductList>;
      /**
       * Retrieve all the product lists of the specified type and event type
       *  belonging to the specified customer.
       * @param customer The customer used for the query, must not be null.
       * @param type The type of list used for the query. The types are defined as constants within ProductList.
       * @param eventType The event type used for the query, must not be null.
       * @return the unsorted collection of ProductList instances of the specified type and event type belonging to the specified customer.
       */
      static getProductLists(
        customer: dw.customer.Customer,
        type: number,
        eventType: string
      ): dw.util.Collection<dw.customer.ProductList>;
      /**
       * Returns the collection of product lists that have the specified address
       *  as the shipping address.
       * @param customerAddress the address to test, must not be null.
       * @return the unsorted collection of ProductList instances using this address.
       */
      static getProductLists(
        customerAddress: dw.customer.CustomerAddress
      ): dw.util.Collection<dw.customer.ProductList>;
      /**
       * Searches for product list instances.
       *
       *  The search can be configured with a map, which key-value pairs are
       *  converted into a query expression. The key-value pairs are turned into a
       *  sequence of '=' or 'like' conditions, which are combined with AND
       *  statements.
       *
       *  Example:
       *  A map with the key/value pairs: 'name'/'tom*', 'age'/66
       *  will be converted as follows: "name like 'tom*' and age = 66"
       *
       *  The identifier for an attribute  to use in a query condition is always the
       *  ID of the  attribute as defined in the type definition. For custom defined attributes
       *  the prefix custom is required in the search term (e.g. custom.color = {1}),
       *  while for system attributes no prefix is used (e.g. name = {4}).
       *
       *  Supported attribute value types with sample expression values:
       *  String 'String', 'Str*', 'Strin?'
       *  Integer 1, 3E4
       *  Number 1.0, 3.99E5
       *  Date yyyy-MM-dd e.g. 2007-05-31 (Default TimeZone = UTC)
       *  DateTime yyyy-MM-dd'T'hh:mm:ss+Z e.g. 2007-05-31T00:00+Z (Z TimeZone = UTC) or 2007-05-31T00:00:00
       *  Boolean true, false
       *  Email '[emailprotected]', '*@demandware.com'
       *  Set of String 'String', 'Str*', 'Strin?'
       *  Set of Integer 1, 3E4
       *  Set of Number 1.0, 3.99E5
       *  Enum of String 'String', 'Str*', 'Strin?'
       *  Enum of Integer 1, 3E4
       *  The following types of attributes are not queryable:
       *  Image
       *  HTML
       *  Text
       *  Quantity
       *  Password
       *  Note, that some system attributes are not queryable by default regardless of the
       *  actual value type code.
       *
       *
       *  The sorting parameter is optional and may contain a comma separated list of
       *  attribute names to sort by. Each sort attribute name may be followed by an
       *  optional sort direction specifier ('asc' | 'desc'). Default sorting directions is
       *  ascending, if no direction was specified.
       *  Example: age desc, name
       *  Please note that specifying a localized custom attribute as the sorting attribute is
       *  currently not supported.
       *
       *  It is strongly recommended to call close() on the returned SeekableIterator
       *  if not all of its elements are being retrieved. This will ensure the proper cleanup of system resources.
       * @param queryAttributes key-value pairs, which define the query.
       * @param sortString an optional sorting or null if no sorting is necessary.
       * @return SeekableIterator containing the result set of the query.
       */
      static queryProductLists(
        queryAttributes: dw.util.Map<any, any>,
        sortString: string
      ): dw.util.SeekableIterator;
      /**
       * Searches for product list instances.
       *
       *  The search can be configured using a simple query language, which
       *  provides most common filter and operator functionality.
       *
       *  The identifier for an attribute  to use in a query condition is always the
       *  ID of the  attribute as defined in the type definition. For custom defined attributes
       *  the prefix custom is required in the search term (e.g. custom.color = {1}),
       *  while for system attributes no prefix is used (e.g. name = {4}).
       *
       *  Supported attribute value types with sample expression values:
       *  String 'String', 'Str*', 'Strin?'
       *  Integer 1, 3E4
       *  Number 1.0, 3.99E5
       *  Date yyyy-MM-dd e.g. 2007-05-31 (Default TimeZone = UTC)
       *  DateTime yyyy-MM-dd'T'hh:mm:ss+Z e.g. 2007-05-31T00:00+Z (Z TimeZone = UTC) or 2007-05-31T00:00:00
       *  Boolean true, false
       *  Email '[emailprotected]', '*@demandware.com'
       *  Set of String 'String', 'Str*', 'Strin?'
       *  Set of Integer 1, 3E4
       *  Set of Number 1.0, 3.99E5
       *  Enum of String 'String', 'Str*', 'Strin?'
       *  Enum of Integer 1, 3E4
       *  The following types of attributes are not queryable:
       *  Image
       *  HTML
       *  Text
       *  Quantity
       *  Password
       *  Note, that some system attributes are not queryable by default regardless of the
       *  actual value type code.
       *
       *
       *  The following operators are supported in a condition:
       *  = Equals - All types; supports NULL value (thumbnail = NULL)
       *  != Not equals - All types; supports NULL value (thumbnail != NULL)
       *  < Less than  - Integer, Number and Date types only
       *  > Greater than - Integer, Number and Date types only
       *  <= Less or equals than - Integer, Number and Date types only
       *  >= Greater or equals than  - Integer, Number and Date types only
       *  LIKE Like - String types and Email only; use if leading or trailing
       *  wildcards will be used to support substring search(custom.country LIKE 'US*')
       *  ILIKE Caseindependent Like - String types and Email only, use to support
       *  case insensitive query (custom.country ILIKE 'usa'), does also support wildcards for
       *  substring matching
       *
       *  Conditions can be combined using logical expressions 'AND', 'OR' and 'NOT'
       *  and nested using parenthesis e.g.
       *  gender = {1} AND (age >= {2} OR (NOT profession LIKE {3})).
       *
       *
       *  The query language provides a placeholder syntax to pass objects as
       *  additional search parameters. Each passed object is related to a
       *  placeholder in the query string. The placeholder must be an Integer that
       *  is surrounded by braces. The first Integer value must be '0', the second
       *  '1' and so on, e.g.
       *  querySystemObjects("sample", "age = {0} or creationDate >= {1}", 18, date)
       *
       *
       *  The sorting parameter is optional and may contain a comma separated list of
       *  attribute names to sort by. Each sort attribute name may be followed by an
       *  optional sort direction specifier ('asc' | 'desc'). Default sorting directions is
       *  ascending, if no direction was specified.
       *  Example: age desc, name
       *  Please note that specifying a localized custom attribute as the sorting attribute is
       *  currently not supported.
       *
       *  Sometimes it is desired to get all instances with a special sorting condition.
       *  This can be easily done by providing the 'sortString' in combination with
       *  an empty 'queryString', e.g. querySystemObjects("sample", "", "ID asc")
       *
       *  It is strongly recommended to call close() on the returned SeekableIterator
       *  if not all of its elements are being retrieved. This will ensure the proper cleanup of system resources.
       * @param queryString the actual query.
       * @param sortString an optional sorting or null if no sorting is necessary.
       * @param args optional parameters for the queryString.
       * @return SeekableIterator containing the result set of the query.
       */
      static queryProductLists(
        queryString: string,
        sortString: string,
        ...args: any[]
      ): dw.util.SeekableIterator;
      /**
       * Removes the specified product list from the system.
       * @param productList The list to remove, must not be null.
       */
      static removeProductList(productList: dw.customer.ProductList): void;
    }

    /**
     * A ProductListRegistrant is typically associated with an event related product list
     *  such as a gift registry. It holds information about a person associated with the
     *  event such as a bride or groom.
     */
    class ProductListRegistrant extends dw.object.ExtensibleObject {
      /**
       * The email address of the registrant or null.
       */
      email: string;
      /**
       * The first name of the registrant or null.
       */
      firstName: string;
      /**
       * The last name of the registrant or null.
       */
      lastName: string;
      /**
       * The role of the registrant or null. The role of a registrant
       *  can be for example the bride of a bridal couple.
       */
      role: string;

      /**
       * Returns the email address of the registrant or null.
       *
       * @return the email address of the registrant or null.
       */
      getEmail(): string;
      /**
       * Returns the first name of the registrant or null.
       *
       * @return the first name of the registrant or null.
       */
      getFirstName(): string;
      /**
       * Returns the last name of the registrant or null.
       *
       * @return the last name of the registrant or null.
       */
      getLastName(): string;
      /**
       * Returns the role of the registrant or null. The role of a registrant
       *  can be for example the bride of a bridal couple.
       *
       * @return the role name of the registrant or null.
       */
      getRole(): string;
      /**
       * Sets the email address of the registrant.
       * @param email the email address of the registrant.
       */
      setEmail(email: string): void;
      /**
       * Sets the first name of the registrant.
       * @param firstName the first name of the registrant.
       */
      setFirstName(firstName: string): void;
      /**
       * Sets the last name of the registrant.
       * @param lastName the last name of the registrant.
       */
      setLastName(lastName: string): void;
      /**
       * Sets the role of the registrant.
       * @param role the role of the registrant.
       */
      setRole(role: string): void;
    }

    /**
     * The class represents a customer profile. It also provides access to the
     *  customers address book and credentials.
     *  <p>
     *  <b>Note:</b> this class handles sensitive security-related data.
     *  Pay special attention to PCI DSS v3. requirements 2, 4, and 12.</p>
     */
    class Profile extends dw.customer.EncryptedObject {
      /**
       * The customer's address book.
       */
      readonly addressBook: dw.customer.AddressBook;
      /**
       * The customer's birthday as a date.
       */
      birthday: Date;
      /**
       * The customer's company name.
       */
      companyName: string;
      /**
       * The customer's credentials.
       */
      readonly credentials: dw.customer.Credentials;
      /**
       * The customer object related to this profile.
       */
      readonly customer: dw.customer.Customer;
      /**
       * The customer's number, which is a number used to identify the Customer.
       */
      readonly customerNo: string;
      /**
       * The customer's email address.
       */
      email: string;
      /**
       * The fax number to use for the customer.
       *  The length is restricted to 32 characters.
       */
      fax: string;
      /**
       * Indicates that the customer is female when set to true.
       */
      readonly female: boolean;
      /**
       * The customer's first name.
       */
      firstName: string;
      /**
       * The customer's gender.
       */
      gender: dw.value.EnumValue;
      /**
       * The customer's job title.
       */
      jobTitle: string;
      /**
       * The last login time of the customer.
       */
      readonly lastLoginTime: Date;
      /**
       * The customer's last name.
       */
      lastName: string;
      /**
       * The last visit time of the customer.
       */
      readonly lastVisitTime: Date;
      /**
       * Indicates that the customer is male when set to true.
       */
      readonly male: boolean;
      /**
       * The upcoming customer's birthday as a date.
       *  If the customer already had birthday this year the method returns the birthday of the next year.
       *  Otherwise its birthday in this year.
       *  If the customer has not set a birthday this method returns null.
       */
      readonly nextBirthday: Date;
      /**
       * The business phone number to use for the customer.
       */
      phoneBusiness: string;
      /**
       * The phone number to use for the customer.
       */
      phoneHome: string;
      /**
       * The mobile phone number to use for the customer.
       */
      phoneMobile: string;
      /**
       * The customer's preferred locale.
       */
      preferredLocale: string;
      /**
       * The time the customer logged in prior to the current login.
       */
      readonly previousLoginTime: Date;
      /**
       * The time the customer visited the store prior to the current visit.
       */
      readonly previousVisitTime: Date;
      /**
       * The salutation to use for the customer.
       */
      salutation: string;
      /**
       * The customer's second name.
       */
      secondName: string;
      /**
       * The customer's suffix, such as "Jr." or "Sr.".
       */
      suffix: string;
      /**
       * The tax ID value. The value is returned either plain
       *  text if the current context allows plain text access, or
       *  if it's not allowed, the ID value will be returned masked.
       *  The following criteria must be met in order to have plain text access:
       *
       *
       *  	the method call must happen in the context of a storefront request;
       *  	the current customer must be registered and authenticated;
       *  	it is the profile of the current customer;
       *   and the current protocol is HTTPS.
       */
      taxID: string;
      /**
       * The masked value of the tax ID.
       */
      readonly taxIDMasked: string;
      /**
       * The tax ID type.
       */
      taxIDType: dw.value.EnumValue;
      /**
       * The customer's title, such as "Mrs" or "Mr".
       */
      title: string;
      /**
       * The wallet of this customer.
       */
      readonly wallet: dw.customer.Wallet;

      /**
       * Returns the customer's address book.
       *
       * @return the customer's address book.
       */
      getAddressBook(): dw.customer.AddressBook;
      /**
       * Returns the customer's birthday as a date.
       *
       * @return the customer's birthday as a date.
       */
      getBirthday(): Date;
      /**
       * Returns the customer's company name.
       *
       * @return the customer's company name.
       */
      getCompanyName(): string;
      /**
       * Returns the customer's credentials.
       *
       * @return the customer's credentials.
       */
      getCredentials(): dw.customer.Credentials;
      /**
       * Returns the customer object related to this profile.
       *
       * @return customer object related to profile.
       */
      getCustomer(): dw.customer.Customer;
      /**
       * Returns the customer's number, which is a number used to identify the Customer.
       *
       * @return the customer's number.
       */
      getCustomerNo(): string;
      /**
       * Returns the customer's email address.
       *
       * @return the customer's email address.
       */
      getEmail(): string;
      /**
       * Returns the fax number to use for the customer.
       *  The length is restricted to 32 characters.
       *
       * @return the fax mobile phone number to use for the customer.
       */
      getFax(): string;
      /**
       * Returns the customer's first name.
       *
       * @return the customer's first name.
       */
      getFirstName(): string;
      /**
       * Returns the customer's gender.
       *
       * @return the customer's gender.
       */
      getGender(): dw.value.EnumValue;
      /**
       * Returns the customer's job title.
       *
       * @return the customer's job title.
       */
      getJobTitle(): string;
      /**
       * Returns the last login time of the customer.
       *
       * @return the time, when the customer was last logged in.
       */
      getLastLoginTime(): Date;
      /**
       * Returns the customer's last name.
       *
       * @return the customer's last name.
       */
      getLastName(): string;
      /**
       * Returns the last visit time of the customer.
       *
       * @return the time, when the customer has visited the storefront the last time (with enabled remember me functionality).
       */
      getLastVisitTime(): Date;
      /**
       * Returns the upcoming customer's birthday as a date.
       *  If the customer already had birthday this year the method returns the birthday of the next year.
       *  Otherwise its birthday in this year.
       *  If the customer has not set a birthday this method returns null.
       *
       * @return the customer's next birthday as a date.
       */
      getNextBirthday(): Date;
      /**
       * Returns the business phone number to use for the customer.
       *
       * @return the business phone number to use for the customer.
       */
      getPhoneBusiness(): string;
      /**
       * Returns the phone number to use for the customer.
       *
       * @return the phone number to use for the customer.
       */
      getPhoneHome(): string;
      /**
       * Returns the mobile phone number to use for the customer.
       *
       * @return the mobile phone number to use for the customer.
       */
      getPhoneMobile(): string;
      /**
       * Returns the customer's preferred locale.
       *
       * @return the customer's preferred locale.
       */
      getPreferredLocale(): string;
      /**
       * Returns the time the customer logged in prior to the current login.
       *
       * @return the time the customer logged in prior to the current login.
       */
      getPreviousLoginTime(): Date;
      /**
       * Returns the time the customer visited the store prior to the current visit.
       *
       * @return the time the customer visited the store prior to the current visit.
       */
      getPreviousVisitTime(): Date;
      /**
       * Returns the salutation to use for the customer.
       *
       * @return the salutation to use for the customer.
       */
      getSalutation(): string;
      /**
       * Returns the customer's second name.
       *
       * @return the customer's second name.
       */
      getSecondName(): string;
      /**
       * Returns the customer's suffix, such as "Jr." or "Sr.".
       *
       * @return the customer's suffix.
       */
      getSuffix(): string;
      /**
       * Returns the tax ID value. The value is returned either plain
       *  text if the current context allows plain text access, or
       *  if it's not allowed, the ID value will be returned masked.
       *  The following criteria must be met in order to have plain text access:
       *
       *
       *  	the method call must happen in the context of a storefront request;
       *  	the current customer must be registered and authenticated;
       *  	it is the profile of the current customer;
       *   and the current protocol is HTTPS.
       *
       * @return the tax ID value
       */
      getTaxID(): string;
      /**
       * Returns the masked value of the tax ID.
       *
       * @return the masked value of the tax ID
       */
      getTaxIDMasked(): string;
      /**
       * Returns the tax ID type.
       *
       * @return the tax ID type
       */
      getTaxIDType(): dw.value.EnumValue;
      /**
       * Returns the customer's title, such as "Mrs" or "Mr".
       *
       * @return the customer's title.
       */
      getTitle(): string;
      /**
       * Returns the wallet of this customer.
       *
       * @return the wallet of this customer.
       */
      getWallet(): dw.customer.Wallet;
      /**
       * Indicates that the customer is female when set to true.
       *
       * @return true if the customer is a female, false otherwise.
       */
      isFemale(): boolean;
      /**
       * Indicates that the customer is male when set to true.
       *
       * @return true if the customer is a male, false otherwise.
       */
      isMale(): boolean;
      /**
       * Sets the customer's birthday as a date.
       * @param aValue the customer's birthday as a date.
       */
      setBirthday(aValue: Date): void;
      /**
       * Sets the customer's company name.
       * @param aValue the customer's company name.
       */
      setCompanyName(aValue: string): void;
      /**
       * Sets the customer's email address.
       * @param aValue the customer's email address.
       */
      setEmail(aValue: string): void;
      /**
       * Sets the fax number to use for the customer.
       *  The length is restricted to 32 characters.
       * @param number the fax number to use for the customer.
       */
      setFax(number: string): void;
      /**
       * Sets the customer's first name.
       * @param aValue the customer's first name.
       */
      setFirstName(aValue: string): void;
      /**
       * Sets the customer's gender.
       * @param aValue the customer's gender.
       */
      setGender(aValue: number): void;
      /**
       * Sets the customer's job title.
       * @param aValue the customer's job title.
       */
      setJobTitle(aValue: string): void;
      /**
       * Sets the customer's last name.
       * @param aValue the customer's last name.
       */
      setLastName(aValue: string): void;
      /**
       * Sets the business phone number to use for the customer.
       *  The length is restricted to 32 characters.
       * @param number the business phone number to use for the customer.
       */
      setPhoneBusiness(number: string): void;
      /**
       * Sets the phone number to use for the customer.
       *  The length is restricted to 32 characters.
       * @param number the phone number to use for the customer.
       */
      setPhoneHome(number: string): void;
      /**
       * Sets the mobile phone number to use for the customer.
       *  The length is restricted to 32 characters.
       * @param number the mobile phone number to use for the customer.
       */
      setPhoneMobile(number: string): void;
      /**
       * Sets the customer's preferred locale.
       * @param aValue the customer's preferred locale.
       */
      setPreferredLocale(aValue: string): void;
      /**
       * Sets the salutation to use for the customer.
       * @param salutation the salutation to use for the customer.
       */
      setSaluation(salutation: string): void;
      /**
       * Sets the salutation to use for the customer.
       * @param salutation the salutation to use for the customer.
       */
      setSalutation(salutation: string): void;
      /**
       * Sets the customer's second name.
       * @param aValue the customer's second name.
       */
      setSecondName(aValue: string): void;
      /**
       * Sets the the customer's suffix.
       * @param aValue the customer's suffix.
       */
      setSuffix(aValue: string): void;
      /**
       * Sets the tax ID value. The value can be set if the current context
       *  allows write access.
       *  The current context allows write access if the currently
       *  logged in user owns this profile and the connection is secured.
       * @param taxID the tax ID value to set
       */
      setTaxID(taxID: string): void;
      /**
       * Sets the tax ID type.
       * @param taxIdType the tax ID type to set
       */
      setTaxIDType(taxIdType: string): void;
      /**
       * Sets the customer's title.
       * @param aValue the customer's title.
       */
      setTitle(aValue: string): void;
    }

    /**
     * Represents a set of payment instruments associated with a registered customer.
     *  <p>
     *  <b>Note:</b> this class allows access to sensitive personal and private
     *  information. Pay attention to appropriate legal and regulatory requirements
     *  when developing.</p>
     */
    class Wallet {
      /**
       * A collection of all payment instruments associated with the
       *  related customer.
       */
      readonly paymentInstruments: dw.util.Collection<
        dw.order.PaymentInstrument
      >;

      /**
       * Creates a new, empty payment instrument object associated with the
       *  related customer for the given payment method.
       * @param paymentMethodId the id of a payment method
       * @return the new payment instrument object.
       */
      createPaymentInstrument(
        paymentMethodId: string
      ): dw.customer.CustomerPaymentInstrument;
      /**
       * Returns a collection of all payment instruments associated with the
       *  related customer.
       *
       * @return Collection of all payment instruments.
       */
      getPaymentInstruments(): dw.util.Collection<dw.order.PaymentInstrument>;
      /**
       * Returns a collection of all payment instruments associated with the
       *  related customer filtered by the given payment method id. If
       *  null is passed as payment method id all payment instruments
       *  of the customer will be retrieved. If for the given payment method id no
       *  payment instrument is associated with the customer an empty collection
       *  will be returned.
       * @param paymentMethodID the paymentMethodID the payment method id to filter for
       * @return Collection of payment instruments for a payment method.
       */
      getPaymentInstruments(
        paymentMethodID: string
      ): dw.util.Collection<dw.order.PaymentInstrument>;
      /**
       * Removes a payment instrument associated with the customer.
       * @param instrument the instrument associated with this customer
       */
      removePaymentInstrument(
        instrument: dw.customer.CustomerPaymentInstrument
      ): void;
    }

    namespace oauth {
      /**
       * Contains OAuth-related artifacts from the HTTP response from the third-party
       *  OAuth server when requesting an access token
       */
      class OAuthAccessTokenResponse {
        /**
         * The access token
         */
        readonly accessToken: string;
        /**
         * The access token expiration
         */
        readonly accessTokenExpiry: number;
        /**
         * The error status.
         *  In cases of errors - more detailed error information
         *  can be seen in the error log files (specifity of error details vary by OAuth provider).
         */
        readonly errorStatus: string;
        /**
         * The OAuth provider id
         */
        readonly oauthProviderId: string;
        /**
         * The refresh token
         */
        readonly refreshToken: string;

        /**
         * Returns the access token
         *
         * @return the access token
         */
        getAccessToken(): string;
        /**
         * Returns the access token expiration
         *
         * @return the access token expiration
         */
        getAccessTokenExpiry(): number;
        /**
         * Returns the error status.
         *  In cases of errors - more detailed error information
         *  can be seen in the error log files (specifity of error details vary by OAuth provider).
         *
         * @return the error status
         */
        getErrorStatus(): string;
        /**
         * Returns the OAuth provider id
         *
         * @return the OAuth provider id
         */
        getOauthProviderId(): string;
        /**
         * Returns the refresh token
         *
         * @return the refresh token
         */
        getRefreshToken(): string;
      }

      /**
       * Contains the combined responses from the third-party OAuth server when
       *  finalizing the authentication.<br><br>
       *  Contains both the <a href="class_dw_customer_oauth_OAuthAccessTokenResponse.html">OAuthAccessTokenResponse</a> <br>
       *  and the <a href="class_dw_customer_oauth_OAuthUserInfoResponse.html">OAuthUserInfoResponse</a>
       */
      class OAuthFinalizedResponse {
        /**
         * The access token response
         */
        readonly accessTokenResponse: dw.customer.oauth.OAuthAccessTokenResponse;
        /**
         * The user info response
         */
        readonly userInfoResponse: dw.customer.oauth.OAuthUserInfoResponse;

        /**
         * Returns the access token response
         *
         * @return the access token response
         */
        getAccessTokenResponse(): dw.customer.oauth.OAuthAccessTokenResponse;
        /**
         * Returns the user info response
         *
         * @return the user info response
         */
        getUserInfoResponse(): dw.customer.oauth.OAuthUserInfoResponse;
      }

      /**
       * The OAuthLoginFlowMgr encapsulates interactions with third party
       *  OAuth providers.<br>
       *  The way to use is:
       *  <ul>
       *   <li>call <a href="class_dw_customer_oauth_OAuthLoginFlowMgr.html#dw_customer_oauth_OAuthLoginFlowMgr_initiateOAuthLogin_String_DetailAnchor">initiateOAuthLogin(String)</a></li>
       *   <li>redirect the user to the returned link</li>
       *   <li>when the user authenticates there the server will call back to
       *   a URL configured on the provider&apos;s web site</li>
       *   <li>when processing the request made from the provider&apos;s web site
       *   you have two choices - either call the <a href="class_dw_customer_oauth_OAuthLoginFlowMgr.html#dw_customer_oauth_OAuthLoginFlowMgr_obtainAccessToken_DetailAnchor">obtainAccessToken()</a>
       *   and <a href="class_dw_customer_oauth_OAuthLoginFlowMgr.html#dw_customer_oauth_OAuthLoginFlowMgr_obtainUserInfo_String_String_DetailAnchor">obtainUserInfo(String, String)</a>
       *   methods one after another separately (gives you more flexibility),
       *   or call the <a href="class_dw_customer_oauth_OAuthLoginFlowMgr.html#dw_customer_oauth_OAuthLoginFlowMgr_finalizeOAuthLogin_DetailAnchor">finalizeOAuthLogin()</a> method which internally
       *   calls the other two (simpler to use).
       *  </li></ul> Sample code for using it:
       *    <pre><code>
       *     var finalizedResponse : OAuthFinalizedResponse = OAuthLoginFlowMgr.finalizeOAuthLogin();
       *     var userInfo = finalizedResponse.userInfoResponse.userInfo;
       *    </code></pre>
       *    or:<pre><code>
       *     var accessTokenResponse : OAuthAccessTokenResponse = OAuthLoginFlowMgr.obtainAccessToken();
       *     var userInfoResponse : OAuthUserInfoResponse = OAuthLoginFlowMgr
       *         .obtainUserInfo(accessTokenResponse.oauthProviderId, accessTokenResponse.accessToken);
       *     var userInfo = userInfoResponse.userInfo;
       *    </code></pre>
       */
      class OAuthLoginFlowMgr {
        constructor();

        /**
         * This method works in tandem with the initiateOAuthLogin(String) method.
         *  After the user has been redirected to the URL returned by that method
         *  to the external OAuth2 provider and the user has interacted with the provider's
         *  site, the browser is redirected to a URL configured on the provider's web
         *  site. This URL should be that of a pipeline that contains
         *  a script invoking the finalizeOAuthLogin method.
         *  At this point the user has either been authenticated by the external provider
         *  or not (forgot password, or simply refused to provide credentials). If the user
         *  has been authenticated by the external provider and the provider returns an
         *  authentication code, this method exchanges the code for a token and with that
         *  token it requests from the provider the user information specified by the
         *  configured scope (id, first/last name, email, etc.).
         *
         *  The method is aggregation of two other methods - obtainAccessToken()
         *  and obtainUserInfo(String, String)
         *  and is provided for convenience. You may want to
         *  use the two individual methods instead if you need more flexibility.
         *
         * @return the user info on success, null otherwise
         */
        static finalizeOAuthLogin(): dw.customer.oauth.OAuthFinalizedResponse;
        /**
         * This method works in tandem with another method - finalizeOAuthLogin().
         *  It starts the process of authentication via an external OAuth2 provider. It
         *  takes one parameter - OAuthProviderId (as configured in the system). Outputs
         *  an URL pointing to the OAuth2 provider's web page to which the browser should
         *  redirect to initiate the actual user authentication or NULL if there is an
         *  invalid configuration or an error occurs.
         *  The method stores a few key/values in the session
         *  (Session.getPrivacy(), implementation specific parameters and may change at any time)
         *  to be picked up by the finalizeOAuthLogin() method  when the provider redirects back.
         * @param oauthProviderId the OAuth provider id
         * @return URL to redirect to
         */
        static initiateOAuthLogin(oauthProviderId: string): dw.web.URLRedirect;
        /**
         * This method is called internally by finalizeOAuthLogin().
         *  There are customer requests to expose a more granular way of
         *  doing the interactions that finalizeOAuthLogin is currently doing
         *  with the third party OAuth server to accommodate certain providers.
         *
         * @return the access token response
         */
        static obtainAccessToken(): dw.customer.oauth.OAuthAccessTokenResponse;
        /**
         * This method is called internally by finalizeOAuthLogin().
         *  There are customer requests to expose a more granular way of
         *  doing the interactions that finalizeOAuthLogin is currently doing
         *  with the third party OAuth server to accommodate certain providers.
         * @param oauthProviderId the OAuth provider id
         * @param accessToken the OAuth provider's access token
         * @return the user info response
         */
        static obtainUserInfo(
          oauthProviderId: string,
          accessToken: string
        ): dw.customer.oauth.OAuthUserInfoResponse;
      }

      /**
       * Contains the response from the third-party OAuth server when
       *  requesting user info. Refer to the corresponding OAuth provider documentation
       *  regarding what the format might be (in most cases it would be JSON).
       *  The data returned would also vary depending on the scope.
       */
      class OAuthUserInfoResponse {
        /**
         * The error status
         *  In cases of errors - more detailed error information
         *  can be seen in the error log files (specificity of error details vary by OAuth provider).
         */
        readonly errorStatus: string;
        /**
         * The user info as a String. Refer to the corresponding OAuth provider documentation
         *  regarding what the format might be (in most cases it would be JSON).
         *  The data returned would also vary depending on the configured 'scope'.
         */
        readonly userInfo: string;

        /**
         * Returns the error status
         *  In cases of errors - more detailed error information
         *  can be seen in the error log files (specificity of error details vary by OAuth provider).
         *
         * @return the error status
         */
        getErrorStatus(): string;
        /**
         * Returns the user info as a String. Refer to the corresponding OAuth provider documentation
         *  regarding what the format might be (in most cases it would be JSON).
         *  The data returned would also vary depending on the configured 'scope'.
         *
         * @return the user info
         */
        getUserInfo(): string;
      }
    }
  }

  namespace experience {
    /**
     * This class represents a page designer managed component as part of a
     *  page. A component comprises of multiple regions that again hold components,
     *  thus spanning a hierarchical tree of components. Using the <a href="class_dw_experience_PageMgr.html#dw_experience_PageMgr_renderRegion_Region_DetailAnchor">PageMgr.renderRegion(Region)</a> or
     *  <a href="class_dw_experience_PageMgr.html#dw_experience_PageMgr_renderRegion_Region_RegionRenderSettings_DetailAnchor">PageMgr.renderRegion(Region, RegionRenderSettings)</a> a region can be rendered which
     *  implicitly includes rendering of all contained visible components. All
     *  content attributes (defined by the corresponding component type) can be
     *  accessed, reading the accordant values as provided by the content editor
     *  that created this component.
     */
    class Component {
      /**
       * The id of this component.
       */
      readonly ID: string;
      /**
       * The name of this component
       */
      readonly name: string;
      /**
       * The type id of this component.
       */
      readonly typeID: string;

      /**
       * Returns the raw attribute value identified by the specified attribute id.
       *  By raw attribute value we denote the value as provided by the content
       *  editor when setting up this component. This value might be fundamentally
       *  different from the value as provided through the content dictionary when
       *  the render function of the component is invoked. This is due to
       *  the fact that during rendering the raw value is processed before being
       *  stored in the content dictionary - for example link placeholders in
       *  markup text are resolved to real URLs as part of such processing.
       *  Accessing the raw value can be helpful if render logic of the
       *  component needs to operate on these unprocessed values.
       * @param attributeID the id of the desired attribute
       * @return the value of the desired attribute, or null if not found
       */
      getAttribute(attributeID: string): any;
      /**
       * Returns the id of this component.
       *
       * @return the component id
       */
      getID(): string;
      /**
       * Returns the name of this component
       *
       * @return the component name
       */
      getName(): string;
      /**
       * Returns the component region that matches the given id.
       * @param id the id of the desired component region
       * @return the region, or null if not found.
       */
      getRegion(id: string): dw.experience.Region;
      /**
       * Returns the type id of this component.
       *
       * @return the component type id
       */
      getTypeID(): string;
    }

    /**
     * A config that drives how the component is rendered. One can basically decide which kind of tag is used as wrapper
     *  element (e.g. <code>&lt;div&gt;...&lt;/div&gt;</code>) and which attributes are to be placed into this wrapper
     *  element (e.g. <code>class=&quot;foo bar&quot;</code>). In case no attributes are provided then the system default settings will
     *  apply. In case no tag name is provided then the system default one will apply.
     *  <ul>
     *  <li>tag_name : div</li>
     *  <li>attributes : {&quot;class&quot;:&quot;experience-component experience-[COMPONENT_TYPE_ID]&quot;}</li>
     *  </ul>
     *  As the [COMPONENT_TYPE_ID] can contain dots due to its package like naming scheme (e.g. assets.image)
     *  any occurrences of these dots will be replaced by dashes (e.g. assets-image) so that CSS selectors
     *  do not have to be escaped.
     */
    class ComponentRenderSettings {
      /**
       * The configured attributes of the wrapper element as set by setAttributes(Object).
       */
      attributes: any;
      /**
       * The tag name of the component wrapper element. Defaults to 'div'.
       */
      tagName: string;

      /**
       * Creates region render settings which can then be configured further. They are to be used for detailed
       *  configuration of a RegionRenderSettings which is subsequently used for
       *  PageMgr.renderRegion(Region, RegionRenderSettings) calls.
       *
       */
      constructor();

      /**
       * Returns the configured attributes of the wrapper element as set by setAttributes(Object).
       *
       * @return the configured attributes of the wrapper element
       */
      getAttributes(): any;
      /**
       * Returns the tag name of the component wrapper element. Defaults to 'div'.
       *
       * @return the tag name of the component wrapper element
       */
      getTagName(): string;
      /**
       * Sets the to be configured <String,String> attributes of the wrapper element. Set it to null in case
       *  you want to system defaults to be applied.
       * @param attributes the to be configured attributes of the wrapper element
       * @return this
       */
      setAttributes(attributes: any): dw.experience.ComponentRenderSettings;
      /**
       * Sets the tag name of the component wrapper element. Must not be empty.
       * @param tagName the tag name of the component wrapper element
       * @return this
       */
      setTagName(tagName: string): dw.experience.ComponentRenderSettings;
    }

    /**
     * This is the context that is handed over to the <code>render</code> function of the respective component type
     *  script.
     *  <pre>     <code>String : render( <a href="class_dw_experience_ComponentScriptContext.html">ComponentScriptContext</a> context)</code>
     *  </pre>
     */
    class ComponentScriptContext {
      /**
       * The component for which the corresponding component type script is currently executed.
       */
      readonly component: dw.experience.Component;
      /**
       * As components are implicitly rendered as part of their hosting region via
       *  PageMgr.renderRegion(Region, RegionRenderSettings) there is the possibility
       *  to define render settings for the region itself but also for its contained components.
       *  The latter will be provided here so you further set or refine them for your component
       *  as part of the render function, i.e. to drive the shape of the
       *  component wrapper element.
       */
      readonly componentRenderSettings: dw.experience.ComponentRenderSettings;
      /**
       * The content attributes of the component. Currently those are setup by the merchant
       *  using page designer and can be processed in your respective component type render function.
       */
      readonly content: dw.util.Map<string, any>;

      /**
       * Returns the component for which the corresponding component type script is currently executed.
       *
       * @return the currently rendered component
       */
      getComponent(): dw.experience.Component;
      /**
       * As components are implicitly rendered as part of their hosting region via
       *  PageMgr.renderRegion(Region, RegionRenderSettings) there is the possibility
       *  to define render settings for the region itself but also for its contained components.
       *  The latter will be provided here so you further set or refine them for your component
       *  as part of the render function, i.e. to drive the shape of the
       *  component wrapper element.
       *
       * @return the component render settings
       */
      getComponentRenderSettings(): dw.experience.ComponentRenderSettings;
      /**
       * Returns the content attributes of the component. Currently those are setup by the merchant
       *  using page designer and can be processed in your respective component type render function.
       *
       * @return content attributes of the component
       */
      getContent(): dw.util.Map<string, any>;
    }

    /**
     * This class represents a custom editor for component attributes of type <code>custom</code>. It is instantiated
     *  by Page Designer and is subsequently used there for editing of such attributes by the merchant in a visual manner.
     *  It therefore serves the Page Designer with all information required by such UI. What exactly
     *  this information will be is up to the developer of the respective custom editor UI, i.e. depends on the respective
     *  json and js files written for both the attribute definition as well as the custom editor type. Currently a configuration can be
     *  served (basically values passed to Page Designer so that it can bootstrap the custom editor UI on the client side).
     *  Furthermore resources can be served, which are URLs to scripts and styles required by the same UI (you will
     *  likely require your own Javascript and CSS there).
     *  <p>
     *  You can access the aforementioned configuration as provided through the editor definition of the respective attribute
     *  definition, which you can also adjust in the <code>init</code> function (see corresponding js file of your custom editor
     *  type) that is called during initialization of the custom editor, i.e. right before it is passed to the Page Designer UI.
     *  The same applies for the script and style resources which you specified as part of your custom editor type and which you
     *  can refine with the <code>init</code> function as needed.
     *  </p>
     */
    class CustomEditor {
      /**
       * The configuration of the custom editor. This is initialized with the values as provided
       *  through the editor definition of the respective attribute definition of type custom.
       *  Be aware that this configuration will have to be serializable to JSON itself as it will be passed
       *  to Page Designer for processing in the UI. So you must not add any values in this map that are not
       *  properly serializable. Do not use complex DWScript classes that do not support JSON serialization
       *  like for instance Product.
       */
      readonly configuration: dw.util.Map<string, any>;
      /**
       * Returns the dependencies to other custom editors, e.g. used as breakout elements. You can use
       *  this mapping to add more custom editor dependencies as needed. For this purpose you want to create
       *  a CustomEditor instance via PageMgr.getCustomEditor(String, Map)) and then add it
       *  to the dependencies mapping with an ID of your choice. In the client side logic of Page Designer
       *  you will then be able to access these dependencies again by using the corresponding ID.
       *
       *
       *  This is especially helpful if your custom editor for an attribute requires to open a breakout panel,
       *  e.g. for a separate picker required by your custom editor. This picker could be another custom editor,
       *  i.e. the one you declare as dependency here.
       */
      readonly dependencies: dw.util.Map<string, dw.experience.CustomEditor>;
      /**
       * The resources of the custom editor. This is initialized with the values as specified
       *  by the custom editor type json (see the respective styles and scripts section).
       */
      readonly resources: dw.experience.CustomEditorResources;

      /**
       * Returns the configuration of the custom editor. This is initialized with the values as provided
       *  through the editor definition of the respective attribute definition of type custom.
       *  Be aware that this configuration will have to be serializable to JSON itself as it will be passed
       *  to Page Designer for processing in the UI. So you must not add any values in this map that are not
       *  properly serializable. Do not use complex DWScript classes that do not support JSON serialization
       *  like for instance Product.
       *
       * @return the configuration of the custom editor
       */
      getConfiguration(): dw.util.Map<string, any>;
      /**
       * Returns the dependencies to other custom editors, e.g. used as breakout elements. You can use
       *  this mapping to add more custom editor dependencies as needed. For this purpose you want to create
       *  a CustomEditor instance via PageMgr.getCustomEditor(String, Map)) and then add it
       *  to the dependencies mapping with an ID of your choice. In the client side logic of Page Designer
       *  you will then be able to access these dependencies again by using the corresponding ID.
       *
       *
       *  This is especially helpful if your custom editor for an attribute requires to open a breakout panel,
       *  e.g. for a separate picker required by your custom editor. This picker could be another custom editor,
       *  i.e. the one you declare as dependency here.
       *
       * @return an ID to CustomEditor mapping
       */
      getDependencies(): dw.util.Map<string, dw.experience.CustomEditor>;
      /**
       * Returns the resources of the custom editor. This is initialized with the values as specified
       *  by the custom editor type json (see the respective styles and scripts section).
       *
       * @return the custom editor resources, will never be null
       */
      getResources(): dw.experience.CustomEditorResources;
    }

    /**
     * This class represents the resources of a custom editor, i.e. URLs to scripts and styles which are required for
     *  client side functionality in Page Designer in context of the corresponding custom attribute UI. These resources
     *  are initially specified as part of your custom editor type (i.e. the respective json file). If needed you can
     *  revise and refine them as part of the <code>init</code> function that is called during initialization of the
     *  <a href="class_dw_experience_CustomEditor.html">CustomEditor</a>, i.e. is subject to your implementation of the respective custom editor type js file.
     */
    class CustomEditorResources {
      /**
       * The specified script resource URLs. You can further modify this list
       *  at runtime of your init function to add more required scripts.
       *  Absolute URLs will be retained, relative paths will be resolved to absolute
       *  ones based on the cartridge path for static resources (e.g. similar to
       *  what URLUtils.httpStatic(String) or
       *  URLUtils.httpsStatic(String)) does.
       */
      readonly scripts: dw.util.List<string>;
      /**
       * The specified style URLs. You can further modify this list
       *  at runtime of your init function to add more required styles.
       *  Absolute URLs will be retained, relative paths will be resolved to absolute
       *  ones based on the cartridge path for static resources (e.g. similar to
       *  what URLUtils.httpStatic(String) or
       *  URLUtils.httpsStatic(String)) does.
       */
      readonly styles: dw.util.List<string>;

      /**
       * Returns the specified script resource URLs. You can further modify this list
       *  at runtime of your init function to add more required scripts.
       *  Absolute URLs will be retained, relative paths will be resolved to absolute
       *  ones based on the cartridge path for static resources (e.g. similar to
       *  what URLUtils.httpStatic(String) or
       *  URLUtils.httpsStatic(String)) does.
       *
       * @return the script resources, will never be null
       */
      getScripts(): dw.util.List<string>;
      /**
       * Returns the specified style URLs. You can further modify this list
       *  at runtime of your init function to add more required styles.
       *  Absolute URLs will be retained, relative paths will be resolved to absolute
       *  ones based on the cartridge path for static resources (e.g. similar to
       *  what URLUtils.httpStatic(String) or
       *  URLUtils.httpsStatic(String)) does.
       *
       * @return the style resources, will never be null
       */
      getStyles(): dw.util.List<string>;
    }

    /**
     * This class represents a page designer managed page. A page comprises of
     *  multiple regions that hold components, which themselves again can have
     *  regions holding components, i.e. spanning a hierarchical tree of components.
     *  Using the <a href="class_dw_experience_PageMgr.html#dw_experience_PageMgr_renderPage_String_String_DetailAnchor">PageMgr.renderPage(String, String)</a> a page can be rendered. As such page
     *  implements a render function for creating render output the render function of
     *  the page itself will also want to access its various properties like the SEO
     *  title etc.
     */
    class Page {
      /**
       * The description of this page.
       */
      readonly description: string;
      /**
       * The id of this page.
       */
      readonly ID: string;
      /**
       * The name of this page.
       */
      readonly name: string;
      /**
       * The SEO description of this page.
       */
      readonly pageDescription: string;
      /**
       * The SEO keywords of this page.
       */
      readonly pageKeywords: string;
      /**
       * The SEO title of this page.
       */
      readonly pageTitle: string;
      /**
       * The search words of the page used for the search index.
       */
      readonly searchWords: string;
      /**
       * The type id of this page.
       */
      readonly typeID: string;
      /**
       * Returns true if the page is currently visible which is the case if:
       *
       *   page is published
       *   the page is set to visible in the current locale
       *   all visibility rules apply, requiring that
       *
       *     schedule matches
       *     customer group matches
       *
       *
       *
       *  If any of these is not the case then false will be returned.
       *
       *  As visibility is driven by the merchant configured dynamic visibility rules, e.g. scheduling and custom segmentation, this
       *  call should NOT happen in a pagecached context outside of the processing induced by PageMgr.renderPage(String, String).
       *  Use hasVisibilityRules() prior to calling this method in order to check for the existence of visibility rules. If there are
       *  visibility rules then do not apply pagecaching. Otherwise the visibility decision making would end up in the pagecache and any subsequent
       *  call would just return from the pagecache instead of performing the isVisible() check again as desired.
       *     ...
       *    var page = PageMgr.getPage(pageID);
       *    if(page.hasVisibilityRules())
       *    {
       *       // pagecaching is NOT ok here
       *       if(page.isVisible())
       *       {
       *          response.writer.print(PageMgr.renderPage(pageID, {});
       *       }
       *    }
       *    else
       *    {
       *        // pagecaching is ok here, but requires a pagecache refresh if merchants start adding visibility rules to the page
       *    }
       *    ...
       */
      readonly visible: boolean;

      /**
       * Returns the description of this page.
       *
       * @return the page description
       */
      getDescription(): string;
      /**
       * Returns the id of this page.
       *
       * @return the page id
       */
      getID(): string;
      /**
       * Returns the name of this page.
       *
       * @return the page name
       */
      getName(): string;
      /**
       * Returns the SEO description of this page.
       *
       * @return the page SEO description
       */
      getPageDescription(): string;
      /**
       * Returns the SEO keywords of this page.
       *
       * @return the page SEO keywords
       */
      getPageKeywords(): string;
      /**
       * Returns the SEO title of this page.
       *
       * @return the page SEO title
       */
      getPageTitle(): string;
      /**
       * Returns the page region that matches the given id.
       * @param id the id of the desired page region
       * @return the region, or null if not found.
       */
      getRegion(id: string): dw.experience.Region;
      /**
       * Returns the search words of the page used for the search index.
       *
       * @return the page search words
       */
      getSearchWords(): string;
      /**
       * Returns the type id of this page.
       *
       * @return the page type id
       */
      getTypeID(): string;
      /**
       * Returns true if the page has visibility rules (scheduling, customer groups) applied, otherwise false. Use this
       *  method prior to isVisible(), so you do not call the latter in a pagecached context.
       *
       * @return true if the page has visibility rules (scheduling, customer groups) applied, otherwise false.
       */
      hasVisibilityRules(): boolean;
      /**
       * Returns true if the page is currently visible which is the case if:
       *
       *   page is published
       *   the page is set to visible in the current locale
       *   all visibility rules apply, requiring that
       *
       *     schedule matches
       *     customer group matches
       *
       *
       *
       *  If any of these is not the case then false will be returned.
       *
       *  As visibility is driven by the merchant configured dynamic visibility rules, e.g. scheduling and custom segmentation, this
       *  call should NOT happen in a pagecached context outside of the processing induced by PageMgr.renderPage(String, String).
       *  Use hasVisibilityRules() prior to calling this method in order to check for the existence of visibility rules. If there are
       *  visibility rules then do not apply pagecaching. Otherwise the visibility decision making would end up in the pagecache and any subsequent
       *  call would just return from the pagecache instead of performing the isVisible() check again as desired.
       *     ...
       *    var page = PageMgr.getPage(pageID);
       *    if(page.hasVisibilityRules())
       *    {
       *       // pagecaching is NOT ok here
       *       if(page.isVisible())
       *       {
       *          response.writer.print(PageMgr.renderPage(pageID, {});
       *       }
       *    }
       *    else
       *    {
       *        // pagecaching is ok here, but requires a pagecache refresh if merchants start adding visibility rules to the page
       *    }
       *    ...
       *
       * @return true if the page is currently visible (published, visible in the current locale, and visibility rules apply), otherwise false (unpublished and/or visibility rules don't apply)
       */
      isVisible(): boolean;
    }

    /**
     * Provides functionality for getting and rendering page designer managed pages.
     *  <p>
     *  The basic flow is to initiate page rendering by ID via <a href="class_dw_experience_PageMgr.html#dw_experience_PageMgr_renderPage_String_String_DetailAnchor">renderPage(String, String)</a>. This will trigger page
     *  rendering from a top level perspective, i.e. the page serves as entry point and root container of components.
     *  As a related page or component template will likely want to trigger rendering of nested components
     *  within its regions it can do this by first fetching the desired region by ID via
     *  <a href="class_dw_experience_Page.html#dw_experience_Page_getRegion_String_DetailAnchor">Page.getRegion(String)</a> or <a href="class_dw_experience_Component.html#dw_experience_Component_getRegion_String_DetailAnchor">Component.getRegion(String)</a> and then call to <a href="class_dw_experience_PageMgr.html#dw_experience_PageMgr_renderRegion_Region_RegionRenderSettings_DetailAnchor">renderRegion(Region, RegionRenderSettings)</a>
     *  with the recently retrieved region (and optionally provide <a href="class_dw_experience_RegionRenderSettings.html">RegionRenderSettings</a> for customized
     *  rendering of region and component wrapper elements).
     *  </p>
     *
     *  <p>Various attributes required for rendering in the corresponding template can be accessed with the
     *  accordant methods of <a href="class_dw_experience_Page.html">Page</a> and <a href="class_dw_experience_Component.html">Component</a>.</p>
     */
    class PageMgr {
      /**
       * Initialize the custom editor of given type id using the passed configuration. The initialization
       *  will trigger the init function of the respective custom editor type for which the passed
       *  custom editor object is being preinitialized with the given configuration (similar to what would
       *  happen through the editor_definition reference by any component type attribute definition).
       *
       *
       *  This method is useful to obtain any custom editor instance you want to reuse within the init
       *  method of another custom editor, e.g. as dependent breakout element.
       * @param customEditorTypeID the reference to a custom editor type, e.g. 'com.foo.bar'
       * @param configuration the data structure used for preinitialization of the custom editor (also see CustomEditor.getConfiguration()). Be aware that this configuration will have to be serializable to JSON itself as it will be passed to Page Designer for processing in the UI. So you must not add any values in this map that are not properly serializable. Do not use complex DWScript classes that do not support JSON serialization like for instance Product.
       * @return the initialized custom editor instance
       */
      static getCustomEditor(
        customEditorTypeID: string,
        configuration: dw.util.Map<any, any>
      ): dw.experience.CustomEditor;
      /**
       * Returns the page identified by the specified id.
       * @param pageID the id of the page
       * @return the page, or null if not found.
       */
      static getPage(pageID: string): dw.experience.Page;
      /**
       * Render a page. All of this is going to happen in two layers of remote includes, therefore pagecaching of page rendering
       *  is separated from the pagecache lifecycle of the caller. The first one is going to be returned by this method.
       *
       *      layer 1 - determines visibility fingerprint for the page and all its nested components driven by scheduling and customer segmentation. This remote include will not be pagecached. It will then delegate to layer 2.
       *      layer 2 - does the actual rendering of the page by invoking its render function. This remote include will factor the previously determined visibility fingerprint in to the pagecache key, in case you decide to use pagecaching.
       *
       *
       *  The layer 1 remote include is what is returned when calling this method.
       *
       *
       *  The provided parameters argument is passed through till the layer 2 remote include which does the actual rendering so that it will be available
       *  for the render function of the invoked page as part of PageScriptContext.getRenderParameters(). You probably want to
       *  provide caller parameters from the outside in shape of a json String to the inside of the page rendering, e.g. to loop through query parameters.
       *
       *
       *  The layer 2 remote include performs the rendering of the page and all its nested components within one request. Thus data sharing between
       *  the page and its nested components can happen in scope of this request.
       *
       *
       *  The rendering of a page invokes the render function of the respective page type.
       *       String : render( PageScriptContext context)
       *
       *  The return value of the render function finally represents the markup produced by this page type.
       *
       *
       *  Nesting of renderPage(String, String), i.e. rendering a page within a page (or respectively its components), is not a supported use case.
       * @param pageID the ID of the page that will be rendered
       * @param parameters the optional parameters passed to page rendering
       * @return the remote include that will yield the markup as produced by page rendering
       */
      static renderPage(pageID: string, parameters: string): string;
      /**
       * Renders a region by triggering rendering of all visible components within
       *  this region. For each of these components the render function of the respective component
       *  type is invoked.
       *       String : render( ComponentScriptContext context)
       *
       *  The return value of the render function will be wrapped by an HTML element - this
       *  finally represents the markup produced by this component type. The markup of the region
       *  accordingly represents the concatenation of all the components markup within an
       *  own wrapper element.
       *  In order to provide styling for these wrapper
       *  elements of the components and the region some render settings can optionally be provided,
       *  which basically allows to configure which kind of tag is used for the wrapper element and
       *  which attributes the wrapper element contains. A sample output could look like this if
       *  RegionRenderSettings are applied with customized tag names and attributes
       *  for the region and component wrapper elements.
       *
       *  <p class="myRegionCssClass">
       *      <span class="myComponentCssClass myComponentCssClass1" data-foo="bar">
       *          ...
       *      </span>
       *      <span class="myComponentCssClass myComponentCssClass2">
       *          ...
       *      </span>
       *  </p>
       *
       *
       *  In order to go with the default settings for the wrapper elements see
       *  renderRegion(Region).
       *
       *
       *  You must NOT call this method outside of the processing induced by renderPage(String, String).
       * @param region the region that will be rendered
       * @param regionRenderSettings the render settings that drive how the region and its components is rendered
       * @return the markup as produced by region rendering
       */
      static renderRegion(
        region: dw.experience.Region,
        regionRenderSettings: dw.experience.RegionRenderSettings
      ): string;
      /**
       * Renders a region by triggering rendering of all visible components within
       *  this region. For each of these components the render function  of the respective component
       *  type is invoked.
       *       String : render( ComponentScriptContext params)
       *
       *  The return value of the render function will be wrapped by an HTML element - this
       *  finally represents the markup produced by this component type. The markup of the region
       *  accordingly represents the concatenation of all the components markup within an
       *  own wrapper element.
       *  The following sample shows how this would look like for a 'pictures' region
       *  that contains two components of type 'assets.image'.
       *
       *  <div class="experience-region experience-pictures">
       *      <div class="experience-component experience-assets-image">
       *          ...
       *      </div>
       *      <div class="experience-component experience-assets-image">
       *          ..
       *      </div>
       *  </div>
       *
       *
       *  The system default for region render settings are:
       *
       *   tag_name : div
       *   attributes : {"class":"experience-region experience-[REGION_ID]"}
       *
       *
       *
       *  The system default for component render settings are:
       *
       *   tag name : div
       *   attributes : {"class":"experience-component experience-[COMPONENT_TYPE_ID]"}
       *
       *  As the [COMPONENT_TYPE_ID] can contain dots due to its package like naming scheme (e.g. assets.image)
       *  any occurrences of these dots will be replaced by dashes (e.g. assets-image) so that CSS selectors
       *  do not have to be escaped.
       *
       *
       *  In order to provide your own settings for the wrapper elements see
       *  renderRegion(Region, RegionRenderSettings).
       *
       *  You must NOT call this method outside of the processing induced by renderPage(String, String).
       * @param region the region that will be rendered
       * @return the markup as produced by region rendering
       */
      static renderRegion(region: dw.experience.Region): string;
    }

    /**
     * This is the context that is handed over to the <code>render</code> function of the respective page type
     *  script.
     *  <pre>     <code>String : render( <a href="class_dw_experience_PageScriptContext.html">PageScriptContext</a> context)</code>
     *  </pre>
     */
    class PageScriptContext {
      /**
       * The content attributes of the page. Currently those are not merchant manageable but
       *  are solely set in your respective page type render function.
       */
      readonly content: dw.util.Map<string, any>;
      /**
       * The page for which the corresponding page type script is currently executed.
       */
      readonly page: dw.experience.Page;
      /**
       * The parameters argument as passed when kicking off page rendering via PageMgr.renderPage(String, String).
       */
      readonly renderParameters: string;

      /**
       * Returns the content attributes of the page. Currently those are not merchant manageable but
       *  are solely set in your respective page type render function.
       *
       * @return content attributes of the page
       */
      getContent(): dw.util.Map<string, any>;
      /**
       * Returns the page for which the corresponding page type script is currently executed.
       *
       * @return the currently rendered page
       */
      getPage(): dw.experience.Page;
      /**
       * Returns the parameters argument as passed when kicking off page rendering via PageMgr.renderPage(String, String).
       *
       * @return the parameters passed to page rendering
       */
      getRenderParameters(): string;
    }

    /**
     * This class represents a region which serves as container of components.
     *  Using the <a href="class_dw_experience_PageMgr.html#dw_experience_PageMgr_renderRegion_Region_DetailAnchor">PageMgr.renderRegion(Region)</a> or <a href="class_dw_experience_PageMgr.html#dw_experience_PageMgr_renderRegion_Region_RegionRenderSettings_DetailAnchor">PageMgr.renderRegion(Region, RegionRenderSettings)</a>
     *  a region can be rendered.
     */
    class Region {
      /**
       * The id of this region.
       */
      readonly ID: string;
      /**
       * The number of components that would be rendered by this region
       *  when calling PageMgr.renderRegion(Region) or PageMgr.renderRegion(Region, RegionRenderSettings).
       *
       *  Due to its time and customer group depending nature this call should NOT happen in a pagecached context
       *  outside of the processing induced by the above mentioned render methods.
       */
      readonly size: number;
      /**
       * The components that would be rendered by this region
       *  when calling PageMgr.renderRegion(Region) or PageMgr.renderRegion(Region, RegionRenderSettings).
       *
       *  As visibility is driven by the merchant configured dynamic visibility rules, e.g. scheduling and custom segmentation, this
       *  call should NOT happen in a pagecached context outside of the processing induced by the above mentioned render methods.
       */
      readonly visibleComponents: dw.util.Collection<dw.experience.Component>;

      /**
       * Returns the id of this region.
       *
       * @return the region id
       */
      getID(): string;
      /**
       * Returns the number of components that would be rendered by this region
       *  when calling PageMgr.renderRegion(Region) or PageMgr.renderRegion(Region, RegionRenderSettings).
       *
       *  Due to its time and customer group depending nature this call should NOT happen in a pagecached context
       *  outside of the processing induced by the above mentioned render methods.
       *
       * @return the number of visible (i.e. renderable) components in this region
       */
      getSize(): number;
      /**
       * Returns the components that would be rendered by this region
       *  when calling PageMgr.renderRegion(Region) or PageMgr.renderRegion(Region, RegionRenderSettings).
       *
       *  As visibility is driven by the merchant configured dynamic visibility rules, e.g. scheduling and custom segmentation, this
       *  call should NOT happen in a pagecached context outside of the processing induced by the above mentioned render methods.
       *
       * @return the visible (i.e. renderable) components in this region
       */
      getVisibleComponents(): dw.util.Collection<dw.experience.Component>;
    }

    /**
     * A config that drives how the region is rendered. One can basically decide which kind of tag is used as wrapper
     *  element (e.g. <code>&lt;div&gt;...&lt;/div&gt;</code>) and which attributes are to be placed into this wrapper
     *  element (e.g. <code>class=&quot;foo bar&quot;</code>).
     *  <p>
     *  If no attributes are provided for the region render settings then the system default ones will apply. Also if no tag
     *  name is provided then the system default one will apply.
     *  </p><ul>
     *  <li>tag_name : div</li>
     *  <li>attributes : {&quot;class&quot;:&quot;experience-region experience-[REGION_ID]&quot;}</li>
     *  </ul>
     *  Furthermore the render settings for components in this region can be specified - in case nothing is set per component
     *  then the default component render setting will be applied during rendering. If also no default component render
     *  setting is provided then the system default one will apply (see <a href="class_dw_experience_ComponentRenderSettings.html">ComponentRenderSettings</a>).
     *  <p></p>
     */
    class RegionRenderSettings {
      /**
       * The configured attributes of the wrapper element as set by setAttributes(Object).
       */
      attributes: any;
      /**
       * The default component render settings. These will be used during rendering of the components contained in
       *  the region in case no dedicated component render settings were provided per component. If also no default is
       *  supplied then the system default will be used during rendering.
       */
      defaultComponentRenderSettings: dw.experience.ComponentRenderSettings;
      /**
       * The tag name of the region wrapper element. Defaults to 'div'.
       */
      tagName: string;

      /**
       * Creates region render settings which can then be configured further. They are to be used for
       *  PageMgr.renderRegion(Region, RegionRenderSettings) calls.
       *
       */
      constructor();

      /**
       * Returns the configured attributes of the wrapper element as set by setAttributes(Object).
       *
       * @return the configured attributes of the wrapper element
       */
      getAttributes(): any;
      /**
       * Returns the component render settings for the given component. In case no explicitly specified settings are found
       *  for this component then the default one will be provided.
       * @param component the component to retrieve the render settings for
       * @return the component render settings or default component render settings if none were found for the given component
       */
      getComponentRenderSettings(
        component: dw.experience.Component
      ): dw.experience.ComponentRenderSettings;
      /**
       * Returns the default component render settings. These will be used during rendering of the components contained in
       *  the region in case no dedicated component render settings were provided per component. If also no default is
       *  supplied then the system default will be used during rendering.
       *
       * @return the default component render settings
       */
      getDefaultComponentRenderSettings(): dw.experience.ComponentRenderSettings;
      /**
       * Returns the tag name of the region wrapper element. Defaults to 'div'.
       *
       * @return the tag name of the region wrapper element
       */
      getTagName(): string;
      /**
       * Sets the to be configured <String,String> attributes of the wrapper element. Set to null in case you
       *  want to system defaults to be applied.
       * @param attributes the to be configured attributes of the wrapper element
       * @return this
       */
      setAttributes(attributes: any): dw.experience.RegionRenderSettings;
      /**
       * Sets the component render settings for the given component.
       * @param component the component to set the render settings for
       * @param componentRenderSettings the desired render settings
       * @return this
       */
      setComponentRenderSettings(
        component: dw.experience.Component,
        componentRenderSettings: dw.experience.ComponentRenderSettings
      ): dw.experience.RegionRenderSettings;
      /**
       * Sets the default component render settings. These will be used during rendering of the components contained in
       *  the region in case no dedicated component render settings were provided per component.
       * @param defaultComponentRenderSettings the default component render settings
       * @return this
       */
      setDefaultComponentRenderSettings(
        defaultComponentRenderSettings: dw.experience.ComponentRenderSettings
      ): dw.experience.RegionRenderSettings;
      /**
       * Sets the tag name of the region wrapper element. Must not be empty.
       * @param tagName the tag name of the region wrapper element
       * @return this
       */
      setTagName(tagName: string): dw.experience.RegionRenderSettings;
    }

    namespace cms {
      /**
       * This class represents a Salesforce CMS record, exposing its:
       *  <ul>
       *      <li><code>id</code>, see <a href="class_dw_experience_cms_CMSRecord.html#dw_experience_cms_CMSRecord_getID_DetailAnchor">getID()</a></li>
       *      <li><code>type</code>, see <a href="class_dw_experience_cms_CMSRecord.html#dw_experience_cms_CMSRecord_getType_DetailAnchor">getType()</a></li>
       *      <li><code>attributes</code>, see <a href="class_dw_experience_cms_CMSRecord.html#dw_experience_cms_CMSRecord_getAttributes_DetailAnchor">getAttributes()</a></li>
       *  </ul>
       *  The <code>attributes</code> are key value pairs:
       *  <ul>
       *      <li>the key being the attribute id as given in the <code>type.attribute_definitions</code> entries</li>
       *      <li>the value being a DWScript API object resolved from the raw attribute value based on the attribute type as given in the <code>type.attribute_definitions</code> entries
       *          (similar to how <a href="class_dw_experience_ComponentScriptContext.html#dw_experience_ComponentScriptContext_getContent_DetailAnchor">ComponentScriptContext.getContent()</a> exposes the raw attribute value of a <a href="class_dw_experience_Component.html#dw_experience_Component_getAttribute_String_DetailAnchor">Component.getAttribute(String)</a> in shape of a DWScript API object based on the attribute type)</li>
       *  </ul>
       */
      class CMSRecord {
        /**
         * Return the Salesforce CMS record attributes as key value pairs:
         *
         *      the key being the attribute id as given in the getType().attribute_definitions entries
         *      the value being a DWScript API object resolved from the raw attribute value based on the attribute type as given in the getType().attribute_definitions entries
         *          (similar to how ComponentScriptContext.getContent() exposes the raw attribute value of a Component.getAttribute(String) in shape of a DWScript API object based on the attribute type)
         *
         *
         *  The attributes are also conveniently accessible through named property support. That means if myCmsRecord.getAttributes().get('foo') yields value 'bar',
         *  then myCmsRecord.foo will give the same results.
         */
        readonly attributes: dw.util.Map<string, any>;
        /**
         * Return the id of the Salesforce CMS record.
         */
        readonly ID: string;
        /**
         * Return the type of the Salesforce CMS record sufficing the content/schema/cmsrecord.json#/definitions/cms_content_type schema. Properties
         *  can be accessed accordingly:
         *
         *      getType().id : string
         *      getType().name : string
         *      getType().attribute_definitions : Map (see content/schema/attributedefinition.json)
         */
        readonly type: dw.util.Map<string, any>;

        /**
         * Return the Salesforce CMS record attributes as key value pairs:
         *
         *      the key being the attribute id as given in the getType().attribute_definitions entries
         *      the value being a DWScript API object resolved from the raw attribute value based on the attribute type as given in the getType().attribute_definitions entries
         *          (similar to how ComponentScriptContext.getContent() exposes the raw attribute value of a Component.getAttribute(String) in shape of a DWScript API object based on the attribute type)
         *
         *
         *  The attributes are also conveniently accessible through named property support. That means if myCmsRecord.getAttributes().get('foo') yields value 'bar',
         *  then myCmsRecord.foo will give the same results.
         *
         * @return the cms record attributes
         */
        getAttributes(): dw.util.Map<string, any>;
        /**
         * Return the id of the Salesforce CMS record.
         *
         * @return the id of the Salesforce CMS record
         */
        getID(): string;
        /**
         * Return the type of the Salesforce CMS record sufficing the content/schema/cmsrecord.json#/definitions/cms_content_type schema. Properties
         *  can be accessed accordingly:
         *
         *      getType().id : string
         *      getType().name : string
         *      getType().attribute_definitions : Map (see content/schema/attributedefinition.json)
         *
         * @return the type of the cms record
         */
        getType(): dw.util.Map<string, any>;
      }
    }

    namespace image {
      /**
       * This class represents an image focal point.
       */
      class FocalPoint {
        /**
         * The focal point abscissa.
         */
        readonly x: number;
        /**
         * The focal point ordinate.
         */
        readonly y: number;

        /**
         * Returns the focal point abscissa.
         *
         * @return the focal point abscissa
         */
        getX(): number;
        /**
         * Returns the focal point ordinate.
         *
         * @return the focal point ordinate
         */
        getY(): number;
      }

      /**
       * This class represents an image with additional configuration capabilities (e.g. optional focal point).
       *  Furthermore it provides access to meta data of the referenced image file.
       */
      class Image {
        /**
         * The image media file from the current site's library.
         */
        readonly file: dw.content.MediaFile;
        /**
         * The focal point of the image.
         */
        readonly focalPoint: dw.experience.image.FocalPoint;
        /**
         * The meta data of the physical image file. This meta data is obtained when
         *  the respective component attribute was saved from Page Designer, i.e. the underlying
         *  image is not queried for the meta data every time getMetaData() is called
         *  but only on store of the related component attribute.
         */
        readonly metaData: dw.experience.image.ImageMetaData;

        /**
         * Returns the image media file from the current site's library.
         *
         * @return the image media file, or null if not found
         */
        getFile(): dw.content.MediaFile;
        /**
         * Returns the focal point of the image.
         *
         * @return the focal point, or null if not found
         */
        getFocalPoint(): dw.experience.image.FocalPoint;
        /**
         * Returns the meta data of the physical image file. This meta data is obtained when
         *  the respective component attribute was saved from Page Designer, i.e. the underlying
         *  image is not queried for the meta data every time getMetaData() is called
         *  but only on store of the related component attribute.
         *
         * @return the meta data of the image, or null if no meta data was provided with the respective component attribute
         */
        getMetaData(): dw.experience.image.ImageMetaData;
      }

      /**
       * This class represents the image meta data, e.g. width and height.
       */
      class ImageMetaData {
        /**
         * The image height.
         */
        readonly height: number;
        /**
         * The image width.
         */
        readonly width: number;

        /**
         * Returns the image height.
         *
         * @return the image height in pixel
         */
        getHeight(): number;
        /**
         * Returns the image width.
         *
         * @return the image width in pixel
         */
        getWidth(): number;
      }
    }
  }

  namespace extensions {
    namespace applepay {
      /**
       * <p>
       *  Result of a hook handling an Apple Pay request.
       *  </p>
       *
       *  <p>
       *  Use the constants in this type to indicate specific error reasons to be provided
       *  to Apple Pay JS. For example, the following code creates a <a href="class_dw_system_Status.html">Status</a>
       *  that indicates the shipping contact information provided by Apple Pay is invalid:
       *  </p>
       *
       *  <pre> var ApplePayHookResult = require(&apos;dw/extensions/applepay/ApplePayHookResult&apos;);
       *  var Status = require(&apos;dw/system/Status&apos;);
       *
       *  var error = new Status(Status.ERROR);
       *  error.addDetail(ApplePayHookResult.STATUS_REASON_DETAIL_KEY, ApplePayHookResult.REASON_SHIPPING_CONTACT);
       *  </pre>
       *
       *  <p>
       *  If a specific error reason is not provided, the generic Apple Pay <code>STATUS_FAILURE</code>
       *  reason will be used when necessary.
       *  </p>
       */
      class ApplePayHookResult {
        /**
         * Error reason code representing an invalid billing address.
         */
        static readonly REASON_BILLING_ADDRESS = "InvalidBillingPostalAddress";
        /**
         * Error reason code representing an error or failure not otherwise specified.
         */
        static readonly REASON_FAILURE = "Failure";
        /**
         * Error reason code representing the PIN is incorrect.
         */
        static readonly REASON_PIN_INCORRECT = "PINIncorrect";
        /**
         * Error reason code representing a PIN lockout.
         */
        static readonly REASON_PIN_LOCKOUT = "PINLockout";
        /**
         * Error reason code representing a PIN is required.
         */
        static readonly REASON_PIN_REQUIRED = "PINRequired";
        /**
         * Error reason code representing an invalid shipping address.
         */
        static readonly REASON_SHIPPING_ADDRESS =
          "InvalidShippingPostalAddress";
        /**
         * Error reason code representing invalid shipping contact information.
         */
        static readonly REASON_SHIPPING_CONTACT = "InvalidShippingContact";
        /**
         * Key for the detail to be used in Status objects to indicate
         *  the reason to communicate to Apple Pay for errors.
         */
        static readonly STATUS_REASON_DETAIL_KEY = "reason";

        /**
         * Detail to the JS custom event to dispatch in response to this result.
         */
        readonly eventDetail: any;
        /**
         * Name of the JS custom event to dispatch in response to this result.
         */
        readonly eventName: string;
        /**
         * URL to navigate to in response to this result.
         */
        readonly redirect: dw.web.URL;
        /**
         * Status describing the outcome of this result.
         */
        readonly status: dw.system.Status;

        /**
         * Constructs a result with the given outcome information.
         * @param status status of the result
         * @param redirect optional URL to which to navigate to in response to this outcome
         */
        constructor(status: dw.system.Status, redirect: dw.web.URL);

        /**
         * Detail to the JS custom event to dispatch in response to this result.
         *
         * @return event detail
         */
        getEventDetail(): any;
        /**
         * Name of the JS custom event to dispatch in response to this result.
         *
         * @return event name
         */
        getEventName(): string;
        /**
         * URL to navigate to in response to this result.
         *
         * @return redirect URL
         */
        getRedirect(): dw.web.URL;
        /**
         * Status describing the outcome of this result.
         *
         * @return status of this result
         */
        getStatus(): dw.system.Status;
        /**
         * Sets the name of the JS custom event to dispatch in response to this result.
         * @param name JS custom event name
         */
        setEvent(name: string): void;
        /**
         * Sets the name and detail of the JS custom event to dispatch in response to this result.
         * @param name JS custom event name
         * @param detail JS custom event detail
         */
        setEvent(name: string, detail: any): void;
      }

      /**
       * ApplePayHooks interface containing extension points for customizing Apple Pay.
       *  <p>
       *  These hooks are executed in a transaction.
       *  </p><p>
       *  The extension points (hook names), and the functions that are called by each extension point. A function must be
       *  defined inside a JavaScript source and must be exported. The script with the exported hook function must be located
       *  inside a site cartridge. Inside the site cartridge a &apos;package.json&apos; file with a &apos;hooks&apos; entry must exist.
       *  </p><p>
       *
       *  </p><pre> &quot;hooks&quot;: &quot;./hooks.json&quot;
       *  </pre>
       *
       *  The hooks entry links to a json file, relative to the &apos;package.json&apos; file. This file lists all registered hooks
       *  inside the hooks property:
       *  <p>
       *
       *  </p><pre> &quot;hooks&quot;: [
       *       {&quot;name&quot;: &quot;dw.extensions.applepay.getRequest&quot;, &quot;script&quot;: &quot;./applepay.ds&quot;}
       *       {&quot;name&quot;: &quot;dw.extensions.applepay.shippingContactSelected&quot;, &quot;script&quot;: &quot;./applepay.ds&quot;}
       *  ]
       *  </pre>
       *  <p>
       *  A hook entry has a &apos;name&apos; and a &apos;script&apos; property.
       *  </p><ul>
       *  <li>The &apos;name&apos; contains the extension point, the hook name.</li>
       *  <li>The &apos;script&apos; contains the script relative to the hooks file, with the exported hook function.</li>
       *  </ul>
       */
      class ApplePayHooks {
        /**
         * The extension point name dw.extensions.applepay.cancel.
         */
        static readonly extensionPointCancel = "dw.extensions.applepay.cancel";
        /**
         * The extension point name dw.extensions.applepay.getRequest.
         */
        static readonly extensionPointGetRequest =
          "dw.extensions.applepay.getRequest";
        /**
         * The extension point name dw.extensions.applepay.paymentAuthorized.authorizeOrderPayment.
         */
        static readonly extensionPointPaymentAuthorizedAuthorizeOrderPayment =
          "dw.extensions.applepay.paymentAuthorized.authorizeOrderPayment";
        /**
         * The extension point name dw.extensions.applepay.paymentAuthorized.createOrder.
         */
        static readonly extensionPointPaymentAuthorizedCreateOrder =
          "dw.extensions.applepay.paymentAuthorized.createOrder";
        /**
         * The extension point name dw.extensions.applepay.paymentAuthorized.failOrder.
         */
        static readonly extensionPointPaymentAuthorizedFailOrder =
          "dw.extensions.applepay.paymentAuthorized.failOrder";
        /**
         * The extension point name dw.extensions.applepay.paymentAuthorized.placeOrder.
         */
        static readonly extensionPointPaymentAuthorizedPlaceOrder =
          "dw.extensions.applepay.paymentAuthorized.placeOrder";
        /**
         * The extension point name dw.extensions.applepay.paymentMethodSelected.
         */
        static readonly extensionPointPaymentMethodSelected =
          "dw.extensions.applepay.paymentMethodSelected";
        /**
         * The extension point name dw.extensions.applepay.prepareBasket.
         */
        static readonly extensionPointPrepareBasket =
          "dw.extensions.applepay.prepareBasket";
        /**
         * The extension point name dw.extensions.applepay.shippingContactSelected.
         */
        static readonly extensionPointShippingContactSelected =
          "dw.extensions.applepay.shippingContactSelected";
        /**
         * The extension point name dw.extensions.applepay.shippingMethodSelected.
         */
        static readonly extensionPointShippingMethodSelected =
          "dw.extensions.applepay.shippingMethodSelected";

        /**
         * Called to authorize the Apple Pay payment for the order. The given order will have been created by the
         *  extensionPointPaymentAuthorizedCreateOrder hook, after the basket was populated with data from
         *  the ApplePayPaymentAuthorizedEvent.
         *
         *
         *  Return a non-error status if you have successfully authorized the payment with your payment service provider.
         *  Your hook implementation must set the necessary payment status and transaction identifier data on the order as
         *  returned by the provider.
         *
         *
         *  Return an error status to indicate a problem, including unsuccessful authorization. See
         *  ApplePayHookResult for how to indicate error statuses with detail information to
         *  be provided to Apple Pay.
         *
         *
         *  See the Apple Pay JS API Reference for more information.
         * @param order the order paid using Apple Pay
         * @param event ApplePayPaymentAuthorizedEvent object
         * @return a non-null status ends the hook execution
         */
        authorizeOrderPayment(
          order: dw.order.Order,
          event: any
        ): dw.system.Status;
        /**
         * Called after the Apple Pay payment sheet was canceled. There is no Apple Pay JS event object for this case. The
         *  given basket is the one that was passed to other hooks earlier in the Apple Pay checkout process.
         *
         *
         *  It is not guaranteed that this hook will be executed for all Apple Pay payment sheets canceled by shoppers or
         *  otherwise ended without a successful order. Calls to this hook are provided on a best-effort basis.
         *
         *
         *  If the returned result includes a redirect URL, the shopper browser will be navigated to that URL if possible. It
         *  is not guaranteed that the response with the hook result will be handled in the shopper browser in all cases.
         * @param basket the basket that was being checked out using Apple Pay
         * @return a non-null result ends the hook execution
         */
        cancel(
          basket: dw.order.Basket
        ): dw.extensions.applepay.ApplePayHookResult;
        /**
         * Called after handling the given ApplePayPaymentAuthorizedEvent for the given basket. Customer
         *  information, billing address, and/or shipping address for the default shipment will have already been updated to
         *  reflect the available contact information provided by Apple Pay based on the Apple Pay configuration for your
         *  site. Any preexisting payment instruments on the basket will have been removed, and a single
         *  DW_APPLE_PAY payment instrument added for the total amount.
         *
         *
         *  The purpose of this hook is to populate the created order with any necessary information from the basket
         *  or the Apple Pay event. Do not use this hook for address verification, or any other validation. Instead
         *  use the extensionPointPaymentAuthorizedAuthorizeOrderPayment hook which allows you to return
         *  an ApplePayHookResult with error status information.
         *
         *
         *  The default implementation of this hook simply calls OrderMgr.createOrder and returns the created
         *  order.
         *
         *
         *  Throw an error to indicate a problem creating the order.
         * @param basket the basket being checked out using Apple Pay
         * @param event ApplePayPaymentAuthorizedEvent object
         * @return a non-null order ends the hook execution
         */
        createOrder(basket: dw.order.Basket, event: any): dw.order.Order;
        /**
         * Called after payment authorization is unsuccessful and the given Apple Pay order must be failed. The purpose
         *  of this hook is to fail the order, or return a redirect URL that results in the order being failed when the shopper
         *  browser is navigated to it. The given status object is the result of calling the
         *  extensionPointPaymentAuthorizedAuthorizeOrderPayment hook.
         *
         *
         *  The default implementation of this hook simply calls OrderMgr.failOrder, and returns a result
         *  with the given status and no redirect URL.
         *
         *
         *  Return a result with an error status to indicate a problem. See ApplePayHookResult
         *  for how to indicate error statuses with detail information to be provided to Apple Pay. If the returned result includes
         *  a redirect URL, the shopper browser will be navigated to that URL if the Apple Pay payment sheet is canceled.
         * @param order the order created for a failed Apple Pay checkout
         * @param status status code returned by the {@value #extensionPointPaymentAuthorizedAuthorizeOrderPayment} hook
         * @return ApplePayHookResult containing a status code to be provided to Apple Pay. A non-null result ends the hook execution
         */
        failOrder(
          order: dw.order.Order,
          status: dw.system.Status
        ): dw.extensions.applepay.ApplePayHookResult;
        /**
         * Called to get the Apple Pay JS PaymentRequest for the given basket. You can set properties in the
         *  given request object to extend or override default properties set automatically based on the Apple Pay
         *  configuration for your site.
         *
         *
         *  Return a result with an error status to indicate a problem. See ApplePayHookResult
         *  for how to indicate error statuses with detail information to be provided to Apple Pay.
         *
         *
         *  If the returned result includes a redirect URL, the shopper browser will be navigated to that URL if the Apple
         *  Pay payment sheet is canceled.
         *
         *
         *  See the Apple Pay JS API Reference for more information.
         * @param basket the basket for the Apple Pay request
         * @param request the Apple Pay payment request object
         * @return a non-null result ends the hook execution
         */
        getRequest(
          basket: dw.order.Basket,
          request: any
        ): dw.extensions.applepay.ApplePayHookResult;
        /**
         * Called after handling the given ApplePayPaymentMethodSelectedEvent for the given basket. This Apple
         *  Pay event does not contain payment card or device information.
         *
         *
         *  The given response object will contain properties whose values are to be passed as parameters to the
         *  ApplePaySession.completePaymentMethodSelection event callback:
         *
         *
         *  total - Updated total line item object
         *  lineItems - Array of updated line item objects
         *
         *
         *  Return a result with an error status to indicate a problem. See ApplePayHookResult
         *  for how to indicate error statuses with detail information to be provided to Apple Pay.
         *
         *
         *  If the returned result includes a redirect URL, the shopper browser will be navigated to that URL if the Apple
         *  Pay payment sheet is canceled.
         *
         *
         *  See the Apple Pay JS API Reference for more information.
         * @param basket the basket being checked out using Apple Pay
         * @param event ApplePayPaymentMethodSelectedEvent object
         * @param response JS object containing Apple Pay event callback parameters
         * @return a non-null result ends the hook execution
         */
        paymentMethodSelected(
          basket: dw.order.Basket,
          event: any,
          response: any
        ): dw.extensions.applepay.ApplePayHookResult;
        /**
         * Called after payment has been authorized and the given Apple Pay order is ready to be placed. The purpose of this
         *  hook is to place the order, or return a redirect URL that results in the order being placed when the shopper
         *  browser is navigated to it.
         *
         *
         *  The default implementation of this hook returns a redirect to COPlaceOrder-Submit with URL
         *  parameters order_id set to Order.getOrderNo() and order_token set to
         *  Order.getOrderToken() which corresponds to SiteGenesis-based implementations. Your hook
         *  implementation should return a result with a different redirect URL as necessary to place the order and show an
         *  order confirmation.
         *
         *
         *  Alternatively, your hook implementation itself can place the order and return a result with a redirect URL to an
         *  order confirmation page that does not place the order. This is inconsistent with SiteGenesis-based
         *  implementations so is not the default.
         *
         *
         *  Return an error status to indicate a problem. See ApplePayHookResult for how to
         *  indicate error statuses with detail information to be provided to Apple Pay. If the returned result includes a
         *  redirect URL, the shopper browser will be navigated to that URL if the Apple Pay payment sheet is canceled.
         * @param order the order paid using Apple Pay
         * @return a non-null result ends the hook execution
         */
        placeOrder(
          order: dw.order.Order
        ): dw.extensions.applepay.ApplePayHookResult;
        /**
         * Called to prepare the given basket for an Apple Pay checkout. This hook will be executed after the user
         *  clicks the Apple Pay button.
         *
         *
         *  The default implementation of this hook calculates the basket. A custom hook implementation that returns a
         *  non-null result must calculate the basket.
         *
         *
         *  The given parameters object will contain properties whose values are passed from the
         *  <isapplepay></isapplepay> tag:
         *
         *
         *  sku - SKU of product to checkout exclusively
         *
         *
         *  Return a result with an error status to indicate a problem. For this hook there is no opportunity to provide user
         *  feedback, so if any error status is returned, the Apple Pay payment sheet will be aborted.
         *
         *
         *  If the returned result includes a redirect URL, the shopper browser will be navigated to that URL after the Apple
         *  Pay payment sheet is aborted.
         * @param basket the basket for the Apple Pay request
         * @param parameters parameters from the <isapplepay></isapplepay> tag
         * @return a non-null result ends the hook execution
         */
        prepareBasket(
          basket: dw.order.Basket,
          parameters: any
        ): dw.extensions.applepay.ApplePayHookResult;
        /**
         * Called after handling the given ApplePayShippingContactSelectedEvent for the given basket. Basket
         *  customer information and/or shipping address for the default shipment will have already been updated to reflect
         *  the available shipping contact information provided by Apple Pay based on the Apple Pay configuration for your
         *  site. The basket will have already been calculated before this hook is called.
         *
         *
         *  The given response object will contain properties whose values are to be passed as parameters to the
         *  ApplePaySession.completeShippingContactSelection event callback:
         *
         *
         *  shippingMethods - Array of applicable shipping method JS objects
         *  total - Updated total line item object
         *  lineItems - Array of updated line item objects
         *
         *
         *  Return a result with an error status to indicate a problem. See ApplePayHookResult
         *  for how to indicate error statuses with detail information to be provided to Apple Pay.
         *
         *
         *  If the returned result includes a redirect URL, the shopper browser will be navigated to that URL if the Apple
         *  Pay payment sheet is canceled.
         *
         *
         *  See the Apple Pay JS API Reference for more information.
         * @param basket the basket being checked out using Apple Pay
         * @param event ApplePayShippingContactSelectedEvent object
         * @param response JS object containing Apple Pay event callback parameters
         * @return a non-null result ends the hook execution
         */
        shippingContactSelected(
          basket: dw.order.Basket,
          event: any,
          response: any
        ): dw.extensions.applepay.ApplePayHookResult;
        /**
         * Called after handling the given ApplePayShippingMethodSelectedEvent for the given basket. The given
         *  shipping method will have already been set on the basket.  The basket will have already been calculated before
         *  this hook is called.
         *
         *
         *  The given response object will contain properties whose values are to be passed as parameters to the
         *  ApplePaySession.completeShippingMethodSelection event callback:
         *
         *
         *  total - Updated total line item object
         *  lineItems - Array of updated line item objects
         *
         *
         *  Return a result with an error status to indicate a problem. See ApplePayHookResult
         *  for how to indicate error statuses with detail information to be provided to Apple Pay.
         *
         *
         *  If the returned result includes a redirect URL, the shopper browser will be navigated to that URL if the Apple
         *  Pay payment sheet is canceled.
         *
         *
         *  See the Apple Pay JS API Reference for more information.
         * @param basket the basket being checked out using Apple Pay
         * @param shippingMethod the shipping method that was selected
         * @param event ApplePayShippingMethodSelectedEvent object
         * @param response JS object containing Apple Pay event callback parameters
         * @return a non-null result ends the hook execution
         */
        shippingMethodSelected(
          basket: dw.order.Basket,
          shippingMethod: dw.order.ShippingMethod,
          event: any,
          response: any
        ): dw.extensions.applepay.ApplePayHookResult;
      }
    }

    namespace facebook {
      /**
       * FacebookFeedHooks interface containing extension points for customizing Facebook export feeds.
       *  <p>
       *  These hooks are not executed in a transaction.
       *  </p><p>
       *  The extension points (hook names), and the functions that are called by each extension point. A function must be
       *  defined inside a JavaScript source and must be exported. The script with the exported hook function must be located
       *  inside a site cartridge. Inside the site cartridge a &apos;package.json&apos; file with a &apos;hooks&apos; entry must exist.
       *  </p><p>
       *
       *  </p><pre> &quot;hooks&quot;: &quot;./hooks.json&quot;
       *  </pre>
       *
       *  The hooks entry links to a json file, relative to the &apos;package.json&apos; file. This file lists all registered hooks
       *  inside the hooks property:
       *  <p>
       *
       *  </p><pre> &quot;hooks&quot;: [
       *       {&quot;name&quot;: &quot;dw.extensions.facebook.feed.transformProduct&quot;, &quot;script&quot;: &quot;./hooks.ds&quot;}
       *  ]
       *  </pre>
       *  <p>
       *  A hook entry has a &apos;name&apos; and a &apos;script&apos; property.
       *  </p><ul>
       *  <li>The &apos;name&apos; contains the extension point, the hook name.</li>
       *  <li>The &apos;script&apos; contains the script relative to the hooks file, with the exported hook function.</li>
       *  </ul>
       */
      class FacebookFeedHooks {
        /**
         * The extension point name dw.extensions.facebook.feed.transformProduct.
         */
        static readonly extensionPointTransformProduct =
          "dw.extensions.facebook.feed.transformProduct";

        /**
         * Called after default transformation of given Demandware product to Facebook product as part of the catalog feed
         *  export.
         *
         *
         *  To customize multiple feeds differently, for example if one is for Facebook Dynamic Ads and the other is for
         *  Instagram Commerce, use the feedId parameter to determine which feed is being exported. If the same
         *  customization should apply to all feeds, ignore the parameter.
         * @param product the Demandware product
         * @param facebookProduct the Facebook representation of the product
         * @param feedId the merchant-selected ID for the feed being exported
         * @return a non-null Status ends the hook execution
         */
        transformProduct(
          product: dw.catalog.Product,
          facebookProduct: dw.extensions.facebook.FacebookProduct,
          feedId: string
        ): dw.system.Status;
      }

      /**
       * Represents a row in the Facebook catalog feed export.
       */
      class FacebookProduct {
        /**
         * Indicates that the product is for adults.
         */
        static readonly AGE_GROUP_ADULT = "adult";
        /**
         * Indicates that the product is for infant children.
         */
        static readonly AGE_GROUP_INFANT = "infant";
        /**
         * Indicates that the product is for children.
         */
        static readonly AGE_GROUP_KIDS = "kids";
        /**
         * Indicates that the product is for newborn children.
         */
        static readonly AGE_GROUP_NEWBORN = "newborn";
        /**
         * Indicates that the product is for toddler children.
         */
        static readonly AGE_GROUP_TODDLER = "toddler";
        /**
         * Indicates that the product can be ordered for later shipment.
         */
        static readonly AVAILABILITY_AVAILABLE_FOR_ORDER =
          "available for order";
        /**
         * Indicates that the product is available to ship immediately.
         */
        static readonly AVAILABILITY_IN_STOCK = "in stock";
        /**
         * Indicates that the product is out of stock.
         */
        static readonly AVAILABILITY_OUT_OF_STOCK = "out of stock";
        /**
         * Indicates that the product will be available in the future.
         */
        static readonly AVAILABILITY_PREORDER = "preorder";
        /**
         * Indicates that the product is new.
         */
        static readonly CONDITION_NEW = "new";
        /**
         * Indicates that the product is used but has been refurbished.
         */
        static readonly CONDITION_REFURBISHED = "refurbished";
        /**
         * Indicates that the product has been used.
         */
        static readonly CONDITION_USED = "used";
        /**
         * Indicates that the product is for females.
         */
        static readonly GENDER_FEMALE = "female";
        /**
         * Indicates that the product is for males.
         */
        static readonly GENDER_MALE = "male";
        /**
         * Indicates that the product is for both males and females.
         */
        static readonly GENDER_UNISEX = "unisex";
        /**
         * Indicates that the product is measured in centimeters.
         */
        static readonly SHIPPING_SIZE_UNIT_CM = "cm";
        /**
         * Indicates that the product is measured in feet.
         */
        static readonly SHIPPING_SIZE_UNIT_FT = "ft";
        /**
         * Indicates that the product is measured in inches.
         */
        static readonly SHIPPING_SIZE_UNIT_IN = "in";
        /**
         * Indicates that the product is measured in meters.
         */
        static readonly SHIPPING_SIZE_UNIT_M = "m";
        /**
         * Indicates that the product is weighed in grams.
         */
        static readonly SHIPPING_WEIGHT_UNIT_G = "g";
        /**
         * Indicates that the product is weighed in kilograms.
         */
        static readonly SHIPPING_WEIGHT_UNIT_KG = "kg";
        /**
         * Indicates that the product is weighed in pounds.
         */
        static readonly SHIPPING_WEIGHT_UNIT_LB = "lb";
        /**
         * Indicates that the product is weighed in ounces.
         */
        static readonly SHIPPING_WEIGHT_UNIT_OZ = "oz";

        /**
         * The age group for the Facebook product.
         */
        ageGroup: string;
        /**
         * The availability of the Facebook product.
         */
        availability: string;
        /**
         * The Facebook brand of the product.
         */
        brand: string;
        /**
         * The Facebook color value label of the product.
         */
        color: string;
        /**
         * The condition of the Facebook product.
         */
        condition: string;
        /**
         * The Facebook custom label 0 value of the product.
         */
        customLabel0: string;
        /**
         * The Facebook custom label 1 value of the product.
         */
        customLabel1: string;
        /**
         * The Facebook custom label 2 value of the product.
         */
        customLabel2: string;
        /**
         * The Facebook custom label 3 value of the product.
         */
        customLabel3: string;
        /**
         * The Facebook custom label 4 value of the product.
         */
        customLabel4: string;
        /**
         * The description of the Facebook product.
         */
        description: string;
        /**
         * The Facebook expiration date of the product. If the product is expired it will not be shown.
         */
        expirationDate: Date;
        /**
         * The gender for the Facebook product.
         */
        gender: string;
        /**
         * The category of this product in the Google category taxonomy. If the value is longer than 250 characters
         *  it is truncated.
         */
        googleProductCategory: string;
        /**
         * The Facebook GTIN of the product.
         */
        gtin: string;
        /**
         * The ID of the Facebook product. This is the same as the ID of the Demandware product.
         */
        readonly ID: string;
        /**
         * A list containing the URLs of the images to show in Facebook for the product.
         */
        imageLinks: dw.util.List<string>;
        /**
         * The ID of the Facebook item group for the product, that is, its master product.
         */
        itemGroupID: string;
        /**
         * The URL of the Demandware storefront link to the product.
         */
        link: dw.web.URL;
        /**
         * The Facebook material value label of the product.
         */
        material: string;
        /**
         * The Facebook MPN of the product.
         */
        mpn: string;
        /**
         * The Facebook pattern value label of the product.
         */
        pattern: string;
        /**
         * The price to show in Facebook for the product.
         */
        price: dw.value.Money;
        /**
         * The Facebook product type. This is the retailer-defined category of the item.
         */
        productType: string;
        /**
         * The sale price to show in Facebook for the product.
         */
        salePrice: dw.value.Money;
        /**
         * The end date of the Facebook sale price of the product.
         */
        salePriceEffectiveDateEnd: Date;
        /**
         * The start date of the Facebook sale price of the product.
         */
        salePriceEffectiveDateStart: Date;
        /**
         * The shipping height of the product.
         */
        shippingHeight: number;
        /**
         * The shipping length of the product.
         */
        shippingLength: number;
        /**
         * The shipping size unit of the product.
         */
        shippingSizeUnit: string;
        /**
         * The shipping weight for the product.
         */
        shippingWeight: dw.value.Quantity;
        /**
         * The shipping width of the product.
         */
        shippingWidth: number;
        /**
         * The Facebook size value label of the product.
         */
        size: string;
        /**
         * The title of the Facebook product.
         */
        title: string;

        /**
         * Returns the age group for the Facebook product.
         *
         * @return product age group
         */
        getAgeGroup(): string;
        /**
         * Returns the availability of the Facebook product.
         *
         * @return product availability
         */
        getAvailability(): string;
        /**
         * Returns the Facebook brand of the product.
         *
         * @return the brand
         */
        getBrand(): string;
        /**
         * Returns the Facebook color value label of the product.
         *
         * @return the color value label
         */
        getColor(): string;
        /**
         * Returns the condition of the Facebook product.
         *
         * @return product condition
         */
        getCondition(): string;
        /**
         * Returns the Facebook custom label 0 value of the product.
         *
         * @return the custom label 0 value
         */
        getCustomLabel0(): string;
        /**
         * Returns the Facebook custom label 1 value of the product.
         *
         * @return the custom label 1 value
         */
        getCustomLabel1(): string;
        /**
         * Returns the Facebook custom label 2 value of the product.
         *
         * @return the custom label 2 value
         */
        getCustomLabel2(): string;
        /**
         * Returns the Facebook custom label 3 value of the product.
         *
         * @return the custom label 3 value
         */
        getCustomLabel3(): string;
        /**
         * Returns the Facebook custom label 4 value of the product.
         *
         * @return the custom label 4 value
         */
        getCustomLabel4(): string;
        /**
         * Returns the description of the Facebook product.
         *
         * @return product description
         */
        getDescription(): string;
        /**
         * Returns the Facebook expiration date of the product. If the product is expired it will not be shown.
         *
         * @return the expiration date
         */
        getExpirationDate(): Date;
        /**
         * Returns the gender for the Facebook product.
         *
         * @return product gender
         */
        getGender(): string;
        /**
         * Returns the category of this product in the Google category taxonomy. If the value is longer than 250 characters
         *  it is truncated.
         *
         * @return the category of this product in the Google category taxonomy
         */
        getGoogleProductCategory(): string;
        /**
         * Returns the Facebook GTIN of the product.
         *
         * @return the GTIN
         */
        getGtin(): string;
        /**
         * Returns the ID of the Facebook product. This is the same as the ID of the Demandware product.
         *
         * @return product ID
         */
        getID(): string;
        /**
         * Returns a list containing the URLs of the images to show in Facebook for the product.
         *
         * @return the URLs of the images
         */
        getImageLinks(): dw.util.List<string>;
        /**
         * Returns the ID of the Facebook item group for the product, that is, its master product.
         *
         * @return the ID of the Facebook item group
         */
        getItemGroupID(): string;
        /**
         * Returns the URL of the Demandware storefront link to the product.
         *
         * @return the URL of the storefront link
         */
        getLink(): dw.web.URL;
        /**
         * Returns the Facebook material value label of the product.
         *
         * @return the material value label
         */
        getMaterial(): string;
        /**
         * Returns the Facebook MPN of the product.
         *
         * @return the MPN
         */
        getMpn(): string;
        /**
         * Returns the Facebook pattern value label of the product.
         *
         * @return the pattern value label
         */
        getPattern(): string;
        /**
         * Returns the price to show in Facebook for the product.
         *
         * @return the price to show in Facebook
         */
        getPrice(): dw.value.Money;
        /**
         * Returns the Facebook product type. This is the retailer-defined category of the item.
         *
         * @return the Facebook product type
         */
        getProductType(): string;
        /**
         * Returns the sale price to show in Facebook for the product.
         *
         * @return the sale price to show in Facebook
         */
        getSalePrice(): dw.value.Money;
        /**
         * Returns the end date of the Facebook sale price of the product.
         *
         * @return the end date of the Facebook sale price
         */
        getSalePriceEffectiveDateEnd(): Date;
        /**
         * Returns the start date of the Facebook sale price of the product.
         *
         * @return the start date of the Facebook sale price
         */
        getSalePriceEffectiveDateStart(): Date;
        /**
         * Returns the shipping height of the product.
         *
         * @return the shipping height
         */
        getShippingHeight(): number;
        /**
         * Returns the shipping length of the product.
         *
         * @return the shipping length
         */
        getShippingLength(): number;
        /**
         * Returns the shipping size unit of the product.
         *
         * @return the shipping size unit
         */
        getShippingSizeUnit(): string;
        /**
         * Returns the shipping weight for the product.
         *
         * @return the shipping weight
         */
        getShippingWeight(): dw.value.Quantity;
        /**
         * Returns the shipping width of the product.
         *
         * @return the shipping width
         */
        getShippingWidth(): number;
        /**
         * Returns the Facebook size value label of the product.
         *
         * @return the size value label
         */
        getSize(): string;
        /**
         * Returns the title of the Facebook product.
         *
         * @return product title
         */
        getTitle(): string;
        /**
         * Sets the age group for the Facebook product. Possible values are
         *  AGE_GROUP_ADULT,
         *  AGE_GROUP_INFANT,
         *  AGE_GROUP_KIDS,
         *  AGE_GROUP_NEWBORN,
         *  AGE_GROUP_TODDLER, or null.
         * @param ageGroup the ageGroup to set for this product
         */
        setAgeGroup(ageGroup: string): void;
        /**
         * Sets the availability of the Facebook product. Possible values are
         *  AVAILABILITY_AVAILABLE_FOR_ORDER,
         *  AVAILABILITY_IN_STOCK,
         *  AVAILABILITY_OUT_OF_STOCK, or
         *  AVAILABILITY_PREORDER
         * @param availability the availability status to set for this product
         */
        setAvailability(availability: string): void;
        /**
         * Sets the Facebook brand of the product. If the value is longer than 70 characters it is truncated.
         * @param brand Facebook brand, up to 70 characters
         */
        setBrand(brand: string): void;
        /**
         * Sets the Facebook color value label of the product. If the value is longer than 100 characters it is truncated.
         * @param color Facebook color value label, up to 100 characters
         */
        setColor(color: string): void;
        /**
         * Sets the condition of the Facebook product. Possible values are
         *  CONDITION_NEW,
         *  CONDITION_REFURBISHED, or
         *  CONDITION_USED.
         * @param condition the condition status to set for this product
         */
        setCondition(condition: string): void;
        /**
         * Sets the Facebook custom label 0 value of the product.
         * @param customLabel0 custom label 0 value
         */
        setCustomLabel0(customLabel0: string): void;
        /**
         * Sets the Facebook custom label 1 value of the product.
         * @param customLabel1 custom label 1 value
         */
        setCustomLabel1(customLabel1: string): void;
        /**
         * Sets the Facebook custom label 2 value of the product.
         * @param customLabel2 custom label 2 value
         */
        setCustomLabel2(customLabel2: string): void;
        /**
         * Sets the Facebook custom label 3 value of the product.
         * @param customLabel3 custom label 3 value
         */
        setCustomLabel3(customLabel3: string): void;
        /**
         * Sets the Facebook custom label 4 value of the product.
         * @param customLabel4 custom label 4 value
         */
        setCustomLabel4(customLabel4: string): void;
        /**
         * Sets the description of the Facebook product. If the value is longer than 5000 characters it is truncated.
         * @param description product description, up to 5000 characters
         */
        setDescription(description: string): void;
        /**
         * Sets the Facebook expiration date of the product.
         * @param expirationDate Facebook expiration date
         */
        setExpirationDate(expirationDate: Date): void;
        /**
         * Sets the gender for the Facebook product. Possible values are
         *  GENDER_MALE,
         *  GENDER_FEMALE,
         *  GENDER_UNISEX, or null.
         * @param gender the gender to set for this product
         */
        setGender(gender: string): void;
        /**
         * Sets the category of this product in the Google category taxonomy.
         * @param googleProductCategory Google product category
         */
        setGoogleProductCategory(googleProductCategory: string): void;
        /**
         * Sets the Facebook GTIN of the product. If the value is longer than 70 characters it is truncated.
         * @param gtin Facebook GTIN, up to 70 characters
         */
        setGtin(gtin: string): void;
        /**
         * Sets the list of URLs of images to show in Facebook for the product.
         * @param imageLinks links to the product images
         */
        setImageLinks(imageLinks: dw.util.List<any>): void;
        /**
         * Sets the ID of the Facebook item group for the product, that is, its master product.
         * @param itemGroupID ID of Facebook item group
         */
        setItemGroupID(itemGroupID: string): void;
        /**
         * Sets the URL of the Demandware storefront link to the product.
         * @param link Demandware storefront link to the product
         */
        setLink(link: dw.web.URL): void;
        /**
         * Sets the Facebook material value label of the product. If the value is longer than 200 characters it is
         *  truncated.
         * @param material Facebook material value label, up to 200 characters
         */
        setMaterial(material: string): void;
        /**
         * Sets the Facebook MPN of the product. If the value is longer than 70 characters it is truncated.
         * @param mpn Facebook MPN, up to 70 characters
         */
        setMpn(mpn: string): void;
        /**
         * Sets the Facebook pattern value label of the product. If the value is longer than 100 characters it is truncated.
         * @param pattern Facebook pattern value label, up to 100 characters
         */
        setPattern(pattern: string): void;
        /**
         * Sets the price to show in Facebook for the product.
         * @param price Facebook price
         */
        setPrice(price: dw.value.Money): void;
        /**
         * Sets the Facebook product type. If the value is longer than 750 characters it is truncated.
         * @param productType Facebook product type, up to 750 characters
         */
        setProductType(productType: string): void;
        /**
         * Sets the sale price to show in Facebook for the product.
         * @param salePrice Facebook sale price
         */
        setSalePrice(salePrice: dw.value.Money): void;
        /**
         * Sets the end date of the Facebook sale price of the product.
         * @param salePriceEffectiveDateEnd end date of Facebook sale price
         */
        setSalePriceEffectiveDateEnd(salePriceEffectiveDateEnd: Date): void;
        /**
         * Sets the start date of the Facebook sale price of the product.
         * @param salePriceEffectiveDateStart start date of Facebook sale price
         */
        setSalePriceEffectiveDateStart(salePriceEffectiveDateStart: Date): void;
        /**
         * Sets the shipping height of the product. If the value is negative it is truncated to 0.
         * @param shippingHeight shipping height, may not be negative
         */
        setShippingHeight(shippingHeight: number): void;
        /**
         * Sets the shipping length of the product. If the value is negative it is truncated to 0.
         * @param shippingLength shipping length, may not be negative
         */
        setShippingLength(shippingLength: number): void;
        /**
         * Sets the shipping size unit of the product.
         * @param shippingSizeUnit shipping size unit
         */
        setShippingSizeUnit(shippingSizeUnit: string): void;
        /**
         * Sets the shipping weight for the product. Possible unit values are
         *  SHIPPING_WEIGHT_UNIT_LB,
         *  SHIPPING_WEIGHT_UNIT_OZ,
         *  SHIPPING_WEIGHT_UNIT_G, or
         *  SHIPPING_WEIGHT_UNIT_KG.
         * @param shippingWeight product shipping weight
         */
        setShippingWeight(shippingWeight: dw.value.Quantity): void;
        /**
         * Sets the shipping width of the product. If the value is negative it is truncated to 0.
         * @param shippingWidth shipping width, may not be negative
         */
        setShippingWidth(shippingWidth: number): void;
        /**
         * Sets the Facebook size value label of the product. If the value is longer than 100 characters it is truncated.
         * @param size Facebook size value label, up to 100 characters
         */
        setSize(size: string): void;
        /**
         * Sets the title of the Facebook product. If the value is longer than 100 characters it is truncated.
         * @param title product title, up to 100 characters
         */
        setTitle(title: string): void;
      }
    }

    namespace paymentapi {
      /**
       * PaymentApiHooks interface containing extension points for customizing Payment API requests for authorization,
       *  and their responses.
       *  <p>
       *  These hooks are executed in a transaction.
       *  </p><p>
       *  The extension points (hook names), and the functions that are called by each extension point. A function must be
       *  defined inside a JavaScript source and must be exported. The script with the exported hook function must be located
       *  inside a site cartridge. Inside the site cartridge a &apos;package.json&apos; file with a &apos;hooks&apos; entry must exist.
       *  </p><p>
       *
       *  </p><pre> &quot;hooks&quot;: &quot;./hooks.json&quot;
       *  </pre>
       *
       *  The hooks entry links to a json file, relative to the &apos;package.json&apos; file. This file lists all registered hooks
       *  inside the hooks property:
       *  <p>
       *
       *  </p><pre> &quot;hooks&quot;: [
       *       {&quot;name&quot;: &quot;dw.extensions.paymentapi.beforeAuthorization&quot;, &quot;script&quot;: &quot;./payment.ds&quot;}
       *       {&quot;name&quot;: &quot;dw.extensions.paymentapi.afterAuthorization&quot;, &quot;script&quot;: &quot;./payment.ds&quot;}
       *  ]
       *  </pre>
       *  <p>
       *  A hook entry has a &apos;name&apos; and a &apos;script&apos; property.
       *  </p><ul>
       *  <li>The &apos;name&apos; contains the extension point, the hook name.</li>
       *  <li>The &apos;script&apos; contains the script relative to the hooks file, with the exported hook function.</li>
       *  </ul>
       */
      class PaymentApiHooks {
        /**
         * The extension point name dw.extensions.paymentapi.afterAuthorization.
         */
        static readonly extensionPointAfterAuthorization =
          "dw.extensions.paymentapi.afterAuthorization";
        /**
         * The extension point name .
         */
        static readonly extensionPointBeforeAuthorization =
          "dw.extensions.paymentapi.beforeAuthorization";

        /**
         * Called after the response has been handled for a request to authorize payment for the given order.
         *
         *
         *  The given status is the result of handling the response without customization. That status will be
         *  used unless an implementation of this hook returns an alternative status.
         * @param order the order whose payment to authorize
         * @param payment the payment instrument to authorize
         * @param custom container of custom properties included in the PSP response
         * @param status the result of handling the response without customization
         * @return a non-null result ends the hook execution
         */
        afterAuthorization(
          order: dw.order.Order,
          payment: dw.order.OrderPaymentInstrument,
          custom: any,
          status: dw.system.Status
        ): dw.system.Status;
        /**
         * Called when a request is to be made to authorize payment for the given order.
         *
         *
         *  Return an error status to indicate a problem. The request will not be made to the payment provider.
         * @param order the order whose payment to authorize
         * @param payment the payment instrument to authorize
         * @param custom container for custom properties to include in request
         * @return a non-null result ends the hook execution
         */
        beforeAuthorization(
          order: dw.order.Order,
          payment: dw.order.OrderPaymentInstrument,
          custom: any
        ): dw.system.Status;
      }
    }

    namespace paymentrequest {
      /**
       * Result of a hook handling a Payment Request request
       */
      class PaymentRequestHookResult {
        /**
         * Detail to the JS custom event to dispatch in response to this result.
         */
        readonly eventDetail: any;
        /**
         * Name of the JS custom event to dispatch in response to this result.
         */
        readonly eventName: string;
        /**
         * URL to navigate to in response to this result.
         */
        readonly redirect: dw.web.URL;
        /**
         * Status describing the outcome of this result.
         */
        readonly status: dw.system.Status;

        /**
         * Constructs a result with the given outcome information.
         * @param status status of the result
         * @param redirect optional URL to which to navigate to in response to this outcome
         */
        constructor(status: dw.system.Status, redirect: dw.web.URL);

        /**
         * Detail to the JS custom event to dispatch in response to this result.
         *
         * @return event detail
         */
        getEventDetail(): any;
        /**
         * Name of the JS custom event to dispatch in response to this result.
         *
         * @return event name
         */
        getEventName(): string;
        /**
         * URL to navigate to in response to this result.
         *
         * @return redirect URL
         */
        getRedirect(): dw.web.URL;
        /**
         * Status describing the outcome of this result.
         *
         * @return status of this result
         */
        getStatus(): dw.system.Status;
        /**
         * Sets the name of the JS custom event to dispatch in response to this result.
         * @param name JS custom event name
         */
        setEvent(name: string): void;
        /**
         * Sets the name and detail of the JS custom event to dispatch in response to this result.
         * @param name JS custom event name
         * @param detail JS custom event detail
         */
        setEvent(name: string, detail: any): void;
      }

      /**
       * PaymentRequestHooks interface containing extension points for customizing Payment Requests.
       *  <p>
       *  These hooks are executed in a transaction.
       *  </p><p>
       *  The extension points (hook names), and the functions that are called by each extension point. A function must be
       *  defined inside a JavaScript source and must be exported. The script with the exported hook function must be located
       *  inside a site cartridge. Inside the site cartridge a &apos;package.json&apos; file with a &apos;hooks&apos; entry must exist.
       *  </p><p>
       *
       *  </p><pre> &quot;hooks&quot;: &quot;./hooks.json&quot;
       *  </pre>
       *
       *  The hooks entry links to a json file, relative to the &apos;package.json&apos; file. This file lists all registered hooks
       *  inside the hooks property:
       *  <p>
       *
       *  </p><pre> &quot;hooks&quot;: [
       *       {&quot;name&quot;: &quot;dw.extensions.paymentrequest.getPaymentRequest&quot;, &quot;script&quot;: &quot;./paymentrequest.ds&quot;}
       *       {&quot;name&quot;: &quot;dw.extensions.paymentrequest.shippingAddressChange&quot;, &quot;script&quot;: &quot;./paymentrequest.ds&quot;}
       *  ]
       *  </pre>
       *  <p>
       *  A hook entry has a &apos;name&apos; and a &apos;script&apos; property.
       *  </p><ul>
       *  <li>The &apos;name&apos; contains the extension point, the hook name.</li>
       *  <li>The &apos;script&apos; contains the script relative to the hooks file, with the exported hook function.</li>
       *  </ul>
       */
      class PaymentRequestHooks {
        /**
         * The extension point name dw.extensions.paymentrequest.abort.
         */
        static readonly extensionPointAbort =
          "dw.extensions.paymentrequest.abort";
        /**
         * The extension point name dw.extensions.paymentrequest.getPaymentRequest.
         */
        static readonly extensionPointGetPaymentRequest =
          "dw.extensions.paymentrequest.getPaymentRequest";
        /**
         * The extension point name dw.extensions.paymentrequest.paymentAccepted.authorizeOrderPayment.
         */
        static readonly extensionPointPaymentAcceptedAuthorizeOrderPayment =
          "dw.extensions.paymentrequest.paymentAccepted.authorizeOrderPayment";
        /**
         * The extension point name .
         */
        static readonly extensionPointPaymentAcceptedPlaceOrder =
          "dw.extensions.paymentrequest.paymentAccepted.placeOrder";
        /**
         * The extension point name .
         */
        static readonly extensionPointShippingAddressChange =
          "dw.extensions.paymentrequest.shippingAddressChange";
        /**
         * The extension point name dw.extensions.paymentrequest.shippingOptionChange.
         */
        static readonly extensionPointShippingOptionChange =
          "dw.extensions.paymentrequest.shippingOptionChange";

        /**
         * Called after the Payment Request user interface was canceled. The given basket is the one that was passed to other
         *  hooks earlier in the Payment Request checkout process.
         *
         *
         *  It is not guaranteed that this hook will be executed for all Payment Request user interfaces canceled by shoppers or
         *  otherwise ended without a successful order. Calls to this hook are provided on a best-effort basis.
         *
         *
         *  If the returned result includes a redirect URL, the shopper browser will be navigated to that URL if possible. It
         *  is not guaranteed that the response with the hook result will be handled in the shopper browser in all cases.
         * @param basket the basket that was being checked out using Payment Request
         * @return a non-null result ends the hook execution
         */
        abort(
          basket: dw.order.Basket
        ): dw.extensions.paymentrequest.PaymentRequestHookResult;
        /**
         * Called after the shopper accepts the Payment Request payment for the given order. Basket customer information,
         *  billing address, and/or shipping address for the default shipment will have already been updated to reflect the
         *  available contact information provided by Payment Request. Any preexisting payment instruments on the basket will
         *  have been removed, and a single DW_ANDROID_PAY payment instrument added for the total amount. The
         *  given order will have been created from this updated basket.
         *
         *
         *  The purpose of this hook is to authorize the Payment Request payment for the order. If a non-error status is returned
         *  that means that you have successfully authorized the payment with your payment service provider. Your hook
         *  implementation must set the necessary payment status and transaction identifier data on the order as returned by
         *  the provider.
         *
         *
         *  Return an error status to indicate a problem, including unsuccessful authorization.
         *
         *
         *  See the Payment Request API for more information.
         * @param order the order paid using Payment Request
         * @param response response to the accepted PaymentRequest
         * @return a non-null status ends the hook execution
         */
        authorizeOrderPayment(
          order: dw.order.Order,
          response: any
        ): dw.system.Status;
        /**
         * Called to get the PaymentRequest constructor parameters for the given basket. You can
         *  set properties in the given parameters object to extend or override default properties set
         *  automatically based on the Google Pay configuration for your site.
         *
         *
         *  The parameters object will contain the following properties by default:
         *
         *  methodData - array containing payment methods the web site accepts
         *  details - information about the transaction that the user is being asked to complete
         *  options - information about what options the web page wishes to use from the payment request system
         *
         *
         *
         *  Return a result with an error status to indicate a problem.
         *
         *
         *  If the returned result includes a redirect URL, the shopper browser will be navigated to that URL if the Payment
         *  Request user interaction is canceled.
         *
         *
         *  See the Payment Request API for more information.
         * @param basket the basket for the Payment Request request
         * @param parameters object containing PaymentRequest constructor parameters
         * @return a non-null result ends the hook execution
         */
        getPaymentRequest(
          basket: dw.order.Basket,
          parameters: any
        ): dw.extensions.paymentrequest.PaymentRequestHookResult;
        /**
         * Called after payment has been authorized and the given Payment Request order is ready to be placed. The purpose of
         *  this hook is to place the order, or return a redirect URL that results in the order being placed when the shopper
         *  browser is navigated to it.
         *
         *
         *  The default implementation of this hook returns a redirect to COPlaceOrder-Submit with URL
         *  parameters order_id set to Order.getOrderNo() and order_token set to
         *  Order.getOrderToken() which corresponds to SiteGenesis-based implementations. Your hook
         *  implementation should return a result with a different redirect URL as necessary to place the order and show an
         *  order confirmation.
         *
         *
         *  Alternatively, your hook implementation itself can place the order and return a result with a redirect URL to an
         *  order confirmation page that does not place the order. This is inconsistent with SiteGenesis-based
         *  implementations so is not the default.
         *
         *
         *  Return an error status to indicate a problem. If the returned result includes a redirect URL, the shopper browser
         *  will be navigated to that URL if the Payment Request user interface is canceled.
         * @param order the order paid using PaymentRequest
         * @return a non-null result ends the hook execution
         */
        placeOrder(
          order: dw.order.Order
        ): dw.extensions.paymentrequest.PaymentRequestHookResult;
        /**
         * Called after handling the Payment Request shippingaddresschange event for the given basket. Basket
         *  customer information and/or shipping address for the default shipment will have already been updated to reflect
         *  the available shipping address information provided by Payment Request. The basket will have already been
         *  calculated before this hook is called.
         *
         *
         *  Return a result with an error status to indicate a problem.
         *
         *
         *  If the returned result includes a redirect URL, the shopper browser will be navigated to that URL if the Payment
         *  Request user interface is canceled.
         *
         *
         *  See the Payment Request API for more information.
         * @param basket the basket being checked out using Payment Request
         * @param details updated PaymentRequest object details
         * @return a non-null result ends the hook execution
         */
        shippingAddressChange(
          basket: dw.order.Basket,
          details: any
        ): dw.extensions.paymentrequest.PaymentRequestHookResult;
        /**
         * Called after handling the Payment Request shippingoptionchange event for the given basket. The given
         *  shipping method will have already been set on the basket. The basket will have already been calculated before
         *  this hook is called.
         *
         *
         *  Return a result with an error status to indicate a problem.
         *
         *
         *  If the returned result includes a redirect URL, the shopper browser will be navigated to that URL if the
         *  Payment Request user interface is canceled.
         *
         *
         *  See the Payment Request API for more information.
         * @param basket the basket being checked out using Payment Request
         * @param shippingMethod the shipping method that was selected
         * @param details updated PaymentRequest object details
         * @return a non-null result ends the hook execution
         */
        shippingOptionChange(
          basket: dw.order.Basket,
          shippingMethod: dw.order.ShippingMethod,
          details: any
        ): dw.extensions.paymentrequest.PaymentRequestHookResult;
      }
    }

    namespace pinterest {
      /**
       * Represents a row in the Pinterest availability feed export file.
       */
      class PinterestAvailability {
        /**
         * The availability of the Pinterest product. Possible values are
         *  PinterestProduct.AVAILABILITY_IN_STOCK or
         *  PinterestProduct.AVAILABILITY_OUT_OF_STOCK.
         */
        availability: string;
        /**
         * The ID of the Pinterest product. This is the same as the ID of the Demandware product.
         */
        readonly ID: string;

        /**
         * Returns the availability of the Pinterest product. Possible values are
         *  PinterestProduct.AVAILABILITY_IN_STOCK or
         *  PinterestProduct.AVAILABILITY_OUT_OF_STOCK.
         *
         */
        getAvailability(): string;
        /**
         * Returns the ID of the Pinterest product. This is the same as the ID of the Demandware product.
         *
         * @return product ID
         */
        getID(): string;
        /**
         * Sets the availability of the Pinterest product. Possible values are
         *  PinterestProduct.AVAILABILITY_IN_STOCK or
         *  PinterestProduct.AVAILABILITY_OUT_OF_STOCK.
         * @param availability the availability status to set for this product
         */
        setAvailability(availability: string): void;
      }

      /**
       * PinterestFeedHooks interface containing extension points for customizing Pinterest export feeds.
       *  <p>
       *  These hooks are not executed in a transaction.
       *  </p><p>
       *  The extension points (hook names), and the functions that are called by each extension point. A function must be
       *  defined inside a JavaScript source and must be exported. The script with the exported hook function must be located
       *  inside a site cartridge. Inside the site cartridge a &apos;package.json&apos; file with a &apos;hooks&apos; entry must exist.
       *  </p><p>
       *
       *  </p><pre> &quot;hooks&quot;: &quot;./hooks.json&quot;
       *  </pre>
       *
       *  The hooks entry links to a json file, relative to the &apos;package.json&apos; file. This file lists all registered hooks
       *  inside the hooks property:
       *  <p>
       *
       *  </p><pre> &quot;hooks&quot;: [
       *       {&quot;name&quot;: &quot;dw.extensions.pinterest.feed.transformProduct&quot;, &quot;script&quot;: &quot;./hooks.ds&quot;}
       *  ]
       *  </pre>
       *  <p>
       *  A hook entry has a &apos;name&apos; and a &apos;script&apos; property.
       *  </p><ul>
       *  <li>The &apos;name&apos; contains the extension point, the hook name.</li>
       *  <li>The &apos;script&apos; contains the script relative to the hooks file, with the exported hook function.</li>
       *  </ul>
       */
      class PinterestFeedHooks {
        /**
         * The extension point name dw.extensions.pinterest.feed.transformAvailability.
         */
        static readonly extensionPointTransformAvailability =
          "dw.extensions.pinterest.feed.transformAvailability";
        /**
         * The extension point name dw.extensions.pinterest.feed.transformProduct.
         */
        static readonly extensionPointTransformProduct =
          "dw.extensions.pinterest.feed.transformProduct";

        /**
         * Called after default transformation of given Demandware product to Pinterest availability as part of the
         *  availability feed export.
         * @param product the Demandware product
         * @param pinterestAvailability the Pinterest representation of the product availability
         * @return a non-null Status ends the hook execution
         */
        transformAvailability(
          product: dw.catalog.Product,
          pinterestAvailability: dw.extensions.pinterest.PinterestAvailability
        ): dw.system.Status;
        /**
         * Called after default transformation of given Demandware product to Pinterest product as part of the catalog feed
         *  export.
         * @param product the Demandware product
         * @param pinterestProduct the Pinterest representation of the product
         * @return a non-null Status ends the hook execution
         */
        transformProduct(
          product: dw.catalog.Product,
          pinterestProduct: dw.extensions.pinterest.PinterestProduct
        ): dw.system.Status;
      }

      /**
       * An order that was placed through Pinterest.
       */
      class PinterestOrder {
        /**
         * Indicates that payment has not been made.
         */
        static readonly PAYMENT_STATUS_NOT_PAID = "NOT_PAID";
        /**
         * Indicates that payment is complete.
         */
        static readonly PAYMENT_STATUS_PAID = "PAID";
        /**
         * Indicates that payment is incomplete.
         */
        static readonly PAYMENT_STATUS_PART_PAID = "PART_PAID";
        /**
         * Indicates an order on backorder.
         */
        static readonly STATUS_BACKORDER = "BACKORDER";
        /**
         * Indicates an order that has been canceled.
         */
        static readonly STATUS_CANCELLED = "CANCELLED";
        /**
         * Indicates an order that has been delivered.
         */
        static readonly STATUS_DELIVERED = "DELIVERED";
        /**
         * Indicates an order in progress.
         */
        static readonly STATUS_IN_PROGRESS = "IN_PROGRESS";
        /**
         * Indicates a new order.
         */
        static readonly STATUS_NEW = "NEW";
        /**
         * Indicates an order that has been returned.
         */
        static readonly STATUS_RETURNED = "RETURNED";
        /**
         * Indicates an order that has shipped.
         */
        static readonly STATUS_SHIPPED = "SHIPPED";

        /**
         * The item ID for this Pinterest order.
         */
        itemId: string;
        /**
         * The order number for this Pinterest order. This is the same as the order number of the Demandware order.
         */
        readonly orderNo: string;
        /**
         * The status of this Pinterest order. Possible values are
         *  PAYMENT_STATUS_PAID,
         *  PAYMENT_STATUS_NOT_PAID,
         *  or PAYMENT_STATUS_PART_PAID.
         */
        paymentStatus: string;
        /**
         * The status of this Pinterest order. Possible values are
         *  STATUS_NEW,
         *  STATUS_IN_PROGRESS,
         *  STATUS_SHIPPED,
         *  STATUS_BACKORDER,
         *  STATUS_CANCELLED,
         *  STATUS_DELIVERED,
         *  or STATUS_RETURNED.
         */
        status: string;

        /**
         * Returns the item ID for this Pinterest order.
         *
         */
        getItemId(): string;
        /**
         * Returns the order number for this Pinterest order. This is the same as the order number of the Demandware order.
         *
         * @return order number
         */
        getOrderNo(): string;
        /**
         * Returns the status of this Pinterest order. Possible values are
         *  PAYMENT_STATUS_PAID,
         *  PAYMENT_STATUS_NOT_PAID,
         *  or PAYMENT_STATUS_PART_PAID.
         *
         */
        getPaymentStatus(): string;
        /**
         * Returns the status of this Pinterest order. Possible values are
         *  STATUS_NEW,
         *  STATUS_IN_PROGRESS,
         *  STATUS_SHIPPED,
         *  STATUS_BACKORDER,
         *  STATUS_CANCELLED,
         *  STATUS_DELIVERED,
         *  or STATUS_RETURNED.
         *
         */
        getStatus(): string;
        /**
         * Sets the item ID for this Pinterest order.
         * @param itemId item ID
         */
        setItemId(itemId: string): void;
        /**
         * Sets the status of this Pinterest order. Possible values are
         *  PAYMENT_STATUS_PAID,
         *  PAYMENT_STATUS_NOT_PAID,
         *  or PAYMENT_STATUS_PART_PAID.
         * @param status the status to set for this order
         */
        setPaymentStatus(status: string): void;
        /**
         * Sets the status of this Pinterest order. Possible values are
         *  STATUS_NEW,
         *  STATUS_IN_PROGRESS,
         *  STATUS_SHIPPED,
         *  STATUS_BACKORDER,
         *  STATUS_CANCELLED,
         *  STATUS_DELIVERED,
         *  or STATUS_RETURNED.
         * @param status the status to set for this order
         */
        setStatus(status: string): void;
      }

      /**
       * PinterestOrderHooks interface containing extension points for customizing Pinterest order status.
       *  <p>
       *  These hooks are not executed in a transaction.
       *  </p><p>
       *  The extension points (hook names), and the functions that are called by each extension point. A function must be
       *  defined inside a JavaScript source and must be exported. The script with the exported hook function must be located
       *  inside a site cartridge. Inside the site cartridge a &apos;package.json&apos; file with a &apos;hooks&apos; entry must exist.
       *  </p><p>
       *
       *  </p><pre> &quot;hooks&quot;: &quot;./hooks.json&quot;
       *  </pre>
       *
       *  The hooks entry links to a json file, relative to the &apos;package.json&apos; file. This file lists all registered hooks
       *  inside the hooks property:
       *  <p>
       *
       *  </p><pre> &quot;hooks&quot;: [
       *       {&quot;name&quot;: &quot;dw.extensions.pinterest.order.getStatus&quot;, &quot;script&quot;: &quot;./hooks.ds&quot;}
       *  ]
       *  </pre>
       *  <p>
       *  A hook entry has a &apos;name&apos; and a &apos;script&apos; property.
       *  </p><ul>
       *  <li>The &apos;name&apos; contains the extension point, the hook name.</li>
       *  <li>The &apos;script&apos; contains the script relative to the hooks file, with the exported hook function.</li>
       *  </ul>
       */
      class PinterestOrderHooks {
        /**
         * The extension point name dw.extensions.pinterest.order.getStatus.
         */
        static readonly extensionPointGetStatus =
          "dw.extensions.pinterest.order.getStatus";

        /**
         * Called to retrieve status for the given order. Return a null status for unknown orders.
         * @param order the Pinterest order
         * @return a non-null Status ends the hook execution
         */
        getStatus(
          order: dw.extensions.pinterest.PinterestOrder
        ): dw.system.Status;
      }

      /**
       * Represents a row in the Pinterest catalog feed export.
       */
      class PinterestProduct {
        /**
         * Indicates that the product is in stock.
         */
        static readonly AVAILABILITY_IN_STOCK = "in stock";
        /**
         * Indicates that the product is not in stock.
         */
        static readonly AVAILABILITY_OUT_OF_STOCK = "out of stock";
        /**
         * Indicates that the product is availabile in preorder.
         */
        static readonly AVAILABILITY_PREORDER = "preorder";
        /**
         * Indicates that the product has never been used.
         */
        static readonly CONDITION_NEW = "new";
        /**
         * Indicates that the product has been used but refurbished.
         */
        static readonly CONDITION_REFURBISHED = "refurbished";
        /**
         * Indicates that the product has been used.
         */
        static readonly CONDITION_USED = "used";

        /**
         * The availability of the Pinterest product. Possible values are
         *  AVAILABILITY_IN_STOCK or
         *  AVAILABILITY_OUT_OF_STOCK.
         */
        availability: string;
        /**
         * The Pinterest brand of the product.
         */
        brand: string;
        /**
         * The Pinterest color value label of the product.
         */
        color: string;
        /**
         * The Pinterest color hex value of the product.
         */
        colorHex: string;
        /**
         * The URL of the image to show in Pinterest for the product color (swatch).
         */
        colorImage: dw.web.URL;
        /**
         * The condition of the Pinterest product. Possible values are
         *  CONDITION_NEW,
         *  CONDITION_REFURBISHED, or
         *  CONDITION_USED.
         */
        condition: string;
        /**
         * The Pinterest description of the product.
         */
        description: string;
        /**
         * The category of this product in the Google category taxonomy.
         */
        googleProductCategory: string;
        /**
         * The Pinterest GTIN of the product.
         */
        gtin: string;
        /**
         * The ID of the Pinterest product. This is the same as the ID of the Demandware product.
         */
        readonly ID: string;
        /**
         * A list containing the URLs of the image to show in Pinterest for the product.
         */
        imageLinks: dw.util.List<string>;
        /**
         * The ID of the Pinterest item group for the product, that is, its master product.
         */
        itemGroupID: string;
        /**
         * The URL of the Pinterest item group for the product, that is, the link to its master product in the
         *  Demandware storefront.
         */
        itemGroupLink: dw.web.URL;
        /**
         * The URL of the Demandware storefront link to the product.
         */
        link: dw.web.URL;
        /**
         * The maximum price to show in Pinterest for the product.
         */
        maxPrice: dw.value.Money;
        /**
         * The minimum price to show in Pinterest for the product.
         */
        minPrice: dw.value.Money;
        /**
         * The price to show in Pinterest for the product.
         */
        price: dw.value.Money;
        /**
         * The Pinterest category path of the product.
         */
        productCategory: string;
        /**
         * The Pinterest return policy of the product.
         */
        returnPolicy: string;
        /**
         * The Pinterest size value label of the product.
         */
        size: string;
        /**
         * The Pinterest title of the product.
         */
        title: string;

        /**
         * Returns the availability of the Pinterest product. Possible values are
         *  AVAILABILITY_IN_STOCK or
         *  AVAILABILITY_OUT_OF_STOCK.
         *
         */
        getAvailability(): string;
        /**
         * Returns the Pinterest brand of the product.
         *
         */
        getBrand(): string;
        /**
         * Returns the Pinterest color value label of the product.
         *
         */
        getColor(): string;
        /**
         * Returns the Pinterest color hex value of the product.
         *
         */
        getColorHex(): string;
        /**
         * Returns the URL of the image to show in Pinterest for the product color (swatch).
         *
         */
        getColorImage(): dw.web.URL;
        /**
         * Returns the condition of the Pinterest product. Possible values are
         *  CONDITION_NEW,
         *  CONDITION_REFURBISHED, or
         *  CONDITION_USED.
         *
         */
        getCondition(): string;
        /**
         * Returns the Pinterest description of the product.
         *
         */
        getDescription(): string;
        /**
         * Returns the category of this product in the Google category taxonomy.
         *
         */
        getGoogleProductCategory(): string;
        /**
         * Returns the Pinterest GTIN of the product.
         *
         */
        getGtin(): string;
        /**
         * Returns the ID of the Pinterest product. This is the same as the ID of the Demandware product.
         *
         * @return product ID
         */
        getID(): string;
        /**
         * Returns a list containing the URLs of the image to show in Pinterest for the product.
         *
         */
        getImageLinks(): dw.util.List<string>;
        /**
         * Returns the ID of the Pinterest item group for the product, that is, its master product.
         *
         */
        getItemGroupID(): string;
        /**
         * Returns the URL of the Pinterest item group for the product, that is, the link to its master product in the
         *  Demandware storefront.
         *
         */
        getItemGroupLink(): dw.web.URL;
        /**
         * Returns the URL of the Demandware storefront link to the product.
         *
         */
        getLink(): dw.web.URL;
        /**
         * Returns the maximum price to show in Pinterest for the product.
         *
         */
        getMaxPrice(): dw.value.Money;
        /**
         * Returns the minimum price to show in Pinterest for the product.
         *
         */
        getMinPrice(): dw.value.Money;
        /**
         * Returns the price to show in Pinterest for the product.
         *
         */
        getPrice(): dw.value.Money;
        /**
         * Returns the Pinterest category path of the product.
         *
         */
        getProductCategory(): string;
        /**
         * Returns the Pinterest return policy of the product.
         *
         */
        getReturnPolicy(): string;
        /**
         * Returns the Pinterest size value label of the product.
         *
         */
        getSize(): string;
        /**
         * Returns the Pinterest title of the product.
         *
         */
        getTitle(): string;
        /**
         * Sets the availability of the Pinterest product. Possible values are
         *  AVAILABILITY_IN_STOCK or
         *  AVAILABILITY_OUT_OF_STOCK.
         * @param availability the availability status to set for this product
         */
        setAvailability(availability: string): void;
        /**
         * Sets the Pinterest brand of the product.
         * @param brand Pinterest brand
         */
        setBrand(brand: string): void;
        /**
         * Sets the Pinterest color value label of the product.
         * @param color Pinterest color value label
         */
        setColor(color: string): void;
        /**
         * Sets the Pinterest color hex value of the product.
         * @param colorHex Pinterest color hex value
         */
        setColorHex(colorHex: string): void;
        /**
         * Sets the URL of the image to show in Pinterest for the product color (swatch).
         * @param colorImage link to Pinterest color image
         */
        setColorImage(colorImage: dw.web.URL): void;
        /**
         * Sets the condition of the Pinterest product. Possible values are
         *  CONDITION_NEW,
         *  CONDITION_REFURBISHED, or
         *  CONDITION_USED.
         * @param condition the condition status to set for this product
         */
        setCondition(condition: string): void;
        /**
         * Sets the Pinterest description of the product.
         * @param description Pinterest description
         */
        setDescription(description: string): void;
        /**
         * Sets the category of this product in the Google category taxonomy.
         * @param googleProductCategory Google product category
         */
        setGoogleProductCategory(googleProductCategory: string): void;
        /**
         * Sets the Pinterest GTIN of the product.
         * @param gtin Pinterest GTIN
         */
        setGtin(gtin: string): void;
        /**
         * Sets the list of URLs of images to show in Pinterest for the product.
         * @param imageLinks links to the product images
         */
        setImageLinks(imageLinks: dw.util.List<any>): void;
        /**
         * Sets the ID of the Pinterest item group for the product, that is, its master product.
         * @param itemGroupID ID of Pinterest item group
         */
        setItemGroupID(itemGroupID: string): void;
        /**
         * Sets the URL of the Pinterest item group for the product, that is, the link to its master product in the
         *  Demandware storefront.
         * @param itemGroupLink link to the Pinterest item group
         */
        setItemGroupLink(itemGroupLink: dw.web.URL): void;
        /**
         * Sets the URL of the Demandware storefront link to the product.
         * @param link Demandware storefront link to the product
         */
        setLink(link: dw.web.URL): void;
        /**
         * Sets the maximum price to show in Pinterest for the product.
         * @param maxPrice Pinterest maximum price
         */
        setMaxPrice(maxPrice: dw.value.Money): void;
        /**
         * Sets the minimum price to show in Pinterest for the product.
         * @param minPrice Pinterest minimum price
         */
        setMinPrice(minPrice: dw.value.Money): void;
        /**
         * Sets the price to show in Pinterest for the product.
         * @param price Pinterest price
         */
        setPrice(price: dw.value.Money): void;
        /**
         * Sets the Pinterest category path of the product.
         * @param productCategory Pinterest category path
         */
        setProductCategory(productCategory: string): void;
        /**
         * Sets the Pinterest return policy of the product.
         * @param returnPolicy Pinterest return policy
         */
        setReturnPolicy(returnPolicy: string): void;
        /**
         * Sets the Pinterest size value label of the product.
         * @param size Pinterest size value label
         */
        setSize(size: string): void;
        /**
         * Sets the Pinterest title of the product.
         * @param title Pinterest title
         */
        setTitle(title: string): void;
      }
    }
  }

  namespace io {
    /**
     * The class supports reading a CSV file. The reader supports handling CSV
     *  entries where the separator is contained in quotes and also CSV entries where
     *  a quoted entry contains newline characters.
     */
    class CSVStreamReader {
      /**
       * Creates a new CSVReader with a ',' as separator character and a '"' as
       *  quote character. The reader doesn't skip any header lines.
       * @param ioreader the reader to use.
       */
      constructor(ioreader: dw.io.Reader);
      /**
       * Creates a new CSVReader with the specified separator character and a '"'
       *  as quote character. The reader doesn't skip any header lines.
       * @param ioreader the reader to use.
       * @param separator a string, which represents the separator character.
       */
      constructor(ioreader: dw.io.Reader, separator: string);
      /**
       * Creates a new CSVReader with the specified separator character and the
       *  specified quote character. The reader doesn't skip any header lines.
       * @param ioreader the reader to use.
       * @param separator a string, which represents the separator character.
       * @param quote a string, which represents the quote character.
       */
      constructor(ioreader: dw.io.Reader, separator: string, quote: string);
      /**
       * Creates a new CSVReader. The separator character, the quote character and
       *  the number of header lines can be specified in the call.
       * @param ioreader the reader to use.
       * @param separator a string, which represents the separator character.
       * @param quote a string, which represents the quote character.
       * @param skip the number of lines to skip at the beginning of the file.
       */
      constructor(
        ioreader: dw.io.Reader,
        separator: string,
        quote: string,
        skip: number
      );

      /**
       * Closes the underlying reader.
       *
       */
      close(): void;
      /**
       * Returns a list of lines representing the entire CSV file. Each line is a
       *  array of strings.
       *
       *  Using this method on large feeds is inherently unsafe and may lead to an
       *  out-of-memory condition. Instead use method readNext() and
       *  process entries line by line.
       *
       * @return a list of lines representing the entire CSV file.
       */
      readAll(): dw.util.List<string[]>;
      /**
       * Returns the next line from the input stream. The line is returned as an
       *  array of strings. The method returns null if the end of the stream is
       *  reached.
       *
       * @return the next line from the input stream as an array of strings.
       */
      readNext(): String[];
    }

    /**
     * The class writes a CSV file.
     *  <p>
     *  <b>Note:</b> when this class is used with sensitive data, be careful in persisting sensitive information to disk.</p>
     */
    class CSVStreamWriter {
      /**
       * Create a new CSVStreamWriter with a ',' as separator and '"'
       *  as quote character.
       * @param writer the writer to use.
       */
      constructor(writer: dw.io.Writer);
      /**
       * Create a new CSVStreamWriter with the specified separator and '"'
       *  as quote character.
       * @param writer the writer to use.
       * @param separator the separator to use.
       */
      constructor(writer: dw.io.Writer, separator: string);
      /**
       * Create a new CSVStreamWriter with the specified separator and the
       *  specified quote character.
       * @param writer the writer to use.
       * @param separator the separator to use.
       * @param quote the quote to use.
       */
      constructor(writer: dw.io.Writer, separator: string, quote: string);

      /**
       * Closes the underlying writer.
       *
       */
      close(): void;
      /**
       * Write a single line to the CSV file.
       * @param line an array of strings.
       */
      writeNext(...line: string[]): void;
    }

    /**
     * Represents a file resource accessible from scripting. As with
     *  <code>java.io.File</code>, a <code>File</code> is essentially an
     *  &quot;abstract pathname&quot; which may or may not denote an actual file on the file
     *  system.  Methods <code>createNewFile</code>,
     *  <code>mkdir</code>, <code>mkdirs</code>, and <code>remove</code> are provided
     *  to actually manipulate physical files.
     *
     *  <p>File access is limited to certain virtual directories.  These directories are
     *  a subset of those accessible through WebDAV.  As a result of this
     *  restriction, pathnames must be one of the following forms:</p>
     *
     *  <ul>
     *  <li><code>/TEMP(/...)</code></li>
     *  <li><code>/IMPEX(/...)</code></li>
     *  <li><code>/REALMDATA(/...)</code></li>
     *  <li><code>/CATALOGS/[Catalog Name](/...)</code></li>
     *  <li><code>/LIBRARIES/[Library Name](/...)</code></li>
     *  </ul>
     *
     *  Note, that these paths are analogous to the WebDAV URIs used to access the
     *  same directories.
     *
     *  <p>The files are stored in a shared file system where multiple processes could
     *  access the same file. The programmer has to make sure no more than one process
     *  writes to a file at a given time.</p>
     *
     *  <p>This class provides other useful methods for listing the
     *  children of a directory and for working with zip files.
     *  </p><p>
     *  <b>Note:</b> when this class is used with sensitive data, be careful in persisting sensitive information.</p>
     */
    class File {
      /**
       * Catalogs root directory.
       */
      static readonly CATALOGS = "CATALOGS";
      /**
       * Customer snapshots root directory.
       */
      static readonly CUSTOMER_SNAPSHOTS = "CUSTOMERSNAPSHOTS";
      /**
       * Customer Payment Instrument root directory.
       */
      static readonly CUSTOMERPI = "CUSTOMERPI";
      /**
       * Reserved for future use.
       */
      static readonly DYNAMIC = "DYNAMIC";
      /**
       * Import/export root directory.
       */
      static readonly IMPEX = "IMPEX";
      /**
       * Libraries root directory.
       */
      static readonly LIBRARIES = "LIBRARIES";
      /**
       * RealmData root directory.
       */
      static readonly REALMDATA = "REALMDATA";
      /**
       * The UNIX style '/' path separator, which must be used for files paths.
       */
      static readonly SEPARATOR = "/";
      /**
       * Static content root directory.
       */
      static readonly STATIC = "STATIC";
      /**
       * Temp root directory.
       */
      static readonly TEMP = "TEMP";

      /**
       * Indicates that this file is a directory.
       */
      readonly directory: boolean;
      /**
       * Indicates if this file is a file.
       */
      readonly file: boolean;
      /**
       * Return the full file path denoted by this File.
       *  This value will be the same regardless of which constructor was
       *  used to create this File.
       */
      readonly fullPath: string;
      /**
       * The name of the file or directory denoted by this object. This is
       *  just the last name in the pathname's name sequence. If the pathname's
       *  name sequence is empty, then the empty string is returned.
       */
      readonly name: string;
      /**
       * The portion of the path relative to the root directory.
       */
      readonly path: string;
      /**
       * The root directory type, e.g. "IMPEX" represented by this
       *  File.
       */
      readonly rootDirectoryType: string;

      /**
       * Creates a File from the given absolute file path in the
       *  file namespace.  If the specified path is not a valid accessible path,
       *  an exception will be thrown.
       *
       *  The passed path should use the forward slash '/' as the path
       *  separator and begin with a leading slash.  However, if a leading slash
       *  is not provided, or the backslash character is used as the separator,
       *  these problems will be fixed.  The normalized value will then be returned
       *  by getFullPath().
       * @param absPath the absolute file path throws IOException
       */
      constructor(absPath: string);
      /**
       * Creates a File given a root directory and a relative path.
       * @param rootDir File object representing root directory
       * @param relPath relative file path
       */
      constructor(rootDir: dw.io.File, relPath: string);

      /**
       * Copy a file. Directories cannot be copied. This method cannot be used from storefront requests.
       * @param file the File object to copy to
       * @return a reference to the copied file.
       */
      copyTo(file: dw.io.File): dw.io.File;
      /**
       * Create file.
       *
       * @return boolean, true - if file has been created, false - file already exists
       */
      createNewFile(): boolean;
      /**
       * Indicates if the file exists.
       *
       * @return true if file exists, false otherwise.
       */
      exists(): boolean;
      /**
       * Return the full file path denoted by this File.
       *  This value will be the same regardless of which constructor was
       *  used to create this File.
       *
       * @return the full file path.
       */
      getFullPath(): string;
      /**
       * Returns the name of the file or directory denoted by this object. This is
       *  just the last name in the pathname's name sequence. If the pathname's
       *  name sequence is empty, then the empty string is returned.
       *
       * @return The name of the file or directory denoted by this object.
       */
      getName(): string;
      /**
       * Returns the portion of the path relative to the root directory.
       *
       * @return the relative file path, possibly blank but not null.
       */
      getPath(): string;
      /**
       * Returns a File representing a directory for the specified
       *  root directory type. If the root directory
       *  type is CATALOGS or LIBRARIES, then an additional argument representing
       *  the specific catalog or library must be provided.  Otherwise, no
       *  additional arguments are needed.
       * @param rootDir root directory type (see the constants defined in this class)
       * @param args root directory specific arguments
       * @return File object representing the directory
       */
      static getRootDirectory(rootDir: string, ...args: string[]): dw.io.File;
      /**
       * Returns the root directory type, e.g. "IMPEX" represented by this
       *  File.
       *
       * @return root directory type
       */
      getRootDirectoryType(): string;
      /**
       * Assumes this instance is a gzip file. Unzipping it will
       *  explode the contents in the directory passed in (root).
       * @param root a File indicating root. root must be a directory.
       */
      gunzip(root: dw.io.File): void;
      /**
       * GZip this instance into a new gzip file. If you're zipping a file, then a single entry, the instance,
       *  is included in the output gzip file. Note that a new File is created. GZipping directories is not suppported.
       *  This file is never modified.
       * @param outputZipFile the zip file created.
       */
      gzip(outputZipFile: dw.io.File): void;
      /**
       * Indicates that this file is a directory.
       *
       * @return true if the file is a directory, false otherwise.
       */
      isDirectory(): boolean;
      /**
       * Indicates if this file is a file.
       *
       * @return true if the file is a file, false otherwise.
       */
      isFile(): boolean;
      /**
       * Return the time, in milliseconds, that this file was last modified.
       *
       * @return the time, in milliseconds, that this file was last modified.
       */
      lastModified(): number;
      /**
       * Return the length of the file in bytes.
       *
       * @return the file length in bytes.
       */
      length(): number;
      /**
       * Returns an array of strings naming the files and directories in the
       *  directory denoted by this object.
       *
       *
       *  If this object does not denote a directory, then this method returns
       *  null. Otherwise an array of strings is returned, one for
       *  each file or directory in the directory. Names denoting the directory
       *  itself and the directory's parent directory are not included in the
       *  result. Each string is a file name rather than a complete path.
       *
       *
       *  There is no guarantee that the name strings in the resulting array will
       *  appear in any specific order; they are not, in particular, guaranteed to
       *  appear in alphabetical order.
       *
       * @return An array of strings naming the files and directories in the directory denoted by this File. The array will be empty if the directory is empty. Returns null if this File does not denote a directory.
       */
      list(): String[];
      /**
       * Returns an array of File objects in the directory denoted
       *  by this File.
       *
       *
       *  If this File does not denote a directory, then this method
       *  returns null. Otherwise an array of File
       *  objects is returned, one for each file or directory in the directory.
       *  Files denoting the directory itself and the directory's parent directory
       *  are not included in the result.
       *
       *
       *  There is no guarantee that the files in the resulting array will appear
       *  in any specific order; they are not, in particular, guaranteed to appear
       *  in alphabetical order. Example usage:
       *
       *
       *
       *  // Assume "foo" is an accessible directory.
       *  var this_directory : dw.io.File = new File("foo");
       *
       *  // Find all files in directory foo, one level "down".
       *  // listFiles() will not traverse subdirectories.
       *  var folder : dw.util.List = this_directory.listFiles();
       *  var first_element : dw.io.File = folder[0];
       *
       *  function modification_comparison(lhs : File, rhs : File)
       *  {
       *  return lhs.lastModified() < rhs.lastModified();
       *  }
       *
       *  function lexigraphic_comparison(lhs: File, rhs : File)
       *  {
       *  return lhs.getName() < rhs.getName();
       *  }
       *
       *  var time_ordered_folder : dw.util.ArrayList = folder.sort(modification_comparison);
       *  var alphabetic_folder : dw.util.ArrayList = folder.sort(lexigraphic_comparison);
       *
       * @return a list of File objects or null if this is not a directory.
       */
      listFiles(): dw.util.List<dw.io.File>;
      /**
       * Returns an array of File objects denoting the files and
       *  directories in the directory denoted by this object that satisfy the
       *  specified filter. The behavior of this method is the same as that of the
       *  listFiles() method, except that the files in the
       *  returned array must satisfy the filter. The filter is a Javascript
       *  function which accepts one argument, a File, and returns
       *  true or false depending on whether the file meets the filter conditions.
       *  If the given filter is null then all files
       *  are accepted. Otherwise, a file satisfies the filter if and only if the
       *  filter returns true. Example usage:
       *
       *
       *
       *  // Assume "foo" is an accessible directory.
       *  var this_directory : dw.io.File = new File("foo");
       *
       *  function longer_than_3(candidate : dw.io.File)
       *  {
       *  return candidate.getName().length > 3;
       *  }
       *
       *  // Find all files in directory foo, one level "down",
       *  // such that the filename is longer than 3 characters.
       *  var folder_long_names : dw.util.List = this_directory.listFiles(longer_than_3);
       * @param filter a Javascript function which accepts a File argument and returns true or false.
       * @return list of File objects or null if this is not a directory
       */
      listFiles(filter: Function): dw.util.List<dw.io.File>;
      /**
       * Returns an MD5 hash of the content of the file of this instance.
       *
       * @return The MD5 hash of the file's content.
       */
      md5(): string;
      /**
       * Creates a directory.
       *
       * @return true if file creation succeeded, false otherwise.
       */
      mkdir(): boolean;
      /**
       * Creates a directory, including, its parent directories, as needed.
       *
       * @return true if file creation succeeded, false otherwise.
       */
      mkdirs(): boolean;
      /**
       * Deletes the file or directory denoted by this object. If this File
       *  represents a directory, then the directory must be empty in order to be
       *  deleted.
       *
       * @return true if file deletion succeeded, false otherwise
       */
      remove(): boolean;
      /**
       * Rename file.
       * @param file the File object to rename to
       * @return boolean, true - if file rename succeeded, false - failed
       */
      renameTo(file: dw.io.File): boolean;
      /**
       * Assumes this instance is a zip file. Unzipping it will
       *  explode the contents in the directory passed in (root).
       * @param root a File indicating root. root must be a directory.
       */
      unzip(root: dw.io.File): void;
      /**
       * Zip this instance into a new zip file. If you're zipping a directory,
       *  the directory itself and all its children files to any level (any number of subdirectories)
       *  are included in the zip file. The directory will be the only entry in the archive (single root).
       *  If you're zipping a file, then a single entry, the instance,
       *  is included in the output zip file. Note that a new File is created.
       *  This file is never modified.
       * @param outputZipFile the zip file created.
       */
      zip(outputZipFile: dw.io.File): void;
    }

    /**
     * File reader class.
     */
    class FileReader extends dw.io.Reader {
      /**
       * Constructs the reader.
       *
       *  To release system resources, close the reader by calling close().
       * @param file the file object to read.
       */
      constructor(file: dw.io.File);
      /**
       * Constructs the reader.
       *
       *  To release system resources, close the reader by calling close().
       * @param file the file object to read.
       * @param encoding the character encoding to use.
       */
      constructor(file: dw.io.File, encoding: string);

      /**
       * Closes the reader.
       *
       */
      close(): void;
    }

    /**
     * Convenience class for writing character files.
     *  <p>
     *  Files are stored in a shared file system where multiple processes could
     *  access the same file. The client code is responsible for ensuring that no
     *  more than one process writes to a file at a given time.
     *  </p><p>
     *  <b>Note:</b> when this class is used with sensitive data, be careful in persisting sensitive information to disk.</p>
     */
    class FileWriter extends dw.io.Writer {
      /**
       * Get the current line separator (e.g. '\n' or '\r\n'), if no value is set the system default '\n' will be used.
       */
      lineSeparator: string;

      /**
       * Constructs the writer for the specified file. Uses "UTF-8" as encoding.
       *
       *  To release system resources, close the writer by calling close().
       * @param file the file object to write to.
       */
      constructor(file: dw.io.File);
      /**
       * Constructs the writer for the specified file. Optional file append mode
       *  is supported. Uses "UTF-8" as encoding.
       *
       *  To release system resources, close the writer by calling close().
       * @param file the file object to write to.
       * @param append flag, whether the file should be written in append mode
       */
      constructor(file: dw.io.File, append: boolean);
      /**
       * Constructs the writer for the specified file with the specified encoding.
       *
       *  To release system resources, close the writer by calling close().
       * @param file the file object to write to.
       * @param encoding the character encoding to use.
       */
      constructor(file: dw.io.File, encoding: string);
      /**
       * Constructs the writer for the specified file with the specified encoding.
       *  Optional file append mode is supported.
       *
       *  To release system resources, close the writer by calling close().
       * @param file the file object to write to.
       * @param encoding the character encoding to use.
       * @param append flag indicating whether the file should be written in append mode.
       */
      constructor(file: dw.io.File, encoding: string, append: boolean);

      /**
       * Closes the writer.
       *
       */
      close(): void;
      /**
       * Get the current line separator (e.g. '\n' or '\r\n'), if no value is set the system default '\n' will be used.
       *
       */
      getLineSeparator(): string;
      /**
       * Set the line separator (e.g. '\n' or '\r\n'), if no value is set the system default '\n' will be used.
       * @param lineSeparator that will be written at the end of each line
       */
      setLineSeparator(lineSeparator: string): void;
      /**
       * Writes the specified line and appends the line separator.
       * @param str the line to write to the file.
       */
      writeLine(str: string): void;
    }

    /**
     * The class represent a stream of bytes that can be read from the
     *  application. The InputStream itself doesn&apos;t provide any methods
     *  to read the data. Instead the InputStream can be chained with
     *  other classes like a XMLStreamReader to read data.
     */
    class InputStream {
      /**
       * Closes the input stream.
       *
       */
      close(): void;
    }

    /**
     * The class represent a stream of bytes that can be written from the
     *  application. The OutputStream itself doesn&apos;t provide any methods
     *  to write the data. Instead the OutputStream can be chained with
     *  other classes like a XMLStreamWriter to write data.
     *  <p>
     *  <b>Note:</b> when this class is used with sensitive data, be careful in persisting sensitive information to disk.</p>
     */
    class OutputStream {
      /**
       * Closes the output stream.
       *
       */
      close(): void;
    }

    /**
     * Template output stream writer.
     *
     *  Printwriter is available in the template scripting context and is used
     *  to write data into the template output stream. You cannot instantiate this class
     *  directly. Instead, the system assigns the object to variable named &apos;out&apos; in the script context
     *  to be used by the template scripts.
     *  <p>
     *  <b>Note:</b> when this class is used with sensitive data, be careful in persisting sensitive information to disk.</p>
     */
    class PrintWriter extends dw.io.Writer {
      /**
       * Prints the given string into the output stream.
       * @param str the String object
       */
      print(str: string): void;
      /**
       * Print the given string followed by a line break into the output stream.
       * @param str the String object
       */
      println(str: string): void;
      /**
       * Prints a line break into the output stream.
       *
       */
      println(): void;
    }

    /**
     * Instances of this class support reading from a random access file. A random
     *  access file behaves like a large array of bytes stored in the file system.
     *  There is a kind of cursor, or index into the implied array, called the file
     *  pointer. Read operations read bytes starting at the file pointer and advance
     *  the file pointer past the bytes read. The file pointer can be read by the
     *  getPosition method and set by the setPosition method.
     */
    class RandomAccessFileReader {
      /**
       * The current offset in this file.
       */
      position: number;

      /**
       * Construct a reader for random read access to the provided file.
       *
       *  To release system resources, close the reader by calling close().
       * @param file The file to be read. Must not be null.
       */
      constructor(file: dw.io.File);

      /**
       * Closes this random access file reader and releases any system resources
       *  associated with the stream.
       *
       */
      close(): void;
      /**
       * Returns the current offset in this file.
       *
       * @return the offset from the beginning of the file, in bytes, at which the next read occurs.
       */
      getPosition(): number;
      /**
       * Returns the length of this file.
       *
       * @return the length of this file, measured in bytes.
       */
      length(): number;
      /**
       * Reads a signed eight-bit value from the file starting from the current
       *  file pointer. Since the byte is interpreted as signed, the value returned
       *  will always be between -128 and +127.
       *
       * @return the next byte of this file as a signed eight-bit byte.
       */
      readByte(): number;
      /**
       * Reads up to n bytes from the file starting at the current file pointer.
       *  If there are fewer than n bytes remaining in the file, then as many bytes
       *  as possible are read. If no bytes remain in the file, then null is
       *  returned.
       * @param numBytes The number of bytes to read. Must be non-negative and smaller than Bytes.MAX_BYTES or an exception will be thrown.
       * @return A Bytes object representing the read bytes or null if no bytes were read.
       */
      readBytes(numBytes: number): dw.util.Bytes;
      /**
       * Sets the file-pointer offset, measured from the beginning of this file,
       *  at which the next read occurs. The offset may be set beyond the end of
       *  the file.
       * @param position the offset position, measured in bytes from the beginning of the file, at which to set the file pointer
       */
      setPosition(position: number): void;
    }

    /**
     * The class supports reading characters from a stream.
     */
    class Reader {
      /**
       * The method reads the whole input stream, parses it and returns a list of strings.
       *
       *  Using this method on large feeds is inherently unsafe and may lead to an out-of-memory condition. Instead use
       *  method readLine() and process one line at a time.
       */
      readonly lines: dw.util.List<string>;
      /**
       * The method reads the whole input stream as one string and returns it.
       *
       *  Using this method is unsafe if the length of the input stream is not known and may lead to an out-of-memory
       *  condition. Instead use method readN(Number).
       */
      readonly string: string;

      /**
       * Closes the reader.
       *
       */
      close(): void;
      /**
       * The method reads the whole input stream, parses it and returns a list of strings.
       *
       *  Using this method on large feeds is inherently unsafe and may lead to an out-of-memory condition. Instead use
       *  method readLine() and process one line at a time.
       *
       * @return a list of strings
       */
      getLines(): dw.util.List<string>;
      /**
       * The method reads the whole input stream as one string and returns it.
       *
       *  Using this method is unsafe if the length of the input stream is not known and may lead to an out-of-memory
       *  condition. Instead use method readN(Number).
       *
       * @return a string, which represents the whole content of the InputStream
       */
      getString(): string;
      /**
       * Reads a single character from the stream. The method returns null if the end of the stream is reached.
       *
       * @return a single character in a string, or null if the end of the stream is reached
       */
      read(): string;
      /**
       * Reads multiple characters from the stream as string. The actual number of characters that were read can be
       *  determined from the length of the returned string. If the end of the stream is reached and no more characters can
       *  be read, the method exits with an exception.
       * @param length the number of characters to read.
       * @return a string whose length is controlled by the length parameter. The actual number of characters that were read can be determined from the length of the returned string.
       */
      read(length: number): string;
      /**
       * Reads the next line.
       *
       * @return A String containing the contents of the line, not including any line termination characters, or null if the end of the stream has been reached.
       */
      readLine(): string;
      /**
       * The method reads the whole input stream, parses it and returns a list of strings.
       *
       *  Using this method on large feeds is inherently unsafe and may lead to an out-of-memory condition. Instead use
       *  method readLine() and process one line at a time.
       *
       * @return a list of strings
       */
      readLines(): dw.util.List<string>;
      /**
       * Reads n characters from the stream as string. The actual number of characters that were read can be determined
       *  from the length of the returned string. If the end of the stream is reached and no more characters can be read,
       *  the method returns null.
       * @param n the number of characters to read
       * @return a string whose maximum length is controlled by the n parameter, or null if the end of the stream is reached and no more characters can be read
       */
      readN(n: number): string;
      /**
       * The method reads the whole input stream as one string and returns it.
       *
       *  Using this method is unsafe if the length of the input stream is not known and may lead to an out-of-memory
       *  condition. Instead use method readN(Number).
       *
       * @return a string, which represents the whole content of the InputStream
       */
      readString(): string;
      /**
       * Identifies if this stream is ready to be read.
       *
       * @return true guarantees that the stream is ready to read without waiting for input. A false response means that the stream may or may not block to wait for input. Note that returning false does not guarantee that the next read() will block.
       */
      ready(): boolean;
      /**
       * Skips the specified number of characters in the stream.
       * @param n the number of characters to skip.
       */
      skip(n: number): void;
    }

    /**
     * A Writer that can be used to generate a String.
     *  <p>
     *  In most cases it is not necessary to use StringWriter. If the final
     *  destination of the output is a file, use <a href="class_dw_io_FileWriter.html">FileWriter</a> directly.
     *  This will help to reduce memory usage. If you wish to transfer a feed to a
     *  remote FTP, SFTP or WebDAV server, first write the feed to the file system
     *  using FileWriter and optionally <a href="class_dw_io_CSVStreamWriter.html">CSVStreamWriter</a> or
     *  <a href="class_dw_io_XMLStreamWriter.html">XMLStreamWriter</a>, then upload the file with
     *  <a href="class_dw_net_FTPClient.html#dw_net_FTPClient_putBinary_String_File_DetailAnchor">FTPClient.putBinary(String, File)</a>,
     *  <a href="class_dw_net_SFTPClient.html#dw_net_SFTPClient_putBinary_String_File_DetailAnchor">SFTPClient.putBinary(String, File)</a>, or
     *  <a href="class_dw_net_WebDAVClient.html#dw_net_WebDAVClient_put_String_File_DetailAnchor">WebDAVClient.put(String, File)</a>.
     *  </p><p>
     *  <b>Note:</b> when this class is used with sensitive data, be careful in persisting sensitive information to disk.</p>
     */
    class StringWriter extends dw.io.Writer {
      /**
       * Creates a new StringWriter.
       *
       */
      constructor();

      /**
       * Returns a string representation of this writer.
       *
       * @return a string representation of this writer.
       */
      toString(): string;
      /**
       * Write the given string to the stream.
       * @param str the string to write to the stream.
       */
      write(str: string): void;
      /**
       * Write the given string to the stream.
       * @param str the string to write to the stream.
       * @param off the offset from which to start writing characters to the stream.
       * @param len the number of characters to write from the stream.
       */
      write(str: string, off: number, len: number): void;
    }

    /**
     * The class supports writing characters to a stream.
     *  <p>
     *  <b>Note:</b> when this class is used with sensitive data, be careful in persisting sensitive information to disk.</p>
     */
    class Writer {
      /**
       * Closes the writer.
       *
       */
      close(): void;
      /**
       * Flushes the buffer.
       *
       */
      flush(): void;
      /**
       * Write the given string to the stream.
       * @param str the string to write to the stream.
       */
      write(str: string): void;
      /**
       * Write the given string to the stream.
       * @param str the string to write to the stream.
       * @param off the offset from which to start writing characters to the stream.
       * @param len the number of characters to write from the stream.
       */
      write(str: string, off: number, len: number): void;
    }

    /**
     * A XMLIndentingStreamWriter writes the XML output formatted for good
     *  readability.
     *  <p>
     *  <b>Note:</b> when this class is used with sensitive data, be careful
     *  in persisting sensitive information to disk.</p>
     */
    class XMLIndentingStreamWriter extends dw.io.XMLStreamWriter {
      /**
       * The indent.
       */
      indent: string;
      /**
       * The string that is used for a new line character. The
       *  default is the normal new line character.
       */
      newLine: string;

      /**
       * Constructs the writer for the specified writer.
       * @param writer the writer to use.
       */
      constructor(writer: dw.io.Writer);

      /**
       * Returns the indent.
       *
       * @return Returns the indent.
       */
      getIndent(): string;
      /**
       * Returns the string that is used for a new line character. The
       *  default is the normal new line character.
       *
       * @return the new line.
       */
      getNewLine(): string;
      /**
       * Specifies a string that will be used as identing characters. The
       *  default are two space characters.
       * @param indent The indent to set.
       */
      setIndent(indent: string): void;
      /**
       * Sets the string that is used for a new line character.
       * @param newLine The newLine to set.
       */
      setNewLine(newLine: string): void;
    }

    /**
     * Useful constants for working with XML streams.
     */
    class XMLStreamConstants {
      /**
       * Represents an attribute in an element.
       */
      static readonly ATTRIBUTE = 10;
      /**
       * Represents a CDATA section in an element.
       */
      static readonly CDATA = 12;
      /**
       * Represents the character data in an XML document.
       */
      static readonly CHARACTERS = 4;
      /**
       * Represents a comment in an XML document.
       */
      static readonly COMMENT = 5;
      /**
       * Represents the document type definition.
       */
      static readonly DTD = 11;
      /**
       * Represents the end of an XML document.
       */
      static readonly END_DOCUMENT = 8;
      /**
       * Represents the end of an element in an XML document.
       */
      static readonly END_ELEMENT = 2;
      /**
       * Represents the entity declaration in an XML document.
       */
      static readonly ENTITY_DECLARATION = 15;
      /**
       * Represents an entity reference in an XML document.
       */
      static readonly ENTITY_REFERENCE = 9;
      /**
       * Represents a namespace declaration in an XML document.
       */
      static readonly NAMESPACE = 13;
      /**
       * Represents the notation declaration in an XML document.
       */
      static readonly NOTATION_DECLARATION = 14;
      /**
       * Represents processing instruction in an XML document.
       */
      static readonly PROCESSING_INSTRUCTION = 3;
      /**
       * Represents a space in an XML document.
       */
      static readonly SPACE = 6;
      /**
       * Represents the start of an XML document.
       */
      static readonly START_DOCUMENT = 7;
      /**
       * Represents the start of an element in an XML document.
       */
      static readonly START_ELEMENT = 1;

      constructor();
    }

    /**
     * The XMLStreamReader allows forward, read-only access to XML.  It is designed
     *  to be the lowest level and most efficient way to read XML data.
     *
     *  <p> The XMLStreamReader is designed to iterate over XML using
     *  next() and hasNext().  The data can be accessed using methods such as getEventType(),
     *  getNamespaceURI(), getLocalName() and getText();</p>
     *
     *  <p> The <a href="class_dw_io_XMLStreamReader.html#dw_io_XMLStreamReader_next_DetailAnchor">next()</a> method causes the reader to read the next parse event.
     *  The next() method returns an integer which identifies the type of event just read.</p>
     *  <p> The event type can be determined using <a href="class_dw_io_XMLStreamReader.html#dw_io_XMLStreamReader_getEventType_DetailAnchor">getEventType()</a>.</p>
     *  <p> Parsing events are defined as the XML Declaration, a DTD,
     *  start tag, character data, white space, end tag, comment,
     *  or processing instruction.  An attribute or namespace event may be encountered
     *  at the root level of a document as the result of a query operation.</p>
     *
     *  <p>The following table describes which methods are valid in what state.
     *  If a method is called in an invalid state the method will throw a
     *  java.lang.IllegalStateException.</p>
     *
     *  <table border="2" rules="all" cellpadding="4">
     *    <thead>
     *      <tr>
     *        <th align="center" colspan="2">
     *          Valid methods for each state
     *        </th>
     *      </tr>
     *    </thead>
     *    <tbody>
     *      <tr>
     *        <th>Event Type</th>
     *        <th>Valid Methods</th>
     *      </tr>
     *      <tr>
     *        <td> All States  </td>
     *        <td> getProperty(), hasNext(), require(), close(),
     *             getNamespaceURI(), isStartElement(),
     *             isEndElement(), isCharacters(), isWhiteSpace(),
     *             getNamespaceContext(), getEventType(),getLocation(),
     *             hasText(), hasName()
     *        </td>
     *      </tr>
     *      <tr>
     *        <td> START_ELEMENT  </td>
     *        <td> next(), getName(), getLocalName(), hasName(), getPrefix(),
     *             getAttributeXXX(), isAttributeSpecified(),
     *             getNamespaceXXX(),
     *             getElementText(), nextTag(), getXMLObject()
     *        </td>
     *      </tr>
     *      <tr>
     *        <td> ATTRIBUTE  </td>
     *        <td> next(), nextTag()
     *             getAttributeXXX(), isAttributeSpecified(),
     *        </td>
     *      </tr>
     *      <tr>
     *        <td> NAMESPACE  </td>
     *        <td> next(), nextTag()
     *             getNamespaceXXX()
     *        </td>
     *      </tr>
     *      <tr>
     *        <td> END_ELEMENT  </td>
     *        <td> next(), getName(), getLocalName(), hasName(), getPrefix(),
     *             getNamespaceXXX(), nextTag()
     *       </td>
     *      </tr>
     *      <tr>
     *        <td> CHARACTERS  </td>
     *        <td> next(), getTextXXX(), nextTag() </td>
     *      </tr>
     *      <tr>
     *        <td> CDATA  </td>
     *        <td> next(), getTextXXX(), nextTag() </td>
     *      </tr>
     *      <tr>
     *        <td> COMMENT  </td>
     *        <td> next(), getTextXXX(), nextTag() </td>
     *      </tr>
     *      <tr>
     *        <td> SPACE  </td>
     *        <td> next(), getTextXXX(), nextTag() </td>
     *      </tr>
     *      <tr>
     *        <td> START_DOCUMENT  </td>
     *        <td> next(), getEncoding(), getVersion(), isStandalone(), standaloneSet(),
     *             getCharacterEncodingScheme(), nextTag()</td>
     *      </tr>
     *      <tr>
     *        <td> END_DOCUMENT  </td>
     *        <td> close()</td>
     *      </tr>
     *      <tr>
     *        <td> PROCESSING_INSTRUCTION  </td>
     *        <td> next(), getPITarget(), getPIData(), nextTag() </td>
     *      </tr>
     *      <tr>
     *        <td> ENTITY_REFERENCE  </td>
     *        <td> next(), getLocalName(), getText(), nextTag() </td>
     *      </tr>
     *      <tr>
     *        <td> DTD  </td>
     *        <td> next(), getText(), nextTag() </td>
     *      </tr>
     *    </tbody>
     *   </table>
     *
     *  <p>
     *
     *  The following is a code sample to read an XML file containing multiple
     *  &quot;myobject&quot; sub-elements.  Only one myObject instance is kept in memory at
     *  any given time to keep memory consumption low:
     *
     *  </p><pre> var fileReader : FileReader = new FileReader(file, &quot;UTF-8&quot;);
     *  var xmlStreamReader : XMLStreamReader = new XMLStreamReader(fileReader);
     *
     *  while (xmlStreamReader.hasNext())
     *  {
     *    if (xmlStreamReader.next() == XMLStreamConstants.START_ELEMENT)
     *    {
     *      var localElementName : String = xmlStreamReader.getLocalName();
     *      if (localElementName == &quot;myobject&quot;)
     *      {
     *        // read single &quot;myobject&quot; as XML
     *        var myObject : XML = xmlStreamReader.getXMLObject();
     *
     *        // process myObject
     *      }
     *    }
     *  }
     *
     *  xmlStreamReader.close();
     *  fileReader.close();
     *  </pre>
     */
    class XMLStreamReader {
      /**
       * The count of attributes on this START_ELEMENT,
       *  this method is only valid on a START_ELEMENT or ATTRIBUTE.  This
       *  count excludes namespace definitions.  Attribute indices are
       *  zero-based.
       */
      readonly attributeCount: number;
      /**
       * The character encoding declared on the XML declaration
       *  Returns null if none was declared.
       */
      readonly characterEncodingScheme: string;
      /**
       * Identifies if the cursor points to a character data event.
       */
      readonly characters: boolean;
      /**
       * The column number where the current event ends or -1 if none is
       *  available.
       */
      readonly columnNumber: number;
      /**
       * Reads the content of a text-only element, an exception is thrown if this is not a text-only element. This method
       *  always returns coalesced content.
       *  Precondition: the current event is START_ELEMENT.
       *  Postcondition: the current event is the corresponding END_ELEMENT.
       *  The method does the following (implementations are free to be optimized but must do equivalent processing):
       *
       *   if ( getEventType() != XMLStreamConstants.START_ELEMENT )
       *  {
       *      throw new XMLStreamException( "parser must be on START_ELEMENT to read next text", getLocation() );
       *  }
       *  int eventType = next();
       *  StringBuffer content = new StringBuffer();
       *  while ( eventType != XMLStreamConstants.END_ELEMENT )
       *  {
       *      if ( eventType == XMLStreamConstants.CHARACTERS || eventType == XMLStreamConstants.CDATA
       *          || eventType == XMLStreamConstants.SPACE || eventType == XMLStreamConstants.ENTITY_REFERENCE )
       *      {
       *          buf.append( getText() );
       *      }
       *      else if ( eventType == XMLStreamConstants.PROCESSING_INSTRUCTION || eventType == XMLStreamConstants.COMMENT )
       *      {
       *          // skipping
       *      }
       *      else if ( eventType == XMLStreamConstants.END_DOCUMENT )
       *      {
       *          throw new XMLStreamException( "unexpected end of document when reading element text content", this );
       *      }
       *      else if ( eventType == XMLStreamConstants.START_ELEMENT )
       *      {
       *          throw new XMLStreamException( "element text content may not contain START_ELEMENT", getLocation() );
       *      }
       *      else
       *      {
       *          throw new XMLStreamException( "Unexpected event type " + eventType, getLocation() );
       *      }
       *      eventType = next();
       *  }
       *  return buf.toString();
       */
      readonly elementText: string;
      /**
       * Return input encoding if known or null if unknown.
       */
      readonly encoding: string;
      /**
       * Identifies if the cursor points to an end tag.
       */
      readonly endElement: boolean;
      /**
       * An integer code that indicates the type
       *  of the event the cursor is pointing to.
       */
      readonly eventType: number;
      /**
       * The line number where the current event ends or -1 if none is
       *  available.
       */
      readonly lineNumber: number;
      /**
       * The (local) name of the current event.
       *  For START_ELEMENT or END_ELEMENT returns the (local) name of the current element.
       *  For ENTITY_REFERENCE it returns entity name.
       *  The current event must be START_ELEMENT or END_ELEMENT,
       *  or ENTITY_REFERENCE.
       */
      readonly localName: string;
      /**
       * The count of namespaces declared on this START_ELEMENT or END_ELEMENT,
       *  this method is only valid on a START_ELEMENT, END_ELEMENT or NAMESPACE. On
       *  an END_ELEMENT the count is of the namespaces that are about to go
       *  out of scope.  This is the equivalent of the information reported
       *  by SAX callback for an end element event.
       */
      readonly namespaceCount: number;
      /**
       * If the current event is a START_ELEMENT or END_ELEMENT  this method
       *  returns the URI of the prefix or the default namespace.
       *  Returns null if the event does not have a prefix.
       */
      readonly namespaceURI: string;
      /**
       * Get the data section of a processing instruction.
       */
      readonly PIData: string;
      /**
       * Get the target of a processing instruction.
       */
      readonly PITarget: string;
      /**
       * The prefix of the current event or null if the event does not have a prefix
       */
      readonly prefix: string;
      /**
       * Get the standalone declaration from the xml declaration.
       */
      readonly standalone: boolean;
      /**
       * Identifies if the cursor points to a start tag.
       */
      readonly startElement: boolean;
      /**
       * The current value of the parse event as a string,
       *  this returns the string value of a CHARACTERS event,
       *  returns the value of a COMMENT, the replacement value
       *  for an ENTITY_REFERENCE, the string value of a CDATA section,
       *  the string value for a SPACE event,
       *  or the String value of the internal subset of the DTD.
       *  If an ENTITY_REFERENCE has been resolved, any character data
       *  will be reported as CHARACTERS events.
       */
      readonly text: string;
      /**
       * The length of the sequence of characters for this
       *  Text event within the text character array.
       */
      readonly textLength: number;
      /**
       * The offset into the text character array where the first
       *  character (of this text event) is stored.
       */
      readonly textStart: number;
      /**
       * Get the xml version declared on the xml declaration.
       *  Returns null if none was declared.
       */
      readonly version: string;
      /**
       * Identifies if the cursor points to a character data event
       *  that consists of all whitespace.
       */
      readonly whiteSpace: boolean;
      /**
       * Reads a sub-tree of the XML document and parses it as XML object.
       *
       *  The stream must be positioned on a START_ELEMENT. Do not call the method
       *  when the stream is positioned at document's root element. This would
       *  cause the whole document to be parsed into a single XML what may lead to
       *  an out-of-memory condition. Instead use #next() to navigate to
       *  sub-elements and invoke getXMLObject() there. Do not keep references to
       *  more than the currently processed XML to keep memory consumption low. The
       *  method reads the stream up to the matching END_ELEMENT. When the method
       *  returns the current event is the END_ELEMENT event.
       */
      readonly XMLObject: any;

      /**
       * Constructs the stream readon on behalf of the reader.
       * @param reader the reader to use.
       */
      constructor(reader: dw.io.Reader);

      /**
       * Frees any resources associated with this Reader.  This method does not close the
       *  underlying reader.
       *
       */
      close(): void;
      /**
       * Returns the count of attributes on this START_ELEMENT,
       *  this method is only valid on a START_ELEMENT or ATTRIBUTE.  This
       *  count excludes namespace definitions.  Attribute indices are
       *  zero-based.
       *
       * @return returns the number of attributes.
       */
      getAttributeCount(): number;
      /**
       * Returns the localName of the attribute at the provided
       *  index.
       * @param index the position of the attribute.
       * @return the local name of the attribute.
       */
      getAttributeLocalName(index: number): string;
      /**
       * Returns the namespace of the attribute at the provided
       *  index.
       * @param index the position of the attribute
       * @return the namespace URI (can be null)
       */
      getAttributeNamespace(index: number): string;
      /**
       * Returns the prefix of this attribute at the
       *  provided index.
       * @param index the position of the attribute.
       * @return the prefix of the attribute.
       */
      getAttributePrefix(index: number): string;
      /**
       * Returns the XML type of the attribute at the provided
       *  index.
       * @param index the position of the attribute.
       * @return the XML type of the attribute.
       */
      getAttributeType(index: number): string;
      /**
       * Returns the normalized attribute value of the
       *  attribute with the namespace and localName
       *  If the namespaceURI is null the namespace
       *  is not checked for equality
       * @param namespaceURI the namespace of the attribute
       * @param localName the local name of the attribute, cannot be null
       * @return returns the value of the attribute or null if not found.
       */
      getAttributeValue(namespaceURI: string, localName: string): string;
      /**
       * Returns the value of the attribute at the
       *  index.
       * @param index the position of the attribute.
       * @return the attribute value.
       */
      getAttributeValue(index: number): string;
      /**
       * Returns the character encoding declared on the XML declaration
       *  Returns null if none was declared.
       *
       * @return the encoding declared in the document or null.
       */
      getCharacterEncodingScheme(): string;
      /**
       * Returns the column number where the current event ends or -1 if none is
       *  available.
       *
       * @return the column number or -1.
       */
      getColumnNumber(): number;
      /**
       * Reads the content of a text-only element, an exception is thrown if this is not a text-only element. This method
       *  always returns coalesced content.
       *  Precondition: the current event is START_ELEMENT.
       *  Postcondition: the current event is the corresponding END_ELEMENT.
       *  The method does the following (implementations are free to be optimized but must do equivalent processing):
       *
       *   if ( getEventType() != XMLStreamConstants.START_ELEMENT )
       *  {
       *      throw new XMLStreamException( "parser must be on START_ELEMENT to read next text", getLocation() );
       *  }
       *  int eventType = next();
       *  StringBuffer content = new StringBuffer();
       *  while ( eventType != XMLStreamConstants.END_ELEMENT )
       *  {
       *      if ( eventType == XMLStreamConstants.CHARACTERS || eventType == XMLStreamConstants.CDATA
       *          || eventType == XMLStreamConstants.SPACE || eventType == XMLStreamConstants.ENTITY_REFERENCE )
       *      {
       *          buf.append( getText() );
       *      }
       *      else if ( eventType == XMLStreamConstants.PROCESSING_INSTRUCTION || eventType == XMLStreamConstants.COMMENT )
       *      {
       *          // skipping
       *      }
       *      else if ( eventType == XMLStreamConstants.END_DOCUMENT )
       *      {
       *          throw new XMLStreamException( "unexpected end of document when reading element text content", this );
       *      }
       *      else if ( eventType == XMLStreamConstants.START_ELEMENT )
       *      {
       *          throw new XMLStreamException( "element text content may not contain START_ELEMENT", getLocation() );
       *      }
       *      else
       *      {
       *          throw new XMLStreamException( "Unexpected event type " + eventType, getLocation() );
       *      }
       *      eventType = next();
       *  }
       *  return buf.toString();
       *
       */
      getElementText(): string;
      /**
       * Return input encoding if known or null if unknown.
       *
       * @return the encoding of this instance or null
       */
      getEncoding(): string;
      /**
       * Returns an integer code that indicates the type
       *  of the event the cursor is pointing to.
       *
       * @return an integer code that indicates the type of the event the cursor is pointing to.
       */
      getEventType(): number;
      /**
       * Returns the line number where the current event ends or -1 if none is
       *  available.
       *
       * @return the line number or -1.
       */
      getLineNumber(): number;
      /**
       * Returns the (local) name of the current event.
       *  For START_ELEMENT or END_ELEMENT returns the (local) name of the current element.
       *  For ENTITY_REFERENCE it returns entity name.
       *  The current event must be START_ELEMENT or END_ELEMENT,
       *  or ENTITY_REFERENCE.
       *
       * @return the local name.
       */
      getLocalName(): string;
      /**
       * Returns the count of namespaces declared on this START_ELEMENT or END_ELEMENT,
       *  this method is only valid on a START_ELEMENT, END_ELEMENT or NAMESPACE. On
       *  an END_ELEMENT the count is of the namespaces that are about to go
       *  out of scope.  This is the equivalent of the information reported
       *  by SAX callback for an end element event.
       *
       * @return returns the number of namespace declarations on this specific element.
       */
      getNamespaceCount(): number;
      /**
       * Returns the prefix for the namespace declared at the
       *  index.  Returns null if this is the default namespace
       *  declaration.
       * @param index the position of the namespace declaration.
       * @return returns the namespace prefix.
       */
      getNamespacePrefix(index: number): string;
      /**
       * Return the uri for the given prefix.
       *  The uri returned depends on the current state of the processor.
       *
       *  NOTE:The 'xml' prefix is bound as defined in
       *  Namespaces in XML
       *  specification to "http://www.w3.org/XML/1998/namespace".
       *
       *  NOTE: The 'xmlns' prefix must be resolved to following namespace
       *  http://www.w3.org/2000/xmlns/
       * @param prefix The prefix to lookup, may not be null
       * @return the uri bound to the given prefix or null if it is not bound
       */
      getNamespaceURI(prefix: string): string;
      /**
       * Returns the uri for the namespace declared at the
       *  index.
       * @param index the position of the namespace declaration.
       * @return returns the namespace uri.
       */
      getNamespaceURI(index: number): string;
      /**
       * If the current event is a START_ELEMENT or END_ELEMENT  this method
       *  returns the URI of the prefix or the default namespace.
       *  Returns null if the event does not have a prefix.
       *
       * @return the URI bound to this elements prefix, the default namespace, or null.
       */
      getNamespaceURI(): string;
      /**
       * Get the data section of a processing instruction.
       *
       * @return the data or null.
       */
      getPIData(): string;
      /**
       * Get the target of a processing instruction.
       *
       * @return the target or null.
       */
      getPITarget(): string;
      /**
       * Returns the prefix of the current event or null if the event does not have a prefix
       *
       * @return the prefix or null.
       */
      getPrefix(): string;
      /**
       * Returns the current value of the parse event as a string,
       *  this returns the string value of a CHARACTERS event,
       *  returns the value of a COMMENT, the replacement value
       *  for an ENTITY_REFERENCE, the string value of a CDATA section,
       *  the string value for a SPACE event,
       *  or the String value of the internal subset of the DTD.
       *  If an ENTITY_REFERENCE has been resolved, any character data
       *  will be reported as CHARACTERS events.
       *
       * @return the current text or null.
       */
      getText(): string;
      /**
       * Returns the length of the sequence of characters for this
       *  Text event within the text character array.
       *
       * @return the length of the sequence of characters for this Text event within the text character array.
       */
      getTextLength(): number;
      /**
       * Returns the offset into the text character array where the first
       *  character (of this text event) is stored.
       *
       * @return the offset into the text character array where the first character (of this text event) is stored.
       */
      getTextStart(): number;
      /**
       * Get the xml version declared on the xml declaration.
       *  Returns null if none was declared.
       *
       * @return the XML version or null.
       */
      getVersion(): string;
      /**
       * Reads a sub-tree of the XML document and parses it as XML object.
       *
       *  The stream must be positioned on a START_ELEMENT. Do not call the method
       *  when the stream is positioned at document's root element. This would
       *  cause the whole document to be parsed into a single XML what may lead to
       *  an out-of-memory condition. Instead use #next() to navigate to
       *  sub-elements and invoke getXMLObject() there. Do not keep references to
       *  more than the currently processed XML to keep memory consumption low. The
       *  method reads the stream up to the matching END_ELEMENT. When the method
       *  returns the current event is the END_ELEMENT event.
       *
       */
      getXMLObject(): any;
      /**
       * Identifies if the current event has a name (is a START_ELEMENT or END_ELEMENT)
       *
       * @return true if the current event has a name, false otherwise.
       */
      hasName(): boolean;
      /**
       * Returns true if there are more parsing events and false
       *  if there are no more events.  This method will return
       *  false if the current state of the XMLStreamReader is
       *  END_DOCUMENT
       *
       * @return true if there are more events, false otherwise
       */
      hasNext(): boolean;
      /**
       * Indicates if the current event has text.
       *  The following events have text:
       *  CHARACTERS,DTD ,ENTITY_REFERENCE, COMMENT, SPACE.
       *
       * @return true if the current event has text, false otherwise.
       */
      hasText(): boolean;
      /**
       * Identifies if this
       *  attribute was created by default.
       * @param index the position of the attribute.
       * @return true if this is a default attribute, false otherwise.
       */
      isAttributeSpecified(index: number): boolean;
      /**
       * Identifies if the cursor points to a character data event.
       *
       * @return true if the cursor points to character data, false otherwise.
       */
      isCharacters(): boolean;
      /**
       * Identifies if the cursor points to an end tag.
       *
       * @return true if the cursor points to an end tag, false otherwise.
       */
      isEndElement(): boolean;
      /**
       * Get the standalone declaration from the xml declaration.
       *
       * @return true if this is standalone, or false otherwise.
       */
      isStandalone(): boolean;
      /**
       * Identifies if the cursor points to a start tag.
       *
       * @return true if the cursor points to a start tag, false otherwise.
       */
      isStartElement(): boolean;
      /**
       * Identifies if the cursor points to a character data event
       *  that consists of all whitespace.
       *
       * @return true if the cursor points to all whitespace, false otherwise.
       */
      isWhiteSpace(): boolean;
      /**
       * Get next parsing event - a processor may return all contiguous
       *  character data in a single chunk, or it may split it into several chunks.
       *  If the property javax.xml.stream.isCoalescing is set to true
       *  element content must be coalesced and only one CHARACTERS event
       *  must be returned for contiguous element content or
       *  CDATA Sections.
       *
       *  By default entity references must be
       *  expanded and reported transparently to the application.
       *  An exception will be thrown if an entity reference cannot be expanded.
       *  If element content is empty (i.e. content is "") then no CHARACTERS event will be reported.
       *
       *  Given the following XML:
       *  <foo><!--description-->content text<![CDATA[<greeting>Hello</greeting>]]>other content</foo>
       *  The behavior of calling next() when being on foo will be:
       *  1- the comment (COMMENT)
       *  2- then the characters section (CHARACTERS)
       *  3- then the CDATA section (another CHARACTERS)
       *  4- then the next characters section (another CHARACTERS)
       *  5- then the END_ELEMENT
       *
       *  NOTE: empty element (such as <tag/>) will be reported
       *   with  two separate events: START_ELEMENT, END_ELEMENT - This preserves
       *    parsing equivalency of empty element to <tag></tag>.
       *
       *  This method will throw an IllegalStateException if it is called after hasNext() returns false.
       *
       * @return the integer code corresponding to the current parse event
       */
      next(): number;
      /**
       * Skips any white space (isWhiteSpace() returns true), COMMENT,
       *  or PROCESSING_INSTRUCTION,
       *  until a START_ELEMENT or END_ELEMENT is reached.
       *  If other than white space characters, COMMENT, PROCESSING_INSTRUCTION, START_ELEMENT, END_ELEMENT
       *  are encountered, an exception is thrown. This method should
       *  be used when processing element-only content separated by white space.
       *
       *   Precondition: none
       *   Postcondition: the current event is START_ELEMENT or END_ELEMENT
       *  and cursor may have moved over any whitespace event.
       *
       *  Essentially it does the following (implementations are free to optimized
       *  but must do equivalent processing):
       *
       *   int eventType = next();
       *  while ( (eventType == XMLStreamConstants.CHARACTERS && isWhiteSpace() )
       *        || (eventType == XMLStreamConstants.CDATA && isWhiteSpace())
       *        || eventType == XMLStreamConstants.SPACE
       *        || eventType == XMLStreamConstants.PROCESSING_INSTRUCTION
       *        || eventType == XMLStreamConstants.COMMENT )
       *  {
       *      eventType = next();
       *  }
       *  if ( eventType != XMLStreamConstants.START_ELEMENT && eventType != XMLStreamConstants.END_ELEMENT )
       *  {
       *      throw new String XMLStreamException( "expected start or end tag", getLocation() );
       *  }
       *  return eventType;
       *
       * @return the event type of the element read (START_ELEMENT or END_ELEMENT)
       */
      nextTag(): number;
      /**
       * Reads the content of a text-only element, an exception is thrown if this is not a text-only element. This method
       *  always returns coalesced content.
       *  Precondition: the current event is START_ELEMENT.
       *  Postcondition: the current event is the corresponding END_ELEMENT.
       *  The method does the following (implementations are free to be optimized but must do equivalent processing):
       *
       *   if ( getEventType() != XMLStreamConstants.START_ELEMENT )
       *  {
       *      throw new XMLStreamException( "parser must be on START_ELEMENT to read next text", getLocation() );
       *  }
       *  int eventType = next();
       *  StringBuffer content = new StringBuffer();
       *  while ( eventType != XMLStreamConstants.END_ELEMENT )
       *  {
       *      if ( eventType == XMLStreamConstants.CHARACTERS || eventType == XMLStreamConstants.CDATA
       *          || eventType == XMLStreamConstants.SPACE || eventType == XMLStreamConstants.ENTITY_REFERENCE )
       *      {
       *          buf.append( getText() );
       *      }
       *      else if ( eventType == XMLStreamConstants.PROCESSING_INSTRUCTION || eventType == XMLStreamConstants.COMMENT )
       *      {
       *          // skipping
       *      }
       *      else if ( eventType == XMLStreamConstants.END_DOCUMENT )
       *      {
       *          throw new XMLStreamException( "unexpected end of document when reading element text content", this );
       *      }
       *      else if ( eventType == XMLStreamConstants.START_ELEMENT )
       *      {
       *          throw new XMLStreamException( "element text content may not contain START_ELEMENT", getLocation() );
       *      }
       *      else
       *      {
       *          throw new XMLStreamException( "Unexpected event type " + eventType, getLocation() );
       *      }
       *      eventType = next();
       *  }
       *  return buf.toString();
       *
       */
      readElementText(): string;
      /**
       * Reads a sub-tree of the XML document and parses it as XML object.
       *
       *  The stream must be positioned on a START_ELEMENT. Do not call the method
       *  when the stream is positioned at document's root element. This would
       *  cause the whole document to be parsed into a single XML what may lead to
       *  an out-of-memory condition. Instead use #next() to navigate to
       *  sub-elements and invoke getXMLObject() there. Do not keep references to
       *  more than the currently processed XML to keep memory consumption low. The
       *  method reads the stream up to the matching END_ELEMENT. When the method
       *  returns the current event is the END_ELEMENT event.
       *
       */
      readXMLObject(): any;
      /**
       * Test if the current event is of the given type and if the namespace and name match the current
       *  namespace and name of the current event.  If the namespaceURI is null it is not checked for equality,
       *  if the localName is null it is not checked for equality.
       * @param type the event type
       * @param namespaceURI the uri of the event, may be null
       * @param localName the localName of the event, may be null
       */
      require(type: number, namespaceURI: string, localName: string): void;
      /**
       * Identifies if standalone was set in the document.
       *
       * @return true if standalone was set in the document, false otherwise.
       */
      standaloneSet(): boolean;
    }

    /**
     * The XMLStreamWriter can be used to write small and large XML feeds.
     *  <p>
     *  <b>Note:</b> when this class is used with sensitive data, be careful in persisting sensitive information to disk.
     *  </p><p>
     *
     *  The XMLStreamWriter does not perform well-formedness checking on its input.
     *  However the writeCharacters method escapes &apos;&amp;&apos; , &apos;&lt;&apos; and &apos;&gt;&apos;. For attribute
     *  values the writeAttribute method escapes the above characters plus &apos;&quot;&apos; to
     *  ensure that all character content and attribute values are well formed.
     *  </p><p>
     *  The following example illustrates how to use this class:
     *
     *  </p><pre> var fileWriter : FileWriter = new FileWriter(file, &quot;UTF-8&quot;);
     *  var xsw : XMLStreamWriter = new XMLStreamWriter(fileWriter);
     *
     *  xsw.writeStartDocument();
     *  xsw.writeStartElement(&quot;products&quot;);
     *    xsw.writeStartElement(&quot;product&quot;);
     *    xsw.writeAttribute(&quot;id&quot;, &quot;p42&quot;);
     *      xsw.writeStartElement(&quot;name&quot;);
     *        xsw.writeCharacters(&quot;blue t-shirt&quot;);
     *      xsw.writeEndElement();
     *      xsw.writeStartElement(&quot;rating&quot;);
     *        xsw.writeCharacters(&quot;2.0&quot;);
     *      xsw.writeEndElement();
     *    xsw.writeEndElement();
     *  xsw.writeEndElement();
     *  xsw.writeEndDocument();
     *
     *  xsw.close();
     *  fileWriter.close();
     *  </pre>
     *
     *  <p>
     *
     *  The code above will write the following to file:
     *
     *  </p><pre> &lt;?xml version=&quot;1.0&quot; ?&gt;
     *  &lt;products&gt;
     *    &lt;product id=&quot;p42&quot;&gt;
     *      &lt;name&gt;a blue t-shirt&lt;/name&gt;
     *      &lt;rating&gt;2.0&lt;/rating&gt;
     *    &lt;/product&gt;
     *  &lt;/products&gt;
     *  </pre>
     *
     *  Note:  This output has been formatted for readability. See
     *  <a href="class_dw_io_XMLIndentingStreamWriter.html">XMLIndentingStreamWriter</a>.
     */
    class XMLStreamWriter {
      /**
       * The current default name space.
       */
      defaultNamespace: string;

      /**
       * Close this writer and free any resources associated with the
       *  writer.  This method does not close the underlying writer.
       *
       */
      close(): void;
      /**
       * Write any cached data to the underlying output mechanism.
       *
       */
      flush(): void;
      /**
       * Returns the current default name space.
       *
       * @return the current default name space.
       */
      getDefaultNamespace(): string;
      /**
       * Gets the prefix the URI is bound to.
       * @param uri the URI to use.
       * @return the prefix or null.
       */
      getPrefix(uri: string): string;
      /**
       * Binds a URI to the default namespace.
       *  This URI is bound
       *  in the scope of the current START_ELEMENT / END_ELEMENT pair.
       *  If this method is called before a START_ELEMENT has been written
       *  the uri is bound in the root scope.
       * @param uri the uri to bind to the default namespace, may be null.
       */
      setDefaultNamespace(uri: string): void;
      /**
       * Sets the prefix the uri is bound to.  This prefix is bound
       *  in the scope of the current START_ELEMENT / END_ELEMENT pair.
       *  If this method is called before a START_ELEMENT has been written
       *  the prefix is bound in the root scope.
       * @param prefix the prefix to bind to the uri, may not be null.
       * @param uri the uri to bind to the prefix, may be null.
       */
      setPrefix(prefix: string, uri: string): void;
      /**
       * Writes an attribute to the output stream without
       *  a prefix.
       * @param localName the local name of the attribute.
       * @param value the value of the attribute.
       */
      writeAttribute(localName: string, value: string): void;
      /**
       * Writes an attribute to the output stream.
       * @param prefix the prefix for this attribute.
       * @param namespaceURI the uri of the prefix for this attribute.
       * @param localName the local name of the attribute.
       * @param value the value of the attribute.
       */
      writeAttribute(
        prefix: string,
        namespaceURI: string,
        localName: string,
        value: string
      ): void;
      /**
       * Writes an attribute to the output stream.
       * @param namespaceURI the uri of the prefix for this attribute.
       * @param localName the local name of the attribute.
       * @param value the value of the attribute.
       */
      writeAttribute(
        namespaceURI: string,
        localName: string,
        value: string
      ): void;
      /**
       * Writes a CData section.
       * @param data the data contained in the CData Section, may not be null.
       */
      writeCData(data: string): void;
      /**
       * Write text to the output.
       * @param text the value to write.
       */
      writeCharacters(text: string): void;
      /**
       * Writes an XML comment with the data enclosed.
       * @param data the data contained in the comment, may be null.
       */
      writeComment(data: string): void;
      /**
       * Writes the default namespace to the stream.
       * @param namespaceURI the uri to bind the default namespace to.
       */
      writeDefaultNamespace(namespaceURI: string): void;
      /**
       * Write a DTD section.  This string represents the entire doctypedecl production
       *  from the XML 1.0 specification.
       * @param dtd the DTD to be written.
       */
      writeDTD(dtd: string): void;
      /**
       * Writes an empty element tag to the output.
       * @param namespaceURI the uri to bind the tag to, may not be null.
       * @param localName local name of the tag, may not be null.
       */
      writeEmptyElement(namespaceURI: string, localName: string): void;
      /**
       * Writes an empty element tag to the output.
       * @param prefix the prefix of the tag, may not be null.
       * @param localName local name of the tag, may not be null.
       * @param namespaceURI the uri to bind the tag to, may not be null.
       */
      writeEmptyElement(
        prefix: string,
        localName: string,
        namespaceURI: string
      ): void;
      /**
       * Writes an empty element tag to the output.
       * @param localName local name of the tag, may not be null.
       */
      writeEmptyElement(localName: string): void;
      /**
       * Closes any start tags and writes corresponding end tags.
       *
       */
      writeEndDocument(): void;
      /**
       * Writes an end tag to the output relying on the internal
       *  state of the writer to determine the prefix and local name
       *  of the event.
       *
       */
      writeEndElement(): void;
      /**
       * Writes an entity reference.
       * @param name the name of the entity.
       */
      writeEntityRef(name: string): void;
      /**
       * Writes a namespace to the output stream.
       *  If the prefix argument to this method is the empty string,
       *  "xmlns", or null this method will delegate to writeDefaultNamespace.
       * @param prefix the prefix to bind this namespace to.
       * @param namespaceURI the uri to bind the prefix to.
       */
      writeNamespace(prefix: string, namespaceURI: string): void;
      /**
       * Writes a processing instruction.
       * @param target the target of the processing instruction, may not be null.
       */
      writeProcessingInstruction(target: string): void;
      /**
       * Writes a processing instruction.
       * @param target the target of the processing instruction, may not be null.
       * @param data the data contained in the processing instruction, may not be null.
       */
      writeProcessingInstruction(target: string, data: string): void;
      /**
       * Writes the given string directly into the output stream. No checks
       *  regarding the correctness of the XML are done. The caller must ensure
       *  that the final result is a correct XML.
       * @param raw the string to write to the output stream.
       */
      writeRaw(raw: string): void;
      /**
       * Write the XML Declaration. Defaults the XML version to 1.0, and the encoding to utf-8
       *
       */
      writeStartDocument(): void;
      /**
       * Write the XML Declaration. Defaults the XML version to 1.0
       * @param version version of the xml document.
       */
      writeStartDocument(version: string): void;
      /**
       * Write the XML Declaration.  Note that the encoding parameter does
       *  not set the actual encoding of the underlying output.  That must
       *  be set when the instance of the XMLStreamWriter is created using the
       *  XMLOutputFactory.
       * @param encoding encoding of the xml declaration.
       * @param version version of the xml document.
       */
      writeStartDocument(encoding: string, version: string): void;
      /**
       * Writes a start tag to the output.  All writeStartElement methods
       *  open a new scope in the internal namespace context.  Writing the
       *  corresponding EndElement causes the scope to be closed.
       * @param localName local name of the tag, may not be null.
       */
      writeStartElement(localName: string): void;
      /**
       * Writes a start tag to the output.
       * @param namespaceURI the namespaceURI of the prefix to use, may not be null.
       * @param localName local name of the tag, may not be null.
       */
      writeStartElement(namespaceURI: string, localName: string): void;
      /**
       * Writes a start tag to the output.
       * @param prefix the prefix of the tag, may not be null.
       * @param localName local name of the tag, may not be null.
       * @param namespaceURI the uri to bind the prefix to, may not be null.
       */
      writeStartElement(
        prefix: string,
        localName: string,
        namespaceURI: string
      ): void;
    }
  }

  namespace job {
    /**
     * Represents an execution of a job. The job execution can be accessed from a <a href="class_dw_job_JobStepExecution.html">JobStepExecution</a> via
     *  <a href="class_dw_job_JobStepExecution.html#dw_job_JobStepExecution_getJobExecution_DetailAnchor">JobStepExecution.getJobExecution()</a>. If a pipeline is used to implement a step the step execution is available
     *  in the pipeline dictionary under the key &apos;JobStepExecution&apos;. If a script module is used to implement a step the step
     *  execution is available as the second parameter of the module&apos;s function that is used to execute the step, e.g.:
     *
     *  <pre> ...
     *  exports.execute( parameters, stepExecution)
     *  {
     *       ...
     *       var jobExecution = stepExecution.getJobExecution();
     *       ...
     *  }
     *  ...
     *  </pre>
     */
    class JobExecution {
      /**
       * The job context which can be used to share data between steps. NOTE: Steps should be self-contained, the
       *  job context should only be used when necessary and with caution. If two steps which are running in parallel in
       *  the same job store data in the job context using the same key the result is undefined.
       */
      readonly context: dw.util.Map<string, any>;
      /**
       * The ID of this job execution.
       */
      readonly ID: string;
      /**
       * The ID of the job this job execution belongs to.
       */
      readonly jobID: string;

      /**
       * Returns the job context which can be used to share data between steps. NOTE: Steps should be self-contained, the
       *  job context should only be used when necessary and with caution. If two steps which are running in parallel in
       *  the same job store data in the job context using the same key the result is undefined.
       *
       * @return the map that represents the job context.
       */
      getContext(): dw.util.Map<string, any>;
      /**
       * Returns the ID of this job execution.
       *
       * @return the ID of this job execution.
       */
      getID(): string;
      /**
       * Returns the ID of the job this job execution belongs to.
       *
       * @return the ID of the job this job execution belongs to.
       */
      getJobID(): string;
    }

    /**
     * Represents an execution of a step that belongs to a job. The job execution this step execution belongs to can be
     *  accessed via <a href="class_dw_job_JobStepExecution.html#dw_job_JobStepExecution_getJobExecution_DetailAnchor">getJobExecution()</a>. If a pipeline is used to implement a step this step execution is available
     *  in the pipeline dictionary under the key &apos;JobStepExecution&apos;. If a script module is used to implement a step this step
     *  execution is available as the second parameter of the module&apos;s function that is used to execute the step, e.g.:
     *
     *  <pre> ...
     *  exports.execute( parameters, stepExecution)
     *  {
     *       ...
     *       var jobExecution = stepExecution.getJobExecution();
     *       ...
     *  }
     *  ...
     *  </pre>
     */
    class JobStepExecution {
      /**
       * The ID of this step execution.
       */
      readonly ID: string;
      /**
       * The job execution this step execution belongs to.
       */
      readonly jobExecution: dw.job.JobExecution;
      /**
       * The ID of the step this step execution belongs to.
       */
      readonly stepID: string;
      /**
       * The ID of the step type of the step this step execution belongs to.
       */
      readonly stepTypeID: string;

      /**
       * Returns the ID of this step execution.
       *
       * @return the ID of this step execution.
       */
      getID(): string;
      /**
       * Returns the job execution this step execution belongs to.
       *
       * @return the job execution this step execution belongs to.
       */
      getJobExecution(): dw.job.JobExecution;
      /**
       * Returns the value of the parameter of the step this step execution belongs to.
       * @param name The name of the parameter.
       * @return the value of the parameter of the step this step execution belongs to.
       */
      getParameterValue(name: string): any;
      /**
       * Returns the ID of the step this step execution belongs to.
       *
       * @return the ID of the step this step execution belongs to.
       */
      getStepID(): string;
      /**
       * Returns the ID of the step type of the step this step execution belongs to.
       *
       * @return the ID of the step type of the step this step execution belongs to.
       */
      getStepTypeID(): string;
    }
  }

  namespace net {
    /**
     * The FTPClient class supports the FTP commands CD, GET, PUT, DEL, MKDIR, RENAME, and LIST. The FTP connection is
     *  established using passive transfer mode (PASV). The transfer of files can be text or binary.
     *  <p>
     *  <b>Note:</b> when this class is used with sensitive data, be careful in persisting sensitive information to disk.
     *  </p><p>
     *  An example usage is as follows:
     *  </p><p>
     *
     *  </p><pre> <code>
     *   var ftp : FTPClient = new dw.net.FTPClient();
     *   ftp.connect(&quot;my.ftp-server.com&quot;, &quot;username&quot;, &quot;password&quot;);
     *   var data : String = ftp.get(&quot;simple.txt&quot;);
     *   ftp.disconnect();
     *  </code>
     *  </pre>
     *  <p>
     *  The default connection timeout depends on the script context timeout and will be set to a maximum of 30 seconds
     *  (default script context timeout is 10 seconds within storefront requests and 15 minutes within jobs).
     *  </p><p>
     *  <b>IMPORTANT NOTE:</b> Before you can make an outbound FTP connection, the FTP server IP address must be enabled for
     *  outbound traffic at the Commerce Cloud Digital firewall for your POD. Please file a support request to request a new firewall
     *  rule.</p>
     */
    class FTPClient {
      /**
       * The default size for get() returning a File is 5MB
       */
      static readonly DEFAULT_GET_FILE_SIZE = 5242880;
      /**
       * The default size for get() returning a String is 2MB
       */
      static readonly DEFAULT_GET_STRING_SIZE = 2097152;
      /**
       * The maximum size for get() returning a File is forty times the default size for getting a file. The
       *  largest file allowed is 200MB.
       */
      static readonly MAX_GET_FILE_SIZE = 209715200;
      /**
       * The maximum size for get() returning a String is five times the default size for getting a String.
       *  The largest String allowed is 10MB.
       */
      static readonly MAX_GET_STRING_SIZE = 10485760;

      /**
       * Identifies if the FTP client is currently connected to the FTP server.
       */
      readonly connected: boolean;
      /**
       * The reply code from the last FTP action.
       */
      readonly replyCode: number;
      /**
       * The string message from the last FTP action.
       */
      readonly replyMessage: string;
      /**
       * The timeout for this client, in milliseconds.
       */
      timeout: number;

      /**
       * Constructs the FTPClient instance.
       *
       */
      constructor();

      /**
       * Changes the current directory on the remote server to the given path.
       * @param path the new current directory
       * @return true if the directory change was okay
       */
      cd(path: string): boolean;
      /**
       * Connects and logs on to an FTP Server as "anonymous" and returns a boolean indicating success or failure.
       * @param host Name of the FTP sever
       * @return true when connection is successful, false otherwise.
       */
      connect(host: string): boolean;
      /**
       * Connects and logs on to an FTP server and returns a boolean indicating success or failure.
       * @param host Name of the FTP sever
       * @param user User name for the login
       * @param password Password for the login
       * @return true when connection is successful, false otherwise.
       */
      connect(host: string, user: string, password: string): boolean;
      /**
       * Connects and logs on to an FTP Server as "anonymous" and returns a boolean indicating success or failure.
       * @param host Name of the FTP sever
       * @param port Port for FTP server
       * @return true when connection is successful, false otherwise.
       */
      connect(host: string, port: number): boolean;
      /**
       * Connects and logs on to an FTP server and returns a boolean indicating success or failure.
       * @param host Name of the FTP sever
       * @param port Port for FTP server
       * @param user User name for the login
       * @param password Password for the login
       * @return true when connection is successful, false otherwise.
       */
      connect(
        host: string,
        port: number,
        user: string,
        password: string
      ): boolean;
      /**
       * Deletes the remote file on the server identified by the path parameter.
       * @param path the path to the file.
       * @return true if the file was successfully deleted, false otherwise.
       */
      del(path: string): boolean;
      /**
       * The method first logs the current user out from the server and then disconnects from the server.
       *
       */
      disconnect(): void;
      /**
       * Reads the content of a remote file and returns it as a string using "ISO-8859-1" encoding to read it. Read at
       *  most MAX_GET_STRING_SIZE bytes.
       * @param path remote path of the file to be read.
       * @return the contents of the file or null if an error occured while reading the file.
       */
      get(path: string): string;
      /**
       * Reads the content of a remote file and returns it as string using the passed encoding. Read at most
       *  MAX_GET_STRING_SIZE characters.
       * @param path remote path of the file to be read.
       * @param encoding an ISO 8859 character encoding labeled as a string, e.g. "ISO-8859-1"
       * @return the contents of the file or null if an error occurred while reading the file.
       */
      get(path: string, encoding: string): string;
      /**
       * Reads the content of a remote file and returns it as a string using "ISO-8859-1" encoding to read it. Read at
       *  most maxGetSize characters.
       * @param path remote path of the file to be read.
       * @param maxGetSize the maximum bytes fetched from the remote file.
       * @return the contents of the file or null if an error occurred while reading the file.
       */
      get(path: string, maxGetSize: number): string;
      /**
       * Reads the content of a remote file and returns it as a string using the specified encoding. Returns at most
       *  maxGetSize characters.
       * @param path remote path of the file to be read.
       * @param encoding the encoding to use.
       * @param maxGetSize the maximum bytes fetched from the remote file.
       * @return the contents of the file or null if an error occurred while reading the file.
       */
      get(path: string, encoding: string, maxGetSize: number): string;
      /**
       * Reads the content of a remote file and creates a local copy in the given file using the passed string encoding to
       *  read the file content and using the system standard encoding "UTF-8" to write the file. Copies at most
       *  MAX_GET_FILE_SIZE bytes.
       * @param path remote path of the file to be read.
       * @param encoding the encoding to use.
       * @param file the local file name
       * @return true if remote file is fetched and copied into local file.
       */
      get(path: string, encoding: string, file: dw.io.File): boolean;
      /**
       * Reads the content of a remote file and creates a local copy in the given file using the passed string encoding to
       *  read the file content and using the system standard encoding "UTF-8" to write the file. Copies at most maxGetSize
       *  bytes.
       * @param path remote path of the file to be read.
       * @param encoding the encoding to use.
       * @param file the local file name
       * @param maxGetSize the maximum number of bytes to fetch
       * @return true if remote file is fetched and copied into local file.
       */
      get(
        path: string,
        encoding: string,
        file: dw.io.File,
        maxGetSize: number
      ): boolean;
      /**
       * Reads the content of a remote file and creates a local copy in the given file. Copies at most MAX_GET_FILE_SIZE
       *  bytes. The FTP transfer is done in Binary mode.
       * @param path remote path of the file to be read.
       * @param file the local file name
       * @return true if remote file is fetched and copied into local file.
       */
      getBinary(path: string, file: dw.io.File): boolean;
      /**
       * Reads the content of a remote file and creates a local copy in the given file. Copies at most maxGetSize bytes.
       *  The FTP transfer is done in Binary mode.
       * @param path remote path of the file to be read.
       * @param file the local file name
       * @param maxGetSize the maximum number of bytes to fetch
       * @return true if remote file is fetched and copied into local file.
       */
      getBinary(path: string, file: dw.io.File, maxGetSize: number): boolean;
      /**
       * Identifies if the FTP client is currently connected to the FTP server.
       *
       * @return true if the client is currently connected.
       */
      getConnected(): boolean;
      /**
       * Returns the reply code from the last FTP action.
       *
       * @return the reply code from the last FTP action.
       */
      getReplyCode(): number;
      /**
       * Returns the string message from the last FTP action.
       *
       * @return the string message from the last FTP action.
       */
      getReplyMessage(): string;
      /**
       * Returns the timeout for this client, in milliseconds.
       *
       * @return the timeout in milliseconds
       */
      getTimeout(): number;
      /**
       * Returns a list of FTPFileInfo objects containing information about the files in the current directory.
       *
       * @return list of objects with remote file information.
       */
      list(): FTPFileInfo[];
      /**
       * Returns a list of FTPFileInfo objects containing information about the files in the remote directory defined by
       *  the given path.
       * @param path the remote path from which the file info is listed.
       * @return list of objects with remote file information.
       */
      list(path: string): FTPFileInfo[];
      /**
       * Creates a directory
       * @param path the path to the directory to create.
       * @return true if the directory was successfully created, false otherwise.
       */
      mkdir(path: string): boolean;
      /**
       * Puts the specified content to the specified full path using "ISO-8859-1" encoding. The full path must include the
       *  path and the file name. If the content of a local file is to be uploaded, please use method
       *  putBinary(String, File) instead.
       * @param path full path on the remote FTP server where the file will be stored.
       * @param content the content to put.
       * @return true or false indicating success or failure.
       */
      put(path: string, content: string): boolean;
      /**
       * Put the given content to a file on the given full path on the FTP server. The full path must include the path and
       *  the file name. The transformation from String into binary data is done via the encoding provided with the method
       *  call. If the content of a local file is to be uploaded, please use method putBinary(String, File)
       *  instead.
       * @param path the full path on the remote FTP server where the file will be stored.
       * @param content the content to put.
       * @param encoding the encoding to use.
       * @return true or false indicating success or failure.
       */
      put(path: string, content: string, encoding: string): boolean;
      /**
       * Put the content of the given file into a file on the remote FTP server with the given full path. The full path
       *  must include the path and the file name.
       * @param path the full path on the remote FTP server where the file will be stored.
       * @param file the file on the local system, which content is send to the remote FTP server.
       * @return true or false indicating success or failure.
       */
      putBinary(path: string, file: dw.io.File): boolean;
      /**
       * Deletes the remote directory on the server identified by the path parameter. In order to delete the directory
       *  successfully the directory needs to be empty, otherwise the removeDirectory() method will return false.
       * @param path the path to the directory.
       * @return true if the directory was successfully deleted, false otherwise.
       */
      removeDirectory(path: string): boolean;
      /**
       * Renames an existing file.
       * @param from the file that will be renamed.
       * @param to the name of the new file.
       * @return true if the file was successfully renamed, false otherwise.
       */
      rename(from: string, to: string): boolean;
      /**
       * Sets the timeout for connections made with the FTP client to the given number of milliseconds. If the given
       *  timeout is less than or equal to zero, the timeout is set to the same value as the script context timeout but
       *  will only be set to a maximum of 30 seconds.
       *
       *  The maximum and default timeout depend on the script context timeout. The maximum timeout is set to a maximum of
       *  2 minutes. The default timeout for a new client is set to a maximum of 30 seconds.
       *
       *  This method can be called at any time, and will affect the next connection made with this client. It is not
       *  possible to set the timeout for an open connection.
       * @param timeoutMillis timeout, in milliseconds, up to a maximum of 2 minutes.
       */
      setTimeout(timeoutMillis: number): void;
    }

    /**
     * The class is used to store information about a remote file.
     *  <p>
     *  <b>Note:</b> when this class is used with sensitive data, be careful in persisting sensitive information to disk.</p>
     */
    class FTPFileInfo {
      /**
       * Identifies if the file is a directory.
       */
      readonly directory: boolean;
      /**
       * The name of the file.
       */
      readonly name: string;
      /**
       * The size of the file.
       */
      readonly size: number;
      /**
       * The timestamp of the file.
       */
      readonly timestamp: Date;

      /**
       * Constructs the FTPFileInfo instance.
       * @param name the name of the file.
       * @param size the size of the file.
       * @param directory controls if the file is a directory.
       * @param timestamp the timestamp of the file.
       */
      constructor(
        name: string,
        size: number,
        directory: boolean,
        timestamp: Date
      );

      /**
       * Identifies if the file is a directory.
       *
       * @return true if the file is a directory, false otherwise.
       */
      getDirectory(): boolean;
      /**
       * Returns the name of the file.
       *
       * @return the name of the file.
       */
      getName(): string;
      /**
       * Returns the size of the file.
       *
       * @return the size of the file.
       */
      getSize(): number;
      /**
       * Returns the timestamp of the file.
       *
       * @return the timestamp of the file.
       */
      getTimestamp(): Date;
    }

    /**
     * The HTTPClient class supports the HTTP methods GET, POST, HEAD, PUT, PATCH, OPTIONS, and DELETE.
     *  If a secure connection via HTTPS is
     *  established the used server certificate or the signing CAs certificate needs to be imported into the customer key
     *  store via Business Manager. <b>Note:</b> when this class is used with sensitive data, be careful in persisting
     *  sensitive information.
     *
     *  <pre> <code>
     *  var httpClient : HTTPClient = new HTTPClient();
     *  var message : String;
     *  httpClient.open(&apos;GET&apos;, &apos;http://www.myinstance.com/feed.xml&apos;);
     *  httpClient.setTimeout(3000);
     *  httpClient.send();
     *  if (httpClient.statusCode == 200)
     *  {
     *       message = httpClient.text;
     *  }
     *  else
     *  {
     *      // error handling
     *      message=&quot;An error occurred with status code &quot;+httpClient.statusCode;
     *  }
     *  </code>
     *  </pre>
     */
    class HTTPClient {
      /**
       * The default size for sendAndReceiveToFile() returning a File is 5MB deprecated in favor of
       *  MAX_GET_FILE_SIZE
       */
      static readonly DEFAULT_GET_FILE_SIZE = 5242880;
      /**
       * The maximum permitted size (in bytes) of an HTTP response when calling operations which write the response to
       *  file. (200MB)
       */
      static readonly MAX_GET_FILE_SIZE = 209715200;
      /**
       * The maximum permitted size (in bytes) of an HTTP response when calling operations which store the response in
       *  memory. (10MB)
       */
      static readonly MAX_GET_MEM_SIZE = 10485760;

      /**
       * All response headers as a map containing the name and value of the response header.
       */
      readonly allResponseHeaders: dw.util.HashMap<
        string,
        dw.util.List<string>
      >;
      /**
       * The returned message body as text for HTTP status code greater or equal to 400. Error messages are not
       *  written to the response file.
       */
      readonly errorText: string;
      /**
       * All response headers as a map in which each entry represents an individual header. The key of the entry
       *  holds the header name and the entry value holds a list of all header values.
       */
      readonly responseHeaders: dw.util.List<string>;
      /**
       * The status code of the last HTTP operation.
       */
      readonly statusCode: number;
      /**
       * The message text of the last HTTP operation.
       */
      readonly statusMessage: string;
      /**
       * The returned message body as text for HTTP status codes between 200 and 299.
       */
      readonly text: string;
      /**
       * The timeout for this client, in milliseconds.
       */
      timeout: number;

      constructor();

      /**
       * Calling this method enables caching for GET requests.
       *
       *  It basically means that a response is cached, and before making a request the HTTP client looks into the cache to
       *  determine whether the response is already available. Only responses with a status code of 2xx, with a content
       *  length, with a size less then 50k, and which are not intended to be immediately written to a file are cached.
       *
       *  The provided parameter defines the TTL (time to live) for the cached content. A value of 0 disables caching. The
       *  URL and the user name are used as cache keys. The total size of the cacheable content and the number of cached
       *  items is limited and automatically managed by the system. Cache control information send by the remote server is
       *  ignored. Caching HTTP responses should be done very carefully. It is important to ensure that the response really
       *  depends only on the URL and doesn't contain any remote state information or time information which is independent
       *  of the URL. It is also important to verify that the application sends exactly the same URL multiple times.
       * @param ttl the TTL for the cached content in secs
       */
      enableCaching(ttl: number): void;
      /**
       * Returns all response headers as a map containing the name and value of the response header.
       *
       * @return a map containing the names and corresponding values of the response headers.
       */
      getAllResponseHeaders(): dw.util.HashMap<string, dw.util.List<string>>;
      /**
       * Returns the returned message body as text for HTTP status code greater or equal to 400. Error messages are not
       *  written to the response file.
       *
       * @return the returned message body as text.
       */
      getErrorText(): string;
      /**
       * Returns a specific response header from the last HTTP operation. The method returns null if the specific header
       *  was not returned.
       * @param header the name of the response header to locate.
       * @return the value of the specified header or null if the header cannot be found.
       */
      getResponseHeader(header: string): string;
      /**
       * Returns all the values of a response header from the last HTTP operation as a list of strings. This reflects the
       *  fact that a specific header, e.g. "Set-Cookie", may be set multiple times. In case there is no such
       *  header, the method returns an empty list.
       * @param name The name of the response header to locate.
       * @return The values of the specified header as a list of strings or an empty list if the header cannot be found.
       */
      getResponseHeaders(name: string): dw.util.List<string>;
      /**
       * Returns all response headers as a map in which each entry represents an individual header. The key of the entry
       *  holds the header name and the entry value holds a list of all header values.
       *
       * @return A map containing the names and corresponding values of the response headers.
       */
      getResponseHeaders(): dw.util.List<string>;
      /**
       * Returns the status code of the last HTTP operation.
       *
       * @return the status code of the last HTTP operation.
       */
      getStatusCode(): number;
      /**
       * Returns the message text of the last HTTP operation.
       *
       * @return the message text of the last HTTP operation.
       */
      getStatusMessage(): string;
      /**
       * Returns the returned message body as text for HTTP status codes between 200 and 299.
       *
       * @return the returned message body as text.
       */
      getText(): string;
      /**
       * Returns the returned message body as text for HTTP status codes between 200 and 299.
       * @param encoding the character encoding to use.
       * @return String the encoded String.
       */
      getText(encoding: string): string;
      /**
       * Returns the timeout for this client, in milliseconds.
       *
       * @return the timeout in milliseconds
       */
      getTimeout(): number;
      /**
       * Opens the specified URL using the specified method. The following methods are supported: GET, POST, HEAD, PUT,
       *  PATCH, OPTIONS, and DELETE
       * @param method the method to use for opening the URL.
       * @param url the url to open.
       */
      open(method: string, url: string): void;
      /**
       * Deprecated method.
       * @param method the method to use for opening the URL.
       * @param url the url to open.
       * @param async true if asynchronous.
       * @param user name of the user.
       * @param password password.
       */
      open(
        method: string,
        url: string,
        async: boolean,
        user: string,
        password: string
      ): void;
      /**
       * Opens the specified URL with the in parameter method specified Http method with given credentials [user,
       *  password] using HTTP basic authentication. The following methods are supported: GET, POST, HEAD, PUT,
       *  PATCH, OPTIONS, and DELETE
       * @param method HTTP method
       * @param url the url
       * @param user name of the user
       * @param password password
       */
      open(method: string, url: string, user: string, password: string): void;
      /**
       * Sends an HTTP request.
       *
       */
      send(): void;
      /**
       * This method performs the actual HTTP communication. The text is sent as a request body. If the text is null no
       *  data will be send to the HTTP server.
       * @param text text String to be sent as request body.
       */
      send(text: string): void;
      /**
       * This method performs the actual HTTP communication. The text is sent as a request body. If the text is null no
       *  data will be send to the HTTP server.
       * @param text text String to be sent as request body.
       * @param encoding character encoding name.
       */
      send(text: string, encoding: string): void;
      /**
       * This method performs the actual HTTP communication. Sends the file to the HTTP server. The file content is sent
       *  as a request body and is sent "as-is" (text or binary).
       * @param file File to be sent.
       */
      send(file: dw.io.File): void;
      /**
       * This method performs the actual HTTP communication. If the file is null no data will be send to the HTTP server.
       *  If this method is used with a GET then the file parameter will contain the contents retrieved. When using this
       *  method with a PUT/POST then the contents of the file parameter will be sent to the server.
       * @param file local file used to read from or write to, depending on the method used.
       * @return true if the returned code was a positive status code
       */
      sendAndReceiveToFile(file: dw.io.File): boolean;
      /**
       * This method performs the actual HTTP communication. If the text is null no data will be send to the HTTP server.
       * @param text text String to be sent.
       * @param outFile local file to write to.
       * @return true if the returned code was a positive status code
       */
      sendAndReceiveToFile(text: string, outFile: dw.io.File): boolean;
      /**
       * This method performs the actual HTTP communication. If the text is null no data will be send to the HTTP server.
       * @param text text String to be sent.
       * @param encoding character encoding name.
       * @param outFile local file to write to.
       * @return true if the returned code was a positive status code
       */
      sendAndReceiveToFile(
        text: string,
        encoding: string,
        outFile: dw.io.File
      ): boolean;
      /**
       * Sends a multipart HTTP request. This method should only be called if the connection to the remote URL was opened
       *  with a POST or PATCH method. All other methods will result in an exception being thrown. The request is constructed
       *  from the passed array of parts.
       * @param parts List of part objects representing either string or file parts.
       * @return true if the returned code was a positive status code.
       */
      sendMultiPart(...parts: dw.net.HTTPRequestPart[]): boolean;
      /**
       * Sets a request header for the next HTTP operation.
       * @param key the request header.
       * @param value the request headers' value.
       */
      setRequestHeader(key: string, value: string): void;
      /**
       * Sets the timeout for connections made with this client to the given number of milliseconds. If the given timeout
       *  is less than or equal to zero, the timeout is set to a maximum value of 2 or 15 minutes, depending on the
       *  context.
       *
       *  This timeout value controls both the "connection timeout" (how long it takes to connect to the remote host) and
       *  the "socket timeout" (how long, after connecting, it will wait without any data being read). Therefore, in the
       *  worst case scenario, the total time of inactivity could be twice as long as the specified value.
       *
       *  The maximum timeout is 15 minutes when the client is used in a job, and 2 minutes otherwise. The default timeout
       *  for a new client is the maximum timeout value.
       *
       *  This method can be called at any time, and will affect the next connection made with this client. It is not
       *  possible to set the timeout for an open connection.
       *
       *  You should always set a reasonable timeout (e.g., a few seconds). Allowing connections to run long can result
       *  in thread exhaustion.
       * @param timeoutMillis timeout, in milliseconds, up to a maximum of 2 or 15 minutes, depending on the context.
       */
      setTimeout(timeoutMillis: number): void;
    }

    /**
     * Simple class representing a single part in a multi-part HTTP POST request. A
     *  part always has a name, and either a string value or a value which comes from
     *  the contents of a File. For each of the two types, a character encoding may
     *  be specified, and for file parts, a content type may additionally be
     *  specified.
     *  <p>
     *  <b>Note:</b> when this class is used with sensitive data, be careful in persisting sensitive information.</p>
     */
    class HTTPRequestPart {
      /**
       * The content type of this part.
       */
      readonly contentType: string;
      /**
       * Get the charset to be used to encode the string.
       */
      readonly encoding: string;
      /**
       * Get the file value of the part.
       */
      readonly fileValue: dw.io.File;
      /**
       * Get the name of the part.
       */
      readonly name: string;
      /**
       * Get the string value of the part.
       */
      readonly stringValue: string;

      /**
       * Construct a part representing a simple string name/value pair. The HTTP
       *  message uses "US-ASCII" as the default character set for the part.
       * @param name The name of the part.
       * @param value The string to post.
       */
      constructor(name: string, value: string);
      /**
       * Construct a part representing a simple string name/value pair. The HTTP
       *  message uses the specified encoding or "US-ASCII" if null is passed
       *  for the part.
       * @param name The name of the part.
       * @param value The string to post.
       * @param encoding The charset to be used to encode the string, if null the default is used.
       */
      constructor(name: string, value: string, encoding: string);
      /**
       * Construct a part representing a name/File pair. The HTTP message will use
       *  "application/octet-stream" as the content type and "ISO-8859-1" as the character
       *  set for the part.
       * @param name The name of the file part
       * @param file The file to post
       */
      constructor(name: string, file: dw.io.File);
      /**
       * Construct a part representing a name/File pair.
       *
       *
       *  If both contentType and encoding are null, then the part will be defaulted to use "application/octet-stream"
       *  as the content-type and "ISO-8859-1" as the encoding.
       *  If only the encoding is null, then the contentType will be used without an encoding.
       *  If only the contentType is null, then it will be defaulted to "text/plain".
       * @param name The name of the file part
       * @param file The file to post
       * @param contentType The content type for this part, if null or blank the default is used.
       * @param encoding the charset encoding for this part, if null or blank the default is used
       */
      constructor(
        name: string,
        file: dw.io.File,
        contentType: string,
        encoding: string
      );

      /**
       * Returns the content type of this part.
       *
       * @return The content type, or null if content type was not specified.
       */
      getContentType(): string;
      /**
       * Get the charset to be used to encode the string.
       *
       * @return The charset, or null if charset was not specified.
       */
      getEncoding(): string;
      /**
       * Get the file value of the part.
       *
       * @return The file value, or null if this part is not a file part.
       */
      getFileValue(): dw.io.File;
      /**
       * Get the name of the part.
       *
       * @return The part name, never null.
       */
      getName(): string;
      /**
       * Get the string value of the part.
       *
       * @return The string value, or null if this part is is not a string part.
       */
      getStringValue(): string;
    }

    /**
     * This class is used to send an email with either plain text or MimeEncodedText content.
     *  Recipient data (from, to, cc, bcc) and subject are specified
     *  using setter methods. When the <a href="class_dw_net_Mail.html#dw_net_Mail_send_DetailAnchor">send()</a> method is invoked,
     *  the email is put into an internal queue and sent asynchronously.
     *  <p>
     *  <b>Note:</b> when this class is used with sensitive data, be careful in persisting sensitive information to disk.
     *  </p><p>
     *  The following example script sends an email with MimeEncodedText content:
     *
     *  </p><pre> <code>
     *  function sendMail() {
     *   var template: Template = new dw.util.Template(&quot;myTemplate.isml&quot;);
     *
     *   var o: Map = new dw.util.HashMap();
     *   o.put(&quot;customer&quot;,&quot;customer&quot;);
     *   o.put(&quot;product&quot;,&quot;product&quot;);
     *
     *   var content: MimeEncodedText = template.render(o);
     *   var mail: Mail = new dw.net.Mail();
     *   mail.addTo(&quot;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="a0d4cfe0c5d8c1cdd0ccc58ecfd2c7">[email&#xA0;protected]</a>&quot;);
     *   mail.setFrom(&quot;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="dbbda9b4b69bbea3bab6abb7bef5b4a9bc">[email&#xA0;protected]</a>&quot;);
     *   mail.setSubject(&quot;Example Email&quot;);
     *   mail.setContent(content);
     *
     *   mail.send();//returns either Status.ERROR or Status.OK, mail might not be sent yet, when this method returns
     *   }
     *  </code>
     *  </pre>
     *  <p>
     *   See <b>Sending email via scripts or hooks</b> in the documentation for additional examples.</p>
     */
    class Mail {
      /**
       * Gets the bcc address List.
       */
      bcc: dw.util.List<string>;
      /**
       * Gets the cc address List.
       */
      cc: dw.util.List<string>;
      /**
       * Gets the email address to use as the from address for the
       *  email.
       */
      from: string;
      /**
       * Gets the subject of the email.
       */
      subject: string;
      /**
       * Gets the to address List where the email is sent.
       */
      to: dw.util.List<string>;

      constructor();

      /**
       * Adds an address to the bcc List. Address must conform to the RFC822 standard.
       * @param bcc new bcc address to add to bcc address List.
       * @return this Mail object.
       */
      addBcc(bcc: string): dw.net.Mail;
      /**
       * Adds an address to the cc List. The address must conform to RFC822 standard.
       * @param cc new cc address to be added to cc address List.
       * @return this Mail object.
       */
      addCc(cc: string): dw.net.Mail;
      /**
       * Adds an address to the to address List. The address must conform to the RFC822 standard.
       * @param to email address to add to the to address List.
       * @return this Mail object.
       */
      addTo(to: string): dw.net.Mail;
      /**
       * Gets the bcc address List.
       *
       * @return bcc address List or empty List if no bcc addresses are set.
       */
      getBcc(): dw.util.List<string>;
      /**
       * Gets the cc address List.
       *
       * @return cc address List or empty List if no cc addresses are set.
       */
      getCc(): dw.util.List<string>;
      /**
       * Gets the email address to use as the from address for the
       *  email.
       *
       * @return the from address for this mail or null if no from address is set yet.
       */
      getFrom(): string;
      /**
       * Gets the subject of the email.
       *
       * @return subject or null if no subject is set yet.
       */
      getSubject(): string;
      /**
       * Gets the to address List where the email is sent.
       *
       * @return to address List or empty List if no to addresses are set.
       */
      getTo(): dw.util.List<string>;
      /**
       * prepares an email that is queued to the internal mail system for
       *  delivery.
       *
       * @return Status which tells if the mail could be successfully queued ( Status.OK) or not ( Status.ERROR). If an error is raised, more information about the reason for the failure can be found within the log files. If the mandatory fields from, content, and subject are empty an IllegalArgumentException is raised. An IllegalArgumentException is raised if neither to, cc nor bcc are set.
       */
      send(): dw.system.Status;
      /**
       * Sets the bcc address List. If there
       *  are already bcc addresses they are overwritten.
       * @param bcc list of Strings representing RFC822 compliant email addresses. List replaces any previously set list of addresses. Throws an exception if the given list is null.
       * @return this Mail object.
       */
      setBcc(bcc: dw.util.List<any>): dw.net.Mail;
      /**
       * Sets the cc address List where the email is sent. If there are
       *  already cc addresses set, they are overwritten. The address(es) must
       *  conform to the RFC822 standard.
       * @param cc List of Strings representing RFC822 compliant email addresses. This List replaces any previously set List of addresses. Throws an exception if the given List is null.
       * @return this Mail object
       */
      setCc(cc: dw.util.List<any>): dw.net.Mail;
      /**
       * Mandatory Sets the email content. The MIME type is set to
       *  "text/plain;charset=UTF-8" and encoding set to "UTF-8".
       * @param content String containing the content of the email.
       * @return this Mail object.
       */
      setContent(content: string): dw.net.Mail;
      /**
       * Mandatory Sets the email content, MIME type, and encoding. No
       *  validation of MIME type and encoding is done. It is the responsibility of
       *  the caller to specify a valid MIME type and encoding.
       * @param content String containing the content of the mail
       * @param mimeType mime type of the content. For example "text/plain;charset=UTF-8" or "text/html"
       * @param encoding character encoding of the email content. For example UTF-8-8
       * @return this Mail object.
       */
      setContent(
        content: string,
        mimeType: string,
        encoding: string
      ): dw.net.Mail;
      /**
       * Mandatory Uses MimeEncodedText to set the
       *  content, MIME type and encoding.
       * @param mimeEncodedText MimeEncodedText from which the content, MIME type, and encoding information is extracted.
       * @return this Mail object.
       */
      setContent(mimeEncodedText: dw.value.MimeEncodedText): dw.net.Mail;
      /**
       * Mandatory Sets the sender address for this email. The address must
       *  conform to the RFC822 standard.
       * @param from String containing a RFC822 compliant email address
       * @return this Mail object.
       */
      setFrom(from: string): dw.net.Mail;
      /**
       * Mandatory sets the subject for the email. If the subject is not set
       *  or set to null at the time send() is invoked and
       *  IllegalArgumentException is thrown.
       * @param subject subject of the mail to send.
       * @return this Mail object.
       */
      setSubject(subject: string): dw.net.Mail;
      /**
       * Sets the to address List where the email is sent. If there are
       *  already to addresses, they are overwritten.
       * @param to list of Strings representing RFC822 compliant email addresses. List replaces any previously set List of addresses. Throws an exception if the given List is null.
       * @return this Mail object
       */
      setTo(to: dw.util.List<any>): dw.net.Mail;
    }

    /**
     * The SFTPClient class supports the SFTP commands GET, PUT, DEL, MKDIR, RENAME, and LIST. The transfer of files can be
     *  text or binary.
     *  <p>
     *  <b>Note:</b> when this class is used with sensitive data, be careful in persisting sensitive information.
     *  </p><p>
     *  An example usage is as follows:
     *  </p><p>
     *
     *  </p><pre> <code>
     *   var sftp : SFTPClient = new dw.net.SFTPClient();
     *   sftp.connect(&quot;my.sftp-server.com&quot;, &quot;username&quot;, &quot;password&quot;);
     *   var data : String = sftp.get(&quot;simple.txt&quot;);
     *   sftp.disconnect();
     *  </code>
     *  </pre>
     *  <p>
     *  The default connection timeout depends on the script context timeout and will be set to a maximum of 30 seconds
     *  (default script context timeout is 10 seconds within storefront requests and 15 minutes within jobs).
     *  </p><p>
     *  <b>IMPORTANT NOTE:</b> Before you can make an outbound SFTP connection, the SFTP server IP address must be enabled
     *  for outbound traffic at the Commerce Cloud Digital firewall for your POD. Please file a support request to request a new firewall
     *  rule.</p>
     */
    class SFTPClient {
      /**
       * The maximum size for get() methods returning a File is 200 MB.
       */
      static readonly MAX_GET_FILE_SIZE = 209715200;
      /**
       * The maximum size for get() methods returning a String is 10 MB.
       */
      static readonly MAX_GET_STRING_SIZE = 10485760;

      /**
       * Identifies if the SFTP client is currently connected to the SFTP server.
       */
      readonly connected: boolean;
      /**
       * The error message from the last SFTP action.
       */
      readonly errorMessage: string;
      /**
       * The timeout for this client, in milliseconds.
       */
      timeout: number;

      /**
       * Constructor.
       *
       */
      constructor();

      /**
       * Adds a known public host key for the next connection attempt.
       *
       *  This method associates the key to the host used in the subsequent connect method, and must be called prior to connect.
       *  The key is not persisted, and is only associated to this instance of the SFTP client.
       *
       *  Multiple keys may added, and the validation will succeed if the remote host matches any of them.
       *
       *  The default behavior is to persist and trust an unknown host key if there are no known host keys available.
       *  If addKnownHostKey is later used to trust specific a specific key or keys, then any previously persisted keys
       *  will be ignored.
       * @param type Type of the host key, such as ssh-rsa
       * @param key Public host key, in the same format as OpenSSH.
       */
      addKnownHostKey(type: string, key: string): void;
      /**
       * Changes the current directory on the remote server to the given path.
       * @param path the new current directory
       * @return true if the directory change was okay
       */
      cd(path: string): boolean;
      /**
       * Connects and logs on to a SFTP server and returns a boolean indicating success or failure.
       * @param host Name of the SFTP sever
       * @param user User name for the login
       * @param password Password for the login
       * @return true when connection is successful, false otherwise.
       */
      connect(host: string, user: string, password: string): boolean;
      /**
       * Connects and logs on to a SFTP server and returns a boolean indicating success or failure.
       * @param host Name of the SFTP sever
       * @param port Port for SFTP server
       * @param user User name for the login
       * @param password Password for the login
       * @return true when connection is successful, false otherwise.
       */
      connect(
        host: string,
        port: number,
        user: string,
        password: string
      ): boolean;
      /**
       * Deletes the remote file on the server identified by the path parameter.
       * @param path the path to the file.
       * @return true if the file was successfully deleted, false otherwise.
       */
      del(path: string): boolean;
      /**
       * The method first logs the current user out from the server and then disconnects from the server.
       *
       */
      disconnect(): void;
      /**
       * Reads the content of a remote file and returns it as a string using "ISO-8859-1" encoding to read it. Files with
       *  at most MAX_GET_STRING_SIZE bytes are read.
       * @param path remote path of the file to be read.
       * @return the contents of the file or null if an error occurred while reading the file.
       */
      get(path: string): string;
      /**
       * Reads the content of a remote file and returns it as a string using the specified encoding. Files with at most
       *  MAX_GET_STRING_SIZE bytes are read.
       * @param path the remote path of the file to be read.
       * @param encoding the encoding to use.
       * @return the contents of the file or null if an error occurred while reading the file.
       */
      get(path: string, encoding: string): string;
      /**
       * Reads the content of a remote file and creates a local copy in the given file using the passed string encoding to
       *  read the file content and using the system standard encoding "UTF-8" to write the file. Copies at most
       *  MAX_GET_FILE_SIZE bytes.
       * @param path the remote path of the file to be read.
       * @param encoding the encoding to use.
       * @param file the local file name
       * @return true if complete remote file is fetched and copied into local file. false, otherwise.
       */
      get(path: string, encoding: string, file: dw.io.File): boolean;
      /**
       * Reads the content of a remote file and creates a local copy in the given file. Copies at most "MAX_GET_FILE_SIZE
       *  bytes. The SFTP transfer is done in binary mode.
       * @param path the remote path of the file to be read.
       * @param file the local file name
       * @return true if complete remote file is fetched and copied into local file. false otherwise
       */
      getBinary(path: string, file: dw.io.File): boolean;
      /**
       * Identifies if the SFTP client is currently connected to the SFTP server.
       *
       * @return true if the client is currently connected.
       */
      getConnected(): boolean;
      /**
       * Returns the error message from the last SFTP action.
       *
       * @return the error message from the last SFTP action
       */
      getErrorMessage(): string;
      /**
       * Returns a SFTPFileInfo objects containing information about the given file/directory path.
       * @param path the remote path from which the file info should be listed.
       * @return the remote file information or null if not present.
       */
      getFileInfo(path: string): dw.net.SFTPFileInfo;
      /**
       * Returns the timeout for this client, in milliseconds.
       *
       * @return the timeout in milliseconds
       */
      getTimeout(): number;
      /**
       * Returns a list of SFTPFileInfo objects containing information about the files in the current directory.
       *
       * @return list of objects with remote file information or null if not present.
       */
      list(): SFTPFileInfo[];
      /**
       * Returns a list of SFTPFileInfo objects containing information about the files in the remote directory defined by
       *  the given path.
       * @param path the remote path from which the file info should be listed.
       * @return list of objects with remote file information or null if not present.
       */
      list(path: string): SFTPFileInfo[];
      /**
       * Creates a directory
       * @param path the path to the directory to create.
       * @return true if the directory was successfully created, false otherwise.
       */
      mkdir(path: string): boolean;
      /**
       * Puts the specified content to the specified path using "ISO-8859-1" encoding. If the content of a local file is
       *  to be uploaded, please use method putBinary(String,File) instead.
       *
       *  NOTE: If the remote file already exists, it is overwritten.
       * @param path the path on the remote SFTP server, where the file will be stored.
       * @param content the content to put.
       * @return true or false indicating success or failure.
       */
      put(path: string, content: string): boolean;
      /**
       * Put the given content to a file on the given path on the SFTP server. The transformation from String into binary
       *  data is done via the encoding provided with the method call. If the content of a local file is to be uploaded,
       *  please use method putBinary(String,File) instead.
       *
       *  NOTE: If the remote file already exists, it is overwritten.
       * @param path the the path on the remote SFTP server, where the file will be stored.
       * @param content the content to put.
       * @param encoding the encoding to use.
       * @return true or false indicating success or failure.
       */
      put(path: string, content: string, encoding: string): boolean;
      /**
       * Put the content of the given file into a file on the remote SFTP server with the given absolute path. NOTE: If
       *  the remote file already exists, it is overwritten.
       * @param path the path on the remote SFTP server where the file will be stored.
       * @param file the file on the local system, which content is send to the remote SFTP server.
       * @return true or false indicating success or failure.
       */
      putBinary(path: string, file: dw.io.File): boolean;
      /**
       * Deletes the remote directory on the server identified by the path parameter. In order to delete the directory
       *  successfully the directory needs to be empty, otherwise the removeDirectory() method will return false.
       * @param path the path to the directory.
       * @return true if the directory was successfully deleted, false otherwise.
       */
      removeDirectory(path: string): boolean;
      /**
       * Renames an existing file.
       * @param from the file that will be renamed.
       * @param to the name of the new file.
       * @return true if the file was successfully renamed, false otherwise.
       */
      rename(from: string, to: string): boolean;
      /**
       * Sets the identity (private key) to use for the next connection attempt.
       *
       *  The key is only associated to this instance of the SFTP client.
       * @param keyRef Reference to the private key
       */
      setIdentity(keyRef: dw.crypto.KeyRef): void;
      /**
       * Sets the timeout for connections made with the SFTP client to the given number of milliseconds. If the given
       *  timeout is less than or equal to zero, the timeout is set to the same value as the script context timeout but
       *  will only be set to a maximum of 30 seconds.
       *
       *  The maximum and default timeout depend on the script context timeout. The maximum timeout is set to a maximum of
       *  2 minutes. The default timeout for a new client is set to a maximum of 30 seconds.
       *
       *  This method can be called at any time, and will affect the next connection made with this client. It is not
       *  possible to set the timeout for an open connection.
       * @param timeoutMillis timeout, in milliseconds, up to a maximum of 2 minutes.
       */
      setTimeout(timeoutMillis: number): void;
    }

    /**
     * The class is used to store information about a remote file.
     *  <p>
     *  <b>Note:</b> when this class is used with sensitive data, be careful in persisting sensitive information to disk.</p>
     */
    class SFTPFileInfo {
      /**
       * Identifies if the file is a directory.
       */
      readonly directory: boolean;
      /**
       * The last modification time of the file/directory.
       */
      readonly modificationTime: Date;
      /**
       * The name of the file/directory.
       */
      readonly name: string;
      /**
       * The size of the file/directory.
       */
      readonly size: number;

      /**
       * Constructs the SFTPFileInfo instance.
       * @param name the name of the file.
       * @param size the size of the file.
       * @param directory controls if the file is a directory.
       * @param mtime last modification time.
       */
      constructor(
        name: string,
        size: number,
        directory: boolean,
        mtime: number
      );

      /**
       * Identifies if the file is a directory.
       *
       * @return true if the file is a directory, false otherwise.
       */
      getDirectory(): boolean;
      /**
       * Returns the last modification time of the file/directory.
       *
       * @return the last modification time.
       */
      getModificationTime(): Date;
      /**
       * Returns the name of the file/directory.
       *
       * @return the name.
       */
      getName(): string;
      /**
       * Returns the size of the file/directory.
       *
       * @return the size.
       */
      getSize(): number;
    }

    /**
     * The WebDAVClient class supports the WebDAV methods GET, PUT, MKCOL, MOVE,
     *  COPY, PROPFIND,OPTIONS and DELETE.
     *  <p>
     *  <b>Note:</b> when this class is used with sensitive data, be careful in persisting sensitive information to disk.
     *   The client can be used as shown in the following example:
     *  </p><p>
     *  </p><pre> var webdavClient : WebDAVClient = new WebDAVClient(&quot;http://mywebdav.server.com&quot;,&quot;myusername&quot;, &quot;mypassword&quot;);
     *  var getString : String = webdavClient.get(&quot;myData.xml&quot;,&quot;UTF-8&quot;);
     *  var message : String;
     *
     *  if (webdavClient.succeeded())
     *  {
     *       message = webDavClient.statusText;
     *  }
     *  else
     *  {
     *      // error handling
     *      message=&quot;An error occured with status code &quot;+webdavClient.statusCode;
     *  }
     *
     *  var data : XML = new XML(getString);
     *  </pre>
     *  <p>
     *  The WebDAV client supports the following authentication schemes:
     *  </p><ul>
     *  <li>Basic authentication</li>
     *  <li>Digest authentication</li>
     *  </ul>
     *
     *  The methods of this class do not generally throw exceptions if the underlying
     *  WebDAV operation do not succeed.The result of a WebDAV operation can be
     *  checked using the methods succeeded(), getStatusCode(), and getStatusText().
     *  <p>
     *  Important note: This WebDAV client cannot be used to access the Commerce Cloud Digital
     *  server via WebDAV protocol.</p>
     */
    class WebDAVClient {
      /**
       * The default encoding character set.
       */
      static readonly DEFAULT_ENCODING = "UTF-8";
      /**
       * The default size for get() returning a File is 5MB.
       */
      static readonly DEFAULT_GET_FILE_SIZE = 5242880;
      /**
       * The default size for get() returning a String is 2MB.
       */
      static readonly DEFAULT_GET_STRING_SIZE = 2097152;
      /**
       * The depth of searching a WebDAV destination using the PROPFIND method -
       *  if that depth is given to the PROPFIND method as an input parameter the
       *  destination will be searched only on the level of the given path and a
       *  list of all containing files on that level will be returned [is not
       *  supported by every server].
       */
      static readonly DEPTH_0 = 0;
      /**
       * The depth of searching a WebDAV destination using the PROPFIND method -
       *  if that depth is given to the PROPFIND method as an input parameter the
       *  destination will be searched until one level under the given path and a
       *  list of all containing files in that two levels [/path and one level
       *  underneath] will be returned [is not supported by every server].
       */
      static readonly DEPTH_1 = 1;
      /**
       * The depth of searching a WebDAV destination using the PROPFIND method -
       *  if that depth is given to the PROPFIND method as an input parameter the
       *  destination will be fully searched and a list of all containing files
       *  will be returned [is not supported by every server].
       */
      static readonly DEPTH_INIFINITY = 2147483647;
      /**
       * The maximum size for get() returning a File is forty times
       *  the default size for getting a file. The largest file allowed is 200MB.
       */
      static readonly MAX_GET_FILE_SIZE = 209715200;
      /**
       * The maximum size for get() returning a String is five
       *  times the default size for getting a String. The largest String allowed
       *  is 10MB.
       */
      static readonly MAX_GET_STRING_SIZE = 10485760;

      /**
       * A HashMap of all response headers.
       */
      readonly allResponseHeaders: dw.util.HashMap<
        string,
        dw.util.List<string>
      >;
      /**
       * The status code after the execution of a method.
       */
      readonly statusCode: number;
      /**
       * The status text after the execution of a method.
       */
      readonly statusText: string;

      /**
       * Creates a new client for the use at a server which requires
       *  authentication.
       *  The client supports the following authentication schemes:
       *       - Basic authentication scheme
       *       - Digest authentication scheme
       * @param rootUrl the url of the server one wants to connect to. All commands will be executed by the client relative to that url.
       * @param username username of the user for server authentication.
       * @param password password of the user for server authentication.
       */
      constructor(rootUrl: string, username: string, password: string);
      /**
       * Creates a new client for the use at a server which does not require
       *  authentication.
       * @param rootUrl the url of the server one wants to connect to. All commands will be executed by the client relative to that url.
       */
      constructor(rootUrl: string);

      /**
       * Adds a request header to the next WebDAV call.
       * @param headerName name of the header.
       * @param headerValue value of the header.
       */
      addRequestHeader(headerName: string, headerValue: string): void;
      /**
       * Closes the current connection to the server.
       *
       */
      close(): void;
      /**
       * Copies a file on the server from one place rootUrl/origin
       *  to the other rootUrl/destination. If
       *  destination already exists it gets overwritten. Returns
       *  true if succeeded, otherwise false.
       * @param origin The origin where a file is located, relative to the rootUrl stated when instantiating the client.
       * @param destination The destination where the file should be copied to, relative to the rootUrl stated when instantiating the client.
       * @return true if succeeded, otherwise false.
       */
      copy(origin: string, destination: string): boolean;
      /**
       * Copies a file on the server from one place rootUrl/origin
       *  to the other rootUrl/destination. If
       *  the passed parameter overwrite is true and
       *  destination already exists it gets overwritten. Returns
       *  true if succeeded, otherwise false.
       * @param origin The origin where a file is located, relative to the rootUrl stated when instantiating the client.
       * @param destination The destination where the file should be copied to, relative to the rootUrl stated when instantiating the client.
       * @param overwrite A flag which determines whether the destination gets overwritten if it exists before copying.
       * @return true if succeeded, otherwise false.
       */
      copy(origin: string, destination: string, overwrite: boolean): boolean;
      /**
       * Copies a file on the server from one place rootUrl/origin
       *  to the other rootUrl/destination. If
       *  the passed parameter overwrite is true and
       *  destination already exists it gets overwritten. If the
       *  passed parameter shallow is true a flat copy mechanism is
       *  used.
       *
       *  Returns true if succeeded, otherwise false.
       * @param origin The origin where a file is located, relative to the rootUrl stated when instantiating the client.
       * @param destination The destination where the file should be copied to, relative to the rootUrl stated when instantiating the client.
       * @param overwrite A flag which determines whether the destination gets overwritten if it exits before copying
       * @param shallow A flag which determines how to copy the given data.
       * @return true if succeeded, otherwise false.
       */
      copy(
        origin: string,
        destination: string,
        overwrite: boolean,
        shallow: boolean
      ): boolean;
      /**
       * Deletes a file or directory from the remote server that can be found
       *  under rootUrl/path. Returns true if
       *  succeeded, otherwise false.
       * @param path The path of the file or collection to delete, relative to the rootUrl stated when instantiating the client.
       * @return true if succeeded, otherwise false.
       */
      del(path: string): boolean;
      /**
       * Reads the content of a remote file or directory that can be found under
       *  rootUrl/path and returns a string
       *  representation of the data found in the DEFAULT_ENCODING encoding. If the
       *  remote location is a directory the result depends on the server
       *  configuration, some return an HTML formatted directory listing. Returns
       *  at most DEFAULT_GET_STRING_SIZE bytes.
       * @param path The path of the collection or file one wants to get, relative to the rootUrl stated when instantiating the client.
       * @return returns the String representation of the data found on the given path.
       */
      get(path: string): string;
      /**
       * Reads the content of a remote file or directory that can be found under
       *  rootUrl/path and returns a string
       *  representation of the data found in the given encoding. If
       *  the remote location is a directory the result depends on the server
       *  configuration, some return an HTML formatted directory listing. Returns
       *  at most DEFAULT_GET_STRING_SIZE bytes.
       * @param path The path of the collection or file one wants to get - relative to the rootUrl stated when instantiating the client.
       * @param encoding The encoding of the resulting String.
       * @return returns the String representation of the data found on the given path in the given encoding.
       */
      get(path: string, encoding: string): string;
      /**
       * Reads the content of a remote file or directory that can be found under
       *  rootUrl/path and returns a string
       *  representation of the data found in the given encoding. If
       *  the remote location is a directory the result depends on the server
       *  configuration, some return an HTML formatted directory listing. Returns
       *  at most maxGetSize bytes.
       * @param path The path of the collection or file one wants to get - relative to the rootUrl stated when instantiating the client.
       * @param encoding The encoding of the resulting String.
       * @param maxGetSize The maximum size of data in bytes. Not to exceed MAX_GET_STRING_SIZE.
       * @return returns the String representation of the data found on the given path in the given encoding.
       */
      get(path: string, encoding: string, maxGetSize: number): string;
      /**
       * Reads the content of a remote file or directory that can be found under
       *  rootUrl/path in DEFAULT_ENCODING
       *  encoding and writes a File in the system's standard
       *  encoding, which is "UTF-8". If the remote location is a directory the
       *  result depends on the server configuration, some return an HTML formatted
       *  directory listing. Receives at most DEFAULT_GET_FILE_SIZE bytes which
       *  determines the file size of the local file. Returns true if succeeded
       *  otherwise false.
       * @param path The path of the collection or file one wants to get - relative to the rootUrl stated when instantiating the client.
       * @param file The file to save the received data in.
       * @return returns true if succeeded, otherwise false.
       */
      get(path: string, file: dw.io.File): boolean;
      /**
       * Reads the content of a remote file or directory that can be found under
       *  rootUrl/path in DEFAULT_ENCODING
       *  encoding and writes a File in the system's standard
       *  encoding, which is "UTF-8". If the remote location is a directory the
       *  result depends on the server configuration, some return an HTML formatted
       *  directory listing. Receives at most maxFileSize bytes which determines
       *  the file size of the local file. Returns true if succeeded, otherwise
       *  false.
       * @param path The path of the collection or file one wants to get - relative to the rootUrl stated when instantiating the client.
       * @param file The file to save the received data in.
       * @param maxFileSize The maximum size of bytes to stream into the file. Not to exceed MAX_GET_FILE_SIZE.
       * @return returns true if succeeded, otherwise false.
       */
      get(path: string, file: dw.io.File, maxFileSize: number): boolean;
      /**
       * Reads the content of a remote file or directory that can be found under
       *  rootUrl/path in the passed encoding and
       *  writes a File in the system standard encoding, which is
       *  "UTF-8". If the remote location is a directory the result depends on the
       *  server configuration, some return an HTML formatted directory listing.
       *  Receives at most maxFileSize bytes which determines the file size of the
       *  local file. Returns true if succeeded, otherwise false.
       * @param path The path of the collection or file one wants to get - relative to the rootUrl stated when instantiating the client.
       * @param file The file to save the received data in.
       * @param encoding The encoding to use when reading the remote file.
       * @param maxFileSize The maximum number of bytes to stream into the file. Not to exceed MAX_GET_FILE_SIZE.
       * @return returns true if succeeded, otherwise false.
       */
      get(
        path: string,
        file: dw.io.File,
        encoding: string,
        maxFileSize: number
      ): boolean;
      /**
       * Returns a HashMap of all response headers.
       *
       * @return all headers in a HashMap.
       */
      getAllResponseHeaders(): dw.util.HashMap<string, dw.util.List<string>>;
      /**
       * Reads the content of a remote binary file that can be found under
       *  rootUrl/path and creates a local copy
       *  in File. If the remote location is a directory the result
       *  depends on the server configuration, some return an HTML formatted
       *  directory listing. Copies at most DEFAULT_GET_FILE_SIZE bytes. Returns
       *  true if succeeded, otherwise false.
       * @param path The path relative to rootUrl on the remote server including the file name.
       * @param file The local file where the received binary data should be stored.
       * @return true if succeeded, otherwise false.
       */
      getBinary(path: string, file: dw.io.File): boolean;
      /**
       * Reads the content of a remote binary file that can be found under
       *  rootUrl/path and creates a local copy
       *  in File. If the remote location is a directory the result
       *  depends on the server configuration, some return an HTML formatted
       *  directory listing. Copies at most maxFileSize bytes. Returns true if
       *  succeeded, otherwise false.
       * @param path The path relative to rootUrl on the remote server including the file name.
       * @param file The file local file where the received binary data should be stored.
       * @param maxFileSize The maximum number of bytes to stream into the file. Not to exceed MAX_GET_FILE_SIZE.
       * @return true if succeeded, otherwise false.
       */
      getBinary(path: string, file: dw.io.File, maxFileSize: number): boolean;
      /**
       * Returns a specified response header - multiple headers are separated by
       *  CRLF.
       * @param header The name of the header.
       * @return The header - in case of multiple headers separated by CRLF.
       */
      getResponseHeader(header: string): string;
      /**
       * Returns the status code after the execution of a method.
       *
       * @return the statusCode.
       */
      getStatusCode(): number;
      /**
       * Returns the status text after the execution of a method.
       *
       * @return the statusText.
       */
      getStatusText(): string;
      /**
       * Creates a directory on the remote server on the location
       *  rootUrl/path.
       * @param path The path relative to the rootUrl stated when instantiating the client where the new collection should be created.
       * @return true if succeeded, otherwise false.
       */
      mkcol(path: string): boolean;
      /**
       * Moves a file on the server from one place rootUrl + "/" +origin
       *  to the other rootUrl/destination. If
       *  destination already exists it gets overwritten. Can also
       *  be used to rename a remote file. Returns true if succeeded, otherwise
       *  false.
       * @param origin The origin where a file is located, relative to the rootUrl stated when instantiating the client.
       * @param destination The destination where the file should be moved to, relative to the rootUrl stated when instantiating the client.
       * @return true if succeeded, otherwise false.
       */
      move(origin: string, destination: string): boolean;
      /**
       * Moves a file on the server from one place rootUrl/origin
       *  to the other rootUrl/destination Can
       *  also be used to rename a remote file. If overwrite is true
       *  and destination already exists it gets overwritten.
       *  Returns true if succeeded, otherwise false.
       * @param origin The origin where a file is located, relative to the rootUrl stated when instantiating the client.
       * @param destination The destination where the file should be moved to, relative to the rootUrl stated when instantiating the client.
       * @param overwrite A flag which determines whether the destination gets overwritten if it exists before moving.
       * @return true if succeeded, otherwise false.
       */
      move(origin: string, destination: string, overwrite: boolean): boolean;
      /**
       * Returns a list of methods which can be executed on the server location
       *  rootUrl/path.
       * @param path The path relative to the rootUrl stated when instantiating the client one wants to get the options for.
       * @return list of WebDav methods which can be executed on the given path.
       */
      options(path: string): String[];
      /**
       * Get file listing of a remote location.
       *
       *  Returns a list of WebDAVFileInfo objects which contain
       *  information about the files and directories located on
       *  rootUrl/path and DEPTH_1 (1) level
       *  underneath.
       * @param path The path relative to the rootUrl stated when instantiating the client where to get information about the containing files from.
       * @return an Array of WebDAVFileInfo objects which hold information about the files located on the server at the location.
       */
      propfind(path: string): WebDAVFileInfo[];
      /**
       * Get file listing of a remote location.
       *
       *  Returns a list of WebDAVFileInfo objects which contain
       *  information about the files and directories located on
       *  rootUrl/path and the passed depth
       *  underneath.
       * @param path The path relative to the rootUrl stated when instantiating the client where to get information about the containing files from.
       * @param depth The level starting from rootUrl down to which the file information gets collected.
       * @return an Array of WebDAVFileInfo objects which hold information about the files located on the server at the location.
       */
      propfind(path: string, depth: number): WebDAVFileInfo[];
      /**
       * Puts content encoded with DEFAULT_ENCODING into a remote located file at
       *  rootUrl/path. Returns true if
       *  succeeded, otherwise false.
       *
       *  If the content of a local file is to be uploaded, please use method
       *  put(String, File) instead.
       * @param path The path to put given content up to, relative to the rootUrl stated when instantiating the client.
       * @param content The content that has to be pushed on to the server.
       * @return true if succeeded, otherwise false.
       */
      put(path: string, content: string): boolean;
      /**
       * Puts content encoded with the passed encoding into a remote located file
       *  at rootUrl/path. Returns true if
       *  succeeded, otherwise false.
       *
       *  If the content of a local file is to be uploaded, please use method
       *  put(String, File) instead.
       * @param path The path to put a given content up to, relative to the rootUrl stated when instantiating the client.
       * @param content The content that has to be pushed on to a remote location.
       * @param encoding The encoding in which the data should be stored on the server.
       * @return true if succeeded, otherwise false.
       */
      put(path: string, content: string, encoding: string): boolean;
      /**
       * Puts content out of a passed local file into a remote located file
       *  at rootUrl/path. This method performs
       *  a binary file transfer. Returns true if succeeded, otherwise false.
       * @param path The path to put given content up to, relative to the rootUrl stated when instantiating the client.
       * @param file The file to push up to the server.
       * @return true if succeeded, otherwise false.
       */
      put(path: string, file: dw.io.File): boolean;
      /**
       * Returns true if the last executed WebDAV method was executed successfully - otherwise false.
       *  See the code snippet above for an example how to use the succeed() method.
       *
       * @return true if the last executed WebDAV method was successful - otherwise false.
       */
      succeeded(): boolean;
    }

    /**
     * Simple class representing a file on a remote WebDAV location.  The class
     *  possesses only read-only attributes of the file and does not permit any
     *  manipulation of the file itself.  Instances of this class are returned
     *  by <a href="class_dw_net_WebDAVClient.html#dw_net_WebDAVClient_propfind_String_DetailAnchor">WebDAVClient.propfind(String)</a> which is used to get a
     *  listing of files in a WebDAV directory.
     *  <p>
     *  <b>Note:</b> when this class is used with sensitive data, be careful in persisting sensitive information to disk.</p>
     */
    class WebDAVFileInfo {
      /**
       * The content type of the file.
       */
      readonly contentType: string;
      /**
       * The creationDate of the file.
       */
      readonly creationDate: Date;
      /**
       * Identifies if the file is a directory.
       */
      readonly directory: boolean;
      /**
       * The name of the file.
       */
      readonly name: string;
      /**
       * The path of the file.
       */
      readonly path: string;
      /**
       * The size of the file.
       */
      readonly size: number;

      /**
       * Returns the content type of the file.
       *
       * @return the content type of the file.
       */
      getContentType(): string;
      /**
       * Returns the creationDate of the file.
       *
       * @return the creationDate of the file.
       */
      getCreationDate(): Date;
      /**
       * Returns the name of the file.
       *
       * @return the name of the file.
       */
      getName(): string;
      /**
       * Returns the path of the file.
       *
       * @return the path of the file.
       */
      getPath(): string;
      /**
       * Returns the size of the file.
       *
       * @return the size of the file.
       */
      getSize(): number;
      /**
       * Identifies if the file is a directory.
       *
       * @return true if the file is a directory, false otherwise.
       */
      isDirectory(): boolean;
      /**
       * Returns the lastModified date of the file.
       *
       * @return the lastModified date of the file.
       */
      lastModified(): Date;
    }
  }

  namespace object {
    /**
     * Represents the active data for an object in Commerce Cloud Digital.
     */
    class ActiveData extends dw.object.ExtensibleObject {
      /**
       * The custom attributes for this object. The returned object can
       *  only be used for retrieving attribute values, not storing them. See
       *  CustomAttributes for a detailed example of the syntax for
       *  working with custom attributes.
       */
      readonly custom: ActiveDataCustomAttributes;
      /**
       * Return true if the ActiveData doesn't exist for the object
       */
      readonly empty: boolean;

      /**
       * Returns the custom attributes for this object. The returned object can
       *  only be used for retrieving attribute values, not storing them. See
       *  CustomAttributes for a detailed example of the syntax for
       *  working with custom attributes.
       *
       * @return the custom attributes for this object.
       */
      getCustom(): ActiveDataCustomAttributes;
      /**
       * Return true if the ActiveData doesn't exist for the object
       *
       * @return true if ActiveData is empty, false otherwise
       */
      isEmpty(): boolean;
    }

    /**
     * This class is used together with other classes that contain custom attributes
     *  and is used to read and write these attributes. The actual attributes are
     *  accessible as ECMA properties. The syntax for setting and retrieving the
     *  value of a custom attribute depends upon the type of the attribute. If the
     *  wrong syntax is used to set an individual attribute than an exception will be
     *  thrown.
     *
     *  <p>
     *
     *  The following script examples demonstrate how to work with custom attributes.
     *  Suppose we have an ExtensibleObject named &quot;eo&quot; possessing attributes of all
     *  the different types supported by the Commerce Cloud Digital metadata system. The
     *  following script snippet shows that setting single-valued attributes is
     *  simply a matter of using the assignment operator and standard ECMA primitives
     *  and built-in types:
     *
     *  </p><p>
     *
     *  </p><pre> // attribute of value type &apos;Boolean&apos;
     *  eo.custom.bvalue = true;
     *  var b : Boolean = eo.custom.bvalue;
     *
     *  // attribute of value type &apos;Integer&apos;
     *  eo.custom.ivalue = 10;
     *  var i : Number = eo.custom.ivalue;
     *
     *  // attribute of value type &apos;Number&apos;
     *  eo.custom.dvalue = 99.99;
     *  var d : Number = eo.custom.dvalue;
     *
     *  // attribute of value type &apos;String&apos;
     *  eo.custom.svalue = &quot;String1&quot;;
     *  var s : String = eo.custom.svalue;
     *
     *  // attribute of value type &apos;Email&apos;
     *  eo.custom.emailvalue = &quot;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="157078747c7955717078747b71627467703b767a78">[email&#xA0;protected]</a>&quot;;
     *  var e : String = eo.custom.emailvalue;
     *
     *  // attribute of value type &apos;Text&apos;
     *  eo.custom.tvalue = &quot;laaaaaaaaaaaarge text&quot;;
     *  var t : String = eo.custom.tvalue;
     *
     *  // attribute of value type &apos;Date&apos;
     *  eo.custom.dtvalue = new Date;
     *  var date : Date = eo.custom.dtvalue;
     *  </pre>
     *
     *  <p>
     *
     *  Setting and retrieving the values for multi-value attributes is also
     *  straightforward and uses ECMA arrays to represent the multiple values. Set-of
     *  attributes and enum-of attributes are handled in a very similar manner. The
     *  chief difference is that enum-of attributes are limited to a prescribed set
     *  of value definitions whereas set-of attributes are open-ended. Furthermore,
     *  each value in an enum-of attribute has a value and a display name which
     *  affects the retrieval logic.
     *
     *  Multi-value attributes are returned as an array. This array is read-only and
     *  can&apos;t be used to update the multi-value attribute. To update the multi-value
     *  attribute an array with new values must be assigned to the attribute.
     *
     *  </p><p>
     *
     *  </p><pre> // attribute of value type &apos;Set of String&apos;
     *  // set the attribute value only if it hasn&apos;t been already set
     *  if( !(&apos;setofstringvalue&apos; in eo.custom) )
     *  {
     *      eo.custom.setofstringvalue = new Array(&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;);
     *  }
     *
     *  // returns an Array of String instances
     *  var setofstring : Array = eo.custom.setofstringvalue;
     *  var s1 : String = setofstring[0];
     *  var s2 : String = setofstring[1];
     *  var s3 : String = setofstring[2];
     *
     *  // attribute of value type &apos;Enum of Integer&apos; with multi-value handling
     *  eo.custom.enumofintmultivalue = new Array(1, 2, 3);
     *
     *  // returns an Array of EnumValue instances
     *  var enumofintmulti : Array = eo.custom.enumofintmultivalue;
     *  var value1 : Number = enumofintmulti[0].getValue();
     *  var displayvalue1 : String = enumofintmulti[0].getDisplayValue();
     *  var value2 : Number = enumofintmulti[1].getValue();
     *  var displayvalue2 : String = enumofintmulti[1].getDisplayValue();
     *  var value3 : Number = enumofintmulti[2].getValue();
     *  var displayvalue3 : String = enumofintmulti[2].getDisplayValue();
     *  </pre>
     *
     *  <p>
     *
     *  For further details on the Commerce Cloud Digital attribute system, see the core
     *  Commerce Cloud Digital documentation.</p>
     */
    class CustomAttributes {
      /**
       * Returns the custom attribute with this name. Throws an exception if attribute is not defined
       */
      [name: string]: any;
    }

    /**
     * Represents a custom object and its corresponding attributes.
     */
    class CustomObject extends dw.object.ExtensibleObject {
      /**
       * The custom attributes of this
       *  object.
       */
      readonly custom: dw.object.CustomAttributes;
      /**
       * The type of the CustomObject.
       */
      readonly type: string;

      /**
       * Returns the custom attributes of this
       *  object.
       *
       * @return the custom attributes of this object.
       */
      getCustom(): dw.object.CustomAttributes;
      /**
       * Returns the type of the CustomObject.
       *
       * @return the type of the CustomObject.
       */
      getType(): string;
    }

    /**
     * Manager class which provides methods for creating, retrieving, deleting,
     *  and searching for custom objects.
     *  <p>
     *  To search for system objects, use <a href="class_dw_object_SystemObjectMgr.html">SystemObjectMgr</a>.</p>
     */
    class CustomObjectMgr {
      /**
       * Returns a new custom object instance of the specified type, using the
       *  given key value. Custom object keys need to be unique for custom object
       *  type.
       * @param type The unique name of the custom object type.
       * @param keyValue The unique key value for the instance.
       * @return The newly created custom object instance.
       */
      static createCustomObject(
        type: string,
        keyValue: string
      ): dw.object.CustomObject;
      /**
       * Returns a new custom object instance of the specified type, using the
       *  given key value. Custom object keys need to be unique for custom object
       *  type.
       * @param type The unique name of the custom object type.
       * @param keyValue The unique key value for the instance.
       * @return The newly created custom object instance.
       */
      static createCustomObject(
        type: string,
        keyValue: number
      ): dw.object.CustomObject;
      /**
       * Returns the meta data for the given type.
       * @param type the type whose meta data is returned.
       * @return the meta data for the given type.
       */
      static describe(type: string): dw.object.ObjectTypeDefinition;
      /**
       * Returns all custom objects of a specific type.
       *
       *  It is strongly recommended to call close() on the returned SeekableIterator
       *  if not all of its elements are being retrieved. This will ensure the proper cleanup of system resources.
       * @param type The name of the custom object type.
       */
      static getAllCustomObjects(type: string): dw.util.SeekableIterator;
      /**
       * Returns a custom object based on it's type and unique key.
       * @param type The name of the custom object type.
       * @param keyValue The unique key value.
       * @return The matching custom object instance or null in case no matching custom object instance could be found.
       */
      static getCustomObject(
        type: string,
        keyValue: string
      ): dw.object.CustomObject;
      /**
       * Returns a custom object based on it's type and unique key.
       * @param type The name of the custom object type.
       * @param keyValue The unique key value.
       * @return The matching custom object instance or null in case no matching custom object instance could be found.
       */
      static getCustomObject(
        type: string,
        keyValue: number
      ): dw.object.CustomObject;
      /**
       * Searches for a single custom object instance.
       *
       *  The search can be configured using a simple query language, which
       *  provides most common filter and operator functionality.
       *
       *  The identifier for an attribute  to use in a query condition is always the
       *  ID of the  attribute as defined in the type definition. For custom defined attributes
       *  the prefix custom is required in the search term (e.g. custom.color = {1}),
       *  while for system attributes no prefix is used (e.g. name = {4}).
       *
       *  Supported attribute value types with sample expression values:
       *  String 'String', 'Str*', 'Strin?'
       *  Integer 1, 3E4
       *  Number 1.0, 3.99E5
       *  Date yyyy-MM-dd e.g. 2007-05-31 (Default TimeZone = UTC)
       *  DateTime yyyy-MM-dd'T'hh:mm:ss+Z e.g. 2007-05-31T00:00+Z (Z TimeZone = UTC) or 2007-05-31T00:00:00
       *  Boolean true, false
       *  Email '[emailprotected]', '*@demandware.com'
       *  Set of String 'String', 'Str*', 'Strin?'
       *  Set of Integer 1, 3E4
       *  Set of Number 1.0, 3.99E5
       *  Enum of String 'String', 'Str*', 'Strin?'
       *  Enum of Integer 1, 3E4
       *  The following types of attributes are not queryable:
       *  Image
       *  HTML
       *  Text
       *  Quantity
       *  Password
       *  Note, that some system attributes are not queryable by default regardless of the
       *  actual value type code.
       *
       *
       *  The following operators are supported in a condition:
       *  = Equals - All types; supports NULL value (thumbnail = NULL)
       *  != Not equals - All types; supports NULL value (thumbnail != NULL)
       *  < Less than  - Integer, Number and Date types only
       *  > Greater than - Integer, Number and Date types only
       *  <= Less or equals than - Integer, Number and Date types only
       *  >= Greater or equals than  - Integer, Number and Date types only
       *  LIKE Like - String types and Email only; use if leading or trailing
       *  wildcards will be used to support substring search(custom.country LIKE 'US*')
       *  ILIKE Caseindependent Like - String types and Email only, use to support
       *  case insensitive query (custom.country ILIKE 'usa'), does also support wildcards for
       *  substring matching
       *
       *  Conditions can be combined using logical expressions 'AND', 'OR' and 'NOT'
       *  and nested using parenthesis e.g.
       *  gender = {1} AND (age >= {2} OR (NOT profession LIKE {3})).
       *
       *
       *  The query language provides a placeholder syntax to pass objects as
       *  additional search parameters. Each passed object is related to a
       *  placeholder in the query string. The placeholder must be an Integer that
       *  is surrounded by braces. The first Integer value must be '0', the second
       *  '1' and so on, e.g.
       *  querySystemObjects("sample", "age = {0} or creationDate >= {1}", 18, date)
       *
       *
       *  If there is more than one object matching the specified query criteria, the
       *  result is not deterministic. In order to retrieve a single object from a sorted result
       *  set it is recommended to use the following code:
       *  queryCustomObjects("", "custom.myAttr asc", null).first().
       *  The method first() returns only the next element and closes the
       *  iterator.
       * @param type the custom object type for the query.
       * @param queryString the actual query.
       * @param args optional parameters for the queryString.
       * @return the custom object defined by type which was found when executing the queryString.
       */
      static queryCustomObject(
        type: string,
        queryString: string,
        ...args: any[]
      ): dw.object.CustomObject;
      /**
       * Searches for custom object instances.
       *
       *  The search can be configured using a simple query language, which
       *  provides most common filter and operator functionality.
       *
       *  The identifier for an attribute  to use in a query condition is always the
       *  ID of the  attribute as defined in the type definition. For custom defined attributes
       *  the prefix custom is required in the search term (e.g. custom.color = {1}),
       *  while for system attributes no prefix is used (e.g. name = {4}).
       *
       *  Supported attribute value types with sample expression values:
       *  String 'String', 'Str*', 'Strin?'
       *  Integer 1, 3E4
       *  Number 1.0, 3.99E5
       *  Date yyyy-MM-dd e.g. 2007-05-31 (Default TimeZone = UTC)
       *  DateTime yyyy-MM-dd'T'hh:mm:ss+Z e.g. 2007-05-31T00:00+Z (Z TimeZone = UTC) or 2007-05-31T00:00:00
       *  Boolean true, false
       *  Email '[emailprotected]', '*@demandware.com'
       *  Set of String 'String', 'Str*', 'Strin?'
       *  Set of Integer 1, 3E4
       *  Set of Number 1.0, 3.99E5
       *  Enum of String 'String', 'Str*', 'Strin?'
       *  Enum of Integer 1, 3E4
       *  The following types of attributes are not queryable:
       *  Image
       *  HTML
       *  Text
       *  Quantity
       *  Password
       *  Note, that some system attributes are not queryable by default regardless of the
       *  actual value type code.
       *
       *
       *  The following operators are supported in a condition:
       *  = Equals - All types; supports NULL value (thumbnail = NULL)
       *  != Not equals - All types; supports NULL value (thumbnail != NULL)
       *  < Less than  - Integer, Number and Date types only
       *  > Greater than - Integer, Number and Date types only
       *  <= Less or equals than - Integer, Number and Date types only
       *  >= Greater or equals than  - Integer, Number and Date types only
       *  LIKE Like - String types and Email only; use if leading or trailing
       *  wildcards will be used to support substring search(custom.country LIKE 'US*')
       *  ILIKE Caseindependent Like - String types and Email only, use to support
       *  case insensitive query (custom.country ILIKE 'usa'), does also support wildcards for
       *  substring matching
       *
       *  Conditions can be combined using logical expressions 'AND', 'OR' and 'NOT'
       *  and nested using parenthesis e.g.
       *  gender = {1} AND (age >= {2} OR (NOT profession LIKE {3})).
       *
       *
       *  The query language provides a placeholder syntax to pass objects as
       *  additional search parameters. Each passed object is related to a
       *  placeholder in the query string. The placeholder must be an Integer that
       *  is surrounded by braces. The first Integer value must be '0', the second
       *  '1' and so on, e.g.
       *  querySystemObjects("sample", "age = {0} or creationDate >= {1}", 18, date)
       *
       *
       *  The sorting parameter is optional and may contain a comma separated list of
       *  attribute names to sort by. Each sort attribute name may be followed by an
       *  optional sort direction specifier ('asc' | 'desc'). Default sorting directions is
       *  ascending, if no direction was specified.
       *  Example: age desc, name
       *  Please note that specifying a localized custom attribute as the sorting attribute is
       *  currently not supported.
       *
       *  Sometimes it is desired to get all instances of specified type with a special sorting condition.
       *  This can be easily done by providing the 'type' of the custom object and the 'sortString' in combination with
       *  an empty 'queryString', e.g. queryCustomObjects("sample", "", "custom.myAttr asc")
       *
       *  It is strongly recommended to call close() on the returned SeekableIterator
       *  if not all of its elements are being retrieved. This will ensure the proper cleanup of system resources.
       * @param type the custom object type for the query.
       * @param queryString the actual query.
       * @param sortString an optional sorting or null if no sorting is necessary.
       * @param args optional parameters for the queryString.
       * @return SeekableIterator containing the result set of the query.
       */
      static queryCustomObjects(
        type: string,
        queryString: string,
        sortString: string,
        ...args: any[]
      ): dw.util.SeekableIterator;
      /**
       * Searches for custom object instances.
       *
       *  The search can be configured with a map, which key-value pairs are
       *  converted into a query expression. The key-value pairs are turned into a
       *  sequence of '=' or 'like' conditions, which are combined with AND
       *  statements.
       *
       *  Example:
       *  A map with the key/value pairs: 'name'/'tom*', 'age'/66
       *  will be converted as follows: "name like 'tom*' and age = 66"
       *
       *  The identifier for an attribute  to use in a query condition is always the
       *  ID of the  attribute as defined in the type definition. For custom defined attributes
       *  the prefix custom is required in the search term (e.g. custom.color = {1}),
       *  while for system attributes no prefix is used (e.g. name = {4}).
       *
       *  Supported attribute value types with sample expression values:
       *  String 'String', 'Str*', 'Strin?'
       *  Integer 1, 3E4
       *  Number 1.0, 3.99E5
       *  Date yyyy-MM-dd e.g. 2007-05-31 (Default TimeZone = UTC)
       *  DateTime yyyy-MM-dd'T'hh:mm:ss+Z e.g. 2007-05-31T00:00+Z (Z TimeZone = UTC) or 2007-05-31T00:00:00
       *  Boolean true, false
       *  Email '[emailprotected]', '*@demandware.com'
       *  Set of String 'String', 'Str*', 'Strin?'
       *  Set of Integer 1, 3E4
       *  Set of Number 1.0, 3.99E5
       *  Enum of String 'String', 'Str*', 'Strin?'
       *  Enum of Integer 1, 3E4
       *  The following types of attributes are not queryable:
       *  Image
       *  HTML
       *  Text
       *  Quantity
       *  Password
       *  Note, that some system attributes are not queryable by default regardless of the
       *  actual value type code.
       *
       *
       *  The sorting parameter is optional and may contain a comma separated list of
       *  attribute names to sort by. Each sort attribute name may be followed by an
       *  optional sort direction specifier ('asc' | 'desc'). Default sorting directions is
       *  ascending, if no direction was specified.
       *  Example: age desc, name
       *  Please note that specifying a localized custom attribute as the sorting attribute is
       *  currently not supported.
       *
       *  It is strongly recommended to call close() on the returned SeekableIterator
       *  if not all of its elements are being retrieved. This will ensure the proper cleanup of system resources.
       * @param type the custom object type for the query.
       * @param queryAttributes key-value pairs, which define the query.
       * @param sortString an optional sorting or null if no sorting is necessary.
       * @return SeekableIterator containing the result set of the query.
       */
      static queryCustomObjects(
        type: string,
        queryAttributes: dw.util.Map<any, any>,
        sortString: string
      ): dw.util.SeekableIterator;
      /**
       * Removes a given custom object.
       * @param object the custom object to remove, must not be null.
       */
      static remove(object: dw.object.CustomObject): void;
    }

    /**
     * Base class alternative to ExtensibleObject for objects customizable through the metadata system.
     *  Similar to ExtensibleObject: the <a href="class_dw_object_Extensible.html#dw_object_Extensible_describe_DetailAnchor">describe()</a> method provides access to the related object-type metadata.
     *  The <a href="class_dw_object_Extensible.html#dw_object_Extensible_getCustom_DetailAnchor">getCustom()</a> method is the central point to retrieve and store the objects attribute
     *  values themselves.
     */
    class Extensible {
      /**
       * The custom attributes for this object.
       */
      readonly custom: dw.object.CustomAttributes;

      /**
       * Returns the meta data of this object. If no meta data is available the
       *  method returns null. The returned ObjectTypeDefinition can be used to
       *  retrieve the metadata for any of the custom attributes.
       *
       * @return the meta data of this object. If no meta data is available the method returns null.
       */
      describe(): dw.object.ObjectTypeDefinition;
      /**
       * Returns the custom attributes for this object.
       *
       * @return the custom attributes for this object.
       */
      getCustom(): dw.object.CustomAttributes;
    }

    /**
     * Base class for all persistent business objects in Commerce Cloud Digital that
     *  are customizable through the metadata system. All objects in Digital
     *  that have custom attributes derive from ExtensibleObject including
     *  both system-defined and custom objects. The describe() method provides access
     *  to the related object-type metadata. The method getCustom() is the central
     *  point to retrieve and store the objects attribute values themselves.
     */
    class ExtensibleObject extends dw.object.PersistentObject {
      /**
       * The custom attributes for this object. The returned object is
       *  used for retrieving and storing attribute values. See
       *  CustomAttributes for a detailed example of the syntax for
       *  working with custom attributes.
       */
      readonly custom: dw.object.CustomAttributes;

      /**
       * Returns the meta data of this object. If no meta data is available the
       *  method returns null. The returned ObjectTypeDefinition can be used to
       *  retrieve the metadata for any of the custom attributes.
       *
       * @return the meta data of this object. If no meta data is available the method returns null.
       */
      describe(): dw.object.ObjectTypeDefinition;
      /**
       * Returns the custom attributes for this object. The returned object is
       *  used for retrieving and storing attribute values. See
       *  CustomAttributes for a detailed example of the syntax for
       *  working with custom attributes.
       *
       * @return the custom attributes for this object.
       */
      getCustom(): dw.object.CustomAttributes;
    }

    /**
     * Represents a note that can be attached to any persistent object
     *  that supports this feature.
     */
    class Note {
      /**
       * Return the login ID of user that is stored in the session at the time
       *  the note is created.
       */
      readonly createdBy: string;
      /**
       * Return the date and time that the note was created.  This is usually
       *  set by the system, but may be specified if the note is generated
       *  via an import.
       */
      readonly creationDate: Date;
      /**
       * Return the subject of the note.
       */
      readonly subject: string;
      /**
       * Return the text of the note.
       */
      readonly text: string;

      /**
       * Return the login ID of user that is stored in the session at the time
       *  the note is created.
       *
       * @return the username.
       */
      getCreatedBy(): string;
      /**
       * Return the date and time that the note was created.  This is usually
       *  set by the system, but may be specified if the note is generated
       *  via an import.
       *
       * @return the creation date.
       */
      getCreationDate(): Date;
      /**
       * Return the subject of the note.
       *
       * @return the subject.
       */
      getSubject(): string;
      /**
       * Return the text of the note.
       *
       * @return the text.
       */
      getText(): string;
    }

    /**
     * Represents the definition of an object&apos;s attribute.
     */
    class ObjectAttributeDefinition {
      /**
       * Boolean value type.
       */
      static readonly VALUE_TYPE_BOOLEAN = 8;
      /**
       * Date value type.
       */
      static readonly VALUE_TYPE_DATE = 6;
      /**
       * Date and Time value type.
       */
      static readonly VALUE_TYPE_DATETIME = 11;
      /**
       * Email value type.
       */
      static readonly VALUE_TYPE_EMAIL = 12;
      /**
       * Enum of int value type.
       */
      static readonly VALUE_TYPE_ENUM_OF_INT = 31;
      /**
       * Enum of String value type.
       */
      static readonly VALUE_TYPE_ENUM_OF_STRING = 33;
      /**
       * HTML value type.
       */
      static readonly VALUE_TYPE_HTML = 5;
      /**
       * Image value type.
       */
      static readonly VALUE_TYPE_IMAGE = 7;
      /**
       * int value type.
       */
      static readonly VALUE_TYPE_INT = 1;
      /**
       * Money value type.
       */
      static readonly VALUE_TYPE_MONEY = 9;
      /**
       * Number value type.
       */
      static readonly VALUE_TYPE_NUMBER = 2;
      /**
       * Password value type.
       */
      static readonly VALUE_TYPE_PASSWORD = 13;
      /**
       * Quantity value type.
       */
      static readonly VALUE_TYPE_QUANTITY = 10;
      /**
       * Set of int value type.
       */
      static readonly VALUE_TYPE_SET_OF_INT = 21;
      /**
       * Set of Number value type.
       */
      static readonly VALUE_TYPE_SET_OF_NUMBER = 22;
      /**
       * Set of String value type.
       */
      static readonly VALUE_TYPE_SET_OF_STRING = 23;
      /**
       * String value type.
       */
      static readonly VALUE_TYPE_STRING = 3;
      /**
       * Text value type.
       */
      static readonly VALUE_TYPE_TEXT = 4;

      /**
       * All attribute groups the attribute is assigned to.
       */
      readonly attributeGroups: dw.util.Collection<
        dw.object.ObjectAttributeGroup
      >;
      /**
       * Return the default value for the attribute or null if none is defined.
       */
      readonly defaultValue: dw.object.ObjectAttributeValueDefinition;
      /**
       * The display name for the attribute, which can be used in the
       *  user interface.
       */
      readonly displayName: string;
      /**
       * The ID of the attribute definition.
       */
      readonly ID: string;
      /**
       * Identifies if the attribute represents the primary key of the object.
       */
      readonly key: boolean;
      /**
       * Checks if this attribute is mandatory.
       */
      readonly mandatory: boolean;
      /**
       * Returns true if the attribute can have multiple values.
       *  Attributes of the following types are multi-value capable:
       *
       *  VALUE_TYPE_SET_OF_INT
       *  VALUE_TYPE_SET_OF_NUMBER
       *  VALUE_TYPE_SET_OF_STRING
       *
       *  Additionally, attributes of the following types can be multi-value
       *  enabled:
       *
       *  VALUE_TYPE_ENUM_OF_INT
       *  VALUE_TYPE_ENUM_OF_STRING
       */
      readonly multiValueType: boolean;
      /**
       * The object type definition in which this attribute is defined.
       */
      readonly objectTypeDefinition: dw.object.ObjectTypeDefinition;
      /**
       * Returns true if the attribute is of type 'Set of'.
       */
      readonly setValueType: boolean;
      /**
       * Indicates if the attribute is a pre-defined system attribute
       *  or a custom attribute.
       */
      readonly system: boolean;
      /**
       * The attribute's unit representation such as
       *  inches for length or pounds for weight. The value returned by
       *  this method is based on the attribute itself.
       */
      readonly unit: string;
      /**
       * The list of attribute values. In the user interface only the
       *  values specified in this list should be offered as valid input values.
       *
       *  The collection contains instances of ObjectAttributeValueDefinition.
       */
      readonly values: dw.util.Collection<
        dw.object.ObjectAttributeValueDefinition
      >;
      /**
       * A code for the data type stored in the attribute. See constants
       *  defined in this class.
       */
      readonly valueTypeCode: number;

      /**
       * Returns all attribute groups the attribute is assigned to.
       *
       * @return all attribute groups the attribute is assigned to.
       */
      getAttributeGroups(): dw.util.Collection<dw.object.ObjectAttributeGroup>;
      /**
       * Return the default value for the attribute or null if none is defined.
       *
       * @return the default value for the attribute or null if none is defined.
       */
      getDefaultValue(): dw.object.ObjectAttributeValueDefinition;
      /**
       * Returns the display name for the attribute, which can be used in the
       *  user interface.
       *
       * @return the display name for the attribute, which can be used in the user interface.
       */
      getDisplayName(): string;
      /**
       * Returns the ID of the attribute definition.
       *
       * @return the ID of the attribute definition.
       */
      getID(): string;
      /**
       * Returns the object type definition in which this attribute is defined.
       *
       * @return the object type definition in which this attribute is defined.
       */
      getObjectTypeDefinition(): dw.object.ObjectTypeDefinition;
      /**
       * Returns the attribute's unit representation such as
       *  inches for length or pounds for weight. The value returned by
       *  this method is based on the attribute itself.
       *
       * @return the attribute's unit representation such as inches for length or pounds for weight.
       */
      getUnit(): string;
      /**
       * Returns the list of attribute values. In the user interface only the
       *  values specified in this list should be offered as valid input values.
       *
       *  The collection contains instances of ObjectAttributeValueDefinition.
       *
       * @return a collection of ObjectAttributeValueDefinition instances representing the list of attribute values, or null if no values are specified.
       */
      getValues(): dw.util.Collection<dw.object.ObjectAttributeValueDefinition>;
      /**
       * Returns a code for the data type stored in the attribute. See constants
       *  defined in this class.
       *
       * @return a code for the data type stored in the attribute. See constants defined in this class.
       */
      getValueTypeCode(): number;
      /**
       * Identifies if the attribute represents the primary key of the object.
       *
       * @return true if the attribute represents the primary key, false otherwise.
       */
      isKey(): boolean;
      /**
       * Checks if this attribute is mandatory.
       *
       * @return true, if this attribute is mandatory
       */
      isMandatory(): boolean;
      /**
       * Returns true if the attribute can have multiple values.
       *  Attributes of the following types are multi-value capable:
       *
       *  VALUE_TYPE_SET_OF_INT
       *  VALUE_TYPE_SET_OF_NUMBER
       *  VALUE_TYPE_SET_OF_STRING
       *
       *  Additionally, attributes of the following types can be multi-value
       *  enabled:
       *
       *  VALUE_TYPE_ENUM_OF_INT
       *  VALUE_TYPE_ENUM_OF_STRING
       *
       * @return true if attributes can have multiple values, otherwise false
       */
      isMultiValueType(): boolean;
      /**
       * Returns true if the attribute is of type 'Set of'.
       *
       */
      isSetValueType(): boolean;
      /**
       * Indicates if the attribute is a pre-defined system attribute
       *  or a custom attribute.
       *
       * @return true if the the attribute is a pre-defined system attribute, false if it is a custom attribute.
       */
      isSystem(): boolean;
      /**
       * Returns a boolean flag indicating whether or not values of this attribute
       *  definition should be encoded using the encoding="off" flag in ISML
       *  templates.
       *
       * @return a boolean flag indicating whether or not values of this attribute definition should be encoded using the encoding="off" flag in ISML templates.
       */
      requiresEncoding(): boolean;
    }

    /**
     * Represents a group of object attributes.
     */
    class ObjectAttributeGroup {
      /**
       * All attribute definitions for this group. The collection
       *  may contain both system attribute definition as well as custom
       *  attribute definitions.
       */
      readonly attributeDefinitions: dw.util.Collection<
        dw.object.ObjectTypeDefinition
      >;
      /**
       * The description of this group in the current locale.
       */
      readonly description: string;
      /**
       * The display name of this group.
       */
      readonly displayName: string;
      /**
       * The ID of this group.
       */
      readonly ID: string;
      /**
       * The object type definition to which this attribute group
       *  belongs.
       */
      readonly objectTypeDefinition: dw.object.ObjectTypeDefinition;
      /**
       * Identifies if this is an sytem or a custom attribute group. A system
       *  attribute group is pre-defined and can not be deleted.
       */
      readonly system: boolean;

      /**
       * Returns all attribute definitions for this group. The collection
       *  may contain both system attribute definition as well as custom
       *  attribute definitions.
       *
       * @return all attribute definitions for this group.
       */
      getAttributeDefinitions(): dw.util.Collection<
        dw.object.ObjectTypeDefinition
      >;
      /**
       * Returns the description of this group in the current locale.
       *
       * @return the display name of this group.
       */
      getDescription(): string;
      /**
       * Returns the display name of this group.
       *
       * @return the display name of this group.
       */
      getDisplayName(): string;
      /**
       * Returns the ID of this group.
       *
       * @return the ID of this group.
       */
      getID(): string;
      /**
       * Returns the object type definition to which this attribute group
       *  belongs.
       *
       * @return the object type definition to which this attribute group belongs.
       */
      getObjectTypeDefinition(): dw.object.ObjectTypeDefinition;
      /**
       * Identifies if this is an sytem or a custom attribute group. A system
       *  attribute group is pre-defined and can not be deleted.
       *
       * @return true if this is a system attribute group, false otherwise.
       */
      isSystem(): boolean;
    }

    /**
     * Represents the value definition associated with an
     *  object attribute.
     */
    class ObjectAttributeValueDefinition {
      /**
       * A display name that can be used to present this value in
       *  the user interface. For example, the value might be '1' but the display
       *  name might be 'Order Exported'.
       */
      readonly displayValue: string;
      /**
       * The actual value for the attribute.
       */
      readonly value: any;

      /**
       * Returns a display name that can be used to present this value in
       *  the user interface. For example, the value might be '1' but the display
       *  name might be 'Order Exported'.
       *
       * @return a display name that can be used to present this value in the user interface.
       */
      getDisplayValue(): string;
      /**
       * Returns the actual value for the attribute.
       *
       * @return the actual value for the attribute.
       */
      getValue(): any;
    }

    /**
     * The class provides access to the meta data of a system object or custom
     *  object.  A short example should suffice to demonstrate how this metadata can
     *  be used in a script:
     *
     *  <pre> var co : CustomObject = CustomObjectMgr.getCustomObject(&quot;sample&quot;, &quot;MyCustomObject&quot;);
     *
     *  // get the object type definition
     *  var typeDef : ObjectTypeDefinition = co.describe();
     *  // get the custom object attribute definition for name &quot;enumIntValue&quot;
     *  var attrDef : ObjectAttributeDefinition = typeDef.getCustomAttributeDefinition( &quot;enumIntValue&quot; );
     *  // get the collection of object attribute value definitions
     *  var valueDefs : Collection = attrDef.getValues();
     *
     *  // return function if there are no object attribute value definitions
     *  if(valueDefs.isEmpty())
     *  {
     *      return;
     *  }
     *
     *  var displayValue : String;
     *  // loop over object attribute value definitions collection
     *  for each ( var valueDef : ObjectAttributeValueDefinition in valueDefs )
     *  {
     *      if( valueDef.getValue() == co.custom.intValue )
     *      {
     *          displayValue = valueDef.getDisplayValue();
     *          break;
     *      }
     *  }
     *  </pre>
     */
    class ObjectTypeDefinition {
      /**
       * A collection of all declared attributes for the object.
       *  The collection contains both system and custom attributes. There might
       *  be system and custom attribute with identical names. So the name of the
       *  attribute is not a uniqueness criteria. Additional the isCustom() flag
       *  must be checked.
       */
      readonly attributeDefinitions: dw.util.Collection<
        dw.object.ObjectTypeDefinition
      >;
      /**
       * A collection of all declared attribute groups. A attribute group
       *  is a collection of attribute, which are typically displayed together as
       *  a visual group.
       */
      readonly attributeGroups: dw.util.Collection<
        dw.object.ObjectAttributeGroup
      >;
      /**
       * The display name of the definition, which can be used in the
       *  user interface.
       */
      readonly displayName: string;
      /**
       * The type id of the business objects.
       */
      readonly ID: string;
      /**
       * Identifies if this object definition is for a system type or a custom
       *  type.
       */
      readonly system: boolean;

      /**
       * Returns a collection of all declared attributes for the object.
       *  The collection contains both system and custom attributes. There might
       *  be system and custom attribute with identical names. So the name of the
       *  attribute is not a uniqueness criteria. Additional the isCustom() flag
       *  must be checked.
       *
       * @return a collection of all declared attributes for the object.
       */
      getAttributeDefinitions(): dw.util.Collection<
        dw.object.ObjectTypeDefinition
      >;
      /**
       * Returns the attribute group with the given name within this object
       *  type definition.
       * @param name The name of the attribute scope to return.
       * @return The matching attribute scope or null if no such scope exists.
       */
      getAttributeGroup(name: string): dw.object.ObjectAttributeGroup;
      /**
       * Returns a collection of all declared attribute groups. A attribute group
       *  is a collection of attribute, which are typically displayed together as
       *  a visual group.
       *
       * @return a collection of all declared attribute groups.
       */
      getAttributeGroups(): dw.util.Collection<dw.object.ObjectAttributeGroup>;
      /**
       * Returns the custom attribute definition with the given name. The method
       *  returns null if no custom attribute is defined with that name.
       * @param name The unique name of the custom attribute definition within the object type.
       * @return The matching attribute definition or null in case no such definition exists.
       */
      getCustomAttributeDefinition(
        name: string
      ): dw.object.ObjectAttributeDefinition;
      /**
       * Returns the display name of the definition, which can be used in the
       *  user interface.
       *
       * @return the display name of the definition, which can be used in the user interface.
       */
      getDisplayName(): string;
      /**
       * Returns the type id of the business objects.
       *
       * @return the type id of the business objects.
       */
      getID(): string;
      /**
       * Returns the system attribute definition with the given name. The method
       *  returns null if no system attribute is defined with that name. Only
       *  system objects have system attributes. A CustomObject has no system attributes
       *  and so the method will always return null for a CustomObject.
       * @param name The unique name of the custom attribute definition within the object type.
       * @return The matching attribute definition or null in case no such definition exists.
       */
      getSystemAttributeDefinition(
        name: string
      ): dw.object.ObjectAttributeDefinition;
      /**
       * Identifies if this object definition is for a system type or a custom
       *  type.
       *
       * @return true if this object definition is for a system type, false otherwise.
       */
      isSystem(): boolean;
    }

    /**
     * Common base class for all objects in Commerce Cloud Digital that have an
     *  identity and can be stored and retrieved.  Each entity is identified by
     *  a unique universal identifier (a UUID).
     */
    class PersistentObject {
      /**
       * The date that this object was created.
       */
      readonly creationDate: Date;
      /**
       * The date that this object was last modified.
       */
      readonly lastModified: Date;
      /**
       * The unique universal identifier for this object.
       */
      readonly UUID: string;

      /**
       * Returns the date that this object was created.
       *
       * @return the date that this object was created.
       */
      getCreationDate(): Date;
      /**
       * Returns the date that this object was last modified.
       *
       * @return the date that this object was last modified.
       */
      getLastModified(): Date;
      /**
       * Returns the unique universal identifier for this object.
       *
       * @return the unique universal identifier for this object.
       */
      getUUID(): string;
    }

    /**
     * Base class alternative to ExtensibleObject for customizable objects which do not rely on the metadata system.
     *  Unlike Extensible any custom attributes can be set on the fly and are not checked against an available list.
     *  Similar to Extensible method <a href="class_dw_object_SimpleExtensible.html#dw_object_SimpleExtensible_getCustom_DetailAnchor">getCustom()</a> is the central point to retrieve and store the objects attribute
     *  values.
     */
    class SimpleExtensible {
      /**
       * The custom attributes for this object.
       */
      readonly custom: dw.object.CustomAttributes;

      /**
       * Returns the custom attributes for this object.
       *
       * @return the custom attributes for this object.
       */
      getCustom(): dw.object.CustomAttributes;
    }

    /**
     * Manager class which provides methods for querying for system objects with
     *  meta data using the Commerce Cloud Digital query language. See individual API methods for
     *  details on the query language.
     *  <p>
     *  Note: Other manager classes such as <a href="class_dw_customer_CustomerMgr.html">CustomerMgr</a>,
     *  <a href="class_dw_catalog_ProductMgr.html">ProductMgr</a>, etc provide more specific and fine-grained
     *  querying methods that can not be achieved using the general query language.
     *  </p><p>
     *  To search for custom objects, use <a href="class_dw_object_CustomObjectMgr.html">CustomObjectMgr</a>.
     *  <b>Note:</b> this class allows access to sensitive information through
     *  operations that retrieve the Profile and Order objects.
     *  Pay attention to appropriate legal and regulatory requirements related to this data.</p>
     */
    class SystemObjectMgr {
      /**
       * Returns the object type definition for the given system object type.
       *
       *  This method can be used for all system object types that are derived from ExtensibleObject.
       * @param type system object type whose type definition should be returned
       * @return the matching object type definition or null in case no such type definition exists.
       */
      static describe(type: string): dw.object.ObjectTypeDefinition;
      /**
       * Returns all system objects of a specific type.
       *  The following system object types are supported:
       *  GiftCertificate
       *  Order
       *  Profile
       *  SourceCodeGroup
       *  Store
       *  ProductList
       *
       *  The method throws an exception in case of another system type.
       *
       *  It is strongly recommended to call close() on the returned SeekableIterator
       *  if not all of its elements are being retrieved. This will ensure the proper cleanup of system resources.
       * @param type The name of the system object type. If a matching type definition cannot be found for the given type a MetaDataException will be thrown.
       * @return SeekableIterator containing all system objects of a specific type.
       */
      static getAllSystemObjects(type: string): dw.util.SeekableIterator;
      /**
       * Searches for a single system object instance. The following system
       *  object types are supported:
       *  GiftCertificate
       *  Order
       *  Profile
       *  SourceCodeGroup
       *  Store
       *  ProductList
       *
       *  The method throws an exception in case of another system type.
       *
       *  The search can be configured using a simple query language, which
       *  provides most common filter and operator functionality.
       *
       *  The identifier for an attribute  to use in a query condition is always the
       *  ID of the  attribute as defined in the type definition. For custom defined attributes
       *  the prefix custom is required in the search term (e.g. custom.color = {1}),
       *  while for system attributes no prefix is used (e.g. name = {4}).
       *
       *  Supported attribute value types with sample expression values:
       *  String 'String', 'Str*', 'Strin?'
       *  Integer 1, 3E4
       *  Number 1.0, 3.99E5
       *  Date yyyy-MM-dd e.g. 2007-05-31 (Default TimeZone = UTC)
       *  DateTime yyyy-MM-dd'T'hh:mm:ss+Z e.g. 2007-05-31T00:00+Z (Z TimeZone = UTC) or 2007-05-31T00:00:00
       *  Boolean true, false
       *  Email '[emailprotected]', '*@demandware.com'
       *  Set of String 'String', 'Str*', 'Strin?'
       *  Set of Integer 1, 3E4
       *  Set of Number 1.0, 3.99E5
       *  Enum of String 'String', 'Str*', 'Strin?'
       *  Enum of Integer 1, 3E4
       *  The following types of attributes are not queryable:
       *  Image
       *  HTML
       *  Text
       *  Quantity
       *  Password
       *  Note, that some system attributes are not queryable by default regardless of the
       *  actual value type code.
       *
       *
       *  The following operators are supported in a condition:
       *  = Equals - All types; supports NULL value (thumbnail = NULL)
       *  != Not equals - All types; supports NULL value (thumbnail != NULL)
       *  < Less than  - Integer, Number and Date types only
       *  > Greater than - Integer, Number and Date types only
       *  <= Less or equals than - Integer, Number and Date types only
       *  >= Greater or equals than  - Integer, Number and Date types only
       *  LIKE Like - String types and Email only; use if leading or trailing
       *  wildcards will be used to support substring search(custom.country LIKE 'US*')
       *  ILIKE Caseindependent Like - String types and Email only, use to support
       *  case insensitive query (custom.country ILIKE 'usa'), does also support wildcards for
       *  substring matching
       *
       *  Conditions can be combined using logical expressions 'AND', 'OR' and 'NOT'
       *  and nested using parenthesis e.g.
       *  gender = {1} AND (age >= {2} OR (NOT profession LIKE {3})).
       *
       *
       *  The query language provides a placeholder syntax to pass objects as
       *  additional search parameters. Each passed object is related to a
       *  placeholder in the query string. The placeholder must be an Integer that
       *  is surrounded by braces. The first Integer value must be '0', the second
       *  '1' and so on, e.g.
       *  querySystemObjects("sample", "age = {0} or creationDate >= {1}", 18, date)
       *
       *
       *  If there is more than one object matching the specified query criteria, the
       *  result is not deterministic. In order to retrieve a single object from a sorted result
       *  set it is recommended to use the following code:
       *  querySystemObjects("", "custom.myAttr asc", null).first().
       *  The method first() returns only the next element and closes the
       *  iterator.
       *
       *  It is strongly recommended to call close() on the returned SeekableIterator
       *  if not all of its elements are being processed. This will enable the cleanup of system resources.
       * @param type the system object type for the query.
       * @param queryString the actual query.
       * @param args optional parameters for the queryString.
       * @return the system object defined by type which was found when executing the queryString.
       */
      static querySystemObject(
        type: string,
        queryString: string,
        ...args: any[]
      ): dw.object.PersistentObject;
      /**
       * Searches for system object instances. The following system object types
       *  are supported:
       *  GiftCertificate
       *  Order
       *  Profile
       *  SourceCodeGroup
       *  Store
       *  ProductList
       *
       *  The method throws an exception in case of another system type.
       *
       *  The search can be configured using a simple query language, which
       *  provides most common filter and operator functionality.
       *
       *  The identifier for an attribute  to use in a query condition is always the
       *  ID of the  attribute as defined in the type definition. For custom defined attributes
       *  the prefix custom is required in the search term (e.g. custom.color = {1}),
       *  while for system attributes no prefix is used (e.g. name = {4}).
       *
       *  Supported attribute value types with sample expression values:
       *  String 'String', 'Str*', 'Strin?'
       *  Integer 1, 3E4
       *  Number 1.0, 3.99E5
       *  Date yyyy-MM-dd e.g. 2007-05-31 (Default TimeZone = UTC)
       *  DateTime yyyy-MM-dd'T'hh:mm:ss+Z e.g. 2007-05-31T00:00+Z (Z TimeZone = UTC) or 2007-05-31T00:00:00
       *  Boolean true, false
       *  Email '[emailprotected]', '*@demandware.com'
       *  Set of String 'String', 'Str*', 'Strin?'
       *  Set of Integer 1, 3E4
       *  Set of Number 1.0, 3.99E5
       *  Enum of String 'String', 'Str*', 'Strin?'
       *  Enum of Integer 1, 3E4
       *  The following types of attributes are not queryable:
       *  Image
       *  HTML
       *  Text
       *  Quantity
       *  Password
       *  Note, that some system attributes are not queryable by default regardless of the
       *  actual value type code.
       *
       *
       *  The following operators are supported in a condition:
       *  = Equals - All types; supports NULL value (thumbnail = NULL)
       *  != Not equals - All types; supports NULL value (thumbnail != NULL)
       *  < Less than  - Integer, Number and Date types only
       *  > Greater than - Integer, Number and Date types only
       *  <= Less or equals than - Integer, Number and Date types only
       *  >= Greater or equals than  - Integer, Number and Date types only
       *  LIKE Like - String types and Email only; use if leading or trailing
       *  wildcards will be used to support substring search(custom.country LIKE 'US*')
       *  ILIKE Caseindependent Like - String types and Email only, use to support
       *  case insensitive query (custom.country ILIKE 'usa'), does also support wildcards for
       *  substring matching
       *
       *  Conditions can be combined using logical expressions 'AND', 'OR' and 'NOT'
       *  and nested using parenthesis e.g.
       *  gender = {1} AND (age >= {2} OR (NOT profession LIKE {3})).
       *
       *
       *  The query language provides a placeholder syntax to pass objects as
       *  additional search parameters. Each passed object is related to a
       *  placeholder in the query string. The placeholder must be an Integer that
       *  is surrounded by braces. The first Integer value must be '0', the second
       *  '1' and so on, e.g.
       *  querySystemObjects("sample", "age = {0} or creationDate >= {1}", 18, date)
       *
       *
       *  The sorting parameter is optional and may contain a comma separated list of
       *  attribute names to sort by. Each sort attribute name may be followed by an
       *  optional sort direction specifier ('asc' | 'desc'). Default sorting directions is
       *  ascending, if no direction was specified.
       *  Example: age desc, name
       *  Please note that specifying a localized custom attribute as the sorting attribute is
       *  currently not supported.
       *
       *  Sometimes it is desired to get all instances of specified type with a special sorting condition.
       *  This can be easily done by providing the 'type' of the system object and the 'sortString' in combination with
       *  an empty 'queryString', e.g. querySystemObjects("sample", "", "ID asc")
       *
       *  It is strongly recommended to call close() on the returned SeekableIterator
       *  if not all of its elements are being retrieved. This will ensure the proper cleanup of system resources.
       * @param type the system object type for the query.
       * @param queryString the actual query.
       * @param sortString an optional sorting or null if no sorting is necessary.
       * @param args optional parameters for the queryString.
       * @return SeekableIterator containing the result set of the query.
       */
      static querySystemObjects(
        type: string,
        queryString: string,
        sortString: string,
        ...args: any[]
      ): dw.util.SeekableIterator;
      /**
       * Searches for system object instances. The following system object types
       *  are supported:
       *  GiftCertificate
       *  Order
       *  Profile
       *  SourceCodeGroup
       *  Store
       *  ProductList
       *
       *  The method throws an exception in case of another system type.
       *
       *  The search can be configured with a map, which key-value pairs are
       *  converted into a query expression. The key-value pairs are turned into a
       *  sequence of '=' or 'like' conditions, which are combined with AND
       *  statements.
       *
       *  Example:
       *  A map with the key/value pairs: 'name'/'tom*', 'age'/66
       *  will be converted as follows: "name like 'tom*' and age = 66"
       *
       *  The identifier for an attribute  to use in a query condition is always the
       *  ID of the  attribute as defined in the type definition. For custom defined attributes
       *  the prefix custom is required in the search term (e.g. custom.color = {1}),
       *  while for system attributes no prefix is used (e.g. name = {4}).
       *
       *  Supported attribute value types with sample expression values:
       *  String 'String', 'Str*', 'Strin?'
       *  Integer 1, 3E4
       *  Number 1.0, 3.99E5
       *  Date yyyy-MM-dd e.g. 2007-05-31 (Default TimeZone = UTC)
       *  DateTime yyyy-MM-dd'T'hh:mm:ss+Z e.g. 2007-05-31T00:00+Z (Z TimeZone = UTC) or 2007-05-31T00:00:00
       *  Boolean true, false
       *  Email '[emailprotected]', '*@demandware.com'
       *  Set of String 'String', 'Str*', 'Strin?'
       *  Set of Integer 1, 3E4
       *  Set of Number 1.0, 3.99E5
       *  Enum of String 'String', 'Str*', 'Strin?'
       *  Enum of Integer 1, 3E4
       *  The following types of attributes are not queryable:
       *  Image
       *  HTML
       *  Text
       *  Quantity
       *  Password
       *  Note, that some system attributes are not queryable by default regardless of the
       *  actual value type code.
       *
       *
       *  The sorting parameter is optional and may contain a comma separated list of
       *  attribute names to sort by. Each sort attribute name may be followed by an
       *  optional sort direction specifier ('asc' | 'desc'). Default sorting directions is
       *  ascending, if no direction was specified.
       *  Example: age desc, name
       *  Please note that specifying a localized custom attribute as the sorting attribute is
       *  currently not supported.
       *
       *  It is strongly recommended to call close() on the returned SeekableIterator
       *  if not all of its elements are being retrieved. This will ensure the proper cleanup of system resources.
       * @param type the system object type for the query.
       * @param queryAttributes key-value pairs, which define the query.
       * @param sortString an optional sorting or null if no sorting is necessary.
       * @return SeekableIterator containing the result set of the query.
       */
      static querySystemObjects(
        type: string,
        queryAttributes: dw.util.Map<any, any>,
        sortString: string
      ): dw.util.SeekableIterator;
    }
  }

  namespace order {
    /**
     * An item which references, or in other words is based upon, an <a href="class_dw_order_OrderItem.html">OrderItem</a>. Provides methods to access the
     *  OrderItem, the order <a href="class_dw_order_LineItem.html">LineItem</a> which has been extended, and the <a href="class_dw_order_Order.html">Order</a>. In addition it defines
     *  methods to access item level prices and the item id. Supports custom-properties.
     */
    class AbstractItem extends dw.object.Extensible {
      /**
       * Gross price of item.
       */
      readonly grossPrice: dw.value.Money;
      /**
       * The item-id used for referencing between items
       */
      readonly itemID: string;
      /**
       * The Order Product- or Shipping- LineItem associated with this item. Should never return null.
       */
      readonly lineItem: dw.order.LineItem;
      /**
       * Net price of item.
       */
      readonly netPrice: dw.value.Money;
      /**
       * The order item extensions related to this item. Should never return null.
       */
      readonly orderItem: dw.order.OrderItem;
      /**
       * The order-item-id used for referencing the OrderItem
       */
      readonly orderItemID: string;
      /**
       * Total tax for item.
       */
      readonly tax: dw.value.Money;
      /**
       * Price of entire item on which tax calculation is based. Same as getNetPrice()
       *  or getGrossPrice() depending on whether the order is based on net or gross prices.
       */
      readonly taxBasis: dw.value.Money;
      /**
       * Tax items representing a tax breakdown
       */
      readonly taxItems: dw.util.Collection<dw.order.TaxItem>;

      /**
       * Gross price of item.
       *
       * @return Gross price of item.
       */
      getGrossPrice(): dw.value.Money;
      /**
       * The item-id used for referencing between items
       *
       * @return the item-id used for referencing between items
       */
      getItemID(): string;
      /**
       * Returns the Order Product- or Shipping- LineItem associated with this item. Should never return null.
       *
       * @return the Order Product- or Shipping- LineItem associated with this item
       */
      getLineItem(): dw.order.LineItem;
      /**
       * Net price of item.
       *
       * @return Net price of item.
       */
      getNetPrice(): dw.value.Money;
      /**
       * Returns the order item extensions related to this item. Should never return null.
       *
       * @return the order item extensions related to this item
       */
      getOrderItem(): dw.order.OrderItem;
      /**
       * The order-item-id used for referencing the OrderItem
       *
       * @return the order-item-id used for referencing the OrderItem
       */
      getOrderItemID(): string;
      /**
       * Total tax for item.
       *
       * @return Total tax for item.
       */
      getTax(): dw.value.Money;
      /**
       * Price of entire item on which tax calculation is based. Same as getNetPrice()
       *  or getGrossPrice() depending on whether the order is based on net or gross prices.
       *
       * @return Price of entire item on which tax calculation is based
       */
      getTaxBasis(): dw.value.Money;
      /**
       * Tax items representing a tax breakdown
       *
       * @return tax items representing a tax breakdown
       */
      getTaxItems(): dw.util.Collection<dw.order.TaxItem>;
    }

    /**
     * Basis for item-based objects stemming from a single <a href="class_dw_order_Order.html">Order</a>, with these common
     *  properties (Invoice is used as an example):
     *
     *  <ul>
     *  <li>
     *  The object has been created from an Order accessible using <a href="class_dw_order_AbstractItemCtnr.html#dw_order_AbstractItemCtnr_getOrder_DetailAnchor">getOrder()</a></li>
     *  <li>Contains a collection of <a href="class_dw_order_AbstractItemCtnr.html#dw_order_AbstractItemCtnr_getItems_DetailAnchor"> items</a>, each item related to exactly one <a href="class_dw_order_OrderItem.html">OrderItem</a> which in turn represents
     *  an extension to one of the order <a href="class_dw_order_ProductLineItem.html">ProductLineItem</a> or one <a href="class_dw_order_ShippingLineItem.html">ShippingLineItem</a>.
     *  Example: an <a href="class_dw_order_Invoice.html">Invoice</a> has <a href="class_dw_order_InvoiceItem.html">InvoiceItem</a>s</li>
     *  <li>
     *  The items hold various prices which are summed, resulting in a
     *  <a href="class_dw_order_AbstractItemCtnr.html#dw_order_AbstractItemCtnr_getProductSubtotal_DetailAnchor"> product-subtotal</a>, a
     *  <a href="class_dw_order_AbstractItemCtnr.html#dw_order_AbstractItemCtnr_getServiceSubtotal_DetailAnchor"> service-subtotal</a> and a <a href="class_dw_order_AbstractItemCtnr.html#dw_order_AbstractItemCtnr_getGrandTotal_DetailAnchor"> grand-total</a>, each represented by a <a href="class_dw_order_SumItem.html">SumItem</a>.</li>
     *  <li>The object is customizable using custom properties</li>
     *  </ul>
     */
    class AbstractItemCtnr extends dw.object.Extensible {
      /**
       * Created by this user.
       */
      readonly createdBy: string;
      /**
       * The time of creation.
       */
      readonly creationDate: Date;
      /**
       * The sum-item representing the grandtotal for all items.
       */
      readonly grandTotal: dw.order.SumItem;
      /**
       * The unsorted collection of items
       */
      readonly items: dw.util.FilteringCollection<dw.order.AbstractItem>;
      /**
       * The last modification time.
       */
      readonly lastModified: Date;
      /**
       * Last modified by this user.
       */
      readonly modifiedBy: string;
      /**
       * The Order this object was created for.
       */
      readonly order: dw.order.Order;
      /**
       * The sum-item representing the subtotal for product items.
       */
      readonly productSubtotal: dw.order.SumItem;
      /**
       * The sum-item representing the subtotal for service items such as
       *  shipping.
       */
      readonly serviceSubtotal: dw.order.SumItem;

      /**
       * Created by this user.
       *
       * @return Created by this user
       */
      getCreatedBy(): string;
      /**
       * The time of creation.
       *
       * @return time of creation.
       */
      getCreationDate(): Date;
      /**
       * Returns the sum-item representing the grandtotal for all items.
       *
       * @return sum-item for all items
       */
      getGrandTotal(): dw.order.SumItem;
      /**
       * Returns the unsorted collection of items
       *
       * @return the unsorted collection of items
       */
      getItems(): dw.util.FilteringCollection<dw.order.AbstractItem>;
      /**
       * The last modification time.
       *
       * @return last modification time..
       */
      getLastModified(): Date;
      /**
       * Last modified by this user.
       *
       * @return Last modified by this user
       */
      getModifiedBy(): string;
      /**
       * Returns the Order this object was created for.
       *
       * @return the Order this object was created for.
       */
      getOrder(): dw.order.Order;
      /**
       * Returns the sum-item representing the subtotal for product items.
       *
       * @return sum-item for product items
       */
      getProductSubtotal(): dw.order.SumItem;
      /**
       * Returns the sum-item representing the subtotal for service items such as
       *  shipping.
       *
       * @return sum-item for service items such as shipping
       */
      getServiceSubtotal(): dw.order.SumItem;
    }

    /**
     * The Appeasement represents a shopper request for an order credit.<br>
     *  Example: The buyer finds any problem with the products but he agrees to preserve them, if he would be compensated,
     *  rather than return them.<br>
     *  <br>
     *  The Appeasement contains 1..n appeasement items.
     *  Each appeasement item is associated with one <a href="class_dw_order_OrderItem.html">OrderItem</a> usually representing an <a href="class_dw_order_Order.html">Order</a>
     *  <a href="class_dw_order_ProductLineItem.html">ProductLineItem</a>. <br>
     *  <br>
     *  An Appeasement can have one of these status values:
     *  <ul>
     *  <li>OPEN - the appeasement is open and appeasement items could be added to it</li>
     *  <li>COMPLETED - the appeasement is complete and it is not allowed to add new items to it, this is a precondition
     *  for refunding the customer for an appeasement.</li>
     *  </ul>
     *  <p>
     *  Order post-processing APIs (gillian) are now inactive by default and will throw
     *  an exception if accessed. On sandboxes the APIs can be activated with a feature
     *  switch &quot;Order Post Processing APIs on Sandboxes&quot;. On PIGs an activation needs
     *  preliminary approval by Product Management. Please contact support in this case.
     *  Existing customers using these APIs are not affected by this change and can use the
     *  APIs until further notice.</p>
     */
    class Appeasement extends dw.order.AbstractItemCtnr {
      /**
       * Sorting by item id. Use with method getItems() as an argument to method FilteringCollection.sort(Object).
       */
      static readonly ORDERBY_ITEMID: any;
      /**
       * Sorting by the position of the related order item. Use with method getItems() as an argument to method FilteringCollection.sort(Object).
       */
      static readonly ORDERBY_ITEMPOSITION: any;
      /**
       * Unsorted, as it is. Use with method getItems() as an argument to method FilteringCollection.sort(Object).
       */
      static readonly ORDERBY_UNSORTED: any;
      /**
       * Selects the product items. Use with method getItems() as an argument to method FilteringCollection.select(Object).
       */
      static readonly QUALIFIER_PRODUCTITEMS: any;
      /**
       * Selects the service items. Use with method getItems() as an argument to method FilteringCollection.select(Object).
       */
      static readonly QUALIFIER_SERVICEITEMS: any;
      /**
       * Constant for Appeasement Status COMPLETED
       */
      static readonly STATUS_COMPLETED = "COMPLETED";
      /**
       * Constant for Appeasement Status OPEN
       */
      static readonly STATUS_OPEN = "OPEN";

      /**
       * The appeasement number.
       */
      readonly appeasementNumber: string;
      /**
       * Returns null or the previously created Invoice.
       */
      readonly invoice: dw.order.Invoice;
      /**
       * Returns null or the invoice-number.
       */
      readonly invoiceNumber: string;
      /**
       * A filtering collection of the appeasement items belonging to the appeasement.
       *
       *  This FilteringCollection could be sorted / filtered using:
       *
       *  FilteringCollection.sort(Object) with ORDERBY_ITEMID
       *  FilteringCollection.sort(Object) with ORDERBY_ITEMPOSITION
       *  FilteringCollection.sort(Object) with ORDERBY_UNSORTED
       *  FilteringCollection.select(Object) with QUALIFIER_PRODUCTITEMS
       *  FilteringCollection.select(Object) with QUALIFIER_SERVICEITEMS
       */
      readonly items: dw.util.FilteringCollection<dw.order.AppeasementItem>;
      /**
       * The reason code for the appeasement. The list of reason codes can be updated
       *  by updating meta-data for Appeasement.
       */
      reasonCode: dw.value.EnumValue;
      /**
       * The reason note for the appeasement.
       */
      reasonNote: string;
      /**
       * Gets the status of this appeasement.
       *  The possible values are STATUS_OPEN, STATUS_COMPLETED.
       */
      status: dw.value.EnumValue;

      /**
       * Creates appeasement items corresponding to certain order items and adds them to the appeasement.
       * @param totalAmount the appeasement amount corresponding to the provided order items; this amount is the net price when the order is net based and respectively - gross price when the order is gross based
       * @param orderItems the order items for which appeasement items should be created
       */
      addItems(
        totalAmount: dw.value.Money,
        orderItems: dw.util.List<any>
      ): void;
      /**
       * Creates a new Invoice based on this Appeasement. The appeasement-number
       *  will be used as the invoice-number.
       *
       *  The method must not be called more than once for an Appeasement,
       *  nor may 2 invoices exist with the same invoice-number.
       *
       *  The new Invoice is a credit-invoice with a Invoice.STATUS_NOT_PAID status, and
       *  should be passed to the refund payment-hook in a separate database transaction for processing.
       *
       * @return the created invoice
       */
      createInvoice(): dw.order.Invoice;
      /**
       * Creates a new Invoice based on this Appeasement. The
       *  invoice-number must be specified as an argument.
       *
       *  The method must not be called more than once for an Appeasement,
       *  nor may 2 invoices exist with the same invoice-number.
       *
       *  The new Invoice is a credit-invoice with a Invoice.STATUS_NOT_PAID status, and
       *  should be passed to the refund payment-hook in a separate database transaction for processing.
       * @param invoiceNumber the invoice-number to be used in the appeasement creation process
       * @return the created invoice
       */
      createInvoice(invoiceNumber: string): dw.order.Invoice;
      /**
       * Returns the appeasement number.
       *
       * @return the appeasement number
       */
      getAppeasementNumber(): string;
      /**
       * Returns null or the previously created Invoice.
       *
       * @return null or the previously created invoice
       */
      getInvoice(): dw.order.Invoice;
      /**
       * Returns null or the invoice-number.
       *
       * @return null or the number of the previously created invoice
       */
      getInvoiceNumber(): string;
      /**
       * Returns a filtering collection of the appeasement items belonging to the appeasement.
       *
       *  This FilteringCollection could be sorted / filtered using:
       *
       *  FilteringCollection.sort(Object) with ORDERBY_ITEMID
       *  FilteringCollection.sort(Object) with ORDERBY_ITEMPOSITION
       *  FilteringCollection.sort(Object) with ORDERBY_UNSORTED
       *  FilteringCollection.select(Object) with QUALIFIER_PRODUCTITEMS
       *  FilteringCollection.select(Object) with QUALIFIER_SERVICEITEMS
       *
       * @return the filtering collection of the appeasement items
       */
      getItems(): dw.util.FilteringCollection<dw.order.AppeasementItem>;
      /**
       * Returns the reason code for the appeasement. The list of reason codes can be updated
       *  by updating meta-data for Appeasement.
       *
       * @return the appeasement reason code
       */
      getReasonCode(): dw.value.EnumValue;
      /**
       * Returns the reason note for the appeasement.
       *
       * @return the reason note or null
       */
      getReasonNote(): string;
      /**
       * Gets the status of this appeasement.
       *  The possible values are STATUS_OPEN, STATUS_COMPLETED.
       *
       * @return the status
       */
      getStatus(): dw.value.EnumValue;
      /**
       * Set the reason code for the appeasement. The list of reason codes can be updated
       *  by updating meta-data for Appeasement.
       * @param reasonCode the reason code to set
       */
      setReasonCode(reasonCode: string): void;
      /**
       * Sets the reason note for the appeasement.
       * @param reasonNote the reason note for the appeasement to set
       */
      setReasonNote(reasonNote: string): void;
      /**
       * Sets the appeasement status.
       *
       *  The possible values are STATUS_OPEN, STATUS_COMPLETED.
       *
       *  When set to status COMPLETED, only the the custom attributes of its appeasement items can be changed.
       * @param appeasementStatus the appeasement status to set.
       */
      setStatus(appeasementStatus: string): void;
    }

    /**
     * Represents an item of an <a href="class_dw_order_Appeasement.html">Appeasement</a> which is associated with one <a href="class_dw_order_OrderItem.html">OrderItem</a> usually representing an <a href="class_dw_order_Order.html">Order</a>
     *  <a href="class_dw_order_ProductLineItem.html">ProductLineItem</a>. Items are created using method <a href="class_dw_order_Appeasement.html#dw_order_Appeasement_addItems_Money_List_DetailAnchor">Appeasement.addItems(Money, List)</a>
     *  <br>
     *  When the related Appeasement were set to status COMPLETED, only the the custom attributes of the appeasement item can be changed.
     *  <p>
     *  Order post-processing APIs (gillian) are now inactive by default and will throw
     *  an exception if accessed. On sandboxes the APIs can be activated with a feature
     *  switch &quot;Order Post Processing APIs on Sandboxes&quot;. On PIGs an activation needs
     *  preliminary approval by Product Management. Please contact support in this case.
     *  Existing customers using these APIs are not affected by this change and can use the
     *  APIs until further notice.</p>
     */
    class AppeasementItem extends dw.order.AbstractItem {
      /**
       * The number of the Appeasement to which this item belongs.
       */
      readonly appeasementNumber: string;
      /**
       * Returns null or the parent item.
       */
      parentItem: dw.order.AppeasementItem;

      /**
       * Returns the number of the Appeasement to which this item belongs.
       *
       * @return the number of the Appeasement to which this item belongs
       */
      getAppeasementNumber(): string;
      /**
       * Returns null or the parent item.
       *
       * @return null or the parent item.
       */
      getParentItem(): dw.order.AppeasementItem;
      /**
       * Set a parent item. The parent item must belong to the same
       *  Appeasement. An infinite parent-child loop is disallowed
       *  as is a parent-child depth greater than 10. Setting a parent item
       *  indicates a dependency of the child item on the parent item, and can be
       *  used to form a parallel structure to that accessed using
       *  ProductLineItem.getParent().
       * @param parentItem The parent item, null is allowed
       */
      setParentItem(parentItem: dw.order.AppeasementItem): void;
    }

    /**
     * The Basket class represents a shopping cart.
     */
    class Basket extends dw.order.LineItemCtnr {
      /**
       * Returns if the basket was created by an agent.
       *
       *  An agent basket is created by an agent on behalf of the customer in comparison to a storefront basket which is
       *  created by the customer e.g. in the storefront. An agent basket can be created with
       *  BasketMgr.createAgentBasket().
       */
      readonly agentBasket: boolean;
      /**
       * The timestamp when the inventory for this basket expires.
       *
       *  It will return null for the following reasons:
       *
       *  No reservation for the basket was done
       *  Reservation is outdated meaning the timestamp is in the past
       *
       *
       *
       *  Please note that the expiry timestamp will not always be valid for the whole basket. It will not be valid for
       *  new items added or items whose quantity has changed after the reservation was done.
       */
      readonly inventoryReservationExpiry: Date;
      /**
       * The order that this basket represents if the basket is being used to edit an order, otherwise this method
       *  returns null. Baskets created via BasketMgr.createBasketFromOrder(Order) will create a reference
       *  to the order that was used to create this basket (please check limitations around basket accessibility in
       *  BasketMgr.createBasketFromOrder(Order)).
       */
      readonly orderBeingEdited: dw.order.Order;
      /**
       * The number of the order that this basket represents if the basket is being used to edit an order,
       *  otherwise this method returns null. Baskets created via BasketMgr.createBasketFromOrder(Order)
       *  will create a reference to the order that was used to create this basket (please check limitations around basket
       *  accessibility in BasketMgr.createBasketFromOrder(Order)).
       */
      readonly orderNoBeingEdited: string;

      /**
       * Returns the timestamp when the inventory for this basket expires.
       *
       *  It will return null for the following reasons:
       *
       *  No reservation for the basket was done
       *  Reservation is outdated meaning the timestamp is in the past
       *
       *
       *
       *  Please note that the expiry timestamp will not always be valid for the whole basket. It will not be valid for
       *  new items added or items whose quantity has changed after the reservation was done.
       *
       * @return the inventory reservation expiry timestamp or null
       */
      getInventoryReservationExpiry(): Date;
      /**
       * Returns the order that this basket represents if the basket is being used to edit an order, otherwise this method
       *  returns null. Baskets created via BasketMgr.createBasketFromOrder(Order) will create a reference
       *  to the order that was used to create this basket (please check limitations around basket accessibility in
       *  BasketMgr.createBasketFromOrder(Order)).
       *
       * @return the order that this basket represents if the basket is being used to edit an order, otherwise this method returns null.
       */
      getOrderBeingEdited(): dw.order.Order;
      /**
       * Returns the number of the order that this basket represents if the basket is being used to edit an order,
       *  otherwise this method returns null. Baskets created via BasketMgr.createBasketFromOrder(Order)
       *  will create a reference to the order that was used to create this basket (please check limitations around basket
       *  accessibility in BasketMgr.createBasketFromOrder(Order)).
       *
       * @return the number of the order that this basket represents if the basket is being used to edit an order, otherwise this method returns null.
       */
      getOrderNoBeingEdited(): string;
      /**
       * Returns if the basket was created by an agent.
       *
       *  An agent basket is created by an agent on behalf of the customer in comparison to a storefront basket which is
       *  created by the customer e.g. in the storefront. An agent basket can be created with
       *  BasketMgr.createAgentBasket().
       *
       * @return true if the basket was created by an agent otherwise false
       */
      isAgentBasket(): boolean;
      /**
       * Releases all inventory previously reserved for this basket.
       *
       *  The method implements its own transaction handling. Calling the method from inside a transaction is disallowed
       *  and results in an exception being thrown. This behavior differs when calling the method from an OCAPI
       *  hook. OCAPI hooks handle transactions themselves, so in this case there is also no need to do any transaction
       *  handling, but to ensure the shortest possible locking of the inventory this method should only be called as
       *  the last step in the OCAPI hook.
       *
       * @return a Status instance with - Status.OK if release inventory was successful, otherwise Status.ERROR.
       */
      releaseInventory(): dw.system.Status;
      /**
       * Reserves inventory for all items in this basket for 10 minutes. Any reservations created by previous calls of
       *  this method will be reset to 10 minutes.
       *
       *
       *  The method can be used to reserve basket items before checkout to ensure that inventory is still available at the
       *  time an order is created from the basket using OrderMgr.createOrder(Basket). If all or some
       *  basket items are not reserved before creating an order, OrderMgr.createOrder(Basket) will
       *  validate item availability and will fail if any item is unavailable. Calling this method in the same request as
       *  OrderMgr.createOrder(Basket) is unnecessary and discouraged for performance reasons.
       *
       *
       *  Note that the maximum total quantity of reservations which can be made at any time is ATS (Available To
       *  Sell, see ProductInventoryRecord.getATS() ), but the ATS itself is not reduced by making a
       *  reservation. An example product has an ATS of 5 with 0 reservations. Now one basket reserves inventory for
       *  quantity 3, at which point any other basket still sees an ATS of 5 but can reserve a maximum of 2 items. The ATS
       *  is reduced when an order is created.
       *
       *
       *  Reservations can only be made for products with an inventory record. The reservation of product bundles is
       *  controlled by the Use Bundle Inventory Only setting on the inventory list. The setting allows inventory to
       *  be reserved for just the bundle or for the bundle and its bundled products.
       *
       *
       *  The following conditions must be met for the method to succeed:
       *
       *  an inventory list must be assigned to the current site
       *  all products in the basket must exist, and must not be of type Master or ProductSet
       *  each product line item must have a valid quantity
       *  each product must have an inventory record, or the inventory list must define that products without inventory
       *  record are available by default
       *  the reservation must succeed for each item as described above.
       *
       *
       *
       *  The method implements its own transaction handling. Calling the method from inside a transaction is disallowed
       *  and results in an exception being thrown. This behavior differs when calling the method from an OCAPI
       *  hook. OCAPI hooks handle transactions themselves, so in this case there is also no need to do any transaction
       *  handling, but to ensure the shortest possible locking of the inventory this method should only be called as
       *  the last step in the OCAPI hook.
       *
       *
       *  If the reservation fails with an ERROR status, existing valid reservations for the basket will remain unchanged
       *  but no new reservations will be made. This might lead to a partially reserved basket.
       *
       *
       *  Behaves same as reserveInventory( null, false );.
       *
       *
       *  This method must not be used with
       *
       *  the CreateOrder2 pipelet, or
       *  OrderMgr.createOrder(Basket), or
       *  OrderMgr.createOrder(Basket, String)
       *
       *  in the same request.
       *
       * @return a Status instance with - Status.OK if all items could be reserved, otherwise Status.ERROR meaning no items were reserved.
       */
      reserveInventory(): dw.system.Status;
      /**
       * Reserves inventory for all items in this basket for a specified amount of minutes. Any reservations created by
       *  previous calls of this method will be reset to that amount of minutes.
       *
       *
       *  The method can be used to reserve basket items before checkout to ensure that inventory is still available at the
       *  time an order is created from the basket using OrderMgr.createOrder(Basket). If all or some
       *  basket items are not reserved before creating an order, OrderMgr.createOrder(Basket) will
       *  validate item availability and will fail if any item is unavailable. Calling this method in the same request as
       *  OrderMgr.createOrder(Basket) is unnecessary and discouraged for performance reasons.
       *
       *
       *  Note that the maximum total quantity of reservations which can be made at any time is ATS (Available To
       *  Sell, see ProductInventoryRecord.getATS() ), but the ATS itself is not reduced by making a
       *  reservation. An example product has an ATS of 5 with 0 reservations. Now one basket reserves inventory for
       *  quantity 3, at which point any other basket still sees an ATS of 5 but can reserve a maximum of 2 items. The ATS
       *  is reduced when an order is created.
       *
       *
       *  Reservations can only be made for products with an inventory record. The reservation of product bundles is
       *  controlled by the Use Bundle Inventory Only setting on the inventory list. The setting allows inventory to
       *  be reserved for just the bundle or for the bundle and its bundled products.
       *
       *
       *  The following conditions must be met for the method to succeed:
       *
       *  an inventory list must be assigned to the current site
       *  all products in the basket must exist, and must not be of type Master or ProductSet
       *  each product line item must have a valid quantity
       *  each product must have an inventory record, or the inventory list must define that products without inventory
       *  record are available by default
       *  the reservation must succeed for each item as described above.
       *
       *
       *
       *  The method implements its own transaction handling. Calling the method from inside a transaction is disallowed
       *  and results in an exception being thrown. This behavior differs when calling the method from an OCAPI
       *  hook. OCAPI hooks handle transactions themselves, so in this case there is also no need to do any transaction
       *  handling, but to ensure the shortest possible locking of the inventory this method should only be called as
       *  the last step in the OCAPI hook.
       *
       *
       *  getInventoryReservationExpiry() can be used to determine when the expiration will expire.
       *
       *
       *  If the reservation fails with an ERROR status, existing valid reservations for the basket will remain unchanged
       *  but no new reservations will be made. This might lead to a partially reserved basket.
       *
       *
       *  Behaves same as reserveInventory( reservationDurationInMinutes, false );.
       *
       *
       *  This method must not be used with
       *
       *  the CreateOrder2 pipelet, or
       *  OrderMgr.createOrder(Basket), or
       *  OrderMgr.createOrder(Basket, String)
       *
       *  in the same request.
       * @param reservationDurationInMinutes reservation duration in minutes, specifying how long the reservation will last. The maximum value for the reservation duration is 240 minutes.
       * @return a Status instance with - Status.OK if all items could be reserved, otherwise Status.ERROR meaning no items were reserved.
       */
      reserveInventory(reservationDurationInMinutes: number): dw.system.Status;
      /**
       * Reserves inventory for all items in this basket for a specified amount of minutes. Any reservations created by
       *  previous calls of this method will be reset to that amount of minutes.
       *
       *
       *  The method can be used to reserve basket items before checkout to ensure that inventory is still available at the
       *  time an order is created from the basket using OrderMgr.createOrder(Basket). If all or some
       *  basket items are not reserved before creating an order, OrderMgr.createOrder(Basket) will
       *  validate item availability and will fail if any item is unavailable. Calling this method in the same request as
       *  OrderMgr.createOrder(Basket) is unnecessary and discouraged for performance reasons.
       *
       *
       *  Note that the maximum total quantity of reservations which can be made at any time is ATS (Available To
       *  Sell, see ProductInventoryRecord.getATS() ), but the ATS itself is not reduced by making a
       *  reservation. An example product has an ATS of 5 with 0 reservations. Now one basket reserves inventory for
       *  quantity 3, at which point any other basket still sees an ATS of 5 but can reserve a maximum of 2 items. The ATS
       *  is reduced when an order is created.
       *
       *
       *  Reservations can only be made for products with an inventory record. The reservation of product bundles is
       *  controlled by the Use Bundle Inventory Only setting on the inventory list. The setting allows inventory to
       *  be reserved for just the bundle or for the bundle and its bundled products.
       *
       *
       *  The following conditions must be met for the method to succeed:
       *
       *  an inventory list must be assigned to the current site
       *  all products in the basket must exist, and must not be of type Master or ProductSet
       *  each product line item must have a valid quantity
       *  each product must have an inventory record, or the inventory list must define that products without inventory
       *  record are available by default
       *  the reservation must succeed for each item as described above or removeIfNotAvailable is set to
       *  true
       *
       *
       *
       *  The method implements its own transaction handling. Calling the method from inside a transaction is disallowed
       *  and results in an exception being thrown. This behavior differs when calling the method from an OCAPI
       *  hook. OCAPI hooks handle transactions themselves, so in this case there is also no need to do any transaction
       *  handling, but to ensure the shortest possible locking of the inventory this method should only be called as
       *  the last step in the OCAPI hook.
       *
       *
       *  getInventoryReservationExpiry() can be used to determine when the expiration will expire.
       *
       *
       *  If the reservation fails with an ERROR status, existing valid reservations for the basket will remain unchanged
       *  but no new reservations will be made. This might lead to a partially reserved basket.
       *
       *
       *  If the reservation succeeds with an OK status and removeIfNotAvailable is true, basket
       *  line items quantities might have been changed or line items might have been removed. The returned
       *  Status object will contain information about the changes. Possible values for
       *  StatusItem.getCode() are:
       *
       *  BUNDLE_REMOVED - a bundle item was removed completely
       *  ITEM_REMOVED - a product line item was removed completely
       *  ITEM_QUANTITY_REDUCED - the quantity of a line item was reduced
       *
       *  StatusItem.getDetails() will contain for each item the sku and uuid of the item
       *  which was changed/removed.
       *
       *
       *  This method must not be used with
       *
       *  the CreateOrder2 pipelet, or
       *  OrderMgr.createOrder(Basket), or
       *  OrderMgr.createOrder(Basket, String)
       *
       *  in the same request.
       * @param reservationDurationInMinutes reservation duration in minutes, specifying how long the reservation will last. The maximum value for the reservation duration is 240 minutes.
       * @param removeIfNotAvailable if true is specified it will not fail if not the full quantity of the items can be reserved. Item quantity will be reduced to the quantity that could be reserved. Item will be removed if not at least quantity 1 for the item could be reserved. Different to that if a bundle line item cannot be reserved completely it will be removed including dependent line item (bundled items).
       * @return a Status instance with - Status.OK meaning reservation process was successful. In case of removeIfNotAvailable is true, status might contain status items (Status.getItems()) for each item that needed to be changed or removed. In the worst case this could result in an empty basket and no items reserved. A Status instance with - Status.ERROR will be returned if removeIfNotAvailable is false and not all items could be reserved fully or any unexpected error occurred.
       */
      reserveInventory(
        reservationDurationInMinutes: number,
        removeIfNotAvailable: boolean
      ): dw.system.Status;
      /**
       * Set the type of the business this order has been placed in.
       *  Possible values are LineItemCtnr.BUSINESS_TYPE_B2C or LineItemCtnr.BUSINESS_TYPE_B2B.
       * @param aType the business type to set for this basket
       */
      setBusinessType(aType: number): void;
      /**
       * Set the channel type in which sales channel this order has been created. This can be used to distinguish order
       *  placed through e.g. Storefront, Call Center or Marketplace.
       *  Possible values are LineItemCtnr.CHANNEL_TYPE_STOREFRONT,
       *  LineItemCtnr.CHANNEL_TYPE_CALLCENTER, LineItemCtnr.CHANNEL_TYPE_MARKETPLACE,
       *  LineItemCtnr.CHANNEL_TYPE_DSS, LineItemCtnr.CHANNEL_TYPE_STORE,
       *  LineItemCtnr.CHANNEL_TYPE_PINTEREST, LineItemCtnr.CHANNEL_TYPE_TWITTER,
       *  LineItemCtnr.CHANNEL_TYPE_FACEBOOKADS, LineItemCtnr.CHANNEL_TYPE_SUBSCRIPTIONS,
       *  LineItemCtnr.CHANNEL_TYPE_ONLINERESERVATION, LineItemCtnr.CHANNEL_TYPE_INSTAGRAMCOMMERCE.
       *
       *  The value for LineItemCtnr.CHANNEL_TYPE_CUSTOMERSERVICECENTER is also available, but it can not be set by the scripting API, it is set only internally.
       * @param aType the channel type to set for this basket
       */
      setChannelType(aType: number): void;
      /**
       * Sets the customer number of the customer associated with this container.
       * @param customerNo the customer number of the customer associated with this container.
       */
      setCustomerNo(customerNo: string): void;
      /**
       * Register a "start checkout" event for the current basket. This event is tracked for AB test statistics
       *  but otherwise has no effect on the basket. The system will register at most one checkout per basket per session.
       *
       */
      startCheckout(): void;
      /**
       * Updates the basket currency if different to session currency, otherwise does nothing.
       *
       *  Use Session.setCurrency(Currency) to set the currency for the session. To reflect the session
       *  currency change to the basket you need to update the basket with this method. This ensures that any upcoming
       *  basket recalculation, which is based on the session currency, matches the basket currency.
       *
       *
       *   ...
       *      if (basket.getBillingAddress().getCountryCode() == 'DE'){
       *        var newCurrency : Currency = Currency.getCurrency('EUR');
       *        session.setCurrency( newCurrency );
       *        basket.updateCurrency();
       *      }
       *      customBasketRecalculate();
       *  ...
       *
       */
      updateCurrency(): void;
    }

    /**
     * Provides static helper methods for managing baskets.
     */
    class BasketMgr {
      /**
       * Retrieve all open baskets for the logged in customer.
       *
       *  Restricted to agent scenario use cases: The returned list contains all agent baskets created with
       *  createAgentBasket() and the current storefront basket which can also be retrieved with
       *  getCurrentBasket(). This method will result in an exception if called by a user without permission
       *  Create_Order_On_Behalf_Of or if no customer is logged in the session.
       *
       *
       *  Please notice that baskets are invalidated after a certain amount of time and may not be returned anymore.
       */
      static readonly baskets: dw.util.List<dw.order.BasketMgr>;
      /**
       * This method returns the current valid basket of the session customer or null if no current valid
       *  basket exists.
       *
       *  The methods getCurrentBasket() and getCurrentOrNewBasket() work based on the selected basket
       *  persistence, which can be configured in the Business Manager site preferences / baskets section. A basket is
       *  valid for the configured basket lifetime.
       *
       *
       *  The current basket, if one exists, is usually updated by the method. In particular the last-modified date is
       *  updated. The lifetime of a basket can be extended in 2 ways:
       *
       *  The basket is modified in some way, e.g. a product is added resulting in the basket total being newly
       *  calculated. This results in the basket lifetime being reset.
       *  The basket has not been modified for 60 minutes, then using this method to access the basket will also reset
       *  the basket lifetime.
       *
       *
       *
       *  Personal data held inside the basket such as addresses, email addresses and payment settings is associated with
       *  the customer to whom the basket belongs. If the basket being updated belongs to a different customer this data is
       *  removed. This happens when a registered customer logs in after having previously created a basket as an anonymous
       *  customer. After the customer logs out, the previous basket is stored (where applicable) and the method returns
       *  null. Personal data is also cleared when the session times out for an anonymous customer.
       *
       *
       *  The following personal data is cleared.
       *
       *  product line items that were added from a wish list
       *  shipping method
       *  coupon line items
       *  gift certificate line items
       *  billing and shipping addresses
       *  payment instruments
       *  buyer email
       *
       *  If the session currency no longer matches the basket currency, the basket currency should be updated with
       *  Basket.updateCurrency().
       *
       *
       *  Typical usage:
       *
       *   var basket : Basket = BasketMgr.getCurrentBasket();
       *  if (basket) {
       *      // do something with basket
       *  }
       *
       *
       *
       *  Constraints:
       *
       *  The method only accesses the basket for the session customer, an exception is thrown when the session
       *  customer is null.
       *  Method getCurrentOrNewBasket() only creates a basket when method getCurrentBasket() returns
       *  null.
       */
      static readonly currentBasket: dw.order.Basket;
      /**
       * This method returns the current valid basket of the session customer or creates a new one if no current valid
       *  basket exists. See getCurrentBasket() for more details.
       */
      static readonly currentOrNewBasket: dw.order.Basket;
      /**
       * This method returns the stored basket of the session customer or null if none is found. A stored
       *  basket is returned in the following situation: - During one visit, a customer-X logs in and receives a basket-A -
       *  In a later visit, a second basket-B is created for an anonymous customer who then logs in as customer-X. In this
       *  case basket-B is reassigned to him and basket-A is accessible as the stored basket. Now it is possible to merge
       *  the information from the stored basket to the active basket.
       *
       *  A stored basket will exist only if the corresponding setting is selected in the Business Manager site
       *  preferences' baskets section. A basket is valid for the configured basket lifetime.
       *
       *  Typical usage:
       *
       *   var storedBasket : Basket = BasketMgr.getStoredBasket();
       *  var currentBasket : Basket = BasketMgr.getCurrentOrNewBasket();
       *  if (storedBasket) {
       *      // transfer all the data needed from the stored to the active basket
       *  }
       */
      static readonly storedBasket: dw.order.Basket;

      /**
       * Creates a new agent basket for the current session customer.
       *
       *  By default only 4 open agent baskets are allowed per customer. If this is exceeded a
       *  CreateAgentBasketLimitExceededException will be thrown.
       *
       *
       *  This method will result in an exception if called by a user without permission Create_Order_On_Behalf_Of or if no
       *  customer is logged in the session.
       *
       * @return the newly created basket for the customer which is logged in
       */
      static createAgentBasket(): dw.order.Basket;
      /**
       * Creates a Basket from an existing Order for the purposes of changing an Order. When an Order is later created
       *  from the Basket, the original Order is changed to status Order.ORDER_STATUS_REPLACED. Restricted
       *  to agent scenario use cases: In case a storefront customer is using it the created storefront basket cannot be
       *  retrieved via
       *
       *  getCurrentBasket() (ScriptAPI),
       *  GET /baskets/ (OCAPI) or
       *  GetBasket (Pipelet).
       *
       *  Baskets containing an "orderNumberBeingEdited" are explicitly excluded from the list of baskets that can be
       *  retrieved. Responsible for this behaviour (this kind of basket cannot be used as general purpose shopping
       *  baskets) - see Basket.getOrderNoBeingEdited() / Basket.getOrderBeingEdited().
       *
       *  In case a Business Manager user is logged in into the session the basket will be marked as an agent basket. See
       *  Basket.isAgentBasket().
       *
       *  The method only succeeds for an Order
       *
       *  without gift certificates,
       *  status is not cancelled,
       *  was not previously replaced and
       *  was not previously exported.
       *
       *  Failures are indicated by throwing an APIException of type CreateBasketFromOrderException which provides one of
       *  these errorCodes:
       *
       *  Code OrderProcessStatusCodes.ORDER_CONTAINS_GC - the Order contains a gift certificate and
       *  cannot be replaced.
       *  Code OrderProcessStatusCodes.ORDER_ALREADY_REPLACED - the Order was already replaced.
       *  Code OrderProcessStatusCodes.ORDER_ALREADY_CANCELLED - the Order was cancelled.
       *  Code OrderProcessStatusCodes.ORDER_ALREADY_EXPORTED - the Order has already been
       *  exported.
       *
       *
       *  Usage:
       *
       *   var order : Order; // known
       *  try
       *  {
       *    var basket : Basket = BasketMgr.createBasketFromOrder(order);
       *  }
       *  catch (e)
       *  {
       *    if (e instanceof APIException && e.type === 'CreateBasketFromOrderException')
       *    {
       *      // handle e.errorCode
       *    }
       *  }
       * @param order Order to create a Basket for
       * @return a new Basket
       */
      static createBasketFromOrder(order: dw.order.Order): dw.order.Basket;
      /**
       * Remove a customer basket.
       *
       *  This method will result in an exception if called by a user without permission Create_Order_On_Behalf_Of or if no
       *  customer is logged in the session.
       * @param basket the basket to be removed
       */
      static deleteBasket(basket: dw.order.Basket): void;
      /**
       * This method returns a valid basket of the session customer or null if none is found.
       *
       *  If the basket does not belong to the session customer, the method returns null.
       *
       *  If the registered customer is not logged in, the method returns null.
       *
       *
       *  Restricted to agent scenario use cases: This method will result in an exception if called by a user without
       *  permission Create_Order_On_Behalf_Of or if no customer is logged in the session.
       *
       *  The basket, if accessible, is usually updated in the same way as getCurrentBasket().
       *
       *  If the session currency no longer matches the basket currency, the basket currency should be updated with
       *  Basket.updateCurrency().
       * @param uuid the id of the requested basket.
       * @return the basket or null
       */
      static getBasket(uuid: string): dw.order.Basket;
      /**
       * Retrieve all open baskets for the logged in customer.
       *
       *  Restricted to agent scenario use cases: The returned list contains all agent baskets created with
       *  createAgentBasket() and the current storefront basket which can also be retrieved with
       *  getCurrentBasket(). This method will result in an exception if called by a user without permission
       *  Create_Order_On_Behalf_Of or if no customer is logged in the session.
       *
       *
       *  Please notice that baskets are invalidated after a certain amount of time and may not be returned anymore.
       *
       * @return all open baskets
       */
      static getBaskets(): dw.util.List<dw.order.BasketMgr>;
      /**
       * This method returns the current valid basket of the session customer or null if no current valid
       *  basket exists.
       *
       *  The methods getCurrentBasket() and getCurrentOrNewBasket() work based on the selected basket
       *  persistence, which can be configured in the Business Manager site preferences / baskets section. A basket is
       *  valid for the configured basket lifetime.
       *
       *
       *  The current basket, if one exists, is usually updated by the method. In particular the last-modified date is
       *  updated. The lifetime of a basket can be extended in 2 ways:
       *
       *  The basket is modified in some way, e.g. a product is added resulting in the basket total being newly
       *  calculated. This results in the basket lifetime being reset.
       *  The basket has not been modified for 60 minutes, then using this method to access the basket will also reset
       *  the basket lifetime.
       *
       *
       *
       *  Personal data held inside the basket such as addresses, email addresses and payment settings is associated with
       *  the customer to whom the basket belongs. If the basket being updated belongs to a different customer this data is
       *  removed. This happens when a registered customer logs in after having previously created a basket as an anonymous
       *  customer. After the customer logs out, the previous basket is stored (where applicable) and the method returns
       *  null. Personal data is also cleared when the session times out for an anonymous customer.
       *
       *
       *  The following personal data is cleared.
       *
       *  product line items that were added from a wish list
       *  shipping method
       *  coupon line items
       *  gift certificate line items
       *  billing and shipping addresses
       *  payment instruments
       *  buyer email
       *
       *  If the session currency no longer matches the basket currency, the basket currency should be updated with
       *  Basket.updateCurrency().
       *
       *
       *  Typical usage:
       *
       *   var basket : Basket = BasketMgr.getCurrentBasket();
       *  if (basket) {
       *      // do something with basket
       *  }
       *
       *
       *
       *  Constraints:
       *
       *  The method only accesses the basket for the session customer, an exception is thrown when the session
       *  customer is null.
       *  Method getCurrentOrNewBasket() only creates a basket when method getCurrentBasket() returns
       *  null.
       *
       * @return the current basket or null if no valid current basket exists.
       */
      static getCurrentBasket(): dw.order.Basket;
      /**
       * This method returns the current valid basket of the session customer or creates a new one if no current valid
       *  basket exists. See getCurrentBasket() for more details.
       *
       * @return the basket, existing or newly created
       */
      static getCurrentOrNewBasket(): dw.order.Basket;
      /**
       * This method returns the stored basket of the session customer or null if none is found. A stored
       *  basket is returned in the following situation: - During one visit, a customer-X logs in and receives a basket-A -
       *  In a later visit, a second basket-B is created for an anonymous customer who then logs in as customer-X. In this
       *  case basket-B is reassigned to him and basket-A is accessible as the stored basket. Now it is possible to merge
       *  the information from the stored basket to the active basket.
       *
       *  A stored basket will exist only if the corresponding setting is selected in the Business Manager site
       *  preferences' baskets section. A basket is valid for the configured basket lifetime.
       *
       *  Typical usage:
       *
       *   var storedBasket : Basket = BasketMgr.getStoredBasket();
       *  var currentBasket : Basket = BasketMgr.getCurrentOrNewBasket();
       *  if (storedBasket) {
       *      // transfer all the data needed from the stored to the active basket
       *  }
       *
       * @return the stored basket or null if no valid stored basket exists.
       */
      static getStoredBasket(): dw.order.Basket;
    }

    /**
     * Line item representing an applied <a href="class_dw_campaign_BonusChoiceDiscount.html">BonusChoiceDiscount</a> in
     *  a LineItemCtnr. This type of line item can only be created by the Commerce Cloud
     *  Digital promotions engine when applying a BonusChoiceDiscount. A
     *  BonusDiscountLineItem is basically a placeholder in the cart which entitles a
     *  customer to add one or more bonus products to his basket from a configured
     *  list of products. Merchants typically display this type of line item in the
     *  cart by showing the corresponding promotion callout message. They typically
     *  provide links to the bonus products that the customer can choose from. This
     *  line item can be removed from the cart but will be re-added each time the
     *  promotions engine re-applies discounts. Merchants may however add custom
     *  logic to show/hide this line item since it just a placeholder and not an
     *  actual product line item.
     *  <p>
     *  The number of products that a customer is allowed to choose from is
     *  determined by <a href="class_dw_order_BonusDiscountLineItem.html#dw_order_BonusDiscountLineItem_getMaxBonusItems_DetailAnchor">getMaxBonusItems()</a>. The collection of products the
     *  customer can choose from is determined by <a href="class_dw_order_BonusDiscountLineItem.html#dw_order_BonusDiscountLineItem_getBonusProducts_DetailAnchor">getBonusProducts()</a>. When a
     *  customer chooses a bonus product in the storefront, it is necessary to use
     *  the <code>AddBonusProductToBasket</code> pipelet instead of the usual
     *  <code>AddProductToBasket</code> pipelet, in order to associate this
     *  BonusDiscountLineItem with the newly created bonus ProductLineItem.
     *  Alternatively, the API method
     *  <a href="class_dw_order_LineItemCtnr.html#dw_order_LineItemCtnr_createBonusProductLineItem_BonusDiscountLineItem_Product_ProductOptionModel_Shipment_DetailAnchor">LineItemCtnr.createBonusProductLineItem(BonusDiscountLineItem, Product, ProductOptionModel, Shipment)</a>
     *  can be used instead. The system does proper validations in order to prevent
     *  incorrect or too many bonus products from being associated with this
     *  BonusDiscountLineItem. Once a customer has selected bonus products, the
     *  product line items representing the chosen bonus products can be retrieved
     *  with <a href="class_dw_order_BonusDiscountLineItem.html#dw_order_BonusDiscountLineItem_getBonusProductLineItems_DetailAnchor">getBonusProductLineItems()</a>.</p>
     */
    class BonusDiscountLineItem extends dw.object.ExtensibleObject {
      /**
       * Returns whether the promotion that triggered the creation of this line item uses a rule to determine the list of
       *  bonus products.
       *
       *  If the promotion is rule based, then a ProductSearchModel should be used to return the bonus products the
       *  customer may choose from, as the methods that return lists will return nothing. See getBonusProducts()
       */
      readonly bonusChoiceRuleBased: boolean;
      /**
       * Get the product line items in the current LineItemCtnr representing the
       *  bonus products that the customer has selected for this discount.
       */
      readonly bonusProductLineItems: dw.util.List<dw.order.ProductLineItem>;
      /**
       * Get the list of bonus products which the customer is allowed to choose
       *  from for this discount. This list is configured by a merchant entering a
       *  list of SKUs for the discount. Products which do not exist in the system,
       *  or are offline, or are not assigned to a category in the site catalog are
       *  filtered out. Unavailable (i.e. out-of-stock) products are NOT filtered
       *  out. This allows merchants to display out-of-stock bonus products with
       *  appropriate messaging.
       *
       *  If the promotion which triggered this discount does not exist, or this
       *  promotion is rule based, then this method returns an empty list.
       *
       *  If the promotion is rule based, then this method will return an empty list.
       *  A ProductSearchModel should be used to return the bonus products the
       *  customer may choose from instead. See
       *  ProductSearchModel.PROMOTION_PRODUCT_TYPE_BONUS and
       *  ProductSearchModel.setPromotionID(String)
       *
       *  If a returned product is a master product, the customer is entitled to
       *  choose from any variant. If the product is an option product, the
       *  customer is entitled to choose any value for each option. Since the
       *  promotions engine does not touch the value of the product option line
       *  items, it is the responsibility of custom code to set option prices.
       */
      readonly bonusProducts: dw.util.List<dw.catalog.Product>;
      /**
       * Get the coupon line item associated with this discount.
       */
      readonly couponLineItem: dw.order.CouponLineItem;
      /**
       * Get the maximum number of bonus items that the customer is permitted to
       *  select for this bonus discount.
       *
       *  If the promotion which triggered this discount does not exist, then this
       *  method returns 0.
       */
      readonly maxBonusItems: number;
      /**
       * Get the promotion associated with this discount.
       */
      readonly promotion: dw.campaign.Promotion;
      /**
       * Get the promotion ID associated with this discount.
       */
      readonly promotionID: string;

      /**
       * Get the product line items in the current LineItemCtnr representing the
       *  bonus products that the customer has selected for this discount.
       *
       * @return The selected product line items, never null.
       */
      getBonusProductLineItems(): dw.util.List<dw.order.ProductLineItem>;
      /**
       * Get the effective price for the passed bonus product. This is expected to
       *  be one of the products returned by getBonusProducts() with one
       *  exception: If a master product is configured as a bonus product, this
       *  implies that a customer may choose from any of its variants. In this
       *  case, it is allowed to pass in a variant to this method and a price will
       *  be returned. If the passed product is not a valid bonus product, this
       *  method throws an exception.
       * @param product The bonus product to retrieve a price for, must not be null.
       * @return The price of the passed bonus product as a Number.
       */
      getBonusProductPrice(product: dw.catalog.Product): dw.value.Money;
      /**
       * Get the list of bonus products which the customer is allowed to choose
       *  from for this discount. This list is configured by a merchant entering a
       *  list of SKUs for the discount. Products which do not exist in the system,
       *  or are offline, or are not assigned to a category in the site catalog are
       *  filtered out. Unavailable (i.e. out-of-stock) products are NOT filtered
       *  out. This allows merchants to display out-of-stock bonus products with
       *  appropriate messaging.
       *
       *  If the promotion which triggered this discount does not exist, or this
       *  promotion is rule based, then this method returns an empty list.
       *
       *  If the promotion is rule based, then this method will return an empty list.
       *  A ProductSearchModel should be used to return the bonus products the
       *  customer may choose from instead. See
       *  ProductSearchModel.PROMOTION_PRODUCT_TYPE_BONUS and
       *  ProductSearchModel.setPromotionID(String)
       *
       *  If a returned product is a master product, the customer is entitled to
       *  choose from any variant. If the product is an option product, the
       *  customer is entitled to choose any value for each option. Since the
       *  promotions engine does not touch the value of the product option line
       *  items, it is the responsibility of custom code to set option prices.
       *
       * @return An ordered list of bonus products that the customer may choose from for this discount.
       */
      getBonusProducts(): dw.util.List<dw.catalog.Product>;
      /**
       * Get the coupon line item associated with this discount.
       *
       * @return The coupon line item associated with this discount, or null if it no longer exists or there is no one.
       */
      getCouponLineItem(): dw.order.CouponLineItem;
      /**
       * Get the maximum number of bonus items that the customer is permitted to
       *  select for this bonus discount.
       *
       *  If the promotion which triggered this discount does not exist, then this
       *  method returns 0.
       *
       * @return The maximum number of bonus items that the customer is permitted to select for this bonus discount, or 0 if the promotion no longer exists.
       */
      getMaxBonusItems(): number;
      /**
       * Get the promotion associated with this discount.
       *
       * @return The promotion associated with this discount, or null if it no longer exists.
       */
      getPromotion(): dw.campaign.Promotion;
      /**
       * Get the promotion ID associated with this discount.
       *
       * @return The promotion ID associated with this discount, never null.
       */
      getPromotionID(): string;
      /**
       * Returns whether the promotion that triggered the creation of this line item uses a rule to determine the list of
       *  bonus products.
       *
       *  If the promotion is rule based, then a ProductSearchModel should be used to return the bonus products the
       *  customer may choose from, as the methods that return lists will return nothing. See getBonusProducts()
       *
       * @return If the promotion no longer exists, then null, otherwise, true if the promotion that triggered the creation of this line item uses a rule to determine the bonus products to choose from.
       */
      isBonusChoiceRuleBased(): boolean;
    }

    /**
     * The CouponLineItem class is used to store redeemed coupons in the Basket.
     */
    class CouponLineItem extends dw.object.ExtensibleObject {
      /**
       * Identifies if the coupon is currently applied in the basket. A coupon
       *  line is applied if there exists at least one price adjustment related
       *  to the coupon line item.
       */
      readonly applied: boolean;
      /**
       * Returns true the line item represents a coupon of a Commerce Cloud Digital
       *  campaign. If the coupon line item represents a custom coupon code,
       *  the method returns false.
       */
      readonly basedOnCampaign: boolean;
      /**
       * The bonus discount line items of the line item container triggered
       *  by this coupon.
       */
      readonly bonusDiscountLineItems: dw.util.Collection<
        dw.order.BonusDiscountLineItem
      >;
      /**
       * The coupon code.
       */
      readonly couponCode: string;
      /**
       * The price adjustments of the line item container triggered
       *  by this coupon.
       */
      readonly priceAdjustments: dw.util.Collection<dw.order.PriceAdjustment>;
      /**
       * The promotion related to the coupon line item.
       */
      readonly promotion: dw.campaign.Promotion;
      /**
       * The id of the related promotion.
       */
      readonly promotionID: string;
      /**
       * This method provides a detailed error status in case the coupon code of
       *  this coupon line item instance became invalid.
       */
      readonly statusCode: string;
      /**
       * Allows to check whether the coupon code of this coupon line item instance
       *  is valid. Coupon line item is valid, if status code is one of the following:
       *
       *  CouponStatusCodes.APPLIED
       *  CouponStatusCodes.NO_APPLICABLE_PROMOTION
       */
      readonly valid: boolean;

      /**
       * Associates the specified price adjustment with the coupon line item.
       *  This method is only applicable if used for price adjustments and
       *  coupon line items NOT based on Commerce Cloud Digital campaigns.
       * @param priceAdjustment Price adjustment to be associated with coupon line item.
       */
      associatePriceAdjustment(priceAdjustment: dw.order.PriceAdjustment): void;
      /**
       * Returns the bonus discount line items of the line item container triggered
       *  by this coupon.
       *
       * @return Price adjustments triggered by the coupon
       */
      getBonusDiscountLineItems(): dw.util.Collection<
        dw.order.BonusDiscountLineItem
      >;
      /**
       * Returns the coupon code.
       *
       * @return Coupon code
       */
      getCouponCode(): string;
      /**
       * Returns the price adjustments of the line item container triggered
       *  by this coupon.
       *
       * @return Price adjustments triggered by the coupon
       */
      getPriceAdjustments(): dw.util.Collection<dw.order.PriceAdjustment>;
      /**
       * Returns the promotion related to the coupon line item.
       *
       * @return Promotion related to coupon represented by line item
       */
      getPromotion(): dw.campaign.Promotion;
      /**
       * Returns the id of the related promotion.
       *
       * @return the id of the related promotion.
       */
      getPromotionID(): string;
      /**
       * This method provides a detailed error status in case the coupon code of
       *  this coupon line item instance became invalid.
       *
       * @return Returns APPLIED if coupon is applied, and otherwise one of the codes defined in CouponStatusCodes
       */
      getStatusCode(): string;
      /**
       * Identifies if the coupon is currently applied in the basket. A coupon
       *  line is applied if there exists at least one price adjustment related
       *  to the coupon line item.
       *
       * @return true if the coupon is currently applied in the basket.
       */
      isApplied(): boolean;
      /**
       * Returns true the line item represents a coupon of a Commerce Cloud Digital
       *  campaign. If the coupon line item represents a custom coupon code,
       *  the method returns false.
       *
       */
      isBasedOnCampaign(): boolean;
      /**
       * Allows to check whether the coupon code of this coupon line item instance
       *  is valid. Coupon line item is valid, if status code is one of the following:
       *
       *  CouponStatusCodes.APPLIED
       *  CouponStatusCodes.NO_APPLICABLE_PROMOTION
       *
       * @return true if the coupon code is valid, false otherwise.
       */
      isValid(): boolean;
    }

    /**
     * This exception is thrown by <a href="class_dw_order_BasketMgr.html#dw_order_BasketMgr_createAgentBasket_DetailAnchor">BasketMgr.createAgentBasket()</a> to indicate that the open agent basket limit for
     *  the current session customer is already reached, and therefore no new agent basket could be created.
     */
    class CreateAgentBasketLimitExceededException extends APIException {}

    /**
     * This APIException is thrown by method <a href="class_dw_order_BasketMgr.html#dw_order_BasketMgr_createBasketFromOrder_Order_DetailAnchor">BasketMgr.createBasketFromOrder(Order)</a>
     *  to indicate no Basket could be created from the Order.
     */
    class CreateBasketFromOrderException extends APIException {
      /**
       * Indicates reason why BasketMgr.createBasketFromOrder(Order) failed.
       */
      readonly errorCode: string;
    }

    /**
     * This exception could be thrown by <a href="class_dw_order_LineItemCtnr.html#dw_order_LineItemCtnr_createCouponLineItem_String_Boolean_DetailAnchor">LineItemCtnr.createCouponLineItem(String, Boolean)</a>
     *  when the provided coupon code is invalid.
     *  <p>
     *  &apos;errorCode&apos; property is set to one of the following values:
     *  </p><ul>
     *  <li><a href="class_dw_campaign_CouponStatusCodes.html#dw_campaign_CouponStatusCodes_COUPON_CODE_ALREADY_IN_BASKET_DetailAnchor">CouponStatusCodes.COUPON_CODE_ALREADY_IN_BASKET</a> = Indicates that coupon code has already been added to basket.</li>
     *  <li><a href="class_dw_campaign_CouponStatusCodes.html#dw_campaign_CouponStatusCodes_COUPON_ALREADY_IN_BASKET_DetailAnchor">CouponStatusCodes.COUPON_ALREADY_IN_BASKET</a> = Indicates that another code of the same MultiCode/System coupon has already been added to basket.</li>
     *  <li><a href="class_dw_campaign_CouponStatusCodes.html#dw_campaign_CouponStatusCodes_COUPON_CODE_ALREADY_REDEEMED_DetailAnchor">CouponStatusCodes.COUPON_CODE_ALREADY_REDEEMED</a> = Indicates that code of MultiCode/System coupon has already been redeemed.</li>
     *  <li><a href="class_dw_campaign_CouponStatusCodes.html#dw_campaign_CouponStatusCodes_COUPON_CODE_UNKNOWN_DetailAnchor">CouponStatusCodes.COUPON_CODE_UNKNOWN</a> = Indicates that coupon not found for given coupon code or that the code itself was not found.</li>
     *  <li><a href="class_dw_campaign_CouponStatusCodes.html#dw_campaign_CouponStatusCodes_COUPON_DISABLED_DetailAnchor">CouponStatusCodes.COUPON_DISABLED</a> = Indicates that coupon is not enabled.</li>
     *  <li><a href="class_dw_campaign_CouponStatusCodes.html#dw_campaign_CouponStatusCodes_REDEMPTION_LIMIT_EXCEEDED_DetailAnchor">CouponStatusCodes.REDEMPTION_LIMIT_EXCEEDED</a> = Indicates that number of redemptions per code exceeded.</li>
     *  <li><a href="class_dw_campaign_CouponStatusCodes.html#dw_campaign_CouponStatusCodes_CUSTOMER_REDEMPTION_LIMIT_EXCEEDED_DetailAnchor">CouponStatusCodes.CUSTOMER_REDEMPTION_LIMIT_EXCEEDED</a> = Indicates that number of redemptions per code and customer exceeded.</li>
     *  <li><a href="class_dw_campaign_CouponStatusCodes.html#dw_campaign_CouponStatusCodes_TIMEFRAME_REDEMPTION_LIMIT_EXCEEDED_DetailAnchor">CouponStatusCodes.TIMEFRAME_REDEMPTION_LIMIT_EXCEEDED</a> = Indicates that number of redemptions per code, customer and time exceeded.</li>
     *  <li><a href="class_dw_campaign_CouponStatusCodes.html#dw_campaign_CouponStatusCodes_NO_ACTIVE_PROMOTION_DetailAnchor">CouponStatusCodes.NO_ACTIVE_PROMOTION</a> = Indicates that coupon is not assigned to an active promotion.</li>
     *  </ul>
     */
    class CreateCouponLineItemException extends APIException {
      /**
       * Returns one of the error codes listed in the class doc.
       */
      readonly errorCode: string;
    }

    /**
     * This APIException is thrown by method <a href="class_dw_order_OrderMgr.html#dw_order_OrderMgr_createOrder_Basket_String_DetailAnchor">OrderMgr.createOrder(Basket, String)</a>
     *  to indicate no Order could be created from the Basket.
     */
    class CreateOrderException extends APIException {}

    /**
     * Represents a Gift Certificate that can be used to purchase
     *  products.
     */
    class GiftCertificate extends dw.object.ExtensibleObject {
      /**
       * Represents a status of 'issued', which indicates that the Gift Certificate
       *  has been created and that it can be used to purchase products.
       */
      static readonly STATUS_ISSUED = 1;
      /**
       * Represents a status of 'partially redeemed', which indicates that the Gift Certificate
       *  has been used to purchase products, but that there is still a balance on
       *  the gift certificate.
       */
      static readonly STATUS_PARTIALLY_REDEEMED = 2;
      /**
       * Represents a status of 'pending', which indicates that the Gift Certificate
       *  has been created but that it cannot be used yet.
       */
      static readonly STATUS_PENDING = 0;
      /**
       * Represents a status of 'redeemed', which indicates that the Gift Certificate
       *  has been used and no longer contains a balance.
       */
      static readonly STATUS_REDEEMED = 3;

      /**
       * The original amount on the gift certificate.
       */
      readonly amount: dw.value.Money;
      /**
       * The balance on the gift certificate.
       */
      readonly balance: dw.value.Money;
      /**
       * The description string.
       */
      description: string;
      /**
       * Returns true if the Gift Certificate is enabled, false otherwise.
       */
      enabled: boolean;
      /**
       * The code of the gift certificate. This redemption code is send to
       *  gift certificate recipient.
       */
      readonly giftCertificateCode: string;
      /**
       * The code of the gift certificate. This redemption code is send to
       *  gift certificate recipient.
       */
      readonly ID: string;
      /**
       * The masked gift certificate code with
       *  all but the last 4 characters replaced with a '*' character.
       */
      readonly maskedGiftCertificateCode: string;
      /**
       * The merchant ID of the gift certificate.
       */
      readonly merchantID: string;
      /**
       * The message to include in the email of the person receiving
       *  the gift certificate.
       */
      message: string;
      /**
       * The order number
       */
      orderNo: string;
      /**
       * The email address of the person receiving
       *  the gift certificate.
       */
      recipientEmail: string;
      /**
       * The name of the person receiving
       *  the gift certificate.
       */
      recipientName: string;
      /**
       * The name of the person or organization that
       *  sent the gift certificate or null if undefined.
       */
      senderName: string;
      /**
       * The status where the possible values are
       *  STATUS_PENDING, STATUS_ISSUED, STATUS_PARTIALLY_REDEEMED
       *  or STATUS_REDEEMED.
       */
      status: number;

      /**
       * Returns the original amount on the gift certificate.
       *
       * @return the original amount on the gift certificate.
       */
      getAmount(): dw.value.Money;
      /**
       * Returns the balance on the gift certificate.
       *
       * @return the balance on the gift certificate.
       */
      getBalance(): dw.value.Money;
      /**
       * Returns the description string.
       *
       * @return the description.
       */
      getDescription(): string;
      /**
       * Returns the code of the gift certificate. This redemption code is send to
       *  gift certificate recipient.
       *
       * @return the code of the gift certificate.
       */
      getGiftCertificateCode(): string;
      /**
       * Returns the code of the gift certificate. This redemption code is send to
       *  gift certificate recipient.
       *
       * @return the code of the gift certificate.
       */
      getID(): string;
      /**
       * Returns the masked gift certificate code with
       *  all but the last 4 characters replaced with a '*' character.
       *
       * @return the masked gift certificate code.
       */
      getMaskedGiftCertificateCode(): string;
      /**
       * Returns the masked gift certificate code with
       *  all but the specified number of characters replaced with a '*' character.
       * @param ignore the number of characters to leave unmasked.
       * @return the masked gift certificate code.
       */
      getMaskedGiftCertificateCode(ignore: number): string;
      /**
       * Returns the merchant ID of the gift certificate.
       *
       * @return the merchant ID of the gift certificate.
       */
      getMerchantID(): string;
      /**
       * Returns the message to include in the email of the person receiving
       *  the gift certificate.
       *
       * @return the message to include in the email of the person receiving the gift certificate.
       */
      getMessage(): string;
      /**
       * Returns the order number
       *
       * @return the order number
       */
      getOrderNo(): string;
      /**
       * Returns the email address of the person receiving
       *  the gift certificate.
       *
       * @return the email address of the person receiving the gift certificate.
       */
      getRecipientEmail(): string;
      /**
       * Returns the name of the person receiving
       *  the gift certificate.
       *
       * @return the name of the person receiving the gift certificate.
       */
      getRecipientName(): string;
      /**
       * Returns the name of the person or organization that
       *  sent the gift certificate or null if undefined.
       *
       * @return the name of the person or organization that sent the gift certificate or null if undefined.
       */
      getSenderName(): string;
      /**
       * Returns the status where the possible values are
       *  STATUS_PENDING, STATUS_ISSUED, STATUS_PARTIALLY_REDEEMED
       *  or STATUS_REDEEMED.
       *
       * @return the status.
       */
      getStatus(): number;
      /**
       * Returns true if the Gift Certificate is enabled, false otherwise.
       *
       * @return true if the Gift Certificate is enabled, false otherwise.
       */
      isEnabled(): boolean;
      /**
       * An optional description that you can use to categorize the
       *  gift certificate.
       * @param description additional description.
       */
      setDescription(description: string): void;
      /**
       * Controls if the Gift Certificate is enabled.
       * @param enabled if true, enables the Gift Certificate.
       */
      setEnabled(enabled: boolean): void;
      /**
       * Sets the message to include in the email of the person receiving
       *  the gift certificate.
       * @param message the message to include in the email of the person receiving the gift certificate.
       */
      setMessage(message: string): void;
      /**
       * Sets the order number
       * @param orderNo the order number to be set
       */
      setOrderNo(orderNo: string): void;
      /**
       * Sets the email address of the person receiving
       *  the gift certificate.
       * @param recipientEmail the email address of the person receiving the gift certificate.
       */
      setRecipientEmail(recipientEmail: string): void;
      /**
       * Sets the name of the person receiving
       *  the gift certificate.
       * @param recipient the name of the person receiving the gift certificate.
       */
      setRecipientName(recipient: string): void;
      /**
       * Sets the name of the person or organization that
       *  sent the gift certificate.
       * @param sender the name of the person or organization that sent the gift certificate.
       */
      setSenderName(sender: string): void;
      /**
       * Sets the status of the gift certificate.
       *  Possible values are: STATUS_ISSUED,
       *  STATUS_PENDING, STATUS_PARTIALLY_REDEEMED
       *  and STATUS_REDEEMED.
       * @param status Gift certificate status
       */
      setStatus(status: number): void;
    }

    /**
     * Represents a Gift Certificate line item in the cart. When an order is
     *  processed, a Gift Certificate is created based on the information in
     *  the Gift Certificate line item.
     */
    class GiftCertificateLineItem extends dw.order.LineItem {
      /**
       * The ID of the gift certificate that this line item
       *  was used to create. If this line item has not been used to create
       *  a Gift Certificate, this method returns null.
       */
      giftCertificateID: string;
      /**
       * The message to include in the email of the person receiving
       *  the gift certificate line item.
       */
      message: string;
      /**
       * The associated ProductListItem.
       */
      productListItem: dw.customer.ProductListItem;
      /**
       * The email address of the person receiving
       *  the gift certificate line item.
       */
      recipientEmail: string;
      /**
       * The name of the person receiving the gift certificate line item.
       */
      recipientName: string;
      /**
       * The name of the person or organization that
       *  sent the gift certificate line item or null if undefined.
       */
      senderName: string;
      /**
       * The associated Shipment.
       */
      shipment: dw.order.Shipment;

      /**
       * Returns the ID of the gift certificate that this line item
       *  was used to create. If this line item has not been used to create
       *  a Gift Certificate, this method returns null.
       *
       * @return the ID of the gift certificate or null if undefined.
       */
      getGiftCertificateID(): string;
      /**
       * Returns the message to include in the email of the person receiving
       *  the gift certificate line item.
       *
       * @return the message to include in the email of the person receiving the gift certificate line item.
       */
      getMessage(): string;
      /**
       * Returns the associated ProductListItem.
       *
       * @return item or null.
       */
      getProductListItem(): dw.customer.ProductListItem;
      /**
       * Returns the email address of the person receiving
       *  the gift certificate line item.
       *
       * @return the email address of the person receiving the gift certificate line item.
       */
      getRecipientEmail(): string;
      /**
       * Returns the name of the person receiving the gift certificate line item.
       *
       * @return the name of the person receiving the gift certificate line item.
       */
      getRecipientName(): string;
      /**
       * Returns the name of the person or organization that
       *  sent the gift certificate line item or null if undefined.
       *
       * @return the name of the person or organization that sent the gift certificate line item or null if undefined.
       */
      getSenderName(): string;
      /**
       * Returns the associated Shipment.
       *
       * @return The shipment of the gift certificate line item
       */
      getShipment(): dw.order.Shipment;
      /**
       * Sets the ID of the gift certificate associated with this line item.
       * @param id the ID of the gift certificate associated with this line item.
       */
      setGiftCertificateID(id: string): void;
      /**
       * Sets the message to include in the email of the person receiving
       *  the gift certificate line item.
       * @param message the message to include in the email of the person receiving the gift certificate line item.
       */
      setMessage(message: string): void;
      /**
       * Sets the associated ProductListItem.
       *
       *  The product list item to be set must be of type gift certificate otherwise an exception is thrown.
       * @param productListItem the product list item to be associated
       */
      setProductListItem(productListItem: dw.customer.ProductListItem): void;
      /**
       * Sets the email address of the person receiving
       *  the gift certificate line item.
       * @param recipientEmail the email address of the person receiving the gift certificate line item.
       */
      setRecipientEmail(recipientEmail: string): void;
      /**
       * Sets the name of the person receiving the gift certificate line item.
       * @param recipient the name of the person receiving the gift certificate line item.
       */
      setRecipientName(recipient: string): void;
      /**
       * Sets the name of the person or organization that
       *  sent the gift certificate line item.
       * @param sender the name of the person or organization that sent the gift certificate line item.
       */
      setSenderName(sender: string): void;
      /**
       * Associates the gift certificate line item with the specified shipment.
       *   Gift certificate line item and shipment must belong to the same line item ctnr.
       * @param shipment The new shipment of the gift certificate line item
       */
      setShipment(shipment: dw.order.Shipment): void;
    }

    /**
     * The GiftCertificateMgr class contains a set of static methods for
     *  interacting with GiftCertificates.
     */
    class GiftCertificateMgr {
      /**
       * Indicates that an error occurred because the Gift Certificate
       *  is currently disabled.
       */
      static readonly GC_ERROR_DISABLED = "GIFTCERTIFICATE-100";
      /**
       * Indicates that an error occurred because the Gift Certificate
       *  does not have a sufficient balance to perform the requested
       *  operation.
       */
      static readonly GC_ERROR_INSUFFICIENT_BALANCE = "GIFTCERTIFICATE-110";
      /**
       * Indicates that an error occurred because the Gift Certificate
       *  Amount was not valid.
       */
      static readonly GC_ERROR_INVALID_AMOUNT = "GIFTCERTIFICATE-140";
      /**
       * Indicates that an error occurred because the Gift Certificate
       *  ID was not valid.
       */
      static readonly GC_ERROR_INVALID_CODE = "GIFTCERTIFICATE-150";
      /**
       * Indicates that an error occurred because the Gift Certificate
       *  has been fully redeemed.
       */
      static readonly GC_ERROR_PENDING = "GIFTCERTIFICATE-130";
      /**
       * Indicates that an error occurred because the Gift Certificate
       *  has been fully redeemed.
       */
      static readonly GC_ERROR_REDEEMED = "GIFTCERTIFICATE-120";

      /**
       * Creates a Gift Certificate. If a non-empty Gift Certificate code is specified, the code will be used to create
       *  the Gift Certificate. Be aware that this code must be unique for the current site. If it is not unique, the Gift
       *  Certificate will not be created.
       * @param amount the amount of the gift certificate. Must not be negative or zero.
       * @param code the code for the new gift certificate. If parameter is null or empty , the system will assign a code to the new gift certificate.
       * @return the newly created Gift Certificate.
       */
      static createGiftCertificate(
        amount: number,
        code: string
      ): dw.order.GiftCertificate;
      /**
       * Creates a Gift Certificate. The system will assign a code to the new Gift Certificate.
       * @param amount the amount of the gift certificate. Must not be negative or zero.
       * @return the newly created Gift Certificate.
       */
      static createGiftCertificate(amount: number): dw.order.GiftCertificate;
      /**
       * Returns the Gift Certificate identified by the specified
       *  gift certificate code.
       * @param giftCertificateCode to identify the Gift Certificate.
       * @return the Gift Certificate identified by the specified code or null.
       */
      static getGiftCertificate(
        giftCertificateCode: string
      ): dw.order.GiftCertificate;
      /**
       * Returns the Gift Certificate identified by the specified
       *  gift certificate code.
       * @param giftCertificateCode to identify the Gift Certificate.
       * @return the Gift Certificate identified by the specified code or null.
       */
      static getGiftCertificateByCode(
        giftCertificateCode: string
      ): dw.order.GiftCertificate;
      /**
       * Returns the Gift Certificate identified by the specified merchant ID.
       * @param merchantID to identify the Gift Certificate.
       * @return the Gift Certificate identified by the specified merchant ID or null.
       */
      static getGiftCertificateByMerchantID(
        merchantID: string
      ): dw.order.GiftCertificate;
      /**
       * Redeems an amount from a Gift Certificate. The Gift Certificate ID
       *  is specified in the OrderPaymentInstrument and the amount
       *  specified in the PaymentTransaction associated with the
       *  OrderPaymentInstrument. If the PaymentTransaction.getTransactionID()
       *  is not null, the value returned by this method is used as the
       *  'Order Number' for the redemption transaction. The 'Order Number' is
       *  visible via the Business Manager.
       * @param paymentInstrument the OrderPaymentInstrument containing the ID of the Gift Certificate to redeem, and the amount of the redemption.
       * @return the status of the redemption operation.
       */
      static redeemGiftCertificate(
        paymentInstrument: dw.order.OrderPaymentInstrument
      ): dw.system.Status;
    }

    /**
     * Helper class containing status codes for the various errors that can occur
     *  when redeeming a gift certificate. One of these codes is returned as part of
     *  a Status object when a unsuccessful call to the
     *  <code>RedeemGiftCertificate</code> pipelet is made.
     */
    class GiftCertificateStatusCodes {
      /**
       * Indicates that an error occurred because the Gift Certificate
       *  was in a different currency than the Basket.
       */
      static readonly GIFTCERTIFICATE_CURRENCY_MISMATCH =
        "GIFTCERTIFICATE_CURRENCY_MISMATCH";
      /**
       * Indicates that an error occurred because the Gift Certificate
       *  is currently disabled.
       */
      static readonly GIFTCERTIFICATE_DISABLED = "GIFTCERTIFICATE_DISABLED";
      /**
       * Indicates that an error occurred because the Gift Certificate
       *  does not have a sufficient balance to perform the requested
       *  operation.
       */
      static readonly GIFTCERTIFICATE_INSUFFICIENT_BALANCE =
        "GIFTCERTIFICATE_INSUFFICIENT_BALANCE";
      /**
       * Indicates that an error occurred because the Gift Certificate
       *  was not found.
       */
      static readonly GIFTCERTIFICATE_NOT_FOUND = "GIFTCERTIFICATE_NOT_FOUND";
      /**
       * Indicates that an error occurred because the Gift Certificate
       *  is pending and is not available for use.
       */
      static readonly GIFTCERTIFICATE_PENDING = "GIFTCERTIFICATE_PENDING";
      /**
       * Indicates that an error occurred because the Gift Certificate
       *  has been fully redeemed.
       */
      static readonly GIFTCERTIFICATE_REDEEMED = "GIFTCERTIFICATE_REDEEMED";

      constructor();
    }

    /**
     * The Invoice can be a debit or credit invoice, and is created
     *  from custom scripts using one of the methods
     *  <a href="class_dw_order_ShippingOrder.html#dw_order_ShippingOrder_createInvoice_String_DetailAnchor">ShippingOrder.createInvoice(String)</a>,
     *  <a href="class_dw_order_Appeasement.html#dw_order_Appeasement_createInvoice_String_DetailAnchor">Appeasement.createInvoice(String)</a>,
     *  <a href="class_dw_order_ReturnCase.html#dw_order_ReturnCase_createInvoice_String_DetailAnchor">ReturnCase.createInvoice(String)</a> or
     *  <a href="class_dw_order_Return.html#dw_order_Return_createInvoice_String_DetailAnchor">Return.createInvoice(String)</a>.
     *  <p>
     *  Order post-processing APIs (gillian) are now inactive by default and will throw
     *  an exception if accessed. On sandboxes the APIs can be activated with a feature
     *  switch &quot;Order Post Processing APIs on Sandboxes&quot;. On PIGs an activation needs
     *  preliminary approval by Product Management. Please contact support in this case.
     *  Existing customers using these APIs are not affected by this change and can use the
     *  APIs until further notice.</p>
     */
    class Invoice extends dw.order.AbstractItemCtnr {
      /**
       * Sorting by creation date. Use with method getPaymentTransactions() as an argument to
       *  method FilteringCollection.sort(Object).
       */
      static readonly ORDERBY_CREATION_DATE: any;
      /**
       * Sorting by item id. Use with method getItems() as an argument to
       *  method FilteringCollection.sort(Object).
       */
      static readonly ORDERBY_ITEMID: any;
      /**
       * Sorting by the position of the related oder item. Use with method
       *  getItems() as an argument to method
       *  FilteringCollection.sort(Object).
       */
      static readonly ORDERBY_ITEMPOSITION: any;
      /**
       * Reverse orders. Use as an argument
       *  to method FilteringCollection.sort(Object).
       */
      static readonly ORDERBY_REVERSE: any;
      /**
       * Unsorted , as it is. Use with method getItems() as an argument
       *  to method FilteringCollection.sort(Object).
       */
      static readonly ORDERBY_UNSORTED: any;
      /**
       * Selects the capture transactions. Use with method getPaymentTransactions() as an
       *  argument to method FilteringCollection.select(Object).
       */
      static readonly QUALIFIER_CAPTURE: any;
      /**
       * Selects the product items. Use with method getItems() as an
       *  argument to method FilteringCollection.select(Object).
       */
      static readonly QUALIFIER_PRODUCTITEMS: any;
      /**
       * Selects the refund transactions. Use with method getPaymentTransactions() as an
       *  argument to method FilteringCollection.select(Object).
       */
      static readonly QUALIFIER_REFUND: any;
      /**
       * Selects for the service items. Use with method getItems() as an
       *  argument to method FilteringCollection.select(Object).
       */
      static readonly QUALIFIER_SERVICEITEMS: any;
      /**
       * Constant for Invoice Status Failed.
       *  The invoice handling failed.
       */
      static readonly STATUS_FAILED = "FAILED";
      /**
       * Constant for Invoice Status Manual.
       *  The invoice is not paid but will not be handled automatically.
       *  A manual invoice handling (capture or refund) is necessary.
       */
      static readonly STATUS_MANUAL = "MANUAL";
      /**
       * Constant for Invoice Status Not Paid.
       *  The invoice is not paid and will be handled automatically.
       */
      static readonly STATUS_NOT_PAID = "NOT_PAID";
      /**
       * Constant for Invoice Status Paid.
       *  The invoice was successfully paid.
       */
      static readonly STATUS_PAID = "PAID";
      /**
       * Constant for Invoice Type Appeasement.
       *  The invoice was created for an appeasement.
       *  The invoice amount needs to be refunded.
       */
      static readonly TYPE_APPEASEMENT = "APPEASEMENT";
      /**
       * Constant for Invoice Type Return.
       *  The invoice was created for a return.
       *  The invoice amount needs to be refunded.
       */
      static readonly TYPE_RETURN = "RETURN";
      /**
       * Constant for Invoice Type Return Case.
       *  The invoice was created for a return case.
       *  The invoice amount needs to be refunded.
       */
      static readonly TYPE_RETURN_CASE = "RETURN_CASE";
      /**
       * Constant for Invoice Type Shipping.
       *  The invoice was created for a shipping order.
       *  The invoice amount needs to be captured.
       */
      static readonly TYPE_SHIPPING = "SHIPPING";

      /**
       * The sum of the captured amounts. The captured amounts are
       *  calculated on the fly.
       *  Associate a payment capture for a OrderPaymentInstrument
       *  with an Invoice using
       *  addCaptureTransaction(OrderPaymentInstrument, Money).
       */
      readonly capturedAmount: dw.value.Money;
      /**
       * The invoice number.
       */
      readonly invoiceNumber: string;
      /**
       * Access the collection of InvoiceItems.
       *
       *  This FilteringCollection can be sorted / filtered using:
       *
       *  FilteringCollection.sort(Object) with
       *  ORDERBY_ITEMID
       *  FilteringCollection.sort(Object) with
       *  ORDERBY_ITEMPOSITION
       *  FilteringCollection.sort(Object) with
       *  ORDERBY_UNSORTED
       *  FilteringCollection.select(Object) with
       *  QUALIFIER_PRODUCTITEMS
       *  FilteringCollection.select(Object) with
       *  QUALIFIER_SERVICEITEMS
       */
      readonly items: dw.util.FilteringCollection<dw.order.InvoiceItem>;
      /**
       * The payment transactions belonging to this Invoice.
       *
       *  This FilteringCollection can be sorted / filtered using:
       *
       *  FilteringCollection.sort(Object) with
       *  ORDERBY_CREATION_DATE
       *  FilteringCollection.sort(Object) with
       *  ORDERBY_UNSORTED
       *  FilteringCollection.select(Object) with
       *  QUALIFIER_CAPTURE
       *  FilteringCollection.select(Object) with
       *  QUALIFIER_REFUND
       */
      readonly paymentTransactions: dw.util.FilteringCollection<
        dw.order.PaymentTransaction
      >;
      /**
       * The sum of the refunded amounts. The refunded amounts are
       *  calculated on the fly.
       *  Associate a payment capture for a OrderPaymentInstrument
       *  with an Invoice using
       *  addRefundTransaction(OrderPaymentInstrument, Money).
       */
      readonly refundedAmount: dw.value.Money;
      /**
       * The invoice status.
       *  The possible values are STATUS_NOT_PAID, STATUS_MANUAL,
       *  STATUS_PAID, STATUS_FAILED.
       */
      status: dw.value.EnumValue;
      /**
       * The invoice type.
       *  The possible values are TYPE_SHIPPING, TYPE_RETURN,
       *  TYPE_RETURN_CASE, TYPE_APPEASEMENT.
       */
      readonly type: dw.value.EnumValue;

      /**
       * The invoice will be accounted.
       *
       *
       *  It will be captured in case of a shipping invoice and it will be refunded in
       *  case of an appeasement, return case or return invoice.
       *
       *
       *  The accounting will be handled in the payment hooks
       *  PaymentHooks.capture(Invoice) or
       *  PaymentHooks.refund(Invoice). The implementing script could add
       *  payment transactions to the invoice. The accompanying business logic will
       *  set the status to PAID or FAILED.
       *
       *
       *  The accounting will fail when the invoice state is different to
       *  STATUS_NOT_PAID or STATUS_FAILED.
       *
       *
       *  The method implements its own transaction handling. The method must not
       *  be called inside a transaction.
       *
       * @return true when the accounting was successful, otherwise false.
       */
      account(): boolean;
      /**
       * Calling this method registers an amount captured for a given
       *  order payment instrument. The authorization for the
       *  capture is associated with the payment transaction belonging to the
       *  instrument. Calling this method allows the Invoice, the
       *  OrderPaymentInstrument and the Order to
       *  return their captured amount as a sum calculated on the fly. The method
       *  may be called multiple times for the same instrument (multiple capture
       *  for one authorization) or for different instruments (invoice settlement
       *  using multiple payments).
       * @param instrument the order payment instrument
       * @param capturedAmount amount to register as captured
       * @return the created capture transaction
       */
      addCaptureTransaction(
        instrument: dw.order.OrderPaymentInstrument,
        capturedAmount: dw.value.Money
      ): dw.order.PaymentTransaction;
      /**
       * Calling this method registers an amount refunded for a given
       *  order payment instrument. Calling this method allows the
       *  Invoice, the OrderPaymentInstrument and
       *  the Order to return their refunded amount as a sum
       *  calculated on the fly. The method may be called multiple times for the
       *  same instrument (multiple refunds of one payment) or for different
       *  instruments (invoice settlement using multiple payments).
       * @param instrument the order payment instrument
       * @param refundedAmount amount to register as refunded
       * @return the created refund transaction
       */
      addRefundTransaction(
        instrument: dw.order.OrderPaymentInstrument,
        refundedAmount: dw.value.Money
      ): dw.order.PaymentTransaction;
      /**
       * Returns the sum of the captured amounts. The captured amounts are
       *  calculated on the fly.
       *  Associate a payment capture for a OrderPaymentInstrument
       *  with an Invoice using
       *  addCaptureTransaction(OrderPaymentInstrument, Money).
       *
       * @return sum of captured amounts
       */
      getCapturedAmount(): dw.value.Money;
      /**
       * Returns the invoice number.
       *
       * @return the invoice number
       */
      getInvoiceNumber(): string;
      /**
       * Access the collection of InvoiceItems.
       *
       *  This FilteringCollection can be sorted / filtered using:
       *
       *  FilteringCollection.sort(Object) with
       *  ORDERBY_ITEMID
       *  FilteringCollection.sort(Object) with
       *  ORDERBY_ITEMPOSITION
       *  FilteringCollection.sort(Object) with
       *  ORDERBY_UNSORTED
       *  FilteringCollection.select(Object) with
       *  QUALIFIER_PRODUCTITEMS
       *  FilteringCollection.select(Object) with
       *  QUALIFIER_SERVICEITEMS
       *
       * @return the invoice items
       */
      getItems(): dw.util.FilteringCollection<dw.order.InvoiceItem>;
      /**
       * Returns the payment transactions belonging to this Invoice.
       *
       *  This FilteringCollection can be sorted / filtered using:
       *
       *  FilteringCollection.sort(Object) with
       *  ORDERBY_CREATION_DATE
       *  FilteringCollection.sort(Object) with
       *  ORDERBY_UNSORTED
       *  FilteringCollection.select(Object) with
       *  QUALIFIER_CAPTURE
       *  FilteringCollection.select(Object) with
       *  QUALIFIER_REFUND
       *
       * @return the payment transactions.
       */
      getPaymentTransactions(): dw.util.FilteringCollection<
        dw.order.PaymentTransaction
      >;
      /**
       * Returns the sum of the refunded amounts. The refunded amounts are
       *  calculated on the fly.
       *  Associate a payment capture for a OrderPaymentInstrument
       *  with an Invoice using
       *  addRefundTransaction(OrderPaymentInstrument, Money).
       *
       * @return sum of refunded amounts
       */
      getRefundedAmount(): dw.value.Money;
      /**
       * Returns the invoice status.
       *  The possible values are STATUS_NOT_PAID, STATUS_MANUAL,
       *  STATUS_PAID, STATUS_FAILED.
       *
       * @return the invoice status
       */
      getStatus(): dw.value.EnumValue;
      /**
       * Returns the invoice type.
       *  The possible values are TYPE_SHIPPING, TYPE_RETURN,
       *  TYPE_RETURN_CASE, TYPE_APPEASEMENT.
       *
       * @return the invoice type
       */
      getType(): dw.value.EnumValue;
      /**
       * Sets the invoice status.
       *  The possible values are STATUS_NOT_PAID, STATUS_MANUAL,
       *  STATUS_PAID, STATUS_FAILED.
       * @param status the invoice status to set
       */
      setStatus(status: string): void;
    }

    /**
     * Represents a specific item in an <a href="class_dw_order_Invoice.html">Invoice</a>. Invoice items are added to the invoice
     *  on its creation, each item references exactly one order-item.
     *  <p>
     *  Order post-processing APIs (gillian) are now inactive by default and will throw
     *  an exception if accessed. On sandboxes the APIs can be activated with a feature
     *  switch &quot;Order Post Processing APIs on Sandboxes&quot;. On PIGs an activation needs
     *  preliminary approval by Product Management. Please contact support in this case.
     *  Existing customers using these APIs are not affected by this change and can use the
     *  APIs until further notice.</p>
     */
    class InvoiceItem extends dw.order.AbstractItem {
      /**
       * Price of a single unit before discount application.
       */
      readonly basePrice: dw.value.Money;
      /**
       * The captured amount for this item.
       */
      capturedAmount: dw.value.Money;
      /**
       * The number of the invoice to which this item belongs.
       */
      readonly invoiceNumber: string;
      /**
       * Returns null or the parent item.
       */
      parentItem: dw.order.InvoiceItem;
      /**
       * The quantity of this item.
       */
      readonly quantity: dw.value.Quantity;
      /**
       * The refunded amount for this item.
       */
      refundedAmount: dw.value.Money;

      /**
       * Price of a single unit before discount application.
       *
       * @return Price of a single unit before discount application.
       */
      getBasePrice(): dw.value.Money;
      /**
       * Returns the captured amount for this item.
       *
       * @return the captured amount for this item
       */
      getCapturedAmount(): dw.value.Money;
      /**
       * Returns the number of the invoice to which this item belongs.
       *
       * @return the number of the invoice to which this item belongs
       */
      getInvoiceNumber(): string;
      /**
       * Returns null or the parent item.
       *
       * @return null or the parent item.
       */
      getParentItem(): dw.order.InvoiceItem;
      /**
       * Returns the quantity of this item.
       *
       * @return quantity of this item
       */
      getQuantity(): dw.value.Quantity;
      /**
       * Returns the refunded amount for this item.
       *
       * @return the refunded amount for this item
       */
      getRefundedAmount(): dw.value.Money;
      /**
       * Updates the captured amount for this item.
       * @param capturedAmount the captured amount for this item
       */
      setCapturedAmount(capturedAmount: dw.value.Money): void;
      /**
       * Set a parent item. The parent item must belong to the same
       *  Invoice. An infinite parent-child loop is disallowed
       *  as is a parent-child depth greater than 10. Setting a parent item
       *  indicates a dependency of the child item on the parent item, and can be
       *  used to form a parallel structure to that accessed using
       *  ProductLineItem.getParent().
       * @param parentItem The parent item, null is allowed
       */
      setParentItem(parentItem: dw.order.InvoiceItem): void;
      /**
       * Updates the refunded amount for this item.
       * @param refundedAmount the refunded amount for this item
       */
      setRefundedAmount(refundedAmount: dw.value.Money): void;
    }

    /**
     * Common line item base class.
     */
    class LineItem extends dw.object.ExtensibleObject {
      /**
       * The base price for the line item, which is the price of the unit before applying adjustments, in the
       *  purchase currency. The base price may be net or gross of tax depending on the configured taxation policy.
       */
      basePrice: dw.value.Money;
      /**
       * The gross price for the line item, which is the price of the unit before applying adjustments, in the
       *  purchase currency, including tax.
       */
      grossPrice: dw.value.Money;
      /**
       * The line item ctnr of the line item.
       */
      readonly lineItemCtnr: dw.order.LineItemCtnr;
      /**
       * The display text for the line item.
       */
      lineItemText: string;
      /**
       * The net price for the line item, which is the price of the unit before applying adjustments, in the
       *  purchase currency, excluding tax.
       */
      netPrice: dw.value.Money;
      /**
       * Get the price of the line item. If the line item is based on net pricing then the net price is returned. If the
       *  line item is based on gross pricing then the gross price is returned.
       */
      readonly price: dw.value.Money;
      /**
       * Return the price amount for the line item. Same as getPrice().getValue().
       */
      priceValue: number;
      /**
       * The tax for the line item, which is the tax of the unit before applying adjustments, in the purchase
       *  currency.
       */
      tax: dw.value.Money;
      /**
       * Get the price used to calculate the tax for this line item.
       */
      readonly taxBasis: dw.value.Money;
      /**
       * The tax class ID for the line item or null if no tax class ID is associated with the line item. In the
       *  case where the tax class ID is null, you should use the default tax class ID.
       */
      taxClassID: string;
      /**
       * The tax rate, which is the decimal tax rate to be applied to the product represented by this line item. A
       *  value of 0.175 represents a percentage of 17.5%.
       */
      taxRate: number;

      /**
       * Returns the base price for the line item, which is the price of the unit before applying adjustments, in the
       *  purchase currency. The base price may be net or gross of tax depending on the configured taxation policy.
       *
       * @return the base price for the line item.
       */
      getBasePrice(): dw.value.Money;
      /**
       * Returns the gross price for the line item, which is the price of the unit before applying adjustments, in the
       *  purchase currency, including tax.
       *
       * @return the value of the gross price.
       */
      getGrossPrice(): dw.value.Money;
      /**
       * Returns the line item ctnr of the line item.
       *
       * @return Line item ctnr of the line item
       */
      getLineItemCtnr(): dw.order.LineItemCtnr;
      /**
       * Returns the display text for the line item.
       *
       * @return the display text.
       */
      getLineItemText(): string;
      /**
       * Returns the net price for the line item, which is the price of the unit before applying adjustments, in the
       *  purchase currency, excluding tax.
       *
       * @return the value for the net price.
       */
      getNetPrice(): dw.value.Money;
      /**
       * Get the price of the line item. If the line item is based on net pricing then the net price is returned. If the
       *  line item is based on gross pricing then the gross price is returned.
       *
       * @return either the net or the gross price
       */
      getPrice(): dw.value.Money;
      /**
       * Return the price amount for the line item. Same as getPrice().getValue().
       *
       * @return the price for the line item
       */
      getPriceValue(): number;
      /**
       * Returns the tax for the line item, which is the tax of the unit before applying adjustments, in the purchase
       *  currency.
       *
       * @return the tax for the line item.
       */
      getTax(): dw.value.Money;
      /**
       * Get the price used to calculate the tax for this line item.
       *
       * @return The tax basis used to calculate tax for this line item, or Money.NOT_AVAILABLE if tax has not been set for this line item yet.
       */
      getTaxBasis(): dw.value.Money;
      /**
       * Returns the tax class ID for the line item or null if no tax class ID is associated with the line item. In the
       *  case where the tax class ID is null, you should use the default tax class ID.
       *
       * @return the tax class ID for the line item or null if no tax class ID is associated with the line item.
       */
      getTaxClassID(): string;
      /**
       * Returns the tax rate, which is the decimal tax rate to be applied to the product represented by this line item. A
       *  value of 0.175 represents a percentage of 17.5%.
       *
       * @return the value of the tax rate.
       */
      getTaxRate(): number;
      /**
       * Sets the base price for the line item, which is the price of the unit before applying adjustments, in the
       *  purchase currency. The base price may be net or gross of tax depending on the configured taxation policy.
       * @param aValue the new value of the base price.
       */
      setBasePrice(aValue: dw.value.Money): void;
      /**
       * Sets the gross price for the line item, which is the Price of the unit before applying adjustments, in the
       *  purchase currency, including tax.
       * @param aValue the new value of the attribute
       */
      setGrossPrice(aValue: dw.value.Money): void;
      /**
       * Sets the display text for the line item.
       * @param aText line item text.
       */
      setLineItemText(aText: string): void;
      /**
       * Sets the value for the net price, which is the price of the unit before applying adjustments, in the purchase
       *  currency, excluding tax.
       * @param aValue the new value for the net price
       */
      setNetPrice(aValue: dw.value.Money): void;
      /**
       * Sets price attributes of the line item based on the current purchase currency and taxation policy.
       *  The methods sets the 'basePrice' attribute of the line item. Additionally, it sets the 'netPrice' attribute of
       *  the line item if the current taxation policy is 'net', and the 'grossPrice' attribute, if the current taxation
       *  policy is 'gross'.
       *  If null is specified as value, the price attributes are reset to Money.NOT_AVAILABLE.
       * @param value Price value or null
       */
      setPriceValue(value: number): void;
      /**
       * Sets the value for the tax of the line item, which is the the tax of the unit before applying adjustments, in the
       *  purchase currency.
       * @param aValue the new value for the tax.
       */
      setTax(aValue: dw.value.Money): void;
      /**
       * Sets the tax class ID for the line item.
       * @param aValue the tax class ID for the line item.
       */
      setTaxClassID(aValue: string): void;
      /**
       * Sets the tax rate, which is the decimal tax rate to be applied to the product represented by this line item. A
       *  value of 0.175 represents a percentage of 17.5%.
       * @param taxRate the new value for the tax rate.
       */
      setTaxRate(taxRate: number): void;
      /**
       * Updates the price attributes of the line item based on the specified price. The base price is set to the
       *  specified value. If the line item is based on net pricing then the net price attribute is set. If the line item
       *  is based on gross pricing then the gross price attribute is set. Whether or not a line item is based on net or
       *  gross pricing is a site-wide configuration parameter.
       * @param price The price to use when performing the update. This price must not be null and must either be equal to NOT_AVAIALBLE or must have a currency code equal to that of the parent container.
       */
      updatePrice(price: dw.value.Money): void;
      /**
       * Updates the tax-related attributes of the line item based on the specified tax rate, a tax basis determined by
       *  the system and the "Tax Rounding Mode" order preference. This method sets the tax basis as an attribute, and is
       *  not affected by the previous value of this attribute.
       *
       *  The value used as a basis depends on the type of line item this is and on the promotion preferences for the
       *  current site. If the "old" tax basis rules are used, then the tax basis will simply be equal to
       *  getPrice(). If the "new" tax basis rules used, then the tax basis depends upon line item type as
       *  follows:
       *
       *  ProductLineItem: basis equals ProductLineItem.getProratedPrice().
       *  ShippingLineItem: basis equals ShippingLineItem.getAdjustedPrice().
       *  ProductShippingLineItem: basis equals
       *  ProductShippingLineItem.getAdjustedPrice().
       *  PriceAdjustment: basis equals 0.00.
       *  All other line item types: basis equals getPrice().
       *
       *  If null is passed as tax rate, tax-related attribute fields are set to N/A.
       * @param taxRate taxRate the tax rate to use or null.
       */
      updateTax(taxRate: number): void;
      /**
       * Updates the tax-related attributes of the line item based on the specified tax rate, the passed tax basis and the
       *  "Tax Rounding Mode" order preference. If null is passed as tax rate or tax basis, tax-related attribute fields
       *  are set to N/A.
       * @param taxRate the tax rate to use or null.
       * @param taxBasis the tax basis to use or null.
       */
      updateTax(taxRate: number, taxBasis: dw.value.Money): void;
      /**
       * Updates tax amount of the line item setting the provided value. Depending on the way how the tax is calculated
       *  (based on net or gross price), the corresponding gross or net price is updated accordingly. For tax calculation
       *  based on net price, the gross price is calculated by adding the tax to the net price. For tax calculation based
       *  on gross price, the net price is calculated by subtracting the tax from the gross price.
       *
       *  If null is passed as tax amount, the item tax and resulting net or gross price are set to N/A.
       *
       *  Note that tax rate is not calculated and it is not updated.
       * @param tax the tax amount of the line item to set
       */
      updateTaxAmount(tax: dw.value.Money): void;
    }

    /**
     * A container for line items, such as ProductLineItems, CouponLineItems,
     *  GiftCertificateLineItems. This container also provides access to shipments,
     *  shipping adjustments (promotions), and payment instruments (credit cards).
     *  <p>
     *  LineItemCtnr also contains a set of methods for creating line items and
     *  adjustments, and for accessing various price values.
     *  There are three types of price-related methods:
     *  </p><p>
     *  </p><ul>
     *  <li><u>Net-based</u> methods represent the amount of a category <b>before tax has been
     *  calculated</b>. For example, the getMerchandizeTotalNetPrice() returns the price
     *  of all merchandise in the container whereas getShippingTotalNetPrice() returns
     *  the price of all shipments in the container.</li>
     *  <li><u>Tax-based</u> methods return the amount of tax on a category. For example, the
     *  getMerchandizeTotalTax() returns the total tax for all merchandise and the
     *  getShippingTotalTax() returns the tax applied to all shipments.</li>
     *  <li><u>Gross-based</u> methods represent the amount of a category <b>after tax has been
     *  calculated</b>. For example, the getMerchandizeTotalGrossPrice() returns the price
     *  of all merchandise in the container, including tax on the merchandise,
     *  whereas getShippingTotalGrossPrice() returns
     *  the price of all shipments in the container, including tax on the shipments in
     *  the container.</li>
     *  </ul>
     *  There are also a set of methods that provide access to &apos;adjusted&apos; values. The
     *  adjusted-based methods return values where promotions have been applied. For
     *  example, the getAdjustedMerchandizeTotalNetPrice() method returns the net price
     *  of all merchandise after product-level and order-level promotions have been
     *  applied. Whereas the getAdjustedMerchandizeTotalGrossPrice() method returns
     *  the price of all merchandise after product-level and order-level promotions
     *  have been applied and includes the amount of merchandise-related tax.
     *  <p>
     *  Finally, there are a set of methods that return the aggregate values
     *  representing the line items in the container. These are the total-based
     *  methods getTotalNetPrice(), getTotalTax() and getTotalGrossPrice(). These
     *  methods return the totals of all items in the container and include any
     *  order-level promotions.</p><p>
     *
     *  Note that all merchandise-related methods do not include &apos;gift certificates&apos;
     *  values in the values they return. Gift certificates are not considered merchandise
     *  as they do not represent a product.</p><p></p>
     */
    class LineItemCtnr extends dw.object.ExtensibleObject {
      /**
       * constant for Business Type B2B
       */
      static readonly BUSINESS_TYPE_B2B = 2;
      /**
       * constant for Business Type B2C
       */
      static readonly BUSINESS_TYPE_B2C = 1;
      /**
       * constant for Channel Type CallCenter
       */
      static readonly CHANNEL_TYPE_CALLCENTER = 2;
      /**
       * constant for Channel Type Customer Service Center
       */
      static readonly CHANNEL_TYPE_CUSTOMERSERVICECENTER = 11;
      /**
       * constant for Channel Type DSS
       */
      static readonly CHANNEL_TYPE_DSS = 4;
      /**
       * constant for Channel Type Facebook Ads
       */
      static readonly CHANNEL_TYPE_FACEBOOKADS = 8;
      /**
       * constant for Channel Type Instagram Commerce
       */
      static readonly CHANNEL_TYPE_INSTAGRAMCOMMERCE = 12;
      /**
       * constant for Channel Type Marketplace
       */
      static readonly CHANNEL_TYPE_MARKETPLACE = 3;
      /**
       * constant for Channel Type Online Reservation
       */
      static readonly CHANNEL_TYPE_ONLINERESERVATION = 10;
      /**
       * constant for Channel Type Pinterest
       */
      static readonly CHANNEL_TYPE_PINTEREST = 6;
      /**
       * constant for Channel Type Store
       */
      static readonly CHANNEL_TYPE_STORE = 5;
      /**
       * constant for Channel Type Storefront
       */
      static readonly CHANNEL_TYPE_STOREFRONT = 1;
      /**
       * constant for Channel Type Subscriptions
       */
      static readonly CHANNEL_TYPE_SUBSCRIPTIONS = 9;
      /**
       * constant for Channel Type Twitter
       */
      static readonly CHANNEL_TYPE_TWITTER = 7;

      /**
       * The adjusted total gross price (including tax) in purchase currency.
       *
       *  Adjusted merchandize prices represent the sum of product prices before
       *  services such as shipping, but after product-level and
       *  order-level adjustments.
       */
      readonly adjustedMerchandizeTotalGrossPrice: dw.value.Money;
      /**
       * The total net price (excluding tax) in purchase currency.
       *
       *  Adjusted merchandize prices represent the sum of product prices before
       *  services such as shipping, but after product-level and
       *  order-level adjustments.
       */
      readonly adjustedMerchandizeTotalNetPrice: dw.value.Money;
      /**
       * The adjusted merchandize total price including product-level and
       *  order-level adjustments. If the line item container is based on net
       *  pricing the adjusted merchandize total net price is returned. If the
       *  line item container is based on gross pricing the adjusted merchandize
       *  total gross price is returned.
       */
      readonly adjustedMerchandizeTotalPrice: dw.value.Money;
      /**
       * The subtotal tax in purchase currency.
       *
       *  Adjusted merchandize prices represent the sum of product prices before
       *  services such as shipping have been added, but after adjustment from
       *  promotions have been added.
       */
      readonly adjustedMerchandizeTotalTax: dw.value.Money;
      /**
       * The adjusted sum of all shipping line items of the line item container,
       *  including tax after shipping adjustments have been applied.
       */
      readonly adjustedShippingTotalGrossPrice: dw.value.Money;
      /**
       * The sum of all shipping line items of the line item container,
       *  excluding tax after shipping adjustments have been applied.
       */
      readonly adjustedShippingTotalNetPrice: dw.value.Money;
      /**
       * The adjusted shipping total price. If the line item container
       *  is based on net pricing the adjusted shipping total net price is
       *  returned. If the line item container is based on gross pricing the adjusted
       *  shipping total gross price is returned.
       */
      readonly adjustedShippingTotalPrice: dw.value.Money;
      /**
       * The tax of all shipping line items of the line item container after
       *  shipping adjustments have been applied.
       */
      readonly adjustedShippingTotalTax: dw.value.Money;
      /**
       * All gift certificate line items of the container.
       */
      readonly allGiftCertificateLineItems: dw.util.Collection<
        dw.order.GiftCertificateLineItem
      >;
      /**
       * All product, shipping, price adjustment, and gift certificate
       *  line items of the line item container.
       */
      readonly allLineItems: dw.util.Collection<dw.order.LineItem>;
      /**
       * All product line items of the container, no matter if they are
       *  dependent or independent. This includes option, bundled and bonus line
       *  items.
       */
      readonly allProductLineItems: dw.util.Collection<
        dw.order.ProductLineItem
      >;
      /**
       * A hash mapping all products in the line item container to their
       *  total quantities.  The total product quantity is used chiefly
       *  to validate the availability of the items in the cart.  This method
       *  is not appropriate to look up prices because it returns products
       *  such as bundled line items which are included in the price of their
       *  parent and therefore have no corresponding price.
       *
       *  The method counts all direct product line items, plus dependent product
       *  line items that are not option line items. It also excludes product line
       *  items that are not associated to any catalog product.
       */
      readonly allProductQuantities: dw.util.HashMap<
        dw.catalog.Product,
        dw.value.Quantity
      >;
      /**
       * The collection of all shipping price adjustments applied
       *  somewhere in the container. This can be adjustments applied to individual
       *  shipments or to the container itself. Note that the promotions engine
       *  only applies shipping price adjustments to the the default shipping line
       *  item of shipments, and never to the container.
       */
      readonly allShippingPriceAdjustments: dw.util.Collection<
        dw.order.PriceAdjustment
      >;
      /**
       * The billing address defined for the container. Returns null if
       *  no billing address has been created yet.
       */
      readonly billingAddress: dw.order.OrderAddress;
      /**
       * An unsorted collection of the the bonus discount line items
       *  associated with this container.
       */
      readonly bonusDiscountLineItems: dw.util.Collection<
        dw.order.BonusDiscountLineItem
      >;
      /**
       * The collection of product line items that are bonus items (where
       *  ProductLineItem.isBonusProductLineItem() is true).
       */
      readonly bonusLineItems: dw.util.Collection<dw.order.ProductLineItem>;
      /**
       * The type of the business this order has been placed in.
       *  Possible values are BUSINESS_TYPE_B2C or BUSINESS_TYPE_B2B.
       */
      readonly businessType: dw.value.EnumValue;
      /**
       * The channel type defines in which sales channel this order has been created. This can be used to distinguish
       *  order placed through Storefront, Call Center or Marketplace.
       *  Possible values are CHANNEL_TYPE_STOREFRONT, CHANNEL_TYPE_CALLCENTER,
       *  CHANNEL_TYPE_MARKETPLACE, CHANNEL_TYPE_DSS, CHANNEL_TYPE_STORE,
       *  CHANNEL_TYPE_PINTEREST, CHANNEL_TYPE_TWITTER, CHANNEL_TYPE_FACEBOOKADS,
       *  CHANNEL_TYPE_SUBSCRIPTIONS, CHANNEL_TYPE_ONLINERESERVATION or CHANNEL_TYPE_CUSTOMERSERVICECENTER.
       */
      readonly channelType: dw.value.EnumValue;
      /**
       * A sorted collection of the coupon line items in the container. The coupon line items are returned in the order
       *  they were added to container.
       */
      readonly couponLineItems: dw.util.Collection<dw.order.CouponLineItem>;
      /**
       * The currency code for this line item container. The currency code
       *  is a 3-character currency mnemonic such as 'USD' or 'EUR'. The currency
       *  code represents the currency in which the calculation is made, and in
       *  which the buyer sees all prices in the store front.
       */
      readonly currencyCode: string;
      /**
       * The customer associated with this container.
       */
      readonly customer: dw.customer.Customer;
      /**
       * The email of the customer associated with this container.
       */
      customerEmail: string;
      /**
       * The name of the customer associated with this container.
       */
      customerName: string;
      /**
       * The customer number of the customer associated with this container.
       */
      readonly customerNo: string;
      /**
       * The default shipment of the line item container.
       */
      readonly defaultShipment: dw.order.Shipment;
      /**
       * The Etag of the line item container. The Etag is a hash that represents the overall container state
       *  including any associated objects like line items.
       */
      readonly etag: string;
      /**
       * All gift certificate line items of the container.
       */
      readonly giftCertificateLineItems: dw.util.Collection<
        dw.order.GiftCertificateLineItem
      >;
      /**
       * An unsorted collection of the PaymentInstrument instances that
       *  represent GiftCertificates in this container.
       */
      readonly giftCertificatePaymentInstruments: dw.util.Collection<
        dw.order.PaymentInstrument
      >;
      /**
       * The total gross price of all gift certificates in
       *  the cart. Should usually be equal to total net price.
       */
      readonly giftCertificateTotalGrossPrice: dw.value.Money;
      /**
       * The total net price (excluding tax) of all gift certificates in
       *  the cart. Should usually be equal to total gross price.
       */
      readonly giftCertificateTotalNetPrice: dw.value.Money;
      /**
       * The gift certificate total price. If the line item container is based
       *  on net pricing the gift certificate total net price is returned. If the line
       *  item container is based on gross pricing the gift certificate total gross
       *  price is returned.
       */
      readonly giftCertificateTotalPrice: dw.value.Money;
      /**
       * The total tax of all gift certificates in
       *  the cart. Should usually be 0.0.
       */
      readonly giftCertificateTotalTax: dw.value.Money;
      /**
       * The total gross price (including tax) in purchase currency.
       *
       *  Merchandize total prices represent the sum of product prices before
       *  services such as shipping or adjustment from promotions have
       *  been added.
       */
      readonly merchandizeTotalGrossPrice: dw.value.Money;
      /**
       * The total net price (excluding tax) in purchase currency.
       *
       *  Merchandize total prices represent the sum of product prices before
       *  services such as shipping or adjustment from promotion have
       *  been added.
       */
      readonly merchandizeTotalNetPrice: dw.value.Money;
      /**
       * The merchandize total price. If the line item container is based
       *  on net pricing the merchandize total net price is returned. If the line
       *  item container is based on gross pricing the merchandize total gross price
       *  is returned.
       */
      readonly merchandizeTotalPrice: dw.value.Money;
      /**
       * The total tax in purchase currency.
       *
       *  Merchandize total prices represent the sum of product prices before
       *  services such as shipping or adjustment from promotions have
       *  been added.
       */
      readonly merchandizeTotalTax: dw.value.Money;
      /**
       * The list of notes for this object, ordered by creation time
       *  from oldest to newest.
       */
      readonly notes: dw.util.List<dw.object.Note>;
      /**
       * The payment instrument of the line item container or null.
       *  This method is deprecated. You should use getPaymentInstruments() or
       *  getGiftCertificatePaymentInstruments() instead.
       */
      readonly paymentInstrument: dw.order.OrderPaymentInstrument;
      /**
       * An unsorted collection of the payment instruments in this
       *  container.
       */
      readonly paymentInstruments: dw.util.Collection<
        dw.order.PaymentInstrument
      >;
      /**
       * The collection of price adjustments that have been applied to the
       *  totals such as promotion on the purchase value (i.e. $10 Off or 10% Off).
       *  The price adjustments are sorted by the order in which they were applied
       *  to the order by the promotions engine.
       */
      readonly priceAdjustments: dw.util.Collection<dw.order.PriceAdjustment>;
      /**
       * The product line items of the container that are not dependent on
       *  other product line items. This includes line items representing bonus
       *  products in the container but excludes option, bundled, and bonus line
       *  items. The returned collection is sorted by the position attribute of the
       *  product line items.
       */
      readonly productLineItems: dw.util.Collection<dw.order.ProductLineItem>;
      /**
       * A hash map of all products in the line item container and their
       *  total quantities. The total product quantity is for example used
       *  to lookup the product price.
       *
       *  The method counts all direct product line items, plus dependent product
       *  line items that are not bundled line items and no option line items. It
       *  also excludes product line items that are not associated to any catalog
       *  product, and bonus product line items.
       */
      readonly productQuantities: dw.util.HashMap<
        dw.catalog.Product,
        dw.value.Quantity
      >;
      /**
       * The total quantity of all product line items.
       *  Not included are bundled line items and option line items.
       */
      readonly productQuantityTotal: number;
      /**
       * All shipments of the line item container.
       *  The first shipment in the returned collection is the default shipment.
       *  All other shipments are sorted ascending by shipment ID.
       */
      readonly shipments: dw.util.Collection<dw.order.Shipment>;
      /**
       * The of shipping price adjustments applied to the
       *  shipping total of the container.  Note that the promotions engine
       *  only applies shipping price adjustments to the the default shipping line
       *  item of shipments, and never to the container.
       */
      readonly shippingPriceAdjustments: dw.util.Collection<
        dw.order.PriceAdjustment
      >;
      /**
       * The sum of all shipping line items of the line item container,
       *  including tax before shipping adjustments have been applied.
       */
      readonly shippingTotalGrossPrice: dw.value.Money;
      /**
       * The sum of all shipping line items of the line item container,
       *  excluding tax before shipping adjustments have been applied.
       */
      readonly shippingTotalNetPrice: dw.value.Money;
      /**
       * The shipping total price. If the line item container is based on
       *  net pricing the shipping total net price is returned. If the line item
       *  container is based on gross pricing the shipping total gross price is
       *  returned.
       */
      readonly shippingTotalPrice: dw.value.Money;
      /**
       * The tax of all shipping line items of the line item container before
       *  shipping adjustments have been applied.
       */
      readonly shippingTotalTax: dw.value.Money;
      /**
       * The grand total price gross of tax for LineItemCtnr, in purchase currency.
       *
       *  Total prices represent the sum of product prices, services prices and adjustments.
       */
      readonly totalGrossPrice: dw.value.Money;
      /**
       * The grand total price for LineItemCtnr net of tax, in purchase currency.
       *
       *  Total prices represent the sum of product prices, services prices and adjustments.
       */
      readonly totalNetPrice: dw.value.Money;
      /**
       * The grand total tax for LineItemCtnr, in purchase currency.
       *
       *  Total prices represent the sum of product prices, services prices and adjustments.
       */
      readonly totalTax: dw.value.Money;

      /**
       * Adds a note to the object.
       * @param subject The subject of the note.
       * @param text The text of the note. Must be no more than 4000 characters or an exception is thrown.
       * @return the added note.
       */
      addNote(subject: string, text: string): dw.object.Note;
      /**
       * Create a billing address for the LineItemCtnr. A LineItemCtnr (e.g.
       *  basket) initially has no billing address. This method creates a billing
       *  address for the LineItemCtnr and replaces an existing billing address.
       *
       * @return The new billing address of the LineItemCtnr.
       */
      createBillingAddress(): dw.order.OrderAddress;
      /**
       * Creates a product line item in the container based on the passed Product
       *  and BonusDiscountLineItem. The product must be assigned to the current
       *  site catalog and must also be a bonus product of the specified
       *  BonusDiscountLineItem or an exception is thrown. The line item is always
       *  created in the default shipment. If successful, the operation always
       *  creates a new ProductLineItem and never simply increments the quantity of
       *  an existing ProductLineItem. An option model can optionally be specified.
       * @param bonusDiscountLineItem Line item representing an applied BonusChoiceDiscount in the LineItemCtnr, must not be null.
       * @param product Product The product to add to the LineItemCtnr. Must not be null and must be a bonus product of bonusDiscountLineItem.
       * @param optionModel ProductOptionModel or null.
       * @param shipment The shipment to add the bonus product to. If null, the product is added to the default shipment.
       */
      createBonusProductLineItem(
        bonusDiscountLineItem: dw.order.BonusDiscountLineItem,
        product: dw.catalog.Product,
        optionModel: dw.catalog.ProductOptionModel,
        shipment: dw.order.Shipment
      ): dw.order.ProductLineItem;
      /**
       * Creates a new CouponLineItem for this container based on the supplied coupon code.
       *
       *  The created coupon line item is based on the Commerce Cloud Digital campaign system if campaignBased parameter is true. In
       *  that case, if the supplied coupon code is not valid, APIException with type 'CreateCouponLineItemException' is
       *  thrown.
       *
       *  If you want to create a custom coupon line item, you must call this method with campaignBased = false or to use
       *  createCouponLineItem(String).
       *
       *
       *  Example:
       *
       *
       *   try {
       *      var cli : CouponLineItem = basket.createCouponLineItem(couponCode, true);
       *  } catch (e if e instanceof APIException && e.type === 'CreateCouponLineItemException')
       *      if (e.errorCode == CouponStatusCodes.COUPON_CODE_ALREADY_IN_BASKET) {
       *          ...
       *      }
       *  }
       *
       *
       *  An dw.order.CreateCouponLineItemException is thrown in case of campaignBased = true only. Indicates that the
       *  provided coupon code is not a valid coupon code to create a coupon line item based on the Commerce Cloud Digital campaign
       *  system. The error code property (CreateCouponLineItemException.errorCode) will be set to one of the following
       *  values:
       *
       *  CouponStatusCodes.COUPON_CODE_ALREADY_IN_BASKET = Indicates that coupon code has already
       *  been added to basket.
       *  CouponStatusCodes.COUPON_ALREADY_IN_BASKET = Indicates that another code of the same
       *  MultiCode/System coupon has already been added to basket.
       *  CouponStatusCodes.COUPON_CODE_ALREADY_REDEEMED = Indicates that code of MultiCode/System
       *  coupon has already been redeemed.
       *  CouponStatusCodes.COUPON_CODE_UNKNOWN = Indicates that coupon not found for given coupon
       *  code or that the code itself was not found.
       *  CouponStatusCodes.COUPON_DISABLED = Indicates that coupon is not enabled.
       *  CouponStatusCodes.REDEMPTION_LIMIT_EXCEEDED = Indicates that number of redemptions per
       *  code exceeded.
       *  CouponStatusCodes.CUSTOMER_REDEMPTION_LIMIT_EXCEEDED = Indicates that number of
       *  redemptions per code and customer exceeded.
       *  CouponStatusCodes.TIMEFRAME_REDEMPTION_LIMIT_EXCEEDED = Indicates that number of
       *  redemptions per code, customer and time exceeded.
       *  CouponStatusCodes.NO_ACTIVE_PROMOTION = Indicates that coupon is not assigned to an
       *  active promotion.
       * @param couponCode the coupon code to be represented by the coupon line item
       * @param campaignBased the flag if the created coupon line item should be based on the Commerce Cloud Digital campaign system
       * @return the created coupon line item
       */
      createCouponLineItem(
        couponCode: string,
        campaignBased: boolean
      ): dw.order.CouponLineItem;
      /**
       * Creates a coupon line item that is not based on the Commerce Cloud Digital campaign
       *  system and associates it with the specified coupon code.
       *
       *  There may not be any other coupon line item in the container with
       *  the specific coupon code, otherwise an exception is thrown.
       *
       *  If you want to create a coupon line item based on the Commerce Cloud Digital campaign
       *  system, you must use createCouponLineItem(String, Boolean)
       *  with campaignBased = true.
       * @param couponCode couponCode represented by the coupon line item.
       * @return New coupon line item.
       */
      createCouponLineItem(couponCode: string): dw.order.CouponLineItem;
      /**
       * Creates a gift certificate line item.
       * @param amount the amount of the gift certificate - mandatory
       * @param recipientEmail the recipient's email address - mandatory
       * @return The new gift certificate line item
       */
      createGiftCertificateLineItem(
        amount: number,
        recipientEmail: string
      ): dw.order.GiftCertificateLineItem;
      /**
       * Creates an OrderPaymentInstrument representing a Gift Certificate.
       *  The amount is set on a PaymentTransaction that is accessible via the
       *  OrderPaymentInstrument. By default, the status of the PaymentTransaction
       *  is set to CREATE. The PaymentTransaction must be processed at a later
       *  time.
       * @param giftCertificateCode the redemption code of the Gift Certificate.
       * @param amount the amount to set on the PaymentTransaction. If the OrderPaymentInstrument is actually redeemed, this is the amount that will be deducted from the Gift Certificate.
       * @return the OrderPaymentInstrument.
       */
      createGiftCertificatePaymentInstrument(
        giftCertificateCode: string,
        amount: dw.value.Money
      ): dw.order.OrderPaymentInstrument;
      /**
       * Creates a payment instrument using the specified payment method id and amount. The amount is set on the
       *  PaymentTransaction that is attached to the payment instrument.
       * @param paymentMethodId The payment method id. See the PaymentInstrument class for payment method types
       * @param amount The payment amount or null
       * @return The new payment instrument
       */
      createPaymentInstrument(
        paymentMethodId: string,
        amount: dw.value.Money
      ): dw.order.OrderPaymentInstrument;
      /**
       * Creates a payment instrument using the specified wallet payment instrument and amount. The amount is set on the
       *  PaymentTransaction that is attached to the payment instrument. All data from the wallet payment
       *  instrument will be copied over to the created payment instrument.
       * @param walletPaymentInstrument The payment instrument from the customer's walled.
       * @param amount The payment amount or null
       * @return The new payment instrument
       */
      createPaymentInstrumentFromWallet(
        walletPaymentInstrument: dw.customer.CustomerPaymentInstrument,
        amount: dw.value.Money
      ): dw.order.OrderPaymentInstrument;
      /**
       * Creates an order price adjustment.
       *  The promotion id is mandatory and must not be the ID of any actual
       *  promotion defined in Commerce Cloud Digital; otherwise an exception is thrown.
       * @param promotionID Promotion ID
       * @return The new price adjustment
       */
      createPriceAdjustment(promotionID: string): dw.order.PriceAdjustment;
      /**
       * Creates an order level price adjustment for a specific discount.
       *  The promotion id is mandatory and must not be the ID of any actual
       *  promotion defined in Commerce Cloud Digital; otherwise an exception is thrown.
       *
       *  The possible discount types are supported: PercentageDiscount and AmountDiscount.
       *
       *  Examples:
       *
       *
       *  var myOrder : dw.order.Order; // assume known
       *  var paTenPercent : dw.order.PriceAdjustment = myOrder.createPriceAdjustment("myPromotionID1", new dw.campaign.PercentageDiscount(10));
       *  var paReduceBy20 : dw.order.PriceAdjustment = myOrder.createPriceAdjustment("myPromotionID2", new dw.campaign.AmountDiscount(20);
       * @param promotionID Promotion ID
       * @param discount The discount
       * @return The new price adjustment
       */
      createPriceAdjustment(
        promotionID: string,
        discount: dw.campaign.Discount
      ): dw.order.PriceAdjustment;
      /**
       * Creates a new product line item in the container and assigns it to the
       *  specified shipment.
       *
       *  If the specified productID represents a product in the site catalog,
       *  the method will associate the product line item with that catalog
       *  product and will copy all order-relevant information, like the
       *  quantity unit, from the catalog product.
       *
       *  If the specified productID does not represent a product of the
       *  site catalog, the method creates a new product line item and
       *  initializes it with the specified product ID and quantity.
       *  If the passed in quantity value is not a positive integer, it
       *  will be rounded to the nearest positive integer.
       *  The minimum order quantity and step quantity will be set to 1.0.
       *
       *
       *  For catalog products, the method follows the configured 'Add2Basket'
       *  strategy to either increment the quantity of an existing product line item
       *  or create a new product line item for the same product. For non-catalog
       *  products, the method creates a new product line item no matter if the
       *  same product is already in the line item container. If a negative
       *  quantity is specified, it is automatically changed to 1.0.
       * @param productID The product ID.
       * @param quantity The quantity of the product.
       * @param shipment Shipment
       * @return the product line item
       */
      createProductLineItem(
        productID: string,
        quantity: dw.value.Quantity,
        shipment: dw.order.Shipment
      ): dw.order.ProductLineItem;
      /**
       * Creates a new product line item in the container and assigns it to the
       *  specified shipment.
       *
       *  If the specified productID represents a product in the site catalog,
       *  the method will associate the product line item with that catalog
       *  product and will copy all order-relevant information, like the
       *  quantity unit, from the catalog product. The quantity of the
       *  product line item is initialized with 1.0 or - if defined - the
       *  minimum order quantity of the product.
       *
       *  If the product represents a product in the site catalog and is an
       *  option product, the product is added with it's default option values.
       *
       *  If the specified productID does not represent a product of the
       *  site catalog, the method creates a new product line item and
       *  initializes it with the specified product ID and with a
       *  quantity, minimum order quantity, and step quantity value
       *  of 1.0.
       * @param productID The product ID.
       * @param shipment Shipment
       * @return The new product line item
       */
      createProductLineItem(
        productID: string,
        shipment: dw.order.Shipment
      ): dw.order.ProductLineItem;
      /**
       * Creates a new product line item in the basket and assigns it to the specified shipment.
       *
       *  If the product list item references a product in the site catalog, the method will associate the product line
       *  item with that catalog product and will copy all order-relevant information, like the quantity unit, from the
       *  catalog product. The quantity of the product line item is initialized with 1.0 or - if defined - the minimum
       *  order quantity of the product.
       *
       *  If the product list item references an option product, the option values are copied from the product list item.
       *
       *  An exception is thrown if
       *
       *  the line item container is no basket.
       *  the type of the product list item is not PRODUCT.
       *  the product list item references a product which is not assigned to the site catalog.
       * @param productListItem the product list item
       * @param shipment the shipment the created product line item will be assigned to
       * @return The new product line item
       */
      createProductLineItem(
        productListItem: dw.customer.ProductListItem,
        shipment: dw.order.Shipment
      ): dw.order.ProductLineItem;
      /**
       * Creates a new product line item in the container and assigns it to the
       *  specified shipment. An option model can be specified.
       *
       *  Please note that the product must be assigned to the current site catalog.
       * @param product Product
       * @param optionModel ProductOptionModel or null
       * @param shipment Shipment
       */
      createProductLineItem(
        product: dw.catalog.Product,
        optionModel: dw.catalog.ProductOptionModel,
        shipment: dw.order.Shipment
      ): dw.order.ProductLineItem;
      /**
       * Creates a standard shipment for the line item container. The specified ID
       *  must not yet be in use for another shipment of this line item container.
       * @param id ID of the shipment.
       */
      createShipment(id: string): dw.order.Shipment;
      /**
       * Creates a shipping price adjustment to be applied to the container.
       *
       *  The promotion ID is mandatory and must not be the ID of any actual
       *  promotion defined in Commerce Cloud Digital; otherwise the method
       *  will throw an exception.
       *
       *  If there already exists a shipping price adjustment referring to
       *  the specified promotion ID, an exception is thrown.
       * @param promotionID Promotion ID
       * @return The new price adjustment
       */
      createShippingPriceAdjustment(
        promotionID: string
      ): dw.order.PriceAdjustment;
      /**
       * Returns the adjusted total gross price (including tax) in purchase currency.
       *
       *  Adjusted merchandize prices represent the sum of product prices before
       *  services such as shipping, but after product-level and
       *  order-level adjustments.
       *
       * @return the adjusted total gross price (including tax) in purchase currency.
       */
      getAdjustedMerchandizeTotalGrossPrice(): dw.value.Money;
      /**
       * Returns the total net price (excluding tax) in purchase currency.
       *
       *  Adjusted merchandize prices represent the sum of product prices before
       *  services such as shipping, but after product-level and
       *  order-level adjustments.
       *
       * @return the total net price (excluding tax) in purchase currency.
       */
      getAdjustedMerchandizeTotalNetPrice(): dw.value.Money;
      /**
       * Returns the adjusted merchandize total price including product-level and
       *  order-level adjustments. If the line item container is based on net
       *  pricing the adjusted merchandize total net price is returned. If the
       *  line item container is based on gross pricing the adjusted merchandize
       *  total gross price is returned.
       *
       * @return either the adjusted merchandize total net or gross price
       */
      getAdjustedMerchandizeTotalPrice(): dw.value.Money;
      /**
       * Returns the adjusted merchandize total price including order-level
       *  adjustments if requested. If the line item container
       *  is based on net pricing the adjusted merchandize total net price is
       *  returned. If the line item container is based on gross pricing the adjusted
       *  merchandize total gross price is returned.
       * @param applyOrderLevelAdjustments controls if order-level price adjustements are applied. If true, the price that is returned includes order-level price adjustments. If false, only product-level price adjustments are applied.
       * @return a price representing the adjusted merchandize total controlled by the applyOrderLevelAdjustments parameter.
       */
      getAdjustedMerchandizeTotalPrice(
        applyOrderLevelAdjustments: boolean
      ): dw.value.Money;
      /**
       * Returns the subtotal tax in purchase currency.
       *
       *  Adjusted merchandize prices represent the sum of product prices before
       *  services such as shipping have been added, but after adjustment from
       *  promotions have been added.
       *
       * @return the subtotal tax in purchase currency.
       */
      getAdjustedMerchandizeTotalTax(): dw.value.Money;
      /**
       * Returns the adjusted sum of all shipping line items of the line item container,
       *  including tax after shipping adjustments have been applied.
       *
       * @return the adjusted sum of all shipping line items of the line item container, including tax after shipping adjustments have been applied.
       */
      getAdjustedShippingTotalGrossPrice(): dw.value.Money;
      /**
       * Returns the sum of all shipping line items of the line item container,
       *  excluding tax after shipping adjustments have been applied.
       *
       * @return the sum of all shipping line items of the line item container, excluding tax after shipping adjustments have been applied.
       */
      getAdjustedShippingTotalNetPrice(): dw.value.Money;
      /**
       * Returns the adjusted shipping total price. If the line item container
       *  is based on net pricing the adjusted shipping total net price is
       *  returned. If the line item container is based on gross pricing the adjusted
       *  shipping total gross price is returned.
       *
       * @return either the adjusted shipping total net or gross price
       */
      getAdjustedShippingTotalPrice(): dw.value.Money;
      /**
       * Returns the tax of all shipping line items of the line item container after
       *  shipping adjustments have been applied.
       *
       * @return the tax of all shipping line items of the line item container after shipping adjustments have been applied.
       */
      getAdjustedShippingTotalTax(): dw.value.Money;
      /**
       * Returns all gift certificate line items of the container.
       *
       * @return A collection of all GiftCertificateLineItems of the container.
       */
      getAllGiftCertificateLineItems(): dw.util.Collection<
        dw.order.GiftCertificateLineItem
      >;
      /**
       * Returns all product, shipping, price adjustment, and gift certificate
       *  line items of the line item container.
       *
       * @return A collection of all product, shipping, price adjustment, and gift certificate line items of the container, in that order.
       */
      getAllLineItems(): dw.util.Collection<dw.order.LineItem>;
      /**
       * Returns all product line items of the container, no matter if they are
       *  dependent or independent. This includes option, bundled and bonus line
       *  items.
       *
       * @return An unsorted collection of all ProductLineItem instances of the container.
       */
      getAllProductLineItems(): dw.util.Collection<dw.order.ProductLineItem>;
      /**
       * Returns all product line items of the container that have a product ID
       *  equal to the specified product ID, no matter if they are dependent or
       *  independent. This includes option, bundled and bonus line items.
       * @param productID The product ID used to filter the product line items.
       * @return An unsorted collection of all ProductLineItem instances which have the specified product ID.
       */
      getAllProductLineItems(
        productID: string
      ): dw.util.Collection<dw.order.ProductLineItem>;
      /**
       * Returns a hash mapping all products in the line item container to their
       *  total quantities.  The total product quantity is used chiefly
       *  to validate the availability of the items in the cart.  This method
       *  is not appropriate to look up prices because it returns products
       *  such as bundled line items which are included in the price of their
       *  parent and therefore have no corresponding price.
       *
       *  The method counts all direct product line items, plus dependent product
       *  line items that are not option line items. It also excludes product line
       *  items that are not associated to any catalog product.
       *
       * @return A map of products and their total quantities.
       */
      getAllProductQuantities(): dw.util.HashMap<
        dw.catalog.Product,
        dw.value.Quantity
      >;
      /**
       * Returns the collection of all shipping price adjustments applied
       *  somewhere in the container. This can be adjustments applied to individual
       *  shipments or to the container itself. Note that the promotions engine
       *  only applies shipping price adjustments to the the default shipping line
       *  item of shipments, and never to the container.
       *
       * @return an unsorted collection of the shipping PriceAdjustment instances associated with this container.
       */
      getAllShippingPriceAdjustments(): dw.util.Collection<
        dw.order.PriceAdjustment
      >;
      /**
       * Returns the billing address defined for the container. Returns null if
       *  no billing address has been created yet.
       *
       * @return the billing address or null.
       */
      getBillingAddress(): dw.order.OrderAddress;
      /**
       * Returns an unsorted collection of the the bonus discount line items
       *  associated with this container.
       *
       * @return An unsorted collection of BonusDiscountLine instances in the container.
       */
      getBonusDiscountLineItems(): dw.util.Collection<
        dw.order.BonusDiscountLineItem
      >;
      /**
       * Returns the collection of product line items that are bonus items (where
       *  ProductLineItem.isBonusProductLineItem() is true).
       *
       * @return the collection of product line items that are bonus items.
       */
      getBonusLineItems(): dw.util.Collection<dw.order.ProductLineItem>;
      /**
       * Returns the type of the business this order has been placed in.
       *  Possible values are BUSINESS_TYPE_B2C or BUSINESS_TYPE_B2B.
       *
       * @return the type of the business this order has been placed in. or null, if the business type is not set
       */
      getBusinessType(): dw.value.EnumValue;
      /**
       * The channel type defines in which sales channel this order has been created. This can be used to distinguish
       *  order placed through Storefront, Call Center or Marketplace.
       *  Possible values are CHANNEL_TYPE_STOREFRONT, CHANNEL_TYPE_CALLCENTER,
       *  CHANNEL_TYPE_MARKETPLACE, CHANNEL_TYPE_DSS, CHANNEL_TYPE_STORE,
       *  CHANNEL_TYPE_PINTEREST, CHANNEL_TYPE_TWITTER, CHANNEL_TYPE_FACEBOOKADS,
       *  CHANNEL_TYPE_SUBSCRIPTIONS, CHANNEL_TYPE_ONLINERESERVATION or CHANNEL_TYPE_CUSTOMERSERVICECENTER.
       *
       * @return the sales channel this order has been placed in or null, if the order channel is not set
       */
      getChannelType(): dw.value.EnumValue;
      /**
       * Returns the coupon line item representing the specified coupon code.
       * @param couponCode the coupon code.
       * @return coupon line item or null.
       */
      getCouponLineItem(couponCode: string): dw.order.CouponLineItem;
      /**
       * Returns a sorted collection of the coupon line items in the container. The coupon line items are returned in the order
       *  they were added to container.
       *
       * @return A sorted list of the CouponLineItem instances in the container.
       */
      getCouponLineItems(): dw.util.Collection<dw.order.CouponLineItem>;
      /**
       * Returns the currency code for this line item container. The currency code
       *  is a 3-character currency mnemonic such as 'USD' or 'EUR'. The currency
       *  code represents the currency in which the calculation is made, and in
       *  which the buyer sees all prices in the store front.
       *
       * @return the currency code for this line item container.
       */
      getCurrencyCode(): string;
      /**
       * Returns the customer associated with this container.
       *
       * @return the customer associated with this container.
       */
      getCustomer(): dw.customer.Customer;
      /**
       * Returns the email of the customer associated with this container.
       *
       * @return the email of the customer associated with this container.
       */
      getCustomerEmail(): string;
      /**
       * Returns the name of the customer associated with this container.
       *
       * @return the name of the customer associated with this container.
       */
      getCustomerName(): string;
      /**
       * Returns the customer number of the customer associated with this container.
       *
       * @return the customer number of the customer associated with this container.
       */
      getCustomerNo(): string;
      /**
       * Returns the default shipment of the line item container.
       *
       * @return Default shipment of the container
       */
      getDefaultShipment(): dw.order.Shipment;
      /**
       * Returns the Etag of the line item container. The Etag is a hash that represents the overall container state
       *  including any associated objects like line items.
       *
       * @return the Etag value
       */
      getEtag(): string;
      /**
       * Returns all gift certificate line items of the container.
       *
       * @return A collection of all GiftCertificateLineItems of the container.
       */
      getGiftCertificateLineItems(): dw.util.Collection<
        dw.order.GiftCertificateLineItem
      >;
      /**
       * Returns all gift certificate line items of the container, no matter if they are
       *  dependent or independent.
       * @param giftCertificateId the gift certificate identifier.
       * @return A collection of all GiftCertificateLineItems of the container.
       */
      getGiftCertificateLineItems(
        giftCertificateId: string
      ): dw.util.Collection<dw.order.GiftCertificateLineItem>;
      /**
       * Returns an unsorted collection of the PaymentInstrument instances that
       *  represent GiftCertificates in this container.
       *
       * @return an unsorted collection containing the set of PaymentInstrument instances that represent GiftCertificates.
       */
      getGiftCertificatePaymentInstruments(): dw.util.Collection<
        dw.order.PaymentInstrument
      >;
      /**
       * Returns an unsorted collection containing all PaymentInstruments of type
       *  PaymentInstrument.METHOD_GIFT_CERTIFICATE where the specified code is the
       *  same code on the payment instrument.
       * @param giftCertificateCode the gift certificate code.
       * @return an unsorted collection containing all PaymentInstruments of type PaymentInstrument.METHOD_GIFT_CERTIFICATE where the specified code is the same code on the payment instrument.
       */
      getGiftCertificatePaymentInstruments(
        giftCertificateCode: string
      ): dw.util.Collection<dw.order.PaymentInstrument>;
      /**
       * Returns the total gross price of all gift certificates in
       *  the cart. Should usually be equal to total net price.
       *
       * @return the total gross price of all gift certificate line items
       */
      getGiftCertificateTotalGrossPrice(): dw.value.Money;
      /**
       * Returns the total net price (excluding tax) of all gift certificates in
       *  the cart. Should usually be equal to total gross price.
       *
       * @return the total net price of all gift certificate line items
       */
      getGiftCertificateTotalNetPrice(): dw.value.Money;
      /**
       * Returns the gift certificate total price. If the line item container is based
       *  on net pricing the gift certificate total net price is returned. If the line
       *  item container is based on gross pricing the gift certificate total gross
       *  price is returned.
       *
       * @return either the gift certificate total net or gross price
       */
      getGiftCertificateTotalPrice(): dw.value.Money;
      /**
       * Returns the total tax of all gift certificates in
       *  the cart. Should usually be 0.0.
       *
       * @return the total tax of all gift certificate line items
       */
      getGiftCertificateTotalTax(): dw.value.Money;
      /**
       * Returns the total gross price (including tax) in purchase currency.
       *
       *  Merchandize total prices represent the sum of product prices before
       *  services such as shipping or adjustment from promotions have
       *  been added.
       *
       * @return the total gross price (including tax) in purchase currency.
       */
      getMerchandizeTotalGrossPrice(): dw.value.Money;
      /**
       * Returns the total net price (excluding tax) in purchase currency.
       *
       *  Merchandize total prices represent the sum of product prices before
       *  services such as shipping or adjustment from promotion have
       *  been added.
       *
       * @return the total net price (excluding tax) in purchase currency.
       */
      getMerchandizeTotalNetPrice(): dw.value.Money;
      /**
       * Returns the merchandize total price. If the line item container is based
       *  on net pricing the merchandize total net price is returned. If the line
       *  item container is based on gross pricing the merchandize total gross price
       *  is returned.
       *
       * @return either the merchandize total net or gross price
       */
      getMerchandizeTotalPrice(): dw.value.Money;
      /**
       * Returns the total tax in purchase currency.
       *
       *  Merchandize total prices represent the sum of product prices before
       *  services such as shipping or adjustment from promotions have
       *  been added.
       *
       * @return the total tax in purchase currency.
       */
      getMerchandizeTotalTax(): dw.value.Money;
      /**
       * Returns the list of notes for this object, ordered by creation time
       *  from oldest to newest.
       *
       * @return the list of notes for this object, ordered by creation time from oldest to newest.
       */
      getNotes(): dw.util.List<dw.object.Note>;
      /**
       * Returns the payment instrument of the line item container or null.
       *  This method is deprecated. You should use getPaymentInstruments() or
       *  getGiftCertificatePaymentInstruments() instead.
       *
       * @return the order payment instrument of the line item container or null.
       */
      getPaymentInstrument(): dw.order.OrderPaymentInstrument;
      /**
       * Returns an unsorted collection of the payment instruments in this
       *  container.
       *
       * @return an unsorted collection containing the set of PaymentInstrument instances associated with this container.
       */
      getPaymentInstruments(): dw.util.Collection<dw.order.PaymentInstrument>;
      /**
       * Returns an unsorted collection of PaymentInstrument instances based on
       *  the specified payment method ID.
       * @param paymentMethodID the ID of the payment method used.
       * @return an unsorted collection of OrderPaymentInstrument instances based on the payment method.
       */
      getPaymentInstruments(
        paymentMethodID: string
      ): dw.util.Collection<dw.order.PaymentInstrument>;
      /**
       * Returns the price adjustment associated to the specified
       *  promotion ID.
       * @param promotionID Promotion id
       * @return The price adjustment associated with the specified promotion ID or null if none was found.
       */
      getPriceAdjustmentByPromotionID(
        promotionID: string
      ): dw.order.PriceAdjustment;
      /**
       * Returns the collection of price adjustments that have been applied to the
       *  totals such as promotion on the purchase value (i.e. $10 Off or 10% Off).
       *  The price adjustments are sorted by the order in which they were applied
       *  to the order by the promotions engine.
       *
       * @return the sorted collection of PriceAdjustment instances.
       */
      getPriceAdjustments(): dw.util.Collection<dw.order.PriceAdjustment>;
      /**
       * Returns the product line items of the container that are not dependent on
       *  other product line items. This includes line items representing bonus
       *  products in the container but excludes option, bundled, and bonus line
       *  items. The returned collection is sorted by the position attribute of the
       *  product line items.
       *
       * @return A sorted collection of ProductLineItem instances which are not dependent on other product line items.
       */
      getProductLineItems(): dw.util.Collection<dw.order.ProductLineItem>;
      /**
       * Returns the product line items of the container that have a product ID
       *  equal to the specified product ID and that are not dependent on other
       *  product line items. This includes line items representing bonus products
       *  in the container, but excludes option, bundled and bonus line items. The
       *  returned collection is sorted by the position attribute of the product
       *  line items.
       * @param productID The Product ID used to filter the product line items.
       * @return A sorted collection of ProductLineItem instances which have the specified product ID and are not dependent on other product line items.
       */
      getProductLineItems(
        productID: string
      ): dw.util.Collection<dw.order.ProductLineItem>;
      /**
       * Returns a hash map of all products in the line item container and their
       *  total quantities. The total product quantity is for example used
       *  to lookup the product price.
       *
       *  The method counts all direct product line items, plus dependent product
       *  line items that are not bundled line items and no option line items. It
       *  also excludes product line items that are not associated to any catalog
       *  product, and bonus product line items.
       *
       * @return a map of products and their total quantities.
       */
      getProductQuantities(): dw.util.HashMap<
        dw.catalog.Product,
        dw.value.Quantity
      >;
      /**
       * Returns a hash map of all products in the line item container and their
       *  total quantities. The total product quantity is for example used
       *  to lookup the product price in the cart.
       *
       *  The method counts all direct product line items, plus dependent product
       *  line items that are not bundled line items and no option line items. It
       *  also excludes product line items that are not associated to any catalog
       *  product.
       *
       *  If the parameter 'includeBonusProducts' is set to true, the method also
       *  counts bonus product line items.
       * @param includeBonusProducts if true also bonus product line item are counted
       * @return A map of products and their total quantities.
       */
      getProductQuantities(
        includeBonusProducts: boolean
      ): dw.util.HashMap<dw.catalog.Product, dw.value.Quantity>;
      /**
       * Returns the total quantity of all product line items.
       *  Not included are bundled line items and option line items.
       *
       * @return The total quantity of all line items of the container.
       */
      getProductQuantityTotal(): number;
      /**
       * Returns the shipment for the specified ID or null if no shipment
       *  with this ID exists in the line item container.
       * @param id the shipment identifier.
       * @return Shipment or null
       */
      getShipment(id: string): dw.order.Shipment;
      /**
       * Returns all shipments of the line item container.
       *  The first shipment in the returned collection is the default shipment.
       *  All other shipments are sorted ascending by shipment ID.
       *
       * @return Shipments of the line item container
       */
      getShipments(): dw.util.Collection<dw.order.Shipment>;
      /**
       * Returns the shipping price adjustment associated with the
       *  specified promotion ID.
       * @param promotionID Promotion id
       * @return The price adjustment associated with the specified promotion ID or null if none was found.
       */
      getShippingPriceAdjustmentByPromotionID(
        promotionID: string
      ): dw.order.PriceAdjustment;
      /**
       * Returns the of shipping price adjustments applied to the
       *  shipping total of the container.  Note that the promotions engine
       *  only applies shipping price adjustments to the the default shipping line
       *  item of shipments, and never to the container.
       *
       * @return a collection of shipping price adjustments.
       */
      getShippingPriceAdjustments(): dw.util.Collection<
        dw.order.PriceAdjustment
      >;
      /**
       * Returns the sum of all shipping line items of the line item container,
       *  including tax before shipping adjustments have been applied.
       *
       * @return the sum of all shipping line items of the line item container, including tax before shipping adjustments have been applied.
       */
      getShippingTotalGrossPrice(): dw.value.Money;
      /**
       * Returns the sum of all shipping line items of the line item container,
       *  excluding tax before shipping adjustments have been applied.
       *
       * @return the sum of all shipping line items of the line item container, excluding tax before shipping adjustments have been applied.
       */
      getShippingTotalNetPrice(): dw.value.Money;
      /**
       * Returns the shipping total price. If the line item container is based on
       *  net pricing the shipping total net price is returned. If the line item
       *  container is based on gross pricing the shipping total gross price is
       *  returned.
       *
       * @return either the shipping total net or gross price
       */
      getShippingTotalPrice(): dw.value.Money;
      /**
       * Returns the tax of all shipping line items of the line item container before
       *  shipping adjustments have been applied.
       *
       * @return the tax of all shipping line items of the line item container before shipping adjustments have been applied.
       */
      getShippingTotalTax(): dw.value.Money;
      /**
       * Returns the grand total price gross of tax for LineItemCtnr, in purchase currency.
       *
       *  Total prices represent the sum of product prices, services prices and adjustments.
       *
       * @return the grand total price.
       */
      getTotalGrossPrice(): dw.value.Money;
      /**
       * Returns the grand total price for LineItemCtnr net of tax, in purchase currency.
       *
       *  Total prices represent the sum of product prices, services prices and adjustments.
       *
       * @return the grand total price.
       */
      getTotalNetPrice(): dw.value.Money;
      /**
       * Returns the grand total tax for LineItemCtnr, in purchase currency.
       *
       *  Total prices represent the sum of product prices, services prices and adjustments.
       *
       * @return the grand total tax.
       */
      getTotalTax(): dw.value.Money;
      /**
       * Removes the all Payment Instruments from this container
       *  and deletes the Payment Instruments.
       *
       */
      removeAllPaymentInstruments(): void;
      /**
       * Removes the specified bonus discount line item from the line item
       *  container.
       * @param bonusDiscountLineItem The bonus discount line item to remove, must not be null.
       */
      removeBonusDiscountLineItem(
        bonusDiscountLineItem: dw.order.BonusDiscountLineItem
      ): void;
      /**
       * Removes the specified coupon line item from the line item
       *  container.
       * @param couponLineItem The coupon line item to remove
       */
      removeCouponLineItem(couponLineItem: dw.order.CouponLineItem): void;
      /**
       * Removes the specified gift certificate line item from the line item container.
       * @param giftCertificateLineItem The gift certificate line item to remove
       */
      removeGiftCertificateLineItem(
        giftCertificateLineItem: dw.order.GiftCertificateLineItem
      ): void;
      /**
       * Removes a note from this line item container and deletes it.
       * @param note The note to remove. Must not be null. Must belong to this line item container.
       */
      removeNote(note: dw.object.Note): void;
      /**
       * Removes the specified Payment Instrument from this container
       *  and deletes the Payment Instrument.
       * @param pi the Payment Instrument to remove.
       */
      removePaymentInstrument(pi: dw.order.PaymentInstrument): void;
      /**
       * Removes the specified price adjustment line item from the line item
       *  container.
       * @param priceAdjustment The price adjustment line item to remove, must not be null.
       */
      removePriceAdjustment(priceAdjustment: dw.order.PriceAdjustment): void;
      /**
       * Removes the specified product line item from the line item container.
       * @param productLineItem The product line item to remove, must not be null.
       */
      removeProductLineItem(productLineItem: dw.order.ProductLineItem): void;
      /**
       * Removes the specified shipment and all associated product,
       *  gift certificate, shipping and price adjustment line items from the
       *  line item container. It is not permissible to remove the default shipment.
       * @param shipment Shipment to be removed, must not be null.
       */
      removeShipment(shipment: dw.order.Shipment): void;
      /**
       * Removes the specified shipping price adjustment line item from the line
       *  item container.
       * @param priceAdjustment The price adjustment line item to remove, must not be null.
       */
      removeShippingPriceAdjustment(
        priceAdjustment: dw.order.PriceAdjustment
      ): void;
      /**
       * Sets the email address of the customer associated with this container.
       * @param aValue the email address of the customer associated with this container.
       */
      setCustomerEmail(aValue: string): void;
      /**
       * Sets the name of the customer associated with this container.
       * @param aValue the name of the customer associated with this container.
       */
      setCustomerName(aValue: string): void;
      /**
       * Calculates the tax for all shipping and order-level merchandise price adjustments in this LineItemCtnr.
       *  The tax on each adjustment is calculated from the taxes of the line items the adjustment applies across.
       *  This method must be invoked at the end of tax calculation of a basket or an order.
       *
       */
      updateOrderLevelPriceAdjustmentTax(): void;
      /**
       * Recalculates the totals of the line item container. It is necessary to call
       *  this method after any type of modification to the basket.
       *
       */
      updateTotals(): void;
      /**
       * Verifies whether the manual price adjustments made for the line item container
       *  exceed the corresponding limits for the current user and the current site.
       *
       *  The results of this method are based on the current values held in the
       *  LineItemCtnr, such as the base price of manual price
       *  adjustments. It is important the method is only called after the
       *  calculation process has completed.
       *
       *   Status.OK is returned if NONE of the manual price adjustments exceed
       *  the correspondent limits.
       *   Status.ERROR is returned if ANY of the manual price adjustments
       *  exceed the correspondent limits.  If this case Status.getItems()
       *  returns all price adjustment limit violations. The code of each StatusItem
       *  represents the violated price adjustment type (see PriceAdjustmentLimitTypes).
       *  StatusItem.getDetails() returns a Map
       *  with the max amount and (where relevant) the item to which the violation
       *  applies.
       *
       *  Usage:
       *   var order : Order; // known
       *
       *  var status : Status = order.verifyPriceAdjustmentLimits();
       *  if (status.status == Status.ERROR)
       *  {
       *    for each (var statusItem : StatusItem in status.items)
       *    {
       *        var statusDetail : MapEntry = statusItem.details.entrySet().iterator().next();
       *        var maxAllowedLimit : Number = (Number) (statusDetail.key);
       *
       *        if (statusItem.code == PriceAdjustmentLimitTypes.TYPE_ORDER)
       *        {
       *            // fix order price adjustment considering maxAllowedLimit
       *        }
       *        else if (statusItem.code == PriceAdjustmentLimitTypes.TYPE_ITEM)
       *        {
       *            var pli : ProductLineItem = (ProductLineItem) (statusDetail.value);
       *            // fix pli price adjustment considering maxAllowedLimit
       *        }
       *        else if (statusItem.code == PriceAdjustmentLimitTypes.TYPE_SHIPPING)
       *        {
       *            if (statusDetail.value == null)
       *            {
       *                // fix order level shipping price adjustment considering maxAllowedLimit
       *            }
       *            else
       *            {
       *                var sli : ShippingLineItem = (ShippingLineItem) (statusDetail.value);
       *                // fix sli price adjustment considering maxAllowedLimit
       *            }
       *        }
       *    }
       *  }
       *
       * @return a Status instance with - Status.OK if all manual price adjustments do not exceed the correspondent limits, otherwise Status.ERROR
       */
      verifyPriceAdjustmentLimits(): dw.system.Status;
    }

    /**
     * The Order class represents an order.
     */
    class Order extends dw.order.LineItemCtnr {
      /**
       * constant for when Confirmation Status is Confirmed
       */
      static readonly CONFIRMATION_STATUS_CONFIRMED = 2;
      /**
       * constant for when Confirmation Status is Not Confirmed
       */
      static readonly CONFIRMATION_STATUS_NOTCONFIRMED = 0;
      /**
       * constant for when Export Status is Exported
       */
      static readonly EXPORT_STATUS_EXPORTED = 1;
      /**
       * constant for when Export Status is Failed
       */
      static readonly EXPORT_STATUS_FAILED = 3;
      /**
       * constant for when Export Status is Not Exported
       */
      static readonly EXPORT_STATUS_NOTEXPORTED = 0;
      /**
       * constant for when Export Status is ready to be exported.
       */
      static readonly EXPORT_STATUS_READY = 2;
      /**
       * constant for when Order Status is Cancelled
       */
      static readonly ORDER_STATUS_CANCELLED = 6;
      /**
       * constant for when Order Status is Completed
       */
      static readonly ORDER_STATUS_COMPLETED = 5;
      /**
       * constant for when Order Status is Created
       */
      static readonly ORDER_STATUS_CREATED = 0;
      /**
       * constant for when Order Status is Failed
       */
      static readonly ORDER_STATUS_FAILED = 8;
      /**
       * constant for when Order Status is New
       */
      static readonly ORDER_STATUS_NEW = 3;
      /**
       * constant for when Order Status is Open
       */
      static readonly ORDER_STATUS_OPEN = 4;
      /**
       * constant for when Order Status is Replaced
       */
      static readonly ORDER_STATUS_REPLACED = 7;
      /**
       * constant for when Payment Status is Not Paid
       */
      static readonly PAYMENT_STATUS_NOTPAID = 0;
      /**
       * constant for when Payment Status is Paid
       */
      static readonly PAYMENT_STATUS_PAID = 2;
      /**
       * constant for when Payment Status is Part Paid
       */
      static readonly PAYMENT_STATUS_PARTPAID = 1;
      /**
       * constant for when Shipping Status is Not shipped
       */
      static readonly SHIPPING_STATUS_NOTSHIPPED = 0;
      /**
       * constant for when Shipping Status is Part Shipped
       */
      static readonly SHIPPING_STATUS_PARTSHIPPED = 1;
      /**
       * constant for when Shipping Status is Shipped
       */
      static readonly SHIPPING_STATUS_SHIPPED = 2;

      /**
       * The affiliate partner ID value, or null.
       */
      affiliatePartnerID: string;
      /**
       * The affiliate partner name value, or null.
       */
      affiliatePartnerName: string;
      /**
       * The collection of AppeasementItems associated with this order.
       */
      readonly appeasementItems: dw.util.FilteringCollection<
        dw.order.AppeasementItem
      >;
      /**
       * The collection of Appeasements associated with this order.
       */
      readonly appeasements: dw.util.FilteringCollection<dw.order.Appeasement>;
      /**
       * If this order was cancelled, returns the value of the
       *  cancel code or null.
       */
      cancelCode: dw.value.EnumValue;
      /**
       * If this order was cancelled, returns the text describing why
       *  the order was cancelled or null.
       */
      cancelDescription: string;
      /**
       * The sum of the captured amounts. The captured amounts
       *  are calculated on the fly. Associate a payment capture for an PaymentInstrument with an Invoice
       *  using Invoice.addCaptureTransaction(OrderPaymentInstrument, Money).
       */
      readonly capturedAmount: dw.value.Money;
      /**
       * The confirmation status of the order.
       *  Possible values are CONFIRMATION_STATUS_NOTCONFIRMED and
       *  CONFIRMATION_STATUS_CONFIRMED.
       */
      confirmationStatus: dw.value.EnumValue;
      /**
       * The name of the user who has created the order.
       *  If an agent user has created the order, the agent user's name
       *  is returned. Otherwise "Customer" is returned.
       */
      readonly createdBy: string;
      /**
       * The current order. The current order
       *  represents the most recent order in a chain of orders.
       *  For example, if Order1 was replaced by Order2, Order2 is the current
       *  representation of the order and Order1 is the original representation
       *  of the order. If you replace Order2 with Order3, Order 3 is now the
       *  current order and Order1 is still the original representation of the
       *  order. If this order has not been replaced, this method returns this
       *  order because this order is the current order.
       */
      readonly currentOrder: dw.order.Order;
      /**
       * The order number of the current order. The current order
       *  represents the most recent order in a chain of orders.
       *  For example, if Order1 was replaced by Order2, Order2 is the current
       *  representation of the order and Order1 is the original representation
       *  of the order. If you replace Order2 with Order3, Order 3 is now the
       *  current order and Order1 is still the original representation of the
       *  order. If this order has not been replaced, calling this method returns the
       *  same value as the getOrderNo() method because this order is the
       *  current order.
       */
      readonly currentOrderNo: string;
      /**
       * The ID of the locale that was in effect when the order
       *  was placed. This is the customer's locale.
       */
      readonly customerLocaleID: string;
      /**
       * The customer-specific reference information for the order, or null.
       */
      customerOrderReference: string;
      /**
       * A date after which an order can be exported.
       */
      exportAfter: Date;
      /**
       * The export status of the order.
       *  Possible values are: EXPORT_STATUS_NOTEXPORTED,
       *  EXPORT_STATUS_EXPORTED, EXPORT_STATUS_READY,
       *  and EXPORT_STATUS_FAILED.
       */
      exportStatus: dw.value.EnumValue;
      /**
       * The value of an external order number associated
       *  with this order, or null.
       */
      externalOrderNo: string;
      /**
       * The status of an external order associated
       *  with this order, or null.
       */
      externalOrderStatus: string;
      /**
       * The text describing the external order, or null.
       */
      externalOrderText: string;
      /**
       * The Global Party ID reconciles customer identity across multiple systems. For example, as part of the Service for
       *  Commerce experience, service agents can find information for customers who have never called into the call
       *  center, but have created a profile on the website. Service agents can find guest order data from Commerce Cloud
       *  and easily create accounts for customers. Customer 360 Data Manager matches records from multiple data sources
       *  to determine all the records associated with a specific customer.
       */
      readonly globalPartyID: string;
      /**
       * Returns true, if the order is imported and false
       *  otherwise.
       */
      readonly imported: boolean;
      /**
       * The collection of InvoiceItems associated with this order.
       *
       *  Order post-processing APIs (gillian) are now inactive by default and will throw
       *  an exception if accessed. On sandboxes the APIs can be activated with a feature
       *  switch "Order Post Processing APIs on Sandboxes". On PIGs an activation needs
       *  preliminary approval by Product Management. Please contact support in this case.
       *  Existing customers using these APIs are not affected by this change and can use the
       *  APIs until further notice.
       */
      readonly invoiceItems: dw.util.FilteringCollection<dw.order.InvoiceItem>;
      /**
       * The invoice number for this Order.
       *
       *  When an order is placed (e.g. with OrderMgr.placeOrder(Order)) invoice number will be filled
       *  using a sequence. Before order was placed null will be returned unless it was set with
       *  setInvoiceNo(String).
       */
      invoiceNo: string;
      /**
       * The collection of Invoices associated with this order.
       *
       *  Order post-processing APIs (gillian) are now inactive by default and will throw
       *  an exception if accessed. On sandboxes the APIs can be activated with a feature
       *  switch "Order Post Processing APIs on Sandboxes". On PIGs an activation needs
       *  preliminary approval by Product Management. Please contact support in this case.
       *  Existing customers using these APIs are not affected by this change and can use the
       *  APIs until further notice.
       */
      readonly invoices: dw.util.FilteringCollection<dw.order.Invoice>;
      /**
       * The order number for this order.
       */
      readonly orderNo: string;
      /**
       * The URL safe token for this order. The order token is a random string (length 32 bytes) associated with
       *  this one order. It should always be used in situations requiring order access to raise the level of qualification.
       */
      readonly orderToken: string;
      /**
       * The original order associated with
       *  this order. The original order represents an order that was the
       *  first ancestor in a chain of orders.
       *  For example, if Order1 was replaced by Order2, Order2 is the current
       *  representation of the order and Order1 is the original representation
       *  of the order. If you replace Order2 with Order3, Order1 is still the
       *  original representation of the order. If this order is the first
       *  ancestor, this method returns this order.
       */
      readonly originalOrder: dw.order.Order;
      /**
       * The order number of the original order associated with
       *  this order. The original order represents an order that was the
       *  first ancestor in a chain of orders.
       *  For example, if Order1 was replaced by Order2, Order2 is the current
       *  representation of the order and Order1 is the original representation
       *  of the order. If you replace Order2 with Order3, Order1 is still the
       *  original representation of the order. If this order is the first
       *  ancestor, this method returns the value of getOrderNo().
       */
      readonly originalOrderNo: string;
      /**
       * The order payment status value.
       *  Possible values are PAYMENT_STATUS_NOTPAID, PAYMENT_STATUS_PARTPAID
       *  or PAYMENT_STATUS_PAID.
       */
      paymentStatus: dw.value.EnumValue;
      /**
       * The payment transaction associated with this order.
       *  It is possible that there are multiple payment transactions
       *  associated with the order.  In this case, this method returns
       *  the transaction associated with the first PaymentInstrument
       *  returned by getPaymentInstruments().
       */
      readonly paymentTransaction: dw.order.PaymentTransaction;
      /**
       * The sum of the refunded amounts. The refunded amounts are
       *  calculated on the fly. Associate a payment refund for an PaymentInstrument with an Invoice
       *  using Invoice.addRefundTransaction(OrderPaymentInstrument, Money).
       */
      readonly refundedAmount: dw.value.Money;
      /**
       * The IP address of the remote host from which the order was created.
       *
       *  If the IP address was not captured for the order because order IP logging
       *  was disabled at the time the order was created, null will be returned.
       */
      readonly remoteHost: string;
      /**
       * If this order was replaced by another order,
       *  returns the value of the replace code. Otherwise.
       *  returns null.
       */
      replaceCode: dw.value.EnumValue;
      /**
       * If this order was replaced by another order,
       *  returns the value of the replace description. Otherwise
       *  returns null.
       */
      replaceDescription: string;
      /**
       * The order that this order replaced or null. For example, if you
       *  have three orders where Order1 was replaced by Order2 and Order2 was
       *  replaced by Order3, calling this method on Order3 will return Order2.
       *  Similarly, calling this method on Order1 will return null as Order1 was
       *  the original order.
       */
      readonly replacedOrder: dw.order.Order;
      /**
       * The order number that this order replaced or null if this order
       *  did not replace an order. For example, if you have three orders
       *  where Order1 was replaced by Order2 and Order2 was replaced by Order3,
       *  calling this method on Order3 will return the order number for
       *  Order2. Similarly, calling this method on Order1 will return null as
       *  Order1 was the original order.
       */
      readonly replacedOrderNo: string;
      /**
       * The order that replaced this order, or null.
       */
      readonly replacementOrder: dw.order.Order;
      /**
       * If this order was replaced by another order,
       *  returns the order number that replaced this order. Otherwise
       *  returns null.
       */
      readonly replacementOrderNo: string;
      /**
       * The collection of ReturnCaseItems associated with this order.
       *
       *  Order post-processing APIs (gillian) are now inactive by default and will throw
       *  an exception if accessed. On sandboxes the APIs can be activated with a feature
       *  switch "Order Post Processing APIs on Sandboxes". On PIGs an activation needs
       *  preliminary approval by Product Management. Please contact support in this case.
       *  Existing customers using these APIs are not affected by this change and can use the
       *  APIs until further notice.
       */
      readonly returnCaseItems: dw.util.FilteringCollection<
        dw.order.ReturnCaseItem
      >;
      /**
       * The collection of ReturnCases associated with this order.
       *
       *  Order post-processing APIs (gillian) are now inactive by default and will throw
       *  an exception if accessed. On sandboxes the APIs can be activated with a feature
       *  switch "Order Post Processing APIs on Sandboxes". On PIGs an activation needs
       *  preliminary approval by Product Management. Please contact support in this case.
       *  Existing customers using these APIs are not affected by this change and can use the
       *  APIs until further notice.
       */
      readonly returnCases: dw.util.FilteringCollection<dw.order.ReturnCase>;
      /**
       * The collection of ReturnItems associated with this order.
       *
       *  Order post-processing APIs (gillian) are now inactive by default and will throw
       *  an exception if accessed. On sandboxes the APIs can be activated with a feature
       *  switch "Order Post Processing APIs on Sandboxes". On PIGs an activation needs
       *  preliminary approval by Product Management. Please contact support in this case.
       *  Existing customers using these APIs are not affected by this change and can use the
       *  APIs until further notice.
       */
      readonly returnItems: dw.util.FilteringCollection<dw.order.ReturnItem>;
      /**
       * The collection of Returns associated with this order.
       *
       *  Order post-processing APIs (gillian) are now inactive by default and will throw
       *  an exception if accessed. On sandboxes the APIs can be activated with a feature
       *  switch "Order Post Processing APIs on Sandboxes". On PIGs an activation needs
       *  preliminary approval by Product Management. Please contact support in this case.
       *  Existing customers using these APIs are not affected by this change and can use the
       *  APIs until further notice.
       */
      readonly returns: dw.util.FilteringCollection<dw.order.Return>;
      /**
       * The collection of ShippingOrderItems associated with this order.
       *
       *  Order post-processing APIs (gillian) are now inactive by default and will throw
       *  an exception if accessed. On sandboxes the APIs can be activated with a feature
       *  switch "Order Post Processing APIs on Sandboxes". On PIGs an activation needs
       *  preliminary approval by Product Management. Please contact support in this case.
       *  Existing customers using these APIs are not affected by this change and can use the
       *  APIs until further notice.
       */
      readonly shippingOrderItems: dw.util.FilteringCollection<
        dw.order.ShippingOrderItem
      >;
      /**
       * The collection of ShippingOrders associated with this order.
       *
       *  Order post-processing APIs (gillian) are now inactive by default and will throw
       *  an exception if accessed. On sandboxes the APIs can be activated with a feature
       *  switch "Order Post Processing APIs on Sandboxes". On PIGs an activation needs
       *  preliminary approval by Product Management. Please contact support in this case.
       *  Existing customers using these APIs are not affected by this change and can use the
       *  APIs until further notice.
       */
      readonly shippingOrders: dw.util.FilteringCollection<
        dw.order.ShippingOrder
      >;
      /**
       * The order shipping status.
       *  Possible values are SHIPPING_STATUS_NOTSHIPPED,
       *  SHIPPING_STATUS_PARTSHIPPED or SHIPPING_STATUS_SHIPPED.
       */
      shippingStatus: dw.value.EnumValue;
      /**
       * The source code stored with the order or null if no source code is attached to the order.
       */
      readonly sourceCode: string;
      /**
       * The source code group attached to the order or null if no source code group is attached to
       *  the order.
       */
      readonly sourceCodeGroup: dw.campaign.SourceCodeGroup;
      /**
       * The source code group id stored with the order or null if no source code group is attached
       *  to the order.
       */
      readonly sourceCodeGroupID: string;
      /**
       * The status of the order.
       *  Possible values are:
       *
       *  ORDER_STATUS_CREATED
       *  ORDER_STATUS_NEW
       *  ORDER_STATUS_OPEN
       *  ORDER_STATUS_COMPLETED
       *  ORDER_STATUS_CANCELLED
       *  ORDER_STATUS_FAILED
       *  ORDER_STATUS_REPLACED
       *
       *
       *  The order status usually changes when a process action is initiated. Most status changes have an action which
       *  needs to executed in order to end having the order in a specific order status. When an order is created with e.g.
       *  OrderMgr.createOrder(Basket) the order status will be ORDER_STATUS_CREATED. The usual
       *  flow is that payment authorization will be added to the order. Once the order is considered as valid (payed,
       *  fraud checked, ...) the order gets placed. This can be done by calling
       *  OrderMgr.placeOrder(Order). The result of placing an order will be status
       *  ORDER_STATUS_OPEN (from a process standpoint ORDER_STATUS_NEW which has the same meaning).
       *  Status ORDER_STATUS_REPLACED is related to functionality
       *  BasketMgr.createBasketFromOrder(Order). ORDER_STATUS_COMPLETED has no meaning by
       *  default but can be used by custom implementations but is a synonym for NEW/OPEN. Below you will find the most important status changes:
       *
       *
       *
       *  Status beforeActionStatus afterBusiness meaning
       *  -OrderMgr.createOrder(Basket)CREATEDOrder was created from a basket.
       *  CREATEDOrderMgr.placeOrder(Order)OPEN/NEWOrder was considered as valid. Order can now be exported to 3rd party systems.
       *  CREATEDOrderMgr.failOrder(Order)FAILEDOrder was considered not valid. E.g. payment authorization was wrong or fraud check was not successful.
       *  OPEN/NEWOrderMgr.cancelOrder(Order)CANCELLEDOrder was cancelled.
       *  CANCELLEDOrderMgr.undoCancelOrder(Order)OPEN/NEWOrder was cancelled by mistake and this needs to be undone.
       *  FAILEDOrderMgr.undoFailOrder(Order)CREATEDOrder was failed by mistake and this needs to be undone.
       *
       *  Every status change will trigger a change in the order journal which is the base for GMV calculations.
       */
      status: dw.value.EnumValue;

      /**
       * Creates a new Appeasement associated with this order.
       *
       *  An appeasementNumber must be specified.
       *
       *  If an Appeasement already exists for the appeasementNumber, the method fails with an
       *  exception.
       *
       *  Order post-processing APIs (gillian) are now inactive by default and will throw
       *  an exception if accessed. On sandboxes the APIs can be activated with a feature
       *  switch "Order Post Processing APIs on Sandboxes". On PIGs an activation needs
       *  preliminary approval by Product Management. Please contact support in this case.
       *  Existing customers using these APIs are not affected by this change and can use the
       *  APIs until further notice.
       * @param appeasementNumber the appeasementNumber to be assigned to the newly created appeasement
       * @return the created appeasement
       */
      createAppeasement(appeasementNumber: string): dw.order.Appeasement;
      /**
       * Creates a new Appeasement associated with this order.
       *
       *  The new Appeasement
       *  will have an appeasementNumber based on the getOrderNo().
       *
       *  Order post-processing APIs (gillian) are now inactive by default and will throw
       *  an exception if accessed. On sandboxes the APIs can be activated with a feature
       *  switch "Order Post Processing APIs on Sandboxes". On PIGs an activation needs
       *  preliminary approval by Product Management. Please contact support in this case.
       *  Existing customers using these APIs are not affected by this change and can use the
       *  APIs until further notice.
       *
       * @return the created appeasement
       */
      createAppeasement(): dw.order.Appeasement;
      /**
       * Creates a new ReturnCase associated with this order
       *  specifying whether the ReturnCase is an RMA (return merchandise authorization).
       *
       *  A returnCaseNumber must be specified.
       *
       *  If a ReturnCase already exists for the returnCaseNumber, the method fails with an
       *  exception.
       *
       *  Order post-processing APIs (gillian) are now inactive by default and will throw
       *  an exception if accessed. On sandboxes the APIs can be activated with a feature
       *  switch "Order Post Processing APIs on Sandboxes". On PIGs an activation needs
       *  preliminary approval by Product Management. Please contact support in this case.
       *  Existing customers using these APIs are not affected by this change and can use the
       *  APIs until further notice.
       * @param returnCaseNumber returnCaseNumber to use
       * @param isRMA whether the new ReturnCase is an RMA (return merchandise authorization)
       * @return null or the ReturnCase associated with the given returnCaseNumber
       */
      createReturnCase(
        returnCaseNumber: string,
        isRMA: boolean
      ): dw.order.ReturnCase;
      /**
       * Creates a new ReturnCase associated with this order
       *  specifying whether the ReturnCase is an RMA (return merchandise authorization).
       *
       *  The new ReturnCase
       *  will have a returnCaseNumber based on the getOrderNo(), e.g. for an order-no 1234 the
       *  return cases will have the numbers 1234#RC1, 1234#RC2, 1234#RC3...
       *
       *  Order post-processing APIs (gillian) are now inactive by default and will throw
       *  an exception if accessed. On sandboxes the APIs can be activated with a feature
       *  switch "Order Post Processing APIs on Sandboxes". On PIGs an activation needs
       *  preliminary approval by Product Management. Please contact support in this case.
       *  Existing customers using these APIs are not affected by this change and can use the
       *  APIs until further notice.
       * @param isRMA whether the new ReturnCase is an RMA (return merchandise authorization)
       * @return the created ReturnCase
       */
      createReturnCase(isRMA: boolean): dw.order.ReturnCase;
      /**
       * Returns the  order item with the given status which wraps a new
       *   service item which is created and added to the order.
       * @param ID the ID of the new service item. This ID will be returned when ShippingLineItem.getID() is called.
       * @param status the status of the order item, use one of  OrderItem.STATUS_NEW  OrderItem.STATUS_OPEN  OrderItem.STATUS_SHIPPED   Order post-processing APIs (gillian) are now inactive by default and will throw an exception if accessed. On sandboxes the APIs can be activated with a feature switch "Order Post Processing APIs on Sandboxes". On PIGs an activation needs preliminary approval by Product Management. Please contact support in this case. Existing customers using these APIs are not affected by this change and can use the APIs until further notice.
       * @return the created order item
       */
      createServiceItem(ID: string, status: string): dw.order.OrderItem;
      /**
       * Creates a new ShippingOrder for this order.
       *
       *  Generates a default shipping order number. Use
       *  createShippingOrder(String) for a defined shipping order number.
       *
       *  Order post-processing APIs (gillian) are now inactive by default and will throw
       *  an exception if accessed. On sandboxes the APIs can be activated with a feature
       *  switch "Order Post Processing APIs on Sandboxes". On PIGs an activation needs
       *  preliminary approval by Product Management. Please contact support in this case.
       *  Existing customers using these APIs are not affected by this change and can use the
       *  APIs until further notice.
       *
       * @return the created shipping order
       */
      createShippingOrder(): dw.order.ShippingOrder;
      /**
       * Creates a new ShippingOrder for this order.
       *
       *  Order post-processing APIs (gillian) are now inactive by default and will throw
       *  an exception if accessed. On sandboxes the APIs can be activated with a feature
       *  switch "Order Post Processing APIs on Sandboxes". On PIGs an activation needs
       *  preliminary approval by Product Management. Please contact support in this case.
       *  Existing customers using these APIs are not affected by this change and can use the
       *  APIs until further notice.
       * @param shippingOrderNumber the document number to be used
       * @return the created shipping order
       */
      createShippingOrder(shippingOrderNumber: string): dw.order.ShippingOrder;
      /**
       * Returns the affiliate partner ID value, or null.
       *
       * @return the affiliate partner ID value, or null.
       */
      getAffiliatePartnerID(): string;
      /**
       * Returns the affiliate partner name value, or null.
       *
       * @return the affiliate partner name value, or null.
       */
      getAffiliatePartnerName(): string;
      /**
       * Returns the Appeasement associated with this order with the given appeasementNumber.
       *  The method returns null if no instance can be found.
       * @param appeasementNumber the appeasement number
       * @return the Appeasement associated with the given appeasementNumber
       */
      getAppeasement(appeasementNumber: string): dw.order.Appeasement;
      /**
       * Returns the AppeasementItem associated with this Order with the given appeasementItemID.
       *  The method returns null if no instance can be found.
       * @param appeasementItemID the ID
       * @return the AppeasementItem associated with the given appeasementItemID.
       */
      getAppeasementItem(appeasementItemID: string): dw.order.AppeasementItem;
      /**
       * Returns the collection of AppeasementItems associated with this order.
       *
       * @return the appeasement items belonging to this order
       */
      getAppeasementItems(): dw.util.FilteringCollection<
        dw.order.AppeasementItem
      >;
      /**
       * Returns the collection of Appeasements associated with this order.
       *
       * @return the appeasements associated with this order
       */
      getAppeasements(): dw.util.FilteringCollection<dw.order.Appeasement>;
      /**
       * If this order was cancelled, returns the value of the
       *  cancel code or null.
       *
       * @return the value of the cancel code.
       */
      getCancelCode(): dw.value.EnumValue;
      /**
       * If this order was cancelled, returns the text describing why
       *  the order was cancelled or null.
       *
       * @return the description as to why the order was cancelled or null.
       */
      getCancelDescription(): string;
      /**
       * Returns the sum of the captured amounts. The captured amounts
       *  are calculated on the fly. Associate a payment capture for an PaymentInstrument with an Invoice
       *  using Invoice.addCaptureTransaction(OrderPaymentInstrument, Money).
       *
       * @return sum of captured amounts
       */
      getCapturedAmount(): dw.value.Money;
      /**
       * Returns the confirmation status of the order.
       *  Possible values are CONFIRMATION_STATUS_NOTCONFIRMED and
       *  CONFIRMATION_STATUS_CONFIRMED.
       *
       * @return Order confirmation status
       */
      getConfirmationStatus(): dw.value.EnumValue;
      /**
       * Returns the name of the user who has created the order.
       *  If an agent user has created the order, the agent user's name
       *  is returned. Otherwise "Customer" is returned.
       *
       * @return the name of the user who created the order.
       */
      getCreatedBy(): string;
      /**
       * Returns the current order. The current order
       *  represents the most recent order in a chain of orders.
       *  For example, if Order1 was replaced by Order2, Order2 is the current
       *  representation of the order and Order1 is the original representation
       *  of the order. If you replace Order2 with Order3, Order 3 is now the
       *  current order and Order1 is still the original representation of the
       *  order. If this order has not been replaced, this method returns this
       *  order because this order is the current order.
       *
       * @return the current order.
       */
      getCurrentOrder(): dw.order.Order;
      /**
       * Returns the order number of the current order. The current order
       *  represents the most recent order in a chain of orders.
       *  For example, if Order1 was replaced by Order2, Order2 is the current
       *  representation of the order and Order1 is the original representation
       *  of the order. If you replace Order2 with Order3, Order 3 is now the
       *  current order and Order1 is still the original representation of the
       *  order. If this order has not been replaced, calling this method returns the
       *  same value as the getOrderNo() method because this order is the
       *  current order.
       *
       * @return the order number of the current order
       */
      getCurrentOrderNo(): string;
      /**
       * Returns the ID of the locale that was in effect when the order
       *  was placed. This is the customer's locale.
       *
       * @return the ID of the locale associated with this order, or null.
       */
      getCustomerLocaleID(): string;
      /**
       * Returns the customer-specific reference information for the order, or null.
       *
       * @return the customer-specific reference information for the order, or null.
       */
      getCustomerOrderReference(): string;
      /**
       * Returns a date after which an order can be exported.
       *
       * @return a date after which an order can be exported.
       */
      getExportAfter(): Date;
      /**
       * Returns the export status of the order.
       *  Possible values are: EXPORT_STATUS_NOTEXPORTED,
       *  EXPORT_STATUS_EXPORTED, EXPORT_STATUS_READY,
       *  and EXPORT_STATUS_FAILED.
       *
       * @return Order export status
       */
      getExportStatus(): dw.value.EnumValue;
      /**
       * Returns the value of an external order number associated
       *  with this order, or null.
       *
       * @return the value of an external order number associated with this order, or null.
       */
      getExternalOrderNo(): string;
      /**
       * Returns the status of an external order associated
       *  with this order, or null.
       *
       * @return the status of an external order associated with this order, or null.
       */
      getExternalOrderStatus(): string;
      /**
       * Returns the text describing the external order, or null.
       *
       * @return the text describing the external order, or null.
       */
      getExternalOrderText(): string;
      /**
       * The Global Party ID reconciles customer identity across multiple systems. For example, as part of the Service for
       *  Commerce experience, service agents can find information for customers who have never called into the call
       *  center, but have created a profile on the website. Service agents can find guest order data from Commerce Cloud
       *  and easily create accounts for customers. Customer 360 Data Manager matches records from multiple data sources
       *  to determine all the records associated with a specific customer.
       *
       * @return the Global Party ID associated with this order, or null.
       */
      getGlobalPartyID(): string;
      /**
       * Returns the Invoice associated with this order with the given invoiceNumber.
       *  The method returns null if no instance can be found.
       *
       *  Order post-processing APIs (gillian) are now inactive by default and will throw
       *  an exception if accessed. On sandboxes the APIs can be activated with a feature
       *  switch "Order Post Processing APIs on Sandboxes". On PIGs an activation needs
       *  preliminary approval by Product Management. Please contact support in this case.
       *  Existing customers using these APIs are not affected by this change and can use the
       *  APIs until further notice.
       * @param invoiceNumber the invoice number
       * @return the invoice associated with the given invoiceNumber
       */
      getInvoice(invoiceNumber: string): dw.order.Invoice;
      /**
       * Returns the InvoiceItem associated with this order with the given ID.
       *  The method returns null if no instance can be found.
       *
       *  Order post-processing APIs (gillian) are now inactive by default and will throw
       *  an exception if accessed. On sandboxes the APIs can be activated with a feature
       *  switch "Order Post Processing APIs on Sandboxes". On PIGs an activation needs
       *  preliminary approval by Product Management. Please contact support in this case.
       *  Existing customers using these APIs are not affected by this change and can use the
       *  APIs until further notice.
       * @param invoiceItemID the item ID
       * @return the invoice item associated with the given ID
       */
      getInvoiceItem(invoiceItemID: string): dw.order.InvoiceItem;
      /**
       * Returns the collection of InvoiceItems associated with this order.
       *
       *  Order post-processing APIs (gillian) are now inactive by default and will throw
       *  an exception if accessed. On sandboxes the APIs can be activated with a feature
       *  switch "Order Post Processing APIs on Sandboxes". On PIGs an activation needs
       *  preliminary approval by Product Management. Please contact support in this case.
       *  Existing customers using these APIs are not affected by this change and can use the
       *  APIs until further notice.
       *
       * @return invoice items belonging to this order
       */
      getInvoiceItems(): dw.util.FilteringCollection<dw.order.InvoiceItem>;
      /**
       * Returns the invoice number for this Order.
       *
       *  When an order is placed (e.g. with OrderMgr.placeOrder(Order)) invoice number will be filled
       *  using a sequence. Before order was placed null will be returned unless it was set with
       *  setInvoiceNo(String).
       *
       * @return the invoice number for this Order.
       */
      getInvoiceNo(): string;
      /**
       * Returns the collection of Invoices associated with this order.
       *
       *  Order post-processing APIs (gillian) are now inactive by default and will throw
       *  an exception if accessed. On sandboxes the APIs can be activated with a feature
       *  switch "Order Post Processing APIs on Sandboxes". On PIGs an activation needs
       *  preliminary approval by Product Management. Please contact support in this case.
       *  Existing customers using these APIs are not affected by this change and can use the
       *  APIs until further notice.
       *
       * @return invoices belonging to this order
       */
      getInvoices(): dw.util.FilteringCollection<dw.order.Invoice>;
      /**
       * Returns the order export XML as String object.
       *
       *  NOTE: This method is deprecated and will be removed soon. Use getOrderExportXML(String, String) instead.
       *
       *  Example:
       *       var orderXmlAsString : String = order.getOrderExportXML(null, null, false);
       *      var orderXml : XML = new XML(orderXmlAsString);
       *
       *  This method can be called for placed orders only, otherwise an exception will be thrown.
       *
       *  Also, an exception will be thrown if the method is called in a transaction with changes.
       * @param encryptionMethod the algorithm to be used for the encryption of the payment instruments if order payments re-encryption is needed
       * @param encryptionKey the base64 encoded form of the public key to be used to encrypt the payment instruments if order payments re-encryption is needed
       * @param encryptUsingEKID ignored
       * @return the order export XML
       */
      getOrderExportXML(
        encryptionMethod: string,
        encryptionKey: string,
        encryptUsingEKID: boolean
      ): string;
      /**
       * Returns the order export XML as String object.
       *
       *  Example:
       *       var orderXmlAsString : String = order.getOrderExportXML(null, null);
       *      var orderXml : XML = new XML(orderXmlAsString);
       *
       *  This method can be called for placed orders only, otherwise an exception will be thrown.
       *
       *  Also, an exception will be thrown if the method is called in a transaction with changes.
       * @param encryptionMethod the algorithm to be used for the encryption of the payment instruments if order payments re-encryption is needed
       * @param encryptionKey the base64 encoded form of the public key to be used to encrypt the payment instruments if order payments re-encryption is needed
       * @return the order export XML
       */
      getOrderExportXML(
        encryptionMethod: string,
        encryptionKey: string
      ): string;
      /**
       * Returns the OrderItem for the itemID.
       *  An OrderItem will only exist for ProductLineItems or
       *  ShippingLineItems which belong to the order.
       *  The method fails with an exception if no instance can be found.
       * @param itemID the itemID
       * @return the order item for itemID
       */
      getOrderItem(itemID: string): dw.order.OrderItem;
      /**
       * Returns the order number for this order.
       *
       * @return the order number for this order.
       */
      getOrderNo(): string;
      /**
       * Returns the URL safe token for this order. The order token is a random string (length 32 bytes) associated with
       *  this one order. It should always be used in situations requiring order access to raise the level of qualification.
       *
       * @return the URL safe token for this order.
       */
      getOrderToken(): string;
      /**
       * Returns the original order associated with
       *  this order. The original order represents an order that was the
       *  first ancestor in a chain of orders.
       *  For example, if Order1 was replaced by Order2, Order2 is the current
       *  representation of the order and Order1 is the original representation
       *  of the order. If you replace Order2 with Order3, Order1 is still the
       *  original representation of the order. If this order is the first
       *  ancestor, this method returns this order.
       *
       * @return the order number of the original order associated with this order.
       */
      getOriginalOrder(): dw.order.Order;
      /**
       * Returns the order number of the original order associated with
       *  this order. The original order represents an order that was the
       *  first ancestor in a chain of orders.
       *  For example, if Order1 was replaced by Order2, Order2 is the current
       *  representation of the order and Order1 is the original representation
       *  of the order. If you replace Order2 with Order3, Order1 is still the
       *  original representation of the order. If this order is the first
       *  ancestor, this method returns the value of getOrderNo().
       *
       * @return the order number of the original order associated with this order.
       */
      getOriginalOrderNo(): string;
      /**
       * Returns the order payment status value.
       *  Possible values are PAYMENT_STATUS_NOTPAID, PAYMENT_STATUS_PARTPAID
       *  or PAYMENT_STATUS_PAID.
       *
       * @return Order payment status
       */
      getPaymentStatus(): dw.value.EnumValue;
      /**
       * Returns the payment transaction associated with this order.
       *  It is possible that there are multiple payment transactions
       *  associated with the order.  In this case, this method returns
       *  the transaction associated with the first PaymentInstrument
       *  returned by getPaymentInstruments().
       *
       * @return the payment transaction or null if there is no transaction.
       */
      getPaymentTransaction(): dw.order.PaymentTransaction;
      /**
       * Returns the sum of the refunded amounts. The refunded amounts are
       *  calculated on the fly. Associate a payment refund for an PaymentInstrument with an Invoice
       *  using Invoice.addRefundTransaction(OrderPaymentInstrument, Money).
       *
       * @return sum of refunded amounts
       */
      getRefundedAmount(): dw.value.Money;
      /**
       * Returns the IP address of the remote host from which the order was created.
       *
       *  If the IP address was not captured for the order because order IP logging
       *  was disabled at the time the order was created, null will be returned.
       *
       * @return The IP address of the remote host captured for the order or null
       */
      getRemoteHost(): string;
      /**
       * If this order was replaced by another order,
       *  returns the value of the replace code. Otherwise.
       *  returns null.
       *
       * @return the replace code
       */
      getReplaceCode(): dw.value.EnumValue;
      /**
       * If this order was replaced by another order,
       *  returns the value of the replace description. Otherwise
       *  returns null.
       *
       * @return the value of the replace code or null.
       */
      getReplaceDescription(): string;
      /**
       * Returns the order that this order replaced or null. For example, if you
       *  have three orders where Order1 was replaced by Order2 and Order2 was
       *  replaced by Order3, calling this method on Order3 will return Order2.
       *  Similarly, calling this method on Order1 will return null as Order1 was
       *  the original order.
       *
       * @return the order that replaced this order, or null.
       */
      getReplacedOrder(): dw.order.Order;
      /**
       * Returns the order number that this order replaced or null if this order
       *  did not replace an order. For example, if you have three orders
       *  where Order1 was replaced by Order2 and Order2 was replaced by Order3,
       *  calling this method on Order3 will return the order number for
       *  Order2. Similarly, calling this method on Order1 will return null as
       *  Order1 was the original order.
       *
       * @return the order number of the order that this order replaced or null.
       */
      getReplacedOrderNo(): string;
      /**
       * Returns the order that replaced this order, or null.
       *
       * @return the order that replaced this order, or null.
       */
      getReplacementOrder(): dw.order.Order;
      /**
       * If this order was replaced by another order,
       *  returns the order number that replaced this order. Otherwise
       *  returns null.
       *
       * @return the order that replaced this order, or null.
       */
      getReplacementOrderNo(): string;
      /**
       * Returns the Return associated with this order with the given returnNumber.
       *  The method returns null if no instance can be found.
       *
       *  Order post-processing APIs (gillian) are now inactive by default and will throw
       *  an exception if accessed. On sandboxes the APIs can be activated with a feature
       *  switch "Order Post Processing APIs on Sandboxes". On PIGs an activation needs
       *  preliminary approval by Product Management. Please contact support in this case.
       *  Existing customers using these APIs are not affected by this change and can use the
       *  APIs until further notice.
       * @param returnNumber the return number
       * @return the return associated with the given returnNumber
       */
      getReturn(returnNumber: string): dw.order.Return;
      /**
       * Returns the ReturnCase associated with this order with the given returnCaseNumber.
       *  The method returns null if no instance can be found.
       *
       *  Order post-processing APIs (gillian) are now inactive by default and will throw
       *  an exception if accessed. On sandboxes the APIs can be activated with a feature
       *  switch "Order Post Processing APIs on Sandboxes". On PIGs an activation needs
       *  preliminary approval by Product Management. Please contact support in this case.
       *  Existing customers using these APIs are not affected by this change and can use the
       *  APIs until further notice.
       * @param returnCaseNumber the return case number
       * @return the return case associated with the given returnCaseNumber
       */
      getReturnCase(returnCaseNumber: string): dw.order.ReturnCase;
      /**
       * Returns the ReturnCaseItem associated with this order with the given returnCaseItemID.
       *  The method returns null if no instance can be found.
       *
       *  Order post-processing APIs (gillian) are now inactive by default and will throw
       *  an exception if accessed. On sandboxes the APIs can be activated with a feature
       *  switch "Order Post Processing APIs on Sandboxes". On PIGs an activation needs
       *  preliminary approval by Product Management. Please contact support in this case.
       *  Existing customers using these APIs are not affected by this change and can use the
       *  APIs until further notice.
       * @param returnCaseItemID the ID
       * @return the return case item associated with the given returnCaseItemID
       */
      getReturnCaseItem(returnCaseItemID: string): dw.order.ReturnCaseItem;
      /**
       * Returns the collection of ReturnCaseItems associated with this order.
       *
       *  Order post-processing APIs (gillian) are now inactive by default and will throw
       *  an exception if accessed. On sandboxes the APIs can be activated with a feature
       *  switch "Order Post Processing APIs on Sandboxes". On PIGs an activation needs
       *  preliminary approval by Product Management. Please contact support in this case.
       *  Existing customers using these APIs are not affected by this change and can use the
       *  APIs until further notice.
       *
       * @return return case items belonging to this order
       */
      getReturnCaseItems(): dw.util.FilteringCollection<
        dw.order.ReturnCaseItem
      >;
      /**
       * Returns the collection of ReturnCases associated with this order.
       *
       *  Order post-processing APIs (gillian) are now inactive by default and will throw
       *  an exception if accessed. On sandboxes the APIs can be activated with a feature
       *  switch "Order Post Processing APIs on Sandboxes". On PIGs an activation needs
       *  preliminary approval by Product Management. Please contact support in this case.
       *  Existing customers using these APIs are not affected by this change and can use the
       *  APIs until further notice.
       *
       * @return return cases belonging to this order
       */
      getReturnCases(): dw.util.FilteringCollection<dw.order.ReturnCase>;
      /**
       * Returns the ReturnItem associated with this order with the given ID.
       *  The method returns null if no instance can be found.
       *
       *  Order post-processing APIs (gillian) are now inactive by default and will throw
       *  an exception if accessed. On sandboxes the APIs can be activated with a feature
       *  switch "Order Post Processing APIs on Sandboxes". On PIGs an activation needs
       *  preliminary approval by Product Management. Please contact support in this case.
       *  Existing customers using these APIs are not affected by this change and can use the
       *  APIs until further notice.
       * @param returnItemID the ID
       * @return the return item associated with the given returnItemID
       */
      getReturnItem(returnItemID: string): dw.order.ReturnItem;
      /**
       * Returns the collection of ReturnItems associated with this order.
       *
       *  Order post-processing APIs (gillian) are now inactive by default and will throw
       *  an exception if accessed. On sandboxes the APIs can be activated with a feature
       *  switch "Order Post Processing APIs on Sandboxes". On PIGs an activation needs
       *  preliminary approval by Product Management. Please contact support in this case.
       *  Existing customers using these APIs are not affected by this change and can use the
       *  APIs until further notice.
       *
       * @return return items belonging to this order
       */
      getReturnItems(): dw.util.FilteringCollection<dw.order.ReturnItem>;
      /**
       * Returns the collection of Returns associated with this order.
       *
       *  Order post-processing APIs (gillian) are now inactive by default and will throw
       *  an exception if accessed. On sandboxes the APIs can be activated with a feature
       *  switch "Order Post Processing APIs on Sandboxes". On PIGs an activation needs
       *  preliminary approval by Product Management. Please contact support in this case.
       *  Existing customers using these APIs are not affected by this change and can use the
       *  APIs until further notice.
       *
       * @return returns belonging to this order
       */
      getReturns(): dw.util.FilteringCollection<dw.order.Return>;
      /**
       * Returns the ShippingOrder associated with this order with the given shippingOrderNumber.
       *  The method returns null if no instance can be found.
       *
       *  Order post-processing APIs (gillian) are now inactive by default and will throw
       *  an exception if accessed. On sandboxes the APIs can be activated with a feature
       *  switch "Order Post Processing APIs on Sandboxes". On PIGs an activation needs
       *  preliminary approval by Product Management. Please contact support in this case.
       *  Existing customers using these APIs are not affected by this change and can use the
       *  APIs until further notice.
       * @param shippingOrderNumber the shipping order number
       * @return the shipping order associated with the given shippingOrderNumber
       */
      getShippingOrder(shippingOrderNumber: string): dw.order.ShippingOrder;
      /**
       * Returns the ShippingOrderItem associated with this order with the given shippingOrderItemID.
       *  The method returns null if no instance can be found.
       *
       *  Order post-processing APIs (gillian) are now inactive by default and will throw
       *  an exception if accessed. On sandboxes the APIs can be activated with a feature
       *  switch "Order Post Processing APIs on Sandboxes". On PIGs an activation needs
       *  preliminary approval by Product Management. Please contact support in this case.
       *  Existing customers using these APIs are not affected by this change and can use the
       *  APIs until further notice.
       * @param shippingOrderItemID the ID
       * @return the shipping order item associated with the given shippingOrderItemID
       */
      getShippingOrderItem(
        shippingOrderItemID: string
      ): dw.order.ShippingOrderItem;
      /**
       * Returns the collection of ShippingOrderItems associated with this order.
       *
       *  Order post-processing APIs (gillian) are now inactive by default and will throw
       *  an exception if accessed. On sandboxes the APIs can be activated with a feature
       *  switch "Order Post Processing APIs on Sandboxes". On PIGs an activation needs
       *  preliminary approval by Product Management. Please contact support in this case.
       *  Existing customers using these APIs are not affected by this change and can use the
       *  APIs until further notice.
       *
       * @return shipping order items belonging to this order
       */
      getShippingOrderItems(): dw.util.FilteringCollection<
        dw.order.ShippingOrderItem
      >;
      /**
       * Returns the collection of ShippingOrders associated with this order.
       *
       *  Order post-processing APIs (gillian) are now inactive by default and will throw
       *  an exception if accessed. On sandboxes the APIs can be activated with a feature
       *  switch "Order Post Processing APIs on Sandboxes". On PIGs an activation needs
       *  preliminary approval by Product Management. Please contact support in this case.
       *  Existing customers using these APIs are not affected by this change and can use the
       *  APIs until further notice.
       *
       * @return shipping orders belonging to this order
       */
      getShippingOrders(): dw.util.FilteringCollection<dw.order.ShippingOrder>;
      /**
       * Returns the order shipping status.
       *  Possible values are SHIPPING_STATUS_NOTSHIPPED,
       *  SHIPPING_STATUS_PARTSHIPPED or SHIPPING_STATUS_SHIPPED.
       *
       * @return Order shipping status
       */
      getShippingStatus(): dw.value.EnumValue;
      /**
       * Returns the source code stored with the order or null if no source code is attached to the order.
       *
       * @return the source code stored with the order or null if no source code is attached to the order.
       */
      getSourceCode(): string;
      /**
       * Returns the source code group attached to the order or null if no source code group is attached to
       *  the order.
       *
       * @return the source code group attached to the order or null if no source code group is attached to the order.
       */
      getSourceCodeGroup(): dw.campaign.SourceCodeGroup;
      /**
       * Returns the source code group id stored with the order or null if no source code group is attached
       *  to the order.
       *
       * @return the source code group id stored with the order or null if no source code group is attached to the order.
       */
      getSourceCodeGroupID(): string;
      /**
       * Returns the status of the order.
       *  Possible values are:
       *
       *  ORDER_STATUS_CREATED
       *  ORDER_STATUS_NEW
       *  ORDER_STATUS_OPEN
       *  ORDER_STATUS_COMPLETED
       *  ORDER_STATUS_CANCELLED
       *  ORDER_STATUS_FAILED
       *  ORDER_STATUS_REPLACED
       *
       *
       *  The order status usually changes when a process action is initiated. Most status changes have an action which
       *  needs to executed in order to end having the order in a specific order status. When an order is created with e.g.
       *  OrderMgr.createOrder(Basket) the order status will be ORDER_STATUS_CREATED. The usual
       *  flow is that payment authorization will be added to the order. Once the order is considered as valid (payed,
       *  fraud checked, ...) the order gets placed. This can be done by calling
       *  OrderMgr.placeOrder(Order). The result of placing an order will be status
       *  ORDER_STATUS_OPEN (from a process standpoint ORDER_STATUS_NEW which has the same meaning).
       *  Status ORDER_STATUS_REPLACED is related to functionality
       *  BasketMgr.createBasketFromOrder(Order). ORDER_STATUS_COMPLETED has no meaning by
       *  default but can be used by custom implementations but is a synonym for NEW/OPEN. Below you will find the most important status changes:
       *
       *
       *
       *  Status beforeActionStatus afterBusiness meaning
       *  -OrderMgr.createOrder(Basket)CREATEDOrder was created from a basket.
       *  CREATEDOrderMgr.placeOrder(Order)OPEN/NEWOrder was considered as valid. Order can now be exported to 3rd party systems.
       *  CREATEDOrderMgr.failOrder(Order)FAILEDOrder was considered not valid. E.g. payment authorization was wrong or fraud check was not successful.
       *  OPEN/NEWOrderMgr.cancelOrder(Order)CANCELLEDOrder was cancelled.
       *  CANCELLEDOrderMgr.undoCancelOrder(Order)OPEN/NEWOrder was cancelled by mistake and this needs to be undone.
       *  FAILEDOrderMgr.undoFailOrder(Order)CREATEDOrder was failed by mistake and this needs to be undone.
       *
       *  Every status change will trigger a change in the order journal which is the base for GMV calculations.
       *
       * @return Status of the order.
       */
      getStatus(): dw.value.EnumValue;
      /**
       * Returns true, if the order is imported and false
       *  otherwise.
       *
       * @return true, if the order was imported, false otherwise.
       */
      isImported(): boolean;
      /**
       * Ensures that the order is authorized.
       *
       *  Checks if the order is authorized by calling the hook
       *  PaymentHooks.validateAuthorization(Order). If the authorization
       *  is not valid it reauthorizes the order by calling the
       *  PaymentHooks.reauthorize(Order).
       *
       * @return the status of the operation, will be Status.OK if the order is authorized after this call
       */
      reauthorize(): dw.system.Status;
      /**
       * Removes the IP address of the remote host if stored.
       *
       *  If IP logging was enabled during order creation the IP address of the customer will be stored and can be
       *  retrieved using getRemoteHost().
       *
       */
      removeRemoteHost(): void;
      /**
       * Sets the affiliate partner ID value.
       * @param affiliatePartnerID the affiliate partner ID value.
       */
      setAffiliatePartnerID(affiliatePartnerID: string): void;
      /**
       * Sets the affiliate partner name value.
       * @param affiliatePartnerName the affiliate partner name value.
       */
      setAffiliatePartnerName(affiliatePartnerName: string): void;
      /**
       * Sets the cancel code value.
       * @param cancelCode the cancel code value.
       */
      setCancelCode(cancelCode: string): void;
      /**
       * Sets the description as to why the order was cancelled.
       * @param cancelDescription the description for why the order was cancelled.
       */
      setCancelDescription(cancelDescription: string): void;
      /**
       * Sets the confirmation status value.
       *  Possible values are CONFIRMATION_STATUS_NOTCONFIRMED or
       *  CONFIRMATION_STATUS_CONFIRMED.
       * @param status Order confirmation status
       */
      setConfirmationStatus(status: number): void;
      /**
       * This method is used to associate the order object with the specified customer object.
       *
       *  If the customer object represents a registered customer, the order will be assigned
       *  to this registered customer and the order's customer number
       *  (LineItemCtnr.getCustomerNo()) will be updated.
       *
       *  If the customer object represents an unregistered (anonymous) customer, the
       *  order will become an anonymous order and the order's customer number
       *  will be set to null.
       * @param customer The customer to be associated with the order.
       */
      setCustomer(customer: dw.customer.Customer): void;
      /**
       * Sets the customer number of the customer associated with this container.
       * @param customerNo the customer number of the customer associated with this container.
       */
      setCustomerNo(customerNo: string): void;
      /**
       * Sets the customer-specific reference information for the order.
       * @param reference the customer-specific reference information for the order.
       */
      setCustomerOrderReference(reference: string): void;
      /**
       * Sets the date after which an order can be exported.
       * @param date the date after which an order can be exported.
       */
      setExportAfter(date: Date): void;
      /**
       * Sets the export status of the order.
       *  Possible values are: EXPORT_STATUS_NOTEXPORTED, EXPORT_STATUS_EXPORTED,
       *  EXPORT_STATUS_READY, and EXPORT_STATUS_FAILED.
       *
       *  Setting the status to EXPORT_STATUS_EXPORTED will also trigger the finalization of on order inventory
       *  transactions for this order meaning that all inventory transactions with type on order will be moved into final
       *  inventory transactions. This is only relevant when On Order Inventory is turned on for the inventory list ordered
       *  products are in.
       *
       *
       *  In case of an exception the current transaction is marked as rollback only.
       * @param status Order export status
       */
      setExportStatus(status: number): void;
      /**
       * Sets the value of an external order number associated
       *  with this order
       * @param externalOrderNo the value of an external order number associated with this order.
       */
      setExternalOrderNo(externalOrderNo: string): void;
      /**
       * Sets the status of an external order associated
       *  with this order
       * @param status the status of the external order.
       */
      setExternalOrderStatus(status: string): void;
      /**
       * Sets the text describing the external order.
       * @param text the text describing the external order.
       */
      setExternalOrderText(text: string): void;
      /**
       * Sets the invoice number for this Order.
       *
       *  Notice that this value might be overwritten during order placement (e.g. with OrderMgr.placeOrder(Order)).
       * @param invoiceNumber the invoice number for this Order.
       */
      setInvoiceNo(invoiceNumber: string): void;
      /**
       * Sets the order status.
       *
       *  Use this method when using Order Post Processing such as the creation of  shipping
       *  orders. The only supported values are ORDER_STATUS_OPEN, ORDER_STATUS_CANCELLED. Setting the
       *  status will adjust the order item status when applicable (item status not SHIPPED or CANCELLED). Note that the
       *  order status and the status of the items are directly related and dependent on one another.
       *
       *  See OrderItem.setStatus(String) for more information about possible status transitions.
       *
       *  Warning: This method will not undo coupon redemptions upon cancellation of an order. Re-opening such an
       *  order later with OrderMgr.undoCancelOrder(Order) or OrderItem.setStatus(String)
       *  with ORDER_STATUS_OPEN will result in an additional application of the same coupon code which in turn
       *  might fail.
       *
       *  Order post-processing APIs (gillian) are now inactive by default and will throw
       *  an exception if accessed. On sandboxes the APIs can be activated with a feature
       *  switch "Order Post Processing APIs on Sandboxes". On PIGs an activation needs
       *  preliminary approval by Product Management. Please contact support in this case.
       *  Existing customers using these APIs are not affected by this change and can use the
       *  APIs until further notice.
       * @param status the status to be set, use one of:  ORDER_STATUS_OPEN  ORDER_STATUS_CANCELLED
       */
      setOrderStatus(status: number): void;
      /**
       * Sets the order payment status.
       *  Possible values are PAYMENT_STATUS_NOTPAID, PAYMENT_STATUS_PARTPAID
       *  or PAYMENT_STATUS_PAID.
       * @param status Order payment status
       */
      setPaymentStatus(status: number): void;
      /**
       * Sets the value of the replace code.
       * @param replaceCode the value of the replace code.
       */
      setReplaceCode(replaceCode: string): void;
      /**
       * Sets the value of the replace description.
       * @param replaceDescription the value of the replace description.
       */
      setReplaceDescription(replaceDescription: string): void;
      /**
       * Sets the order shipping status value.
       *  Possible values are SHIPPING_STATUS_NOTSHIPPED,
       *  SHIPPING_STATUS_PARTSHIPPED or SHIPPING_STATUS_SHIPPED.
       * @param status Order shipping status
       */
      setShippingStatus(status: number): void;
      /**
       * Sets the status of the order.
       *
       *  Possible values are:
       *
       *  ORDER_STATUS_NEW
       *  ORDER_STATUS_OPEN
       *  ORDER_STATUS_COMPLETED
       *  ORDER_STATUS_CANCELLED
       *  ORDER_STATUS_REPLACED
       *
       *  This method does not support order statuses ORDER_STATUS_CREATED or ORDER_STATUS_FAILED. Please
       *  use OrderMgr.placeOrder(Order) or OrderMgr.failOrder(Order).
       *
       *  Setting the order status to ORDER_STATUS_CANCELLED will have the same effect as calling
       *  OrderMgr.cancelOrder(Order). Setting a canceled order to ORDER_STATUS_NEW,
       *  ORDER_STATUS_OPEN or ORDER_STATUS_COMPLETED will have the same effect as calling
       *  OrderMgr.undoCancelOrder(Order). It is recommended to use the methods in
       *  OrderMgr directly to be able to do error processing with the return code.
       * @param status Order status
       */
      setStatus(status: number): void;
      /**
       * Tracks an order change.
       *
       *  This adds a history entry to the order. Focus of history entries are changes through business logic, both custom
       *  and internal logic. Tracked order changes are read-only and can be accessed in the Business Manager order
       *  history. The following attributes of the created  history entry are initialized:
       *  Note.getCreatedBy() gets the current user assigned
       *  Note.getCreationDate() gets the current date assigned
       *
       *
       *  This feature is intended to track important changes in custom order flow which should become visible in Business
       *  Manager's history tab. It is NOT intended as auditing feature for every change to an order. A warning will be
       *  produced after 600 notes are added to an order. The warning can be reviewed in Business Manager's Quota Status
       *  screen. Attempting to add a note to an order which already has 1000 notes results in an exception. Please bear in
       *  mind that internal changes, such as order status changes, also track changes. Avoid using this feature in
       *  recurring jobs which may re-process orders multiple times as the limit needs to be considered each time a change
       *  is tracked. The same limit on the number of notes added also applies when using method
       *  LineItemCtnr.addNote(String, String) to add notes.
       * @param text the text of the history entry
       * @return the created history entry
       */
      trackOrderChange(text: string): dw.object.Note;
    }

    /**
     * The Address class represents a customer&apos;s address.
     *  <p>
     *  <b>Note:</b> this class allows access to sensitive personal and private information.
     *  Pay attention to appropriate legal and regulatory requirements.</p>
     */
    class OrderAddress extends dw.object.ExtensibleObject {
      /**
       * The customer's first address.
       */
      address1: string;
      /**
       * The customer's second address.
       */
      address2: string;
      /**
       * The Customer's City.
       */
      city: string;
      /**
       * The Customer's company name.
       */
      companyName: string;
      /**
       * The customer's country code.
       */
      countryCode: dw.value.EnumValue;
      /**
       * The Customer's first name.
       */
      firstName: string;
      /**
       * A concatenation of the Customer's first, middle,
       *  and last names and it' suffix.
       */
      readonly fullName: string;
      /**
       * The customer's job title.
       */
      jobTitle: string;
      /**
       * The customer's last name.
       */
      lastName: string;
      /**
       * The customer's phone number.
       */
      phone: string;
      /**
       * The customer's postal code.
       */
      postalCode: string;
      /**
       * The customer's post box.
       */
      postBox: string;
      /**
       * The customer's salutation.
       */
      salutation: string;
      /**
       * The customer's second name.
       */
      secondName: string;
      /**
       * The customer's state.
       */
      stateCode: string;
      /**
       * The customer's suffix.
       */
      suffix: string;
      /**
       * The customer's suite.
       */
      suite: string;
      /**
       * The customer's title.
       */
      title: string;

      /**
       * Returns the customer's first address.
       *
       * @return the first address value.
       */
      getAddress1(): string;
      /**
       * Returns the customer's second address.
       *
       * @return the second address value.
       */
      getAddress2(): string;
      /**
       * Returns the Customer's City.
       *
       * @return the Customer's city.
       */
      getCity(): string;
      /**
       * Returns the Customer's company name.
       *
       * @return the company name.
       */
      getCompanyName(): string;
      /**
       * Returns the customer's country code.
       *
       * @return the country code.
       */
      getCountryCode(): dw.value.EnumValue;
      /**
       * Returns the Customer's first name.
       *
       * @return the Customer first name.
       */
      getFirstName(): string;
      /**
       * Returns a concatenation of the Customer's first, middle,
       *  and last names and it' suffix.
       *
       * @return a concatenation of the Customer's first, middle, and last names and it' suffix.
       */
      getFullName(): string;
      /**
       * Returns the customer's job title.
       *
       * @return the job title.
       */
      getJobTitle(): string;
      /**
       * Returns the customer's last name.
       *
       * @return the last name.
       */
      getLastName(): string;
      /**
       * Returns the customer's phone number.
       *
       * @return the phone number.
       */
      getPhone(): string;
      /**
       * Returns the customer's postal code.
       *
       * @return the postal code.
       */
      getPostalCode(): string;
      /**
       * Returns the customer's post box.
       *
       * @return the postBox.
       */
      getPostBox(): string;
      /**
       * Returns the customer's salutation.
       *
       * @return the customer's salutation.
       */
      getSalutation(): string;
      /**
       * Returns the customer's second name.
       *
       * @return the second name.
       */
      getSecondName(): string;
      /**
       * Returns the customer's state.
       *
       * @return the state.
       */
      getStateCode(): string;
      /**
       * Returns the customer's suffix.
       *
       * @return the suffix.
       */
      getSuffix(): string;
      /**
       * Returns the customer's suite.
       *
       * @return the customer's suite.
       */
      getSuite(): string;
      /**
       * Returns the customer's title.
       *
       * @return the title.
       */
      getTitle(): string;
      /**
       * Returns true if the specified address is equivalent to
       *  this address. An equivalent address is an address whose
       *  core attributes contain the same values. The core attributes
       *  are:
       *
       *  address1
       *  address2
       *  city
       *  companyName
       *  countryCode
       *  firstName
       *  lastName
       *  postalCode
       *  postBox
       *  stateCode
       * @param address the address to test.
       * @return true if the specified address is equivalent to this address, false otherwise.
       */
      isEquivalentAddress(address: any): boolean;
      /**
       * Sets the customer's first address.
       * @param value The value to set.
       */
      setAddress1(value: string): void;
      /**
       * Sets the customer's second address.
       * @param value The value to set.
       */
      setAddress2(value: string): void;
      /**
       * Sets the Customer's City.
       * @param city the Customer's city to set.
       */
      setCity(city: string): void;
      /**
       * Sets the Customer's company name.
       * @param companyName the name of the company.
       */
      setCompanyName(companyName: string): void;
      /**
       * Sets the Customer's country code.
       * @param countryCode the country code.
       */
      setCountryCode(countryCode: string): void;
      /**
       * Sets the Customer's first name.
       * @param firstName the customer's first name to set.
       */
      setFirstName(firstName: string): void;
      /**
       * Sets the customer's job title.
       * @param jobTitle The job title to set.
       */
      setJobTitle(jobTitle: string): void;
      /**
       * Sets the customer's last name.
       * @param lastName The last name to set.
       */
      setLastName(lastName: string): void;
      /**
       * Sets the customer's phone number. The length is restricted to 256 characters.
       * @param phoneNumber The phone number to set.
       */
      setPhone(phoneNumber: string): void;
      /**
       * Sets the customer's postal code.
       * @param postalCode The postal code to set.
       */
      setPostalCode(postalCode: string): void;
      /**
       * Sets the customer's post box.
       * @param postBox The post box to set.
       */
      setPostBox(postBox: string): void;
      /**
       * Sets the customer's salutation.
       * @param value the customer's salutation.
       */
      setSaluation(value: string): void;
      /**
       * Sets the customer's salutation.
       * @param value the customer's salutation.
       */
      setSalutation(value: string): void;
      /**
       * Sets the customer's second name.
       * @param secondName The second name to set.
       */
      setSecondName(secondName: string): void;
      /**
       * Sets the customer's state.
       * @param state The state to set.
       */
      setStateCode(state: string): void;
      /**
       * Sets the customer's suffix.
       * @param suffix The suffix to set.
       */
      setSuffix(suffix: string): void;
      /**
       * Sets the customer's suite. The length is restricted to 256 characters.
       * @param value the customer's suite.
       */
      setSuite(value: string): void;
      /**
       * Sets the customer's title.
       * @param title The title to set.
       */
      setTitle(title: string): void;
    }

    /**
     * Defines <i>extensions</i> to <a href="class_dw_order_ProductLineItem.html">ProductLineItem</a>s and
     *  <a href="class_dw_order_ShippingLineItem.html">ShippingLineItem</a>s belonging to an <a href="class_dw_order_Order.html"> order</a>.
     *
     *  <p>
     *  The order-item can be accessed using
     *  <a href="class_dw_order_ProductLineItem.html#dw_order_ProductLineItem_getOrderItem_DetailAnchor">ProductLineItem.getOrderItem()</a> or
     *  <a href="class_dw_order_ShippingLineItem.html#dw_order_ShippingLineItem_getOrderItem_DetailAnchor">ShippingLineItem.getOrderItem()</a> - these methods return null
     *  if the item is associated with a <a href="class_dw_order_Basket.html"> basket</a> rather than
     *  an <a href="class_dw_order_Order.html"> order</a>. Alternative access is available using
     *  <a href="class_dw_order_Order.html#dw_order_Order_getOrderItem_String_DetailAnchor">Order.getOrderItem(String)</a> by passing the
     *  <a href="class_dw_order_OrderItem.html#dw_order_OrderItem_getItemID_DetailAnchor"> itemID</a> used to identify the
     *  order-item in for example export files. The
     *  associated order-item can also be accessed from
     *  <a href="class_dw_order_InvoiceItem.html"> invoice-items</a>,
     *  <a href="class_dw_order_ShippingOrderItem.html"> shipping-order-items</a>,
     *  <a href="class_dw_order_ReturnItem.html"> return-items</a> and <a href="class_dw_order_ReturnCaseItem.html"> return-case-items</a> using <a href="class_dw_order_AbstractItem.html#dw_order_AbstractItem_getOrderItem_DetailAnchor">AbstractItem.getOrderItem()</a>.
     *
     *  </p><p>
     *  The order-item provides an item-level <a href="class_dw_order_OrderItem.html#dw_order_OrderItem_getStatus_DetailAnchor"> status</a> and
     *  <a href="class_dw_order_OrderItem.html#dw_order_OrderItem_getType_DetailAnchor"> type</a>, methods for accessing and creating associated items,
     *  and methods used to <a href="class_dw_order_OrderItem.html#dw_order_OrderItem_allocateInventory_Boolean_DetailAnchor"> allocate
     *  inventory</a> for <a href="class_dw_order_ShippingOrder.html"> shipping-order</a> creation.
     *  </p><p>
     *  Order post-processing APIs (gillian) are now inactive by default and will throw
     *  an exception if accessed. On sandboxes the APIs can be activated with a feature
     *  switch &quot;Order Post Processing APIs on Sandboxes&quot;. On PIGs an activation needs
     *  preliminary approval by Product Management. Please contact support in this case.
     *  Existing customers using these APIs are not affected by this change and can use the
     *  APIs until further notice.</p>
     */
    class OrderItem {
      /**
       * Constant for Order Item Status BACKORDER
       */
      static readonly STATUS_BACKORDER = "BACKORDER";
      /**
       * Constant for Order Item Status CANCELLED
       */
      static readonly STATUS_CANCELLED = "CANCELLED";
      /**
       * Constant for Order Item Status CONFIRMED
       */
      static readonly STATUS_CONFIRMED = "CONFIRMED";
      /**
       * Constant for Order Item Status CREATED
       */
      static readonly STATUS_CREATED = "CREATED";
      /**
       * Constant for Order Item Status NEW
       */
      static readonly STATUS_NEW = "NEW";
      /**
       * Constant for Order Item Status OPEN
       */
      static readonly STATUS_OPEN = "OPEN";
      /**
       * Constant for Order Item Status SHIPPED
       */
      static readonly STATUS_SHIPPED = "SHIPPED";
      /**
       * Constant for Order Item Status WAREHOUSE
       */
      static readonly STATUS_WAREHOUSE = "WAREHOUSE";
      /**
       * Constant for Order Item Type PRODUCT
       */
      static readonly TYPE_PRODUCT = "PRODUCT";
      /**
       * Constant for Order Item Type SERVICE
       */
      static readonly TYPE_SERVICE = "SERVICE";

      /**
       * Sum of amounts appeased for this item, calculated by iterating over
       *  invoice items associated with the item.
       */
      readonly appeasedAmount: dw.value.Money;
      /**
       * Sum of amounts captured for this item, calculated by iterating over
       *  invoice items associated with the item.
       */
      readonly capturedAmount: dw.value.Money;
      /**
       * All invoice items associated with this item, each
       *  InvoiceItem will belong to a different
       *  Invoice, which can also be accessed using
       *  Order.getInvoices() or Order.getInvoice(String).
       */
      readonly invoiceItems: dw.util.Collection<dw.order.InvoiceItem>;
      /**
       * The itemID used to identify the OrderItem. Note this is
       *  not a UUID, it is created internally when the OrderItem
       *  instance is created, and is typically used within export files to
       *  identify the item.
       */
      readonly itemID: string;
      /**
       * The line item which is being extended by this instance.
       */
      readonly lineItem: dw.order.LineItem;
      /**
       * Sum of amounts refunded for this item, calculated by iterating over
       *  invoice items associated with the item.
       */
      readonly refundedAmount: dw.value.Money;
      /**
       * All return case items associated with this item,
       *  each ReturnCaseItem will belong to a different
       *  ReturnCase, which can also be accessed using
       *  Order.getReturnCases() or Order.getReturnCase(String).
       */
      readonly returnCaseItems: dw.util.Collection<dw.order.ReturnCaseItem>;
      /**
       * The quantity returned, dynamically sum of quantities held by associated
       *  ReturnItems.
       */
      readonly returnedQuantity: dw.value.Quantity;
      /**
       * The last added non-cancelled shipping order item if one exists, otherwise null.
       *
       *  Multiple shipping order items that are not in status ShippingOrderItem.STATUS_CANCELLED
       *  can exist for one OrderItem, for example if the OrderItem has been split for shipping purposes.
       *  The method returns null if no non-cancelled shipping order item exists.
       */
      readonly shippingOrderItem: dw.order.ShippingOrderItem;
      /**
       * A collection of the ShippingOrderItems created for this item.
       *  ShippingOrder items represents the whole or part of this item which could
       *  be delivered, and belong to a shipping order.
       *  Note that the cancelled shipping order items are returned too.
       *  This method is equivalent to getShippingOrderItems(Boolean)
       *  called with parameter true.
       */
      readonly shippingOrderItems: dw.util.Collection<
        dw.order.ShippingOrderItem
      >;
      /**
       * A collection of all split OrderItems associated with this item. Inverse relation to getSplitSourceItem().
       *
       *  Split order items are created when
       *
       *  creating a ShippingOrderItem for a ShippingOrder, see ShippingOrder.createShippingOrderItem(OrderItem, Quantity)
       *  splitting an existing ShippingOrderItem, see ShippingOrderItem.split(Quantity)
       *
       *  with a specified quantity less than the existing quantity of the associated ProductLineItem. In this case the associated ProductLineItem
       *  is split by creating a new ProductLineItem and associating a new ShippingOrderItem with this item. The new ShippingOrderItem
       *  receives the specified quantity and the quantity of the item is set to the remaining quantity. All split items are associated to their originating item via
       *  the "split source item" association.
       */
      readonly splitItems: dw.util.Collection<dw.order.OrderItem>;
      /**
       * The split source item associated with this item, if existing. Inverse relation to getSplitItems().
       *
       *  A split source item is associated after the successful creation of a split item with a quantity less than the existing quantity of the item to split.
       *  For details see getSplitItems().
       */
      readonly splitSourceItem: dw.order.OrderItem;
      /**
       * Gets the order item status.
       *  The possible values are:
       *
       *  STATUS_NEW
       *  STATUS_OPEN
       *  STATUS_BACKORDER
       *  STATUS_CONFIRMED
       *  STATUS_WAREHOUSE
       *  STATUS_SHIPPED
       *  STATUS_CANCELLED
       */
      status: dw.value.EnumValue;
      /**
       * The type of line item with which this instance is associated, one
       *  of
       *
       *  SERVICE (method getLineItem() returns a
       *  ShippingLineItem
       *  PRODUCT (method getLineItem() returns a
       *  ProductLineItem
       */
      readonly type: dw.value.EnumValue;

      /**
       * Please note that this method is disabled by default. Please contact support for enabling it.
       *
       *  Attempts to allocate inventory for the item and returns the quantity that could be allocated or null
       *  if no allocation was possible.
       *
       *  All  option product line items are allocated with
       *  their parent. Note that for items with option product line items no partial allocation is possible. That means
       *  the partialAllocation parameter will in this case always be considered as false
       * @param partialAllocation true accept a partial allocation as a result. Partial allocation is only possible when no option product line items are included, false only full allocation will be used, partial allocation will be released automatically
       * @return successful: the newly allocated quantity failed: null
       */
      allocateInventory(partialAllocation: boolean): dw.value.Quantity;
      /**
       * Sum of amounts appeased for this item, calculated by iterating over
       *  invoice items associated with the item.
       *
       * @return Sum of amounts refunded for this item
       */
      getAppeasedAmount(): dw.value.Money;
      /**
       * Sum of amounts captured for this item, calculated by iterating over
       *  invoice items associated with the item.
       *
       * @return Sum of amounts captured for this item
       */
      getCapturedAmount(): dw.value.Money;
      /**
       * Returns all invoice items associated with this item, each
       *  InvoiceItem will belong to a different
       *  Invoice, which can also be accessed using
       *  Order.getInvoices() or Order.getInvoice(String).
       *
       * @return invoice items associated with this item
       */
      getInvoiceItems(): dw.util.Collection<dw.order.InvoiceItem>;
      /**
       * The itemID used to identify the OrderItem. Note this is
       *  not a UUID, it is created internally when the OrderItem
       *  instance is created, and is typically used within export files to
       *  identify the item.
       *
       * @return the itemID of the OrderItem
       */
      getItemID(): string;
      /**
       * Returns the line item which is being extended by this instance.
       *
       * @return the line item associated with this instance
       */
      getLineItem(): dw.order.LineItem;
      /**
       * Sum of amounts refunded for this item, calculated by iterating over
       *  invoice items associated with the item.
       *
       * @return Sum of amounts refunded for this item
       */
      getRefundedAmount(): dw.value.Money;
      /**
       * Returns all return case items associated with this item,
       *  each ReturnCaseItem will belong to a different
       *  ReturnCase, which can also be accessed using
       *  Order.getReturnCases() or Order.getReturnCase(String).
       *
       * @return return case items associated with this item
       */
      getReturnCaseItems(): dw.util.Collection<dw.order.ReturnCaseItem>;
      /**
       * The quantity returned, dynamically sum of quantities held by associated
       *  ReturnItems.
       *
       * @return quantity returned, the sum of quantities held by associated ReturnItems
       */
      getReturnedQuantity(): dw.value.Quantity;
      /**
       * The last added non-cancelled shipping order item if one exists, otherwise null.
       *
       *  Multiple shipping order items that are not in status ShippingOrderItem.STATUS_CANCELLED
       *  can exist for one OrderItem, for example if the OrderItem has been split for shipping purposes.
       *  The method returns null if no non-cancelled shipping order item exists.
       *
       * @return the last not cancelled shipping order item or null
       */
      getShippingOrderItem(): dw.order.ShippingOrderItem;
      /**
       * Returns a collection of the ShippingOrderItems created for this item.
       *  ShippingOrder items represents the whole or part of this item which could
       *  be delivered, and belong to a shipping order.
       *  Note that the cancelled shipping order items are returned too.
       *  This method is equivalent to getShippingOrderItems(Boolean)
       *  called with parameter true.
       *
       * @return collection of the shipping order items created for this item
       */
      getShippingOrderItems(): dw.util.Collection<dw.order.ShippingOrderItem>;
      /**
       * Returns a collection of the ShippingOrderItems created for this item.
       *  ShippingOrder items represent the whole or part of this item which could
       *  be delivered, and belong to a shipping order.
       *  Depending on the includeCancelled parameter the cancelled shipping order
       *  items will be returned or not.
       * @param includeCancelled true all shipping order items, including the cancelled, created for this item will be returned false only non-cancelled shipping order items created for this item will be returned
       * @return collection of the shipping order items created for this item
       */
      getShippingOrderItems(
        includeCancelled: boolean
      ): dw.util.Collection<dw.order.ShippingOrderItem>;
      /**
       * Returns a collection of all split OrderItems associated with this item. Inverse relation to getSplitSourceItem().
       *
       *  Split order items are created when
       *
       *  creating a ShippingOrderItem for a ShippingOrder, see ShippingOrder.createShippingOrderItem(OrderItem, Quantity)
       *  splitting an existing ShippingOrderItem, see ShippingOrderItem.split(Quantity)
       *
       *  with a specified quantity less than the existing quantity of the associated ProductLineItem. In this case the associated ProductLineItem
       *  is split by creating a new ProductLineItem and associating a new ShippingOrderItem with this item. The new ShippingOrderItem
       *  receives the specified quantity and the quantity of the item is set to the remaining quantity. All split items are associated to their originating item via
       *  the "split source item" association.
       *
       * @return the split order items associated with this item
       */
      getSplitItems(): dw.util.Collection<dw.order.OrderItem>;
      /**
       * Returns the split source item associated with this item, if existing. Inverse relation to getSplitItems().
       *
       *  A split source item is associated after the successful creation of a split item with a quantity less than the existing quantity of the item to split.
       *  For details see getSplitItems().
       *
       * @return the split source item or null
       */
      getSplitSourceItem(): dw.order.OrderItem;
      /**
       * Gets the order item status.
       *  The possible values are:
       *
       *  STATUS_NEW
       *  STATUS_OPEN
       *  STATUS_BACKORDER
       *  STATUS_CONFIRMED
       *  STATUS_WAREHOUSE
       *  STATUS_SHIPPED
       *  STATUS_CANCELLED
       *
       * @return the status
       */
      getStatus(): dw.value.EnumValue;
      /**
       * Returns the type of line item with which this instance is associated, one
       *  of
       *
       *  SERVICE (method getLineItem() returns a
       *  ShippingLineItem
       *  PRODUCT (method getLineItem() returns a
       *  ProductLineItem
       *
       * @return the type of order item, one of TYPE_PRODUCT or TYPE_SERVICE.
       */
      getType(): dw.value.EnumValue;
      /**
       * Set the status of the order item, use one of the values documented in getStatus().
       *
       *  If the order item has a related shipping order item (see getShippingOrderItem()) the status of the
       *  shipping order item will be adjusted to the same status. Setting the status of an order item might also change
       *  the status of the related order. The following rules apply in top-down order:
       *
       *  all items STATUS_CANCELLED - order status is Order.ORDER_STATUS_CANCELLED
       *  at least one item in status STATUS_SHIPPED and all other items are STATUS_CANCELLED order
       *  status is Order.ORDER_STATUS_COMPLETED
       *  at least one item in status STATUS_CREATED, STATUS_OPEN, STATUS_NEW
       *  , STATUS_BACKORDER - order status is Order.ORDER_STATUS_OPEN, order confirmation status
       *  is Order.CONFIRMATION_STATUS_NOTCONFIRMED
       *  other combinations will have only items in STATUS_CONFIRMED, STATUS_CANCELLED and
       *  STATUS_SHIPPED - order status is Order.ORDER_STATUS_OPEN, order confirmation status is
       *  Order.CONFIRMATION_STATUS_CONFIRMED
       * @param status status string matching one of the values for status
       */
      setStatus(status: string): void;
    }

    /**
     * <p>
     *  Provides static helper methods for managing orders.
     *  </p>
     *  <p>
     *  Pipelet GetOrder and methods provided to access orders such as <a href="class_dw_order_OrderMgr.html#dw_order_OrderMgr_getOrder_String_DetailAnchor">getOrder(String)</a> and
     *  <a href="class_dw_order_OrderMgr.html#dw_order_OrderMgr_searchOrders_String_String_Object_DetailAnchor">searchOrders(String, String, Object...)</a> can be limited by the site preference &apos;Limit Storefront Order
     *  Access&apos;. An insecure order access occurs in a storefront session when all of the following are true:
     *  </p><ul>
     *  <li>The current storefront session is not the session in which the order was created.</li>
     *  <li>The session customer does not match the order customer.</li>
     *  <li>The order status is not CREATED.</li>
     *  </ul>
     *  When an order is accessed in an insecure manner:
     *  <ul>
     *  <li>If the preference is ACTIVE, the action is disallowed and a SecurityException with a message beginning
     *  &apos;Unauthorized access to order&apos; is thrown.</li>
     *  <li>If the preference is NOT ACTIVE, a SecurityException with a message beginning &apos;Unauthorized access to order&apos; is
     *  logged as an error.</li>
     *  </ul>
     *  <p></p>
     */
    class OrderMgr {
      /**
       * This method cancels an order. Only orders in status OPEN, NEW, or COMPLETED can be cancelled.
       *
       *
       *  Setting of cancel code and cancel description can be done by calling
       *  Order.setCancelCode(String) and Order.setCancelDescription(String). *
       *  If the order contains product or gift certificate line items associated with product list items, records of the
       *  purchase of the product list items will be removed.
       *
       *
       *  Inventory transactions and coupon redemptions associated with the order will be rolled back.
       *
       *
       *  It is important to consider that this method will cancel orders with gift certificate line items.
       *
       *
       *  If an order has any active post-processing objects (e.g. shipping orders, returns, appeasements),
       *  then it cannot be cancelled directly. Its status is set automatically, based on the statuses of its
       *  post-processing objects. To cancel such an order, you must cancel all related post-processing objects.
       *
       *
       *  If your B2C Commerce instance is integrated with Order Management, then you manage order statuses in
       *  Order Management. Use Order Management API endpoints.
       * @param order the order to be cancelled
       * @return Status 'OK' or 'ERROR'
       */
      static cancelOrder(order: dw.order.Order): dw.system.Status;
      /**
       * This method creates an order based on a basket. If successful, the new order will be in status
       *  Order.ORDER_STATUS_CREATED. The basket will be removed from the session and marked for removal.
       *
       *
       *  This method throws an APIException with type 'CreateOrderException' if any of the following conditions are
       *  encountered:
       *
       *  any of the totals (net, gross, tax) of the basket is N/A
       *  any of the product items is not available (this takes previously reserved items into account)
       *  any campaign-based coupon in the basket is invalid (see CouponLineItem.isValid()
       *  the basket represents an order being edited, but the order has been already been replaced by another
       *  order
       *  the basket represents an order being edited, but the customer associated with the original order is not the
       *  same as the current customer
       *
       *
       *
       *  The method removes all empty shipments from the basket before creating the order. A shipment is said to be empty
       *  if all of the following are true:
       *
       *  it contains no product or gift certificate line items
       *  all total prices (net, gross, tax) are 0.0
       *
       *
       *
       *  This method decrements inventory for all products contained in the order. A previous call to
       *  Basket.reserveInventory() is unnecessary and discouraged within the same request. The method
       *  takes any items with reserved inventory into account, allowing an early reservation of items, e.g. at the
       *  beginning of the checkout process. As described above, an APIException is thrown if any item is not available.
       *
       *
       *  If the basket contains product or gift certificate line items associated with product list items, the method
       *  updates the purchased quantity of the product list items; see
       *  ProductListItem.getPurchasedQuantity().
       *
       *
       *  This method must not be used with the ReserveInventoryForOrder pipelet or
       *  Basket.reserveInventory() in the same request.
       *
       *
       *  Usage:
       *
       *
       *
       *   var basket : Basket; // known
       *  try
       *  {
       *    var order : Order = OrderMgr.createOrder(basket);
       *  }
       *  catch (e if e instanceof APIException && e.type === 'CreateOrderException')
       *  {
       *    // handle e
       *  }
       * @param basket basket to create an order for
       * @return a new order
       */
      static createOrder(basket: dw.order.Basket): dw.order.Order;
      /**
       * This method is identical to createOrder(Basket) but allows the optional specification of an
       *  orderNo. The orderNo must be unique within the context of a site.
       *
       *
       *  This method must not be used with the ReserveInventoryForOrder pipelet or
       *  Basket.reserveInventory() in the same request.
       *
       *
       *  Usage:
       *
       *
       *   var basket : Basket; // known
       *  var orderNo : String; // known
       *  try
       *  {
       *    var order : Order = OrderMgr.createOrder(basket, orderNo);
       *  }
       *  catch (e if e instanceof APIException && e.type === 'CreateOrderException')
       *  {
       *    // handle e
       *  }
       * @param basket basket to create an order for
       * @param orderNo optional order number; an order number will be generated if null is specified
       * @return a new order
       */
      static createOrder(
        basket: dw.order.Basket,
        orderNo: string
      ): dw.order.Order;
      /**
       * Creates an order number.
       *
       *
       *  The order number is created via hook OrderHooks.createOrderNo(). If no hook is registered
       *  for the endpoint, the order number will be generated by calling createOrderSequenceNo().
       *
       * @return the next available order number
       */
      static createOrderNo(): string;
      /**
       * Creates an order number that is either taken from the organization or the site order series.
       *
       * @return the next available order number
       */
      static createOrderSequenceNo(): string;
      /**
       * Triggers the shipping order creation for an order.
       *
       *
       *  Must be run outside of a transaction. Will call hooks of the shipping order creation process, which are:
       *
       *  ShippingOrderHooks.extensionPointPrepareCreateShippingOrders
       *  ShippingOrderHooks.extensionPointCreateShippingOrders
       *  ShippingOrderHooks.extensionPointAfterStatusChange
       *  ShippingOrderHooks.extensionPointNotifyStatusChange
       *
       *
       *
       *  As a result, zero, one, or multiple ShippingOrders are created.
       *
       *  Order post-processing APIs (gillian) are now inactive by default and will throw
       *  an exception if accessed. On sandboxes the APIs can be activated with a feature
       *  switch "Order Post Processing APIs on Sandboxes". On PIGs an activation needs
       *  preliminary approval by Product Management. Please contact support in this case.
       *  Existing customers using these APIs are not affected by this change and can use the
       *  APIs until further notice.
       * @param order the order to run the shipping order creation for
       * @return Status 'OK' or 'ERROR' with an error message
       */
      static createShippingOrders(order: dw.order.Order): dw.system.Status;
      /**
       * Returns the meta data for Orders.
       *
       * @return the meta data for Orders.
       */
      static describeOrder(): dw.object.ObjectTypeDefinition;
      /**
       * This method fails an unplaced order and is usually called if payment could not be authorized. The specified Order
       *  must be in status CREATED, and will be set to status FAILED.
       *
       *
       *  Inventory transactions and coupon redemptions associated with the Order will be rolled back.
       *
       *
       *  If the order is failed in the same session in which it was created, the basket will be reopened such that it can
       *  be used for a subsequent order.
       * @param order the order to be placed
       * @return Status 'OK' or 'ERROR' with an error message
       */
      static failOrder(order: dw.order.Order): dw.system.Status;
      /**
       * This method fails an unplaced order and is usually called if payment could not be authorized. The specified Order
       *  must be in status CREATED, and will be set to status FAILED.
       *
       *
       *  Inventory transactions and coupon redemptions associated with the Order will be rolled back.
       * @param order the order to be placed
       * @param reopenBasketIfPossible reopen the basket if it still exists and limit for number of baskets is not reached
       * @return Status 'OK' or 'ERROR' with an error message. Status detail basket contains the reopened basket, if it has been reopened successfully.
       */
      static failOrder(
        order: dw.order.Order,
        reopenBasketIfPossible: boolean
      ): dw.system.Status;
      /**
       * Returns the order with the specified order number. Order access in the storefront can be limited; see the class
       *  description. Use getOrder(String, String) instead for secure access in a storefront session.
       * @param orderNumber the order number of the order to retrieve
       * @return Order for the specified order number
       */
      static getOrder(orderNumber: string): dw.order.Order;
      /**
       * Securely resolves an order using the orderNumber and orderToken.
       *
       *
       *  The order token is generated during order creation in a secure way that is designed to prevent
       *  access by unauthorized parties. You can retrieve the token via (Order.getOrderToken().
       *
       *
       *  This version of the getOrder method does not return an exception when the Limit Storefront
       *  Order Access site preference is enabled. Best security practice is to always enable this
       *  preference, and to use this method when appropriate.
       *
       *
       *  You should always use this method in the following cases.
       *
       *  Integration use cases (such as asynchronous payment processing)
       *  When resolving orders from links (for example, order confirmation)
       *  Storefront use cases
       * @param orderNumber the order number of the order to retrieve
       * @param orderToken the order token of the order to retrieve
       * @return Order for the specified order number. null is returned if order is not found by number or token does not correspond to the order found
       */
      static getOrder(orderNumber: string, orderToken: string): dw.order.Order;
      /**
       * This method places an order and is usually called after payment has been authorized. The specified order must be
       *  in status CREATED, and will be set to status NEW.
       *
       *
       *  If the order contains product or gift certificate line items associated with product list items, records of the
       *  purchase of the product list items will be made. For example, if the basket contains an item added from a gift
       *  registry, the purchase history of the respective gift registry item is updated.
       *
       *
       *  The order will count toward product and customer active data.
       *
       *
       *  Placing an order leads to the generation of shipment numbers for all shipments and the invoice number of the
       *  order. See Shipment.getShipmentNo() and Order.getInvoiceNo(). This is done
       *  using sequences.
       * @param order the order to be placed
       * @return Status 'OK' or 'ERROR' with an error message
       */
      static placeOrder(order: dw.order.Order): dw.system.Status;
      /**
       * Executes a user-definable function on a set of orders. This method is intended to be used in batch processes and
       *  jobs, since it allows efficient processing of large result sets (which might take a while to process). First, a
       *  search with the given parameters is executed. Then the given function is executed once for each order of the
       *  search result. The order is handed over as the only parameter to this function.
       *
       *
       *  The search can be configured using a simple query language, which provides most common filter and operator
       *  functionality. The callback function will be supplied with a single argument of type 'Order'. When the function
       *  defines additional arguments, they will be undefined when called. When the method doesn't define any argument, it
       *  will be called anyway. Error during execution of the callback will be logged, and execution will continue with
       *  the next element from the result set. This method can be used as in this example (which counts the number of
       *  orders):
       *
       *
       *           var count=0;
       *          function callback(order: Order)
       *          {
       *              count++;
       *              dw.system.Logger.debug("order found: "+order.documentNo)
       *          }
       *         OrderMgr.processOrders(callback, "buyerno=1");
       *         dw.system.Logger.debug("found "+count+" orders for buyerno 1");
       * @param processFunction the function to execute for each order
       * @param queryString the query string to use when searching for an order.
       * @param args the query string arguments.
       */
      static processOrders(
        processFunction: Function,
        queryString: string,
        ...args: any[]
      ): void;
      /**
       * Searches for a single order instance. Order access in the storefront can be limited; see the class description.
       *
       *
       *  The search can be configured using a simple query language, which provides most common filter and operator
       *  functionality.
       *
       *
       *  The identifier for an attribute to use in a query condition is always the ID of the attribute as defined
       *  in the type definition. For custom-defined attributes, the prefix 'custom' is required in the search term (e.g.
       *  custom.color = {1}), while for system attributes no prefix is used (e.g. name = {4}).
       *
       *
       *  Supported attribute value types with sample expression values:
       *
       *  String 'String', 'Str*', 'Strin?'
       *  Integer 1, 3E4
       *  Number 1.0, 3.99E5
       *  Date yyyy-MM-dd e.g. 2007-05-31 (Default TimeZone = UTC)
       *  DateTime
       *  yyyy-MM-dd'T'hh:mm:ss+Z e.g. 2007-05-31T00:00+Z (Z TimeZone = UTC) or 2007-05-31T00:00:00
       *  Boolean true, false
       *  Email '[emailprotected]', '*@demandware.com'
       *  Set of String 'String', 'Str*', 'Strin?'
       *  Set of Integer 1, 3E4
       *  Set of Number 1.0, 3.99E5
       *  Enum of String 'String', 'Str*', 'Strin?'
       *  Enum of Integer 1, 3E4
       *
       *
       *
       *  The following types of attributes are not queryable:
       *
       *  Image
       *  HTML
       *  Text
       *  Quantity
       *  Password
       *
       *
       *
       *  Note that some system attributes are not queryable by default, regardless of the actual value type code.
       *
       *
       *  The following operators are supported in a condition:
       *
       *  = Equals - All types; supports NULL value (thumbnail = NULL)
       *  != Not equals - All types; supports NULL value (thumbnail != NULL)
       *  < Less than - Integer, Number, and Date types only
       *  > Greater than - Integer, Number, and Date types only
       *  <= Less or equals than - Integer, Number, and Date types only
       *  >= Greater or equals than - Integer, Number, and Date types only
       *  LIKE Like - String types and Email only; use if leading or trailing wildcards will be used to
       *  support substring search (e.g. custom.country LIKE 'US*')
       *  ILIKE Caseindependent Like - String types and Email only; use to support case-insensitive queries
       *  (e.g. custom.country ILIKE 'usa'); also supports wildcards for substring matching
       *
       *
       *
       *  Conditions can be combined using logical expressions 'AND', 'OR', and 'NOT', and nested using parentheses, e.g.
       *  gender = {1} AND (age >= {2} OR (NOT profession LIKE {3})).
       *
       *
       *  The query language provides a placeholder syntax to pass objects as additional search parameters. Each passed
       *  object is related to a placeholder in the query string. The placeholder must be an Integer that is surrounded by
       *  braces. The first Integer value must be '0', the second '1', and so on, e.g.
       *  querySystemObjects("sample", "age = {0} or creationDate >= {1}", 18, date)
       *
       *
       *  If there is more than one object matching the specified query criteria, the result is not deterministic. In order
       *  to retrieve a single object from a sorted result set, it is recommended to use the following code:
       *  queryOrders("", "custom.myAttr asc", null).first(). The method first() returns only the
       *  next element and closes the iterator. This method will be deprecated in a future release. We recommend to use
       *  methods searchOrder(String, Object...), searchOrders(Map, String), and
       *  searchOrders(String, String, Object...) to search for orders, and to use method
       *  processOrders(Function, String, Object...) to search for and process orders in jobs.
       * @param queryString the query string that is used to locate the order.
       * @param args one or more arguments to apply.
       * @return the order that was found when executing the queryString.
       */
      static queryOrder(queryString: string, ...args: any[]): dw.order.Order;
      /**
       * Searches for order instances. Order access in the storefront can be limited; see the class description.
       *
       *
       *  The search can be configured using a simple query language, which provides most common filter and operator
       *  functionality.
       *
       *
       *  The identifier for an attribute to use in a query condition is always the ID of the attribute as defined
       *  in the type definition. For custom-defined attributes, the prefix 'custom' is required in the search term (e.g.
       *  custom.color = {1}), while for system attributes no prefix is used (e.g. name = {4}).
       *
       *
       *  Supported attribute value types with sample expression values:
       *
       *  String 'String', 'Str*', 'Strin?'
       *  Integer 1, 3E4
       *  Number 1.0, 3.99E5
       *  Date yyyy-MM-dd e.g. 2007-05-31 (Default TimeZone = UTC)
       *  DateTime
       *  yyyy-MM-dd'T'hh:mm:ss+Z e.g. 2007-05-31T00:00+Z (Z TimeZone = UTC) or 2007-05-31T00:00:00
       *  Boolean true, false
       *  Email '[emailprotected]', '*@demandware.com'
       *  Set of String 'String', 'Str*', 'Strin?'
       *  Set of Integer 1, 3E4
       *  Set of Number 1.0, 3.99E5
       *  Enum of String 'String', 'Str*', 'Strin?'
       *  Enum of Integer 1, 3E4
       *
       *
       *
       *  The following types of attributes are not queryable:
       *
       *  Image
       *  HTML
       *  Text
       *  Quantity
       *  Password
       *
       *
       *
       *  Note that some system attributes are not queryable by default, regardless of the actual value type code.
       *
       *
       *  The following operators are supported in a condition:
       *
       *  = Equals - All types; supports NULL value (thumbnail = NULL)
       *  != Not equals - All types; supports NULL value (thumbnail != NULL)
       *  < Less than - Integer, Number, and Date types only
       *  > Greater than - Integer, Number, and Date types only
       *  <= Less or equals than - Integer, Number, and Date types only
       *  >= Greater or equals than - Integer, Number, and Date types only
       *  LIKE Like - String types and Email only; use if leading or trailing wildcards will be used to
       *  support substring search (e.g. custom.country LIKE 'US*')
       *  ILIKE Caseindependent Like - String types and Email only; use to support case-insensitive queries
       *  (e.g. custom.country ILIKE 'usa'); also supports wildcards for substring matching
       *
       *
       *
       *  Conditions can be combined using logical expressions 'AND', 'OR', and 'NOT', and nested using parentheses, e.g.
       *  gender = {1} AND (age >= {2} OR (NOT profession LIKE {3})).
       *
       *
       *  The query language provides a placeholder syntax to pass objects as additional search parameters. Each passed
       *  object is related to a placeholder in the query string. The placeholder must be an Integer that is surrounded by
       *  braces. The first Integer value must be '0', the second '1', and so on, e.g.
       *  querySystemObjects("sample", "age = {0} or creationDate >= {1}", 18, date)
       *
       *
       *  The sorting parameter is optional and may contain a comma-separated list of attribute names to sort by.
       *  Each sort attribute name may be followed by an optional sort direction specifier ('asc' | 'desc'). The default
       *  sorting direction is ascending, if no direction was specified.
       *
       *
       *  Example: age desc, name
       *
       *
       *  Please note that specifying a localized custom attribute as the sorting attribute is currently not supported.
       *
       *
       *  Sometimes it is desired to get all instances of a specified type with a special sorting condition. This can be
       *  easily done by providing the 'type' of the custom object and the 'sortString' in combination with an empty
       *  'queryString', e.g. queryOrders("sample", "", "custom.myAttr asc").
       *
       *
       *  It is strongly recommended to call SeekableIterator.close() on the returned
       *  SeekableIterator if not all of its elements are being retrieved. This will ensure the proper cleanup of system
       *  resources.
       *
       *
       *  This method will be deprecated in a future release. We recommend to use methods
       *  searchOrder(String, Object...), searchOrders(Map, String), and
       *  searchOrders(String, String, Object...) to search for orders, and to use the method
       *  processOrders(Function, String, Object...) to search for and process orders in jobs.
       * @param queryString the actual query.
       * @param sortString an optional sorting, or null if no sorting is necessary.
       * @param args one or more arguments for the query string.
       * @return SeekableIterator containing the result set of the query.
       */
      static queryOrders(
        queryString: string,
        sortString: string,
        ...args: any[]
      ): dw.util.SeekableIterator;
      /**
       * Searches for order instances. Order access in the storefront can be limited; see the class description.
       *
       *
       *  The search can be configured with a map, which converts key-value pairs into a query expression. The
       *  key-value pairs are turned into a sequence of '=' or 'like' conditions, which are combined with AND statements.
       *
       *
       *  Example:
       *
       *
       *  A map with the key/value pairs: 'name'/'tom*', 'age'/66 will be converted as follows:
       *  "name like 'tom*' and age = 66"
       *
       *
       *  The identifier for an attribute to use in a query condition is always the ID of the attribute as defined
       *  in the type definition. For custom-defined attributes, the prefix 'custom' is required in the search term (e.g.
       *  custom.color = {1}), while for system attributes no prefix is used (e.g. name = {4}).
       *
       *
       *  Supported attribute value types with sample expression values:
       *
       *  String 'String', 'Str*', 'Strin?'
       *  Integer 1, 3E4
       *  Number 1.0, 3.99E5
       *  Date yyyy-MM-dd e.g. 2007-05-31 (Default TimeZone = UTC)
       *  DateTime
       *  yyyy-MM-dd'T'hh:mm:ss+Z e.g. 2007-05-31T00:00+Z (Z TimeZone = UTC) or 2007-05-31T00:00:00
       *  Boolean true, false
       *  Email '[emailprotected]', '*@demandware.com'
       *  Set of String 'String', 'Str*', 'Strin?'
       *  Set of Integer 1, 3E4
       *  Set of Number 1.0, 3.99E5
       *  Enum of String 'String', 'Str*', 'Strin?'
       *  Enum of Integer 1, 3E4
       *
       *
       *
       *  The following types of attributes are not queryable:
       *
       *  Image
       *  HTML
       *  Text
       *  Quantity
       *  Password
       *
       *
       *
       *  Note that some system attributes are not queryable by default, regardless of the actual value type code.
       *
       *
       *  The sorting parameter is optional and may contain a comma-separated list of attribute names to sort by.
       *  Each sort attribute name may be followed by an optional sort direction specifier ('asc' | 'desc'). The default
       *  sorting direction is ascending, if no direction was specified.
       *
       *
       *  Example: age desc, name
       *
       *
       *  Please note that specifying a localized custom attribute as the sorting attribute is currently not supported.
       *
       *
       *  It is strongly recommended to call the SeekableIterator.close() on the returned
       *  SeekableIterator if not all of its elements are being retrieved. This will ensure the proper cleanup of system
       *  resources.
       *
       *
       *  This method will be deprecated in a future release. We recommend to use methods
       *  searchOrder(String, Object...), searchOrders(Map, String), and
       *  searchOrders(String, String, Object...) to search for orders, and to use method
       *  processOrders(Function, String, Object...) to search for and process orders in jobs.
       * @param queryAttributes a set of key-value pairs that define the query.
       * @param sortString an optional sorting, or null if no sorting is necessary.
       * @return SeekableIterator containing the result set of the query.
       */
      static queryOrders(
        queryAttributes: dw.util.Map<any, any>,
        sortString: string
      ): dw.util.SeekableIterator;
      /**
       * Searches for a single order instance. Order access in the storefront can be limited; see the class description.
       *
       *
       *  The search can be configured using a simple query language, which provides most common filter and operator
       *  functionality.
       *
       *
       *  The identifier for an attribute to use in a query condition is always the ID of the attribute as defined
       *  in the type definition. For custom-defined attributes the prefix 'custom' is required in the search term (e.g.
       *  custom.color = {1}), while for system attributes no prefix is used (e.g. name = {4}).
       *
       *
       *  Supported attribute value types with sample expression values:
       *
       *  String 'String', 'Str*', 'Strin?'
       *  Integer 1, 3E4
       *  Number 1.0, 3.99E5
       *  Date yyyy-MM-dd e.g. 2007-05-31 (Default TimeZone = UTC)
       *  DateTime
       *  yyyy-MM-dd'T'hh:mm:ss+Z e.g. 2007-05-31T00:00+Z (Z TimeZone = UTC) or 2007-05-31T00:00:00
       *  Boolean true, false
       *  Email '[emailprotected]', '*@demandware.com'
       *  Set of String 'String', 'Str*', 'Strin?'
       *  Set of Integer 1, 3E4
       *  Set of Number 1.0, 3.99E5
       *  Enum of String 'String', 'Str*', 'Strin?'
       *  Enum of Integer 1, 3E4
       *
       *
       *
       *  The following types of attributes are not queryable:
       *
       *  Image
       *  HTML
       *  Text
       *  Quantity
       *  Password
       *
       *
       *
       *  Note that some system attributes are not queryable by default, regardless of the actual value type code.
       *
       *
       *  The following operators are supported in a condition:
       *
       *  = Equals - All types; supports NULL value (thumbnail = NULL)
       *  != Not equals - All types; supports NULL value (thumbnail != NULL)
       *  < Less than - Integer, Number, and Date types only
       *  > Greater than - Integer, Number, and Date types only
       *  <= Less or equals than - Integer, Number, and Date types only
       *  >= Greater or equals than - Integer, Number, and Date types only
       *  LIKE Like - String types and Email only; use if leading or trailing wildcards will be used to
       *  support substring search (e.g. custom.country LIKE 'US*')
       *  ILIKE Caseindependent Like - String types and Email only; use to support case-insensitive queries
       *  (e.g. custom.country ILIKE 'usa'), also supports wildcards for substring matching
       *
       *
       *
       *  Conditions can be combined using logical expressions 'AND', 'OR', and 'NOT', and nested using parentheses, e.g.
       *  gender = {1} AND (age >= {2} OR (NOT profession LIKE {3})).
       *
       *
       *  The query language provides a placeholder syntax to pass objects as additional search parameters. Each passed
       *  object is related to a placeholder in the query string. The placeholder must be an Integer that is surrounded by
       *  braces. The first Integer value must be '0', the second '1', and so on, e.g.
       *  querySystemObjects("sample", "age = {0} or creationDate >= {1}", 18, date).
       *
       *
       *  If there is more than one object matching the specified query criteria, the result is not deterministic. In order
       *  to retrieve a single object from a sorted result set, it is recommended to use the following code:
       *  queryOrders("", "custom.myAttr asc", null).first(). The method first() returns only the
       *  next element and closes the iterator.
       *
       *
       *  If the order search API is configured to use the new Search Service, the following differences apply:
       *
       *  wildcards will be filtered from the query (*, %, +) and replaced by spaces
       *  LIKE and ILIKE queries will be executed as fulltext queries (working on whole words), not as substring
       *  searches
       *  LIKE queries will always be case-insensitive
       *  using logical operators may change the execution of LIKE/ILIKE clauses to exact string comparison, depending
       *  on how they are combined
       *  using logical operators may result in degraded performance, depending on how they are combined
       * @param queryString the query string that is used to locate the order.
       * @param args one or more arguments to apply.
       * @return the order that was found when executing the queryString.
       */
      static searchOrder(queryString: string, ...args: any[]): dw.order.Order;
      /**
       * Searches for order instances. Order access in the storefront can be limited; see the class description.
       *
       *
       *  The search can be configured using a simple query language, which provides most common filter and operator
       *  functionality.
       *
       *
       *  The identifier for an attribute to use in a query condition is always the ID of the attribute as defined
       *  in the type definition. For custom-defined attributes the prefix 'custom' is required in the search term (e.g.
       *  custom.color = {1}), while for system attributes no prefix is used (e.g. name = {4}).
       *
       *
       *  Supported attribute value types with sample expression values:
       *
       *  String 'String', 'Str*', 'Strin?'
       *  Integer 1, 3E4
       *  Number 1.0, 3.99E5
       *  Date yyyy-MM-dd e.g. 2007-05-31 (Default TimeZone = UTC)
       *  DateTime
       *  yyyy-MM-dd'T'hh:mm:ss+Z e.g. 2007-05-31T00:00+Z (Z TimeZone = UTC) or 2007-05-31T00:00:00
       *  Boolean true, false
       *  Email '[emailprotected]', '*@demandware.com'
       *  Set of String 'String', 'Str*', 'Strin?'
       *  Set of Integer 1, 3E4
       *  Set of Number 1.0, 3.99E5
       *  Enum of String 'String', 'Str*', 'Strin?'
       *  Enum of Integer 1, 3E4
       *
       *
       *
       *  The following types of attributes are not queryable:
       *
       *  Image
       *  HTML
       *  Text
       *  Quantity
       *  Password
       *
       *
       *
       *  Note that some system attributes are not queryable by default, regardless of the actual value type code.
       *
       *
       *  The following operators are supported in a condition:
       *
       *  = Equals - All types; supports NULL value (thumbnail = NULL)
       *  != Not equals - All types; supports NULL value (thumbnail != NULL)
       *  < Less than - Integer, Number, and Date types only
       *  > Greater than - Integer, Number, and Date types only
       *  <= Less or equals than - Integer, Number, and Date types only
       *  >= Greater or equals than - Integer, Number, and Date types only
       *  LIKE Like - String types and Email only; use if leading or trailing wildcards will be used to
       *  support substring search (e.g. custom.country LIKE 'US*')
       *  ILIKE Caseindependent Like - String types and Email only; use to support case-insensitive queries
       *  (e.g. custom.country ILIKE 'usa'); also supports wildcards for substring matching
       *
       *  Note that wildcards are not supported by Search Service.
       *
       *
       *  Conditions can be combined using logical expressions 'AND', 'OR', and 'NOT', and nested using parentheses, e.g.
       *  gender = {1} AND (age >= {2} OR (NOT profession LIKE {3})).
       *
       *
       *  The query language provides a placeholder syntax to pass objects as additional search parameters. Each passed
       *  object is related to a placeholder in the query string. The placeholder must be an Integer that is surrounded by
       *  braces. The first Integer value must be '0', the second '1', and so on, e.g.
       *  querySystemObjects("sample", "age = {0} or creationDate >= {1}", 18, date).
       *
       *
       *  The sorting parameter is optional and may contain a comma-separated list of attribute names to sort by.
       *  Each sort attribute name may be followed by an optional sort direction specifier ('asc' | 'desc'). The default
       *  sorting direction is ascending, if no direction was specified.
       *
       *
       *  Example: age desc, name
       *
       *
       *  Please note that specifying a localized custom attribute as the sorting attribute is currently not supported.
       *
       *
       *  Sometimes it is desired to get all instances of a specified type with a special sorting condition. This can be
       *  easily done by providing the 'type' of the custom object and the 'sortString' in combination with an empty
       *  'queryString', e.g. queryOrders("sample", "", "custom.myAttr asc").
       *
       *
       *  It is strongly recommended to call SeekableIterator.close() on the returned
       *  SeekableIterator if not all of its elements are being retrieved. This will ensure the proper cleanup of system
       *  resources.
       *
       *
       *  If the order search API is configured to use the new Search Service, the following differences apply:
       *
       *  wildcards will be filtered from the query (*, %, +) and replaced by spaces
       *  LIKE and ILIKE queries will be executed as fulltext queries (working on whole words), not as substring
       *  searches
       *  LIKE queries will always be case-insensitive
       *  using logical operators may change the execution of LIKE/ILIKE clauses to exact string comparison, depending
       *  on how they are combined
       *  using logical operators may result in degraded performance, depending on how they are combined
       *  the result is limited to a maximum of 1000 orders
       * @param queryString the actual query.
       * @param sortString an optional sorting or null if no sorting is necessary.
       * @param args one or more arguments for the query string.
       * @return SeekableIterator containing the result set of the query.
       */
      static searchOrders(
        queryString: string,
        sortString: string,
        ...args: any[]
      ): dw.util.SeekableIterator;
      /**
       * Searches for order instances. Order access in the storefront can be limited; see the class description.
       *
       *
       *  The search can be configured with a map, which converts key-value pairs into a query expression. The
       *  key-value pairs are turned into a sequence of '=' or 'like' conditions, which are combined with AND statements.
       *
       *
       *  Example:
       *
       *
       *  A map with the key/value pairs: 'name'/'tom*', 'age'/66 will be converted as follows:
       *  "name like 'tom*' and age = 66" Note that wildcards are not supported by Search Service.
       *
       *
       *  The identifier for an attribute to use in a query condition is always the ID of the attribute as defined
       *  in the type definition. For custom-defined attributes, the prefix 'custom' is required in the search term (e.g.
       *  custom.color = {1}), while for system attributes no prefix is used (e.g. name = {4}).
       *
       *
       *  Supported attribute value types with sample expression values:
       *
       *  String 'String', 'Str*', 'Strin?'
       *  Integer 1, 3E4
       *  Number 1.0, 3.99E5
       *  Date yyyy-MM-dd e.g. 2007-05-31 (Default TimeZone = UTC)
       *  DateTime
       *  yyyy-MM-dd'T'hh:mm:ss+Z e.g. 2007-05-31T00:00+Z (Z TimeZone = UTC) or 2007-05-31T00:00:00
       *  Boolean true, false
       *  Email '[emailprotected]', '*@demandware.com'
       *  Set of String 'String', 'Str*', 'Strin?'
       *  Set of Integer 1, 3E4
       *  Set of Number 1.0, 3.99E5
       *  Enum of String 'String', 'Str*', 'Strin?'
       *  Enum of Integer 1, 3E4
       *
       *
       *
       *  The following types of attributes are not queryable:
       *
       *  Image
       *  HTML
       *  Text
       *  Quantity
       *  Password
       *
       *
       *
       *  Note that some system attributes are not queryable by default, regardless of the actual value type code.
       *
       *
       *  The sorting parameter is optional and may contain a comma-separated list of attribute names to sort by.
       *  Each sort attribute name may be followed by an optional sort direction specifier ('asc' | 'desc'). The default
       *  sorting direction is ascending, if no direction was specified.
       *
       *
       *  Example: age desc, name
       *
       *
       *  Please note that specifying a localized custom attribute as the sorting attribute is currently not supported.
       *
       *
       *  It is strongly recommended to call SeekableIterator.close() on the returned
       *  SeekableIterator if not all of its elements are being retrieved. This will ensure the proper cleanup of system
       *  resources.
       *
       *
       *  If the order search API is configured to use the new Search Service, the following differences apply:
       *
       *  wildcards will be filtered from the query (*, %, +) and replaced by spaces
       *  LIKE and ILIKE queries will be executed as fulltext queries (working on whole words), not as substring
       *  searches
       *  LIKE queries will always be case-insensitive
       *  using logical operators may change the execution of LIKE/ILIKE clauses to exact string comparison, depending
       *  on how they are combined
       *  using logical operators may result in degraded performance, depending on how they are combined
       *  the result is limited to a maximum of 1000 orders
       * @param queryAttributes a set of key-value pairs that define the query.
       * @param sortString an optional sorting or null if no sorting is necessary.
       * @return SeekableIterator containing the result set of the query.
       */
      static searchOrders(
        queryAttributes: dw.util.Map<any, any>,
        sortString: string
      ): dw.util.SeekableIterator;
      /**
       * This method is used to turn a CANCELLED order into an OPEN order.
       *
       *
       *  The specified order must be a cancelled order (Order.ORDER_STATUS_CANCELLED). The method will
       *  reserve inventory for all product line items, and create redemptions for all coupons. If successful, the status
       *  of the order will be changed to Order.ORDER_STATUS_OPEN. If the order contains product or gift
       *  certificate line items associated with product list items, records of the purchase of the product list items will
       *  be recreated.
       *
       *
       *  If the undoCancelOrder call fails, the transaction is marked as rollback only  all changes in the associated
       *  transaction will no longer be committed.
       *
       *
       *  Possible error status codes are:
       *
       *  OrderProcessStatusCodes.COUPON_INVALID - coupon is not active anymore or maximum amount of
       *  redemptions is reached
       *  OrderProcessStatusCodes.ORDER_NOT_CANCELLED - order is not in status
       *  Order.ORDER_STATUS_CANCELLED
       *  OrderProcessStatusCodes.INVENTORY_RESERVATION_FAILED - inventory reservation failed
       * @param order the order on which to undo the cancel cancelOrder(Order)
       * @return Status 'OK' or 'ERROR' with one of the error codes described above
       */
      static undoCancelOrder(order: dw.order.Order): dw.system.Status;
      /**
       * This method is used to turn a FAILED order into a CREATED order.
       *
       *
       *  The specified order must be a failed order (Order.ORDER_STATUS_FAILED). The method will reserve
       *  inventory for all product line items, and create redemptions for all coupons. If successful, the status of the
       *  order will be changed to Order.ORDER_STATUS_CREATED.
       *
       *
       *  If the undoFailOrder call fails, the transaction is marked as rollback only  all changes in the associated
       *  transaction will no longer be committed.
       *
       *
       *  Possible error status codes are:
       *
       *  OrderProcessStatusCodes.COUPON_INVALID - coupon is not active anymore or maximum amount of
       *  redemptions is reached
       *  OrderProcessStatusCodes.ORDER_NOT_FAILED - order is not in status
       *  Order.ORDER_STATUS_FAILED
       *  OrderProcessStatusCodes.INVENTORY_RESERVATION_FAILED - inventory reservation failed
       * @param order the order on which to undo the fail failOrder(Order)
       * @return Status 'OK' or 'ERROR' with one of the error codes described above
       */
      static undoFailOrder(order: dw.order.Order): dw.system.Status;
    }

    /**
     * Represents any payment instrument used to pay orders, such as credit card
     *  or bank transfer. The object defines standard methods for credit card
     *  payment, and can be extended by attributes appropriate for other
     *  payment methods.
     */
    class OrderPaymentInstrument extends dw.order.PaymentInstrument {
      /**
       * The driver's license associated with a bank account if the calling
       *  context meets the following criteria:
       *
       *
       *  If the method call happens in the context of a storefront request and
       *  the current customer is identical to the customer related to the basket
       *  or order, and the current protocol is HTTPS.
       *
       *
       *  If the method call happens in the context of the business manager and the
       *  current user has permission to the Orders module.
       *
       *
       *  Otherwise, the method throws an exception.
       */
      readonly bankAccountDriversLicense: string;
      /**
       * The account number if the calling context meets
       *  the following criteria:
       *
       *
       *  If the method call happens in the context of a storefront request and
       *  the current customer is identical to the customer related to the basket
       *  or order, and the current protocol is HTTPS.
       *
       *
       *  If the method call happens in the context of the business manager and the
       *  current user has permissions to the Orders module.
       *
       *
       *  Otherwise, the method throws an exception.
       */
      readonly bankAccountNumber: string;
      /**
       * The sum of the captured amounts. The captured amounts
       *  are calculated on the fly. Associate a payment capture for an Payment Instrument with an Invoice
       *  using Invoice method addCaptureTransaction.
       */
      readonly capturedAmount: dw.value.Money;
      /**
       * The de-crypted creditcard number if the calling context meets
       *  the following criteria:
       *
       *
       *  If the method call happens in the context of a storefront request and
       *  the current authenticated customer is referenced by the basket or order, and the current protocol is HTTPS.
       *
       *
       *  If the customer is anonymous, and the order references this customer, and the protocol is secure and
       *  the order status is CREATED.
       *
       *
       *  If the method call happens in the context of the business manager and the
       *  current user has the permission to manage orders.
       *
       *
       *  If the payment information has not been masked as a result of the data retention security policy
       *  for the site.
       *
       *
       *  Otherwise, the method returns the masked credit card number.
       */
      readonly creditCardNumber: string;
      /**
       * The Payment Transaction for this Payment Instrument or null.
       */
      readonly paymentTransaction: dw.order.PaymentTransaction;
      /**
       * The sum of the refunded amounts. The refunded amounts
       *  are calculated on the fly. Associate a payment refund for an Payment Instrument with an Invoice
       *  using Invoice method addRefundTransaction.
       */
      readonly refundedAmount: dw.value.Money;

      /**
       * Returns the driver's license associated with a bank account if the calling
       *  context meets the following criteria:
       *
       *
       *  If the method call happens in the context of a storefront request and
       *  the current customer is identical to the customer related to the basket
       *  or order, and the current protocol is HTTPS.
       *
       *
       *  If the method call happens in the context of the business manager and the
       *  current user has permission to the Orders module.
       *
       *
       *  Otherwise, the method throws an exception.
       *
       * @return the driver's license number if the calling context meets the necessary criteria.
       */
      getBankAccountDriversLicense(): string;
      /**
       * Returns the account number if the calling context meets
       *  the following criteria:
       *
       *
       *  If the method call happens in the context of a storefront request and
       *  the current customer is identical to the customer related to the basket
       *  or order, and the current protocol is HTTPS.
       *
       *
       *  If the method call happens in the context of the business manager and the
       *  current user has permissions to the Orders module.
       *
       *
       *  Otherwise, the method throws an exception.
       *
       * @return the account number if the calling context meets the necessary criteria.
       */
      getBankAccountNumber(): string;
      /**
       * Returns the sum of the captured amounts. The captured amounts
       *  are calculated on the fly. Associate a payment capture for an Payment Instrument with an Invoice
       *  using Invoice method addCaptureTransaction.
       *
       * @return sum of captured amounts
       */
      getCapturedAmount(): dw.value.Money;
      /**
       * Returns the de-crypted creditcard number if the calling context meets
       *  the following criteria:
       *
       *
       *  If the method call happens in the context of a storefront request and
       *  the current authenticated customer is referenced by the basket or order, and the current protocol is HTTPS.
       *
       *
       *  If the customer is anonymous, and the order references this customer, and the protocol is secure and
       *  the order status is CREATED.
       *
       *
       *  If the method call happens in the context of the business manager and the
       *  current user has the permission to manage orders.
       *
       *
       *  If the payment information has not been masked as a result of the data retention security policy
       *  for the site.
       *
       *
       *  Otherwise, the method returns the masked credit card number.
       *
       * @return the de-crypted creditcard number if the calling context meets the necessary criteria.
       */
      getCreditCardNumber(): string;
      /**
       * Returns the Payment Transaction for this Payment Instrument or null.
       *
       * @return the Payment Transaction for this Payment Instrument or null.
       */
      getPaymentTransaction(): dw.order.PaymentTransaction;
      /**
       * Returns the sum of the refunded amounts. The refunded amounts
       *  are calculated on the fly. Associate a payment refund for an Payment Instrument with an Invoice
       *  using Invoice method addRefundTransaction.
       *
       * @return sum of refunded amounts
       */
      getRefundedAmount(): dw.value.Money;
    }

    /**
     * Contains constants representing different status codes
     *  for interacting with an order, such as cancelling
     *  or editing an order.
     */
    class OrderProcessStatusCodes {
      /**
       * Indicates that a coupon in the order is not valid.
       */
      static readonly COUPON_INVALID = "COUPON_INVALID";
      /**
       * Indicates that no inventory could be reserved for the order.
       */
      static readonly INVENTORY_RESERVATION_FAILED =
        "INVENTORY_RESERVATION_FAILED";
      /**
       * Indicates that the order could not be used because
       *  it has already been cancelled.
       */
      static readonly ORDER_ALREADY_CANCELLED = "ORDER_CANCELLED";
      /**
       * Indicates that the order could not be used because it
       *  has already been exported.
       */
      static readonly ORDER_ALREADY_EXPORTED = "ORDER_EXPORTED";
      /**
       * Indicates that the order could not be used because
       *  it has already been failed.
       */
      static readonly ORDER_ALREADY_FAILED = "ORDER_FAILED";
      /**
       * Indicates that the order could not be used because
       *  it has already been replaced.
       */
      static readonly ORDER_ALREADY_REPLACED = "ORDER_REPLACED";
      /**
       * Indicates that the order could not be used because it
       *  contains gift certificates.
       */
      static readonly ORDER_CONTAINS_GC = "CANCEL_ORDER_GC";
      /**
       * Indicates that the order could not be used because
       *  it is not cancelled.
       */
      static readonly ORDER_NOT_CANCELLED = "ORDER_NOT_CANCELLED";
      /**
       * Indicates that the order could not be used because
       *  it has not been failed.
       */
      static readonly ORDER_NOT_FAILED = "ORDER_NOT_FAILED";
      /**
       * Indicates that the order could not be used because
       *  it has not been placed.
       */
      static readonly ORDER_NOT_PLACED = "ORDER_NOT_PLACED";

      constructor();
    }

    /**
     * Represents payment cards and provides methods to access the payment card
     *  attributes and status.
     *  <p>
     *  <b>Note:</b> this class handles sensitive financial and card holder data.
     *  Pay special attention to PCI DSS v3. requirements 1, 3, 7, and 9.</p>
     */
    class PaymentCard extends dw.object.ExtensibleObject {
      /**
       * Returns 'true' if payment card is active (enabled), otherwise 'false' is returned.
       */
      readonly active: boolean;
      /**
       * The unique card type of the payment card.
       */
      readonly cardType: string;
      /**
       * The description of the payment card.
       */
      readonly description: dw.content.MarkupText;
      /**
       * The reference to the payment card image.
       */
      readonly image: dw.content.MediaFile;
      /**
       * The name of the payment card.
       */
      readonly name: string;

      /**
       * Returns the unique card type of the payment card.
       *
       * @return cardType of the payment card.
       */
      getCardType(): string;
      /**
       * Returns the description of the payment card.
       *
       * @return Description of the payment card.
       */
      getDescription(): dw.content.MarkupText;
      /**
       * Returns the reference to the payment card image.
       *
       * @return Image of the payment card.
       */
      getImage(): dw.content.MediaFile;
      /**
       * Returns the name of the payment card.
       *
       * @return Name of the payment card.
       */
      getName(): string;
      /**
       * Returns 'true' if payment card is active (enabled), otherwise 'false' is returned.
       *
       * @return true if payment card is active, otherwise false.
       */
      isActive(): boolean;
      /**
       * Returns 'true' if this payment card is applicable for the specified
       *  customer, country and payment amount and the session currency.
       *
       *
       *  The payment card is applicable if
       *
       *  the card is restricted by customer group, and at least one of the
       *  groups of the specified customer is assigned to the card
       *  the card is restricted by billing country, and the specified country
       *  code is assigned to the card
       *  the method is restricted by payment amount for the session currency,
       *  and the specified payment amount is within the limits of the min/max
       *  payment amount defined for the method and the session currency
       *  the method is restricted by session currency, and the session
       *  currency code is assigned to the method
       *
       *
       *  All parameters are optional, and if not specified, the respective
       *  restriction won't be validated. For example, if a card is restricted by
       *  billing country, but no country code is specified, this card will be
       *  returned, unless it is filtered out by customer group or payment amount.
       * @param customer Customer or null
       * @param countryCode Billing country code or null
       * @param paymentAmount Payment amount or null
       * @return true if payment card is applicable, false otherwise
       */
      isApplicable(
        customer: dw.customer.Customer,
        countryCode: string,
        paymentAmount: number
      ): boolean;
      /**
       * Verify the card against the provided values. This method is equivalent to
       *  verify(Number, Number, String, String) but omits verification of the
       *  card security code. If the verification fails the resulting
       *  Status will hold up to 2 error items each with a code:
       *
       *
       *  PaymentStatusCodes.CREDITCARD_INVALID_EXPIRATION_DATE - the expiresMonth and expiresYear do not describe a
       *  month in the future, or describe an invalid month outside the range 1-12.
       *  PaymentStatusCodes.CREDITCARD_INVALID_CARD_NUMBER - the cardNumber does not verify against one or more configured
       *  checks, which may include the Luhn checksum, accepted number lengths, or accepted number prefixes.
       * @param expiresMonth expiration month as integer, 1 (January) to 12 (December)
       * @param expiresYear expiration year as integer, e.g. 2025
       * @param cardNumber card number, a string containing digital characters
       * @return status indicating result
       */
      verify(
        expiresMonth: number,
        expiresYear: number,
        cardNumber: string
      ): dw.system.Status;
      /**
       * Verify the card against the provided values. If the verification fails the resulting
       *  Status will hold up to 3 error items with these codes:
       *
       *
       *  PaymentStatusCodes.CREDITCARD_INVALID_EXPIRATION_DATE  - the expiresMonth and expiresYear do not describe a
       *  month in the future, or describe an invalid month outside the range 1-12.
       *  PaymentStatusCodes.CREDITCARD_INVALID_CARD_NUMBER - the cardNumber does not verify against one or more configured
       *  checks, which may include the Luhn checksum, accepted number lengths, or accepted number prefixes.
       *  PaymentStatusCodes.CREDITCARD_INVALID_SECURITY_CODE - the card security code does not verify against the configured
       *  accepted length.
       * @param expiresMonth expiration month as integer, 1 (January) to 12 (December)
       * @param expiresYear expiration year as integer, e.g. 2025
       * @param cardNumber card number, a string containing digital characters
       * @param csc card security code, a string containing digital characters
       * @return status indicating result
       */
      verify(
        expiresMonth: number,
        expiresYear: number,
        cardNumber: string,
        csc: string
      ): dw.system.Status;
    }

    /**
     * Base class for payment instrument either stored in the customers profile
     *  or related to an order. A payment instrument can be credit card
     *  or bank transfer. The object defines standard methods for credit card
     *  payment, and can be extended by attributes appropriate for other
     *  payment methods.
     *  <p>
     *  <b>Note:</b> this class handles sensitive financial and card holder data.
     *  Pay special attention to PCI DSS v3. requirements 1, 3, 7, and 9.</p>
     */
    class PaymentInstrument extends dw.customer.EncryptedObject {
      /**
       * Constant for specification of the public key encryption algorithm RSA.
       */
      static readonly ENCRYPTION_ALGORITHM_RSA = "RSA";
      /**
       * Represents a bank transfer type of payment.
       */
      static readonly METHOD_BANK_TRANSFER = "BANK_TRANSFER";
      /**
       * Represents a 'bill me later' type of payment.
       */
      static readonly METHOD_BML = "BML";
      /**
       * Represents a credit card type of payment.
       */
      static readonly METHOD_CREDIT_CARD = "CREDIT_CARD";
      /**
       * Represents an Android Pay payment.
       */
      static readonly METHOD_DW_ANDROID_PAY = "DW_ANDROID_PAY";
      /**
       * Represents an Apple Pay payment.
       */
      static readonly METHOD_DW_APPLE_PAY = "DW_APPLE_PAY";
      /**
       * Represents a gift certificate.
       */
      static readonly METHOD_GIFT_CERTIFICATE = "GIFT_CERTIFICATE";

      /**
       * The driver's license number associated with the bank account if the
       *  calling context meets the following criteria:
       *
       *
       *  If the instance is a CustomerPaymentInstrument, and
       *  we are in the context of a storefront request, and the current customer
       *  is registered and authenticated, and the payment instrument is associated
       *  to the profile of the current customer, and the current protocol is HTTPS
       *
       *
       *  If the instance is a OrderPaymentInstrumentInfo, and we are in
       *  the context of a storefront request, and the current customer is identical
       *  to the customer related to the basket, and the current protocol is HTTPS
       *
       *
       *  If the instance is a OrderPaymentInstrumentInfo, and we are in
       *  the context of a business manager request, and the current user has the
       *  permission MANAGE_ORDERS
       *
       *
       *  If the instance is a OrderPaymentInstrumentInfo, and the account information
       *  has not been masked as a result of the data retention security policy
       *  for the site
       *
       *
       *
       *  Otherwise, the method returns the masked driver's license number.
       */
      bankAccountDriversLicense: string;
      /**
       * The last 4 characters of the decrypted driver's license number of
       *  the bank account associated with this PaymentInstrument.
       *
       *  If the number is empty or null
       *  it will be returned without an exception.
       */
      readonly bankAccountDriversLicenseLastDigits: string;
      /**
       * The driver's license state code associated with a bank account payment instrument.
       *  Returns null for other payment methods.
       */
      bankAccountDriversLicenseStateCode: string;
      /**
       * The full name of the holder of a bank account payment instrument.
       *  Returns null for other payment methods.
       */
      bankAccountHolder: string;
      /**
       * The bank account number if the calling context meets
       *  the following criteria:
       *
       *
       *  If the instance is a CustomerPaymentInstrument, and
       *  we are in the context of a storefront request, and the current customer
       *  is registered and authenticated, and the payment instrument is associated
       *  to the profile of the current customer, and the current protocol is HTTPS
       *
       *
       *  If the instance is a OrderPaymentInstrumentInfo, and we are in
       *  the context of a storefront request, and the current customer is identical
       *  to the customer related to the basket, and the current protocol is HTTPS
       *
       *
       *  If the instance is a OrderPaymentInstrumentInfo, and we are in
       *  the context of a business manager request, and the current user has the
       *  permission MANAGE_ORDERS
       *
       *
       *  If the instance is a OrderPaymentInstrumentInfo, and the account information
       *  has not been masked as a result of the data retention security policy
       *  for the site
       *
       *
       *
       *  Otherwise, the method returns the masked bank account number.
       */
      bankAccountNumber: string;
      /**
       * The last 4 characters of the decrypted bank account number.
       *
       *  If the number is empty or null,
       *  it will be returned without an exception.
       */
      readonly bankAccountNumberLastDigits: string;
      /**
       * The bank routing number of a bank account payment instrument.
       *  Returns null for other payment methods.
       *
       *  If account information has been masked due to the data retention security
       *  policy for the site, the return value is fully masked.
       */
      bankRoutingNumber: string;
      /**
       * The month of the year in which the credit card
       *  expires (1-12).
       */
      creditCardExpirationMonth: number;
      /**
       * The year in which the credit card
       *  expires, such as '2004'.
       */
      creditCardExpirationYear: number;
      /**
       * Returns true if this payment instrument represents an expired credit
       *  card. This check is only logical if the credit card expiration month and
       *  year are set. If either of these attributes are not set, then this method
       *  always returns false.
       */
      readonly creditCardExpired: boolean;
      /**
       * The name of the credit card owner.
       */
      creditCardHolder: string;
      /**
       * The credit card issue number.  This attribute is only used by
       *  specific credit/debit card processors such as Solo and Switch in the UK.
       */
      creditCardIssueNumber: string;
      /**
       * The decrypted credit card number if the calling context meets
       *  the following criteria:
       *
       *
       *  If the instance is a CustomerPaymentInstrument, and
       *  we are in the context of a storefront request, and the current customer
       *  is registered and authenticated, and the payment instrument is associated
       *  to the profile of the current customer, and the current protocol is HTTPS
       *
       *
       *  If the instance is a OrderPaymentInstrument in the context of a storefront request, and
       *  the current authenticated customer is referenced by the basket or order, and
       *  the current protocol is HTTPS.
       *
       *
       *  If the customer is anonymous, and the customer is referenced by the order, and the protocol is secure and
       *  the order status is CREATED.
       *
       *
       *  If the instance is a OrderPaymentInstrument, and we are in
       *  the context of a business manager request, and the current user has the
       *  permission MANAGE_ORDERS
       *
       *
       *  If the instance is a OrderPaymentInstrument, and the account information
       *  has not been masked as a result of the data retention security policy
       *  for the site
       *
       *
       *
       *  Otherwise, the method returns the masked credit card number.
       */
      creditCardNumber: string;
      /**
       * The last 4 characters of the decrypted credit card number.
       *
       *  If the number is empty or null
       *  it will be returned without an exception.
       */
      readonly creditCardNumberLastDigits: string;
      /**
       * Secure credit card data can be replaced by a token by utilizing a
       *  tokenization provider, which securely stores the credit card data using
       *  the token as a key. The stored data can later reused by including the
       *  token in a request. In this way credit card processes such as
       *  authorization and capture can be implemented without being responsible
       *  for persisting the credit card data.
       */
      creditCardToken: string;
      /**
       * The type of the credit card.
       */
      creditCardType: string;
      /**
       * The month of the year in which the credit card became
       *  valid (1-12).  This attribute is not used by all credit card types.
       */
      creditCardValidFromMonth: number;
      /**
       * The year in which the credit card became valid, such as '2001'.
       *  This attribute is not used by all credit card types.
       */
      creditCardValidFromYear: number;
      /**
       * The Gift Certificate code for this Payment Instrument.
       */
      giftCertificateCode: string;
      /**
       * The Gift Certificate ID for this Payment Instrument.
       */
      giftCertificateID: string;
      /**
       * The decrypted driver's license number of the bank account with
       *  all but the last 4 characters replaced with a '*' character.
       *
       *  If the driver's license number is empty,
       *  it will be returned without an exception.
       */
      readonly maskedBankAccountDriversLicense: string;
      /**
       * The decrypted bank account number with
       *  all but the last 4 characters replaced with a '*' character.
       *
       *  If the number is empty (i.e. "" or null),
       *  it will be returned without an exception.
       */
      readonly maskedBankAccountNumber: string;
      /**
       * The decrypted credit card number with
       *  all but the last 4 characters replaced with a '*' character.
       *
       *  If the number is empty,
       *  it will be returned without an exception.
       */
      readonly maskedCreditCardNumber: string;
      /**
       * The masked gift certificate code with
       *  all but the last 4 characters replaced with a '*' character.
       */
      readonly maskedGiftCertificateCode: string;
      /**
       * The identifier of the payment method represented by this
       *  payment instrument.
       */
      readonly paymentMethod: string;
      /**
       * Returns true if the account information for this Payment Instrument
       *  has been permanently masked as a result of the data retention security policy
       *  for the site or a creditcard tokenization, and false otherwise.
       *
       *  When account information is masked only the last 4 digits of the credit card
       *  or bank account number are recoverable.  The bank account driver's license number
       *  and bank routing number are completely masked.
       */
      readonly permanentlyMasked: boolean;

      /**
       * Returns the driver's license number associated with the bank account if the
       *  calling context meets the following criteria:
       *
       *
       *  If the instance is a CustomerPaymentInstrument, and
       *  we are in the context of a storefront request, and the current customer
       *  is registered and authenticated, and the payment instrument is associated
       *  to the profile of the current customer, and the current protocol is HTTPS
       *
       *
       *  If the instance is a OrderPaymentInstrumentInfo, and we are in
       *  the context of a storefront request, and the current customer is identical
       *  to the customer related to the basket, and the current protocol is HTTPS
       *
       *
       *  If the instance is a OrderPaymentInstrumentInfo, and we are in
       *  the context of a business manager request, and the current user has the
       *  permission MANAGE_ORDERS
       *
       *
       *  If the instance is a OrderPaymentInstrumentInfo, and the account information
       *  has not been masked as a result of the data retention security policy
       *  for the site
       *
       *
       *
       *  Otherwise, the method returns the masked driver's license number.
       *
       * @return the driver's license number if the calling context meets the necessary criteria.
       */
      getBankAccountDriversLicense(): string;
      /**
       * Returns the last 4 characters of the decrypted driver's license number of
       *  the bank account associated with this PaymentInstrument.
       *
       *  If the number is empty or null
       *  it will be returned without an exception.
       *
       * @return the last 4 characters of the de-crypted driver's license number.
       */
      getBankAccountDriversLicenseLastDigits(): string;
      /**
       * Returns the last specified number of characters of the decrypted driver's license number of
       *  the bank account associated with this PaymentInstrument.
       *
       *  If the number is empty (i.e. "" or null),
       *  it will be returned without an exception.
       *
       *  Note that count is limited to 4 in an unsecure environment,
       *  and if account information for this payment instrument has been masked
       *  due to the data retention security policy for the site.
       * @param count number of characters to be returned.
       * @return the last specified number of characters of the decrypted driver's license number.
       */
      getBankAccountDriversLicenseLastDigits(count: number): string;
      /**
       * Returns the driver's license state code associated with a bank account payment instrument.
       *  Returns null for other payment methods.
       *
       * @return the state in which the bank account driver's license was issued.
       */
      getBankAccountDriversLicenseStateCode(): string;
      /**
       * Returns the full name of the holder of a bank account payment instrument.
       *  Returns null for other payment methods.
       *
       * @return the bank account holder's full name.
       */
      getBankAccountHolder(): string;
      /**
       * Returns the bank account number if the calling context meets
       *  the following criteria:
       *
       *
       *  If the instance is a CustomerPaymentInstrument, and
       *  we are in the context of a storefront request, and the current customer
       *  is registered and authenticated, and the payment instrument is associated
       *  to the profile of the current customer, and the current protocol is HTTPS
       *
       *
       *  If the instance is a OrderPaymentInstrumentInfo, and we are in
       *  the context of a storefront request, and the current customer is identical
       *  to the customer related to the basket, and the current protocol is HTTPS
       *
       *
       *  If the instance is a OrderPaymentInstrumentInfo, and we are in
       *  the context of a business manager request, and the current user has the
       *  permission MANAGE_ORDERS
       *
       *
       *  If the instance is a OrderPaymentInstrumentInfo, and the account information
       *  has not been masked as a result of the data retention security policy
       *  for the site
       *
       *
       *
       *  Otherwise, the method returns the masked bank account number.
       *
       * @return the bank account number if the calling context meets the necessary criteria.
       */
      getBankAccountNumber(): string;
      /**
       * Returns the last 4 characters of the decrypted bank account number.
       *
       *  If the number is empty or null,
       *  it will be returned without an exception.
       *
       * @return the last 4 characters of the decrypted bank account number.
       */
      getBankAccountNumberLastDigits(): string;
      /**
       * Returns the last specified number of characters of the decrypted bank account card number.
       *
       *  If the number is empty (i.e. "" or null),
       *  it will be returned without an exception.
       *
       *  Note that count is limited to 4 in an unsecure environment,
       *  and if account information for this payment instrument has been masked
       *  due to the data retention security policy for the site.
       * @param count number of characters to be returned.
       * @return the last specified characters of the decrypted bank account number.
       */
      getBankAccountNumberLastDigits(count: number): string;
      /**
       * Returns the bank routing number of a bank account payment instrument.
       *  Returns null for other payment methods.
       *
       *  If account information has been masked due to the data retention security
       *  policy for the site, the return value is fully masked.
       *
       * @return the bank account rounting number.
       */
      getBankRoutingNumber(): string;
      /**
       * Returns the month of the year in which the credit card
       *  expires (1-12).
       *
       * @return the month of the year in which the credit card expires (1-12).
       */
      getCreditCardExpirationMonth(): number;
      /**
       * Returns the year in which the credit card
       *  expires, such as '2004'.
       *
       * @return the year in which the credit card expires.
       */
      getCreditCardExpirationYear(): number;
      /**
       * Returns the name of the credit card owner.
       *
       * @return the name of the credit card owner.
       */
      getCreditCardHolder(): string;
      /**
       * Returns the credit card issue number.  This attribute is only used by
       *  specific credit/debit card processors such as Solo and Switch in the UK.
       *
       * @return the credit card issue number
       */
      getCreditCardIssueNumber(): string;
      /**
       * Returns the decrypted credit card number if the calling context meets
       *  the following criteria:
       *
       *
       *  If the instance is a CustomerPaymentInstrument, and
       *  we are in the context of a storefront request, and the current customer
       *  is registered and authenticated, and the payment instrument is associated
       *  to the profile of the current customer, and the current protocol is HTTPS
       *
       *
       *  If the instance is a OrderPaymentInstrument in the context of a storefront request, and
       *  the current authenticated customer is referenced by the basket or order, and
       *  the current protocol is HTTPS.
       *
       *
       *  If the customer is anonymous, and the customer is referenced by the order, and the protocol is secure and
       *  the order status is CREATED.
       *
       *
       *  If the instance is a OrderPaymentInstrument, and we are in
       *  the context of a business manager request, and the current user has the
       *  permission MANAGE_ORDERS
       *
       *
       *  If the instance is a OrderPaymentInstrument, and the account information
       *  has not been masked as a result of the data retention security policy
       *  for the site
       *
       *
       *
       *  Otherwise, the method returns the masked credit card number.
       *
       * @return the decrypted credit card number if the calling context meets the necessary criteria.
       */
      getCreditCardNumber(): string;
      /**
       * Returns the last 4 characters of the decrypted credit card number.
       *
       *  If the number is empty or null
       *  it will be returned without an exception.
       *
       * @return the last 4 characters of the de-crypted credit card number.
       */
      getCreditCardNumberLastDigits(): string;
      /**
       * Returns the last specified number of characters of the decrypted credit card number.
       *
       *  If the number is empty (i.e. "" or null),
       *  it will be returned without an exception.
       *
       *  Note that count is limited to 4 in an unsecure environment,
       *  and if account information for this payment instrument has been masked
       *  due to the data retention security policy for the site.
       * @param count number of characters to be returned.
       * @return the last specified number of characters of the decrypted credit card number.
       */
      getCreditCardNumberLastDigits(count: number): string;
      /**
       * Secure credit card data can be replaced by a token by utilizing a
       *  tokenization provider, which securely stores the credit card data using
       *  the token as a key. The stored data can later reused by including the
       *  token in a request. In this way credit card processes such as
       *  authorization and capture can be implemented without being responsible
       *  for persisting the credit card data.
       *
       * @return the token
       */
      getCreditCardToken(): string;
      /**
       * Returns the type of the credit card.
       *
       * @return the type of the credit card.
       */
      getCreditCardType(): string;
      /**
       * Returns the month of the year in which the credit card became
       *  valid (1-12).  This attribute is not used by all credit card types.
       *
       * @return the month of the year in which the credit card became valid (1-12).
       */
      getCreditCardValidFromMonth(): number;
      /**
       * Returns the year in which the credit card became valid, such as '2001'.
       *  This attribute is not used by all credit card types.
       *
       * @return the year in which the credit card became valid
       */
      getCreditCardValidFromYear(): number;
      /**
       * Encrypts the driver's license number of the bank account of this object with the given algorithm
       *  and the given public key. Returned is the base64-encoded representation
       *  of the result.
       *  See also Cipher.encrypt(String, String, String, String, Number) on how to generate RSA key pairs.
       *
       *  If account information has been masked due to the data retention security
       *  policy for the site, the returned value is the base64-encoded representation
       *  of the encrypted form of the masked number.
       * @param algorithm The algorithm to be used for the encryption of this bank account driver's license. Currently only "RSA" is supported.
       * @param publicKey A base64 encoded form of the public key to be used to encrypt this bank account driver's license number.
       * @return the base64-encoded representation of the bank account driver's license.
       */
      getEncryptedBankAccountDriversLicense(
        algorithm: string,
        publicKey: string
      ): string;
      /**
       * Encrypts the bank account number of this object with the given algorithm
       *  and the given public key. Returned is the base64-encoded representation
       *  of the result.
       *
       *  If account information has been masked due to the data retention security
       *  policy for the site, the returned value is the base64-encoded representation
       *  of the encrypted form of the masked number.
       * @param algorithm The algorithm to be used for the encryption of this credit card number. Currently only "RSA" is supported.
       * @param publicKey A base64 encoded form of the public key to be used to encrypt this credit card number.
       * @return the base64-encoded representation of the bank account number.
       */
      getEncryptedBankAccountNumber(
        algorithm: string,
        publicKey: string
      ): string;
      /**
       * Encrypts the credit card number of this object with the given algorithm
       *  and the given public key. Returned is the base64-encoded representation
       *  of the result.
       *  See also Cipher.encrypt(String, String, String, String, Number) on how to generate RSA key pairs.
       *
       *  If account information has been masked due to the data retention security
       *  policy for the site, the returned value is the base64-encoded representation
       *  of the encrypted form of the masked number.
       * @param algorithm The algorithm to be used for the encryption of this credit card number. Currently only "RSA" is supported.
       * @param publicKey A base64 encoded form of the public key to be used to encrypt this credit card number.
       * @return the base64-encoded representation of the credit card number.
       */
      getEncryptedCreditCardNumber(
        algorithm: string,
        publicKey: string
      ): string;
      /**
       * Encrypts the credit card number of this object with the given algorithm
       *  and the public key taken from a certificate in the keystore.
       *  Returned is the base64-encoded representation of the result.
       *  See also Cipher.encrypt(String, CertificateRef, String, String, Number) on how to generate RSA key pairs.
       *
       *  If account information has been masked due to the data retention security
       *  policy for the site, the returned value is the base64-encoded representation
       *  of the encrypted form of the masked number.
       * @param algorithm The algorithm to be used for the encryption of this credit card number. Currently only "RSA" is supported.
       * @param publicKey A reference to a trusted certificate entry containing the public key in the keystore.
       * @return the base64-encoded representation of the credit card number.
       */
      getEncryptedCreditCardNumber(
        algorithm: string,
        publicKey: dw.crypto.CertificateRef
      ): string;
      /**
       * Returns the Gift Certificate code for this Payment Instrument.
       *
       * @return the Gift Certificate code or null if not set.
       */
      getGiftCertificateCode(): string;
      /**
       * Returns the Gift Certificate ID for this Payment Instrument.
       *
       * @return the Gift Certificate ID or null if not set.
       */
      getGiftCertificateID(): string;
      /**
       * Returns the decrypted driver's license number of the bank account with
       *  all but the last 4 characters replaced with a '*' character.
       *
       *  If the driver's license number is empty,
       *  it will be returned without an exception.
       *
       * @return the decrypted driver's license number with all but the last 4 characters replaced with a '*' character.
       */
      getMaskedBankAccountDriversLicense(): string;
      /**
       * Returns the decrypted driver's license number of the bank account with
       *  all but the specified number characters replaced with a '*' character.
       *
       *  If the driver's license number is empty (i.e. "" or null),
       *  it will be returned without an exception.
       *
       *  Note that ignore is limited to 4 in an unsecure environment,
       *  and if account information for this payment instrument has been masked
       *  due to the data retention security policy for the site.
       * @param ignore the number of characters to leave unmasked.
       * @return the decrypted driver's license number with all but the specified number characters replaced with a '*' character.
       */
      getMaskedBankAccountDriversLicense(ignore: number): string;
      /**
       * Returns the decrypted bank account number with
       *  all but the last 4 characters replaced with a '*' character.
       *
       *  If the number is empty (i.e. "" or null),
       *  it will be returned without an exception.
       *
       * @return the decrypted bank account number with all but the last 4 characters replaced with a '*' character.
       */
      getMaskedBankAccountNumber(): string;
      /**
       * Returns the decrypted bank account number with
       *  all but the specified number characters replaced with a '*' character.
       *
       *  If the card number is empty (i.e. "" or null),
       *  it will be returned without an exception.
       *
       *  Note that ignore is limited to 4 in an unsecure environment,
       *  and if account information for this payment instrument has been masked
       *  due to the data retention security policy for the site.
       * @param ignore the number of characters to leave unmasked
       * @return the decrypted bank account number with all but the specified number of characters replaced with a '*' character.
       */
      getMaskedBankAccountNumber(ignore: number): string;
      /**
       * Returns the decrypted credit card number with
       *  all but the last 4 characters replaced with a '*' character.
       *
       *  If the number is empty,
       *  it will be returned without an exception.
       *
       * @return the decrypted credit card number with all but the last 4 characters replaced with a '*' character.
       */
      getMaskedCreditCardNumber(): string;
      /**
       * Returns the decrypted credit card number with
       *  all but the specified number characters replaced with a '*' character.
       *
       *  If the card number is empty (i.e. "" or null),
       *  it will be returned without an exception.
       *
       *  Note that ignore is limited to 4 in an unsecure environment,
       *  and if account information for this payment instrument has been masked
       *  due to the data retention security policy for the site.
       * @param ignore the number of characters to leave unmasked.
       * @return the decrypted credit card number with all but the specified number characters replaced with a '*' character.
       */
      getMaskedCreditCardNumber(ignore: number): string;
      /**
       * Returns the masked gift certificate code with
       *  all but the last 4 characters replaced with a '*' character.
       *
       * @return the masked gift certificate code.
       */
      getMaskedGiftCertificateCode(): string;
      /**
       * Returns the masked gift certificate code with
       *  all but the specified number of characters replaced with a '*' character.
       * @param ignore the number of characters to leave unmasked.
       * @return the masked gift certificate code.
       */
      getMaskedGiftCertificateCode(ignore: number): string;
      /**
       * Returns the identifier of the payment method represented by this
       *  payment instrument.
       *
       * @return the identifier of the payment method represented by this payment instrument.
       */
      getPaymentMethod(): string;
      /**
       * Returns true if this payment instrument represents an expired credit
       *  card. This check is only logical if the credit card expiration month and
       *  year are set. If either of these attributes are not set, then this method
       *  always returns false.
       *
       * @return true if this payment instrument represents an expired credit card, false otherwise
       */
      isCreditCardExpired(): boolean;
      /**
       * Returns true if the account information for this Payment Instrument
       *  has been permanently masked as a result of the data retention security policy
       *  for the site or a creditcard tokenization, and false otherwise.
       *
       *  When account information is masked only the last 4 digits of the credit card
       *  or bank account number are recoverable.  The bank account driver's license number
       *  and bank routing number are completely masked.
       *
       * @return whether or not the account information has been masked
       */
      isPermanentlyMasked(): boolean;
      /**
       * Set the driver's license number associated with a bank account payment instrument.
       * @param license the bank account holder driver's license.
       */
      setBankAccountDriversLicense(license: string): void;
      /**
       * Set the driver's license state code associated with a bank account payment instrument.
       * @param stateCode the state in which the bank account driver's license was issued.
       */
      setBankAccountDriversLicenseStateCode(stateCode: string): void;
      /**
       * Set the full name of the holder of a bank account payment instrument.
       * @param holder the bank account holder's full name.
       */
      setBankAccountHolder(holder: string): void;
      /**
       * Set the bank account number of a bank account payment instrument.
       * @param accountNumber the bank account number.
       */
      setBankAccountNumber(accountNumber: string): void;
      /**
       * Set the bank routing number of a bank account payment instrument.
       * @param routingNumber the bank account rounting number.
       */
      setBankRoutingNumber(routingNumber: string): void;
      /**
       * Sets the month of the year in which the credit card
       *  expires. Permissible values are from 1 to 12.
       * @param aValue the month of the year in which the credit card expires. Permissible values are from 1 to 12.
       */
      setCreditCardExpirationMonth(aValue: number): void;
      /**
       * Sets the year in which the credit card
       *  expires, such as '2004'.
       * @param aValue the year in which the credit card expires.
       */
      setCreditCardExpirationYear(aValue: number): void;
      /**
       * Sets the name of the credit card owner.
       * @param aValue the name of the credit card owner.
       */
      setCreditCardHolder(aValue: string): void;
      /**
       * Set the credit card issue number.  This attribute is only used by
       *  specific credit/debit card processors such as Solo and Switch in the UK.
       * @param aValue the credit card issue number
       */
      setCreditCardIssueNumber(aValue: string): void;
      /**
       * Sets the credit card number for this payment.
       * @param aValue the new value of the credit card number.
       */
      setCreditCardNumber(aValue: string): void;
      /**
       * Secure credit card data can be replaced by a token by utilizing a
       *  tokenization provider, which securely stores the credit card data using
       *  the token as a key. The stored data can later reused by including the
       *  token in a request. In this way credit card processes such as
       *  authorization and capture can be implemented without being responsible
       *  for persisting the credit card data.
       *
       *  An Exception will be thrown when the token is null or blank.
       *
       *  When setting a credit card token, the account information (including the
       *  creditcard number) is masked and all creditcard attributes are frozen and
       *  an attempt to change will be result in an exception.
       * @param token the token
       */
      setCreditCardToken(token: string): void;
      /**
       * Sets the type of the credit card.
       * @param aValue the type of the credit card.
       */
      setCreditCardType(aValue: string): void;
      /**
       * Sets the month of the year in which the credit card became valid (1-12).
       *  This attribute is not used by all credit card types
       * @param aValue the month of the year in which the credit card became valid (1-12).
       */
      setCreditCardValidFromMonth(aValue: number): void;
      /**
       * Sets the year in which the credit card became valid, such as '2001'.
       *  This attribute is not used by all credit card types.
       * @param aValue the year in which the credit card became valid
       */
      setCreditCardValidFromYear(aValue: number): void;
      /**
       * Sets the Gift Certificate code for this Payment Instrument.
       * @param giftCertificateCode the Gift Certificate code.
       */
      setGiftCertificateCode(giftCertificateCode: string): void;
      /**
       * Sets the Gift Certificate ID for this Payment Instrument.
       * @param giftCertificateID the Gift Certificate ID.
       */
      setGiftCertificateID(giftCertificateID: string): void;
    }

    /**
     * The PaymentMethod class represents a logical type of payment a customer can
     *  make in the storefront. This class provides methods to access the payment
     *  method attributes, status, and (for card-based payment methods) the related
     *  payment cards.
     *  <p>
     *  A typical storefront presents the customer a list of payment methods that a
     *  customer can choose from after he has entered his billing address during the
     *  checkout.
     *  <a href="class_dw_order_PaymentMgr.html#dw_order_PaymentMgr_getApplicablePaymentMethods_Customer_String_Number_DetailAnchor">PaymentMgr.getApplicablePaymentMethods(Customer, String, Number)</a>
     *  is used to determine the PaymentMethods that are relevant for the customer
     *  based on the amount of his order, his customer groups, and his shipping
     *  address.</p>
     */
    class PaymentMethod extends dw.object.ExtensibleObject {
      /**
       * Returns 'true' if payment method is active (enabled), otherwise 'false' is returned.
       */
      readonly active: boolean;
      /**
       * Returns enabled payment cards that are assigned to this payment method, regardless
       *  of current customer, country or payment amount restrictions.
       *  The payment cards are sorted as defined in the Business Manager.
       */
      readonly activePaymentCards: dw.util.List<dw.order.PaymentCard>;
      /**
       * The description of the payment method.
       */
      readonly description: dw.content.MarkupText;
      /**
       * The unique ID of the payment method.
       */
      readonly ID: string;
      /**
       * The reference to the payment method image.
       */
      readonly image: dw.content.MediaFile;
      /**
       * The name of the payment method.
       */
      readonly name: string;
      /**
       * The payment processor associated to this payment method.
       */
      readonly paymentProcessor: dw.order.PaymentProcessor;

      /**
       * Returns enabled payment cards that are assigned to this payment method, regardless
       *  of current customer, country or payment amount restrictions.
       *  The payment cards are sorted as defined in the Business Manager.
       *
       * @return List of enabled payment cards of current site
       */
      getActivePaymentCards(): dw.util.List<dw.order.PaymentCard>;
      /**
       * Returns the sorted list of all enabled payment cards of this payment
       *  method applicable for the specified customer, country, payment amount and the session currency
       *  The payment cards are sorted as defined in the Business Manager.
       *
       *  A payment card is applicable if
       *
       *   the card is restricted by customer group, and at least one of
       *  the groups of the specified customer is assigned to the card
       *   the card is restricted by billing country, and the specified
       *  country code is assigned to the card
       *  the card is restricted by payment amount for the session currency,
       *  and the specified payment amount is within the limits of the min/max
       *  payment amount defined for the method and the session currency
       *   the card is restricted by currency code, and the specified
       *  currency code matches session currency.
       *
       *
       *  All parameters are optional, and if not specified, the respective
       *  restriction won't be validated. For example, if a card is restricted
       *  by billing country, but no country code is specified, this card will
       *  be returned, unless it is filtered out by customer group or payment
       *  amount.
       * @param customer Customer or null
       * @param countryCode Billing country code or null
       * @param paymentAmount Payment amount or null
       * @return List of applicable payment cards of this payment method
       */
      getApplicablePaymentCards(
        customer: dw.customer.Customer,
        countryCode: string,
        paymentAmount: number
      ): dw.util.List<dw.order.PaymentCard>;
      /**
       * Returns the description of the payment method.
       *
       * @return Description of the payment method.
       */
      getDescription(): dw.content.MarkupText;
      /**
       * Returns the unique ID of the payment method.
       *
       * @return ID of the payment method.
       */
      getID(): string;
      /**
       * Returns the reference to the payment method image.
       *
       * @return Image of the payment method.
       */
      getImage(): dw.content.MediaFile;
      /**
       * Returns the name of the payment method.
       *
       * @return Name of the payment method.
       */
      getName(): string;
      /**
       * Returns the payment processor associated to this payment method.
       *
       * @return the payment processor associated to this payment method.
       */
      getPaymentProcessor(): dw.order.PaymentProcessor;
      /**
       * Returns 'true' if payment method is active (enabled), otherwise 'false' is returned.
       *
       * @return true if payment method is active, otherwise false.
       */
      isActive(): boolean;
      /**
       * Returns 'true' if this payment method is applicable for the specified
       *  customer, country and payment amount and the session currency.
       *
       *
       *  The payment method is applicable if
       *
       *  the method is restricted by customer group, and at least one of the
       *  groups of the specified customer is assigned to the method
       *  the method is restricted by billing country, and the specified
       *  country code is assigned to the method
       *  the method is restricted by payment amount for the session currency,
       *  and the specified payment amount is within the limits of the min/max
       *  payment amount defined for the method and the session currency
       *  the method is restricted by currency code, and the specified
       *  currency code matches session currency.
       *
       *
       *  All parameters are optional, and if not specified, the respective
       *  restriction won't be validated. For example, if a method is restricted by
       *  billing country, but no country code is specified, this method will be
       *  returned, unless it is filtered out by customer group or payment amount.
       * @param customer Customer or null
       * @param countryCode Billing country code or null
       * @param paymentAmount Payment amount or null
       * @return true if payment method is applicable, false otherwise
       */
      isApplicable(
        customer: dw.customer.Customer,
        countryCode: string,
        paymentAmount: number
      ): boolean;
    }

    /**
     * <a href="class_dw_order_PaymentMgr.html">PaymentMgr</a> is used to access payment methods and payment
     *  cards of the current site.
     *  <p>
     *  To access payment methods and payment cards explicitly, use methods
     *  <a href="class_dw_order_PaymentMgr.html#dw_order_PaymentMgr_getPaymentMethod_String_DetailAnchor">getPaymentMethod(String)</a> and <a href="class_dw_order_PaymentMgr.html#dw_order_PaymentMgr_getPaymentCard_String_DetailAnchor">getPaymentCard(String)</a>.</p>
     *  <p>
     *  To access active payment methods use method <a href="class_dw_order_PaymentMgr.html#dw_order_PaymentMgr_getActivePaymentMethods_DetailAnchor">getActivePaymentMethods()</a>.</p>
     *  <p>
     *  To access applicable payment methods for a customer, country and/or payment
     *  amount use method <a href="class_dw_order_PaymentMgr.html#dw_order_PaymentMgr_getApplicablePaymentMethods_Customer_String_Number_DetailAnchor">getApplicablePaymentMethods(Customer, String, Number)</a>.</p>
     */
    class PaymentMgr {
      /**
       * The sorted list of all enabled payment methods of the current
       *  site, regardless of any customer group, country, payment amount or currency
       *  restrictions. The payment methods are sorted as defined in the Business
       *  Manager.
       */
      static readonly activePaymentMethods: dw.util.List<
        dw.order.PaymentMethod
      >;

      /**
       * Returns the sorted list of all enabled payment methods of the current
       *  site, regardless of any customer group, country, payment amount or currency
       *  restrictions. The payment methods are sorted as defined in the Business
       *  Manager.
       *
       * @return List of enabled payment methods of current site
       */
      static getActivePaymentMethods(): dw.util.List<dw.order.PaymentMethod>;
      /**
       * Returns the sorted list of all enabled payment methods of the current
       *  site applicable for the session currency, specified customer, country and payment amount.
       *  The payment methods are sorted as defined in the Business Manager.
       *
       *  A payment method is applicable if
       *
       *   the method is restricted by customer group, and at least one of
       *  the groups of the specified customer is assigned to the method
       *   the method is restricted by billing country, and the specified
       *  country code is assigned to the method
       *  the method is restricted by payment amount for the session currency,
       *  and the specified payment amount is within the limits of the min/max
       *  payment amount defined for the method and the session currency
       *   the method is restricted by currency code, and the specified
       *  currency code matches session currency.
       *
       *
       *  All parameters are optional, and if not specified, the respective
       *  restriction won't be validated. For example, if a method is restricted
       *  by billing country, but no country code is specified, this method will
       *  be returned, unless it is filtered out by customer group or payment
       *  amount.
       * @param customer Customer or null
       * @param countryCode Billing country code or null
       * @param paymentAmount Payment amount or null
       * @return List of applicable payment methods of current site
       */
      static getApplicablePaymentMethods(
        customer: dw.customer.Customer,
        countryCode: string,
        paymentAmount: number
      ): dw.util.List<dw.order.PaymentMethod>;
      /**
       * Returns the payment card for the specified cardType or null if no such
       *  card exists in the current site.
       * @param cardType PaymentCard type
       * @return PaymentCard or null
       */
      static getPaymentCard(cardType: string): dw.order.PaymentCard;
      /**
       * Returns the payment method for the specified ID or null if no such method
       *  exists in the current site.
       * @param id PaymentMethod ID
       * @return PaymentMethod or null
       */
      static getPaymentMethod(id: string): dw.order.PaymentMethod;
    }

    /**
     * A PaymentProcessor represents an entity that processes payments of one or
     *  more types. In the Commerce Cloud Digital system, a payment processor is just a container
     *  for configuration values, which describe, for example, the parameters (URL,
     *  merchant ID, password, etc) required for connecting to a payment gateway.
     *  <p>
     *  The system has several built in PaymentProcessors. These are:
     *
     *  </p><ul>
     *  <li>BASIC_CREDIT</li>
     *  <li>BASIC_GIFT_CERTIFICATE</li>
     *  <li>CYBERSOURCE_CREDIT</li>
     *  <li>CYBERSOURCE_BML</li>
     *  <li>PAYPAL_CREDIT</li>
     *  <li>PAYPAL_EXPRESS</li>
     *  <li>VERISIGN_CREDIT</li>
     *  </ul>
     *
     *  The first two of these are merely placeholders with no associated preference
     *  values. The remaining system payment processors define preference values
     *  which are maintained in the Business Manager and are used in conjunction with
     *  built-in Commerce Cloud Digital payment integrations. Preferences of system
     *  PaymentProcessors are not intended to be read programmatically.
     *  <p>
     *  Merchants may also define custom payment processors. This is done by defining
     *  a payment processor with an arbitrary ID in the Business Manager, and then
     *  configuring an attribute group with the same ID on the
     *  <a href="class_dw_system_SitePreferences.html">SitePreferences</a> system object. Attributes added to the
     *  group will be considered preferences of the payment processor and will be
     *  readable through <a href="class_dw_order_PaymentProcessor.html#dw_order_PaymentProcessor_getPreferenceValue_String_DetailAnchor">getPreferenceValue(String)</a>. Merchants can design
     *  their checkout process to read these preferences at run time for connecting
     *  to their payment gateways.
     *  </p><p>
     *  Every <a href="class_dw_order_PaymentMethod.html">PaymentMethod</a> in the system is associated with at most
     *  one PaymentProcessor. This basically represents the physical payment gateway
     *  which processes the (logical) payment method. Each payment processor may be
     *  associated with an arbitrary number of payment methods. Also, each payment
     *  transaction has one PaymentProcessor which is set by custom code during the
     *  checkout process.</p>
     */
    class PaymentProcessor extends dw.object.ExtensibleObject {
      /**
       * The 'ID' of this processor.
       */
      readonly ID: string;

      /**
       * Returns the 'ID' of this processor.
       *
       * @return the 'ID' of this processor, e.g. "BASIC_CREDIT".
       */
      getID(): string;
      /**
       * Returns the value of the specified preference for this payment processor.
       *  If the preference name is invalid (or null) or no preference value is
       *  defined for this payment processor, null is returned.
       * @param name preference name. Typically an attribute defined on SitePreferences contained in an attribute group whose name is the same as this.ID.
       * @return preference value, or null.
       */
      getPreferenceValue(name: string): any;
    }

    /**
     * Helper class containing status codes for the various errors that can occur
     *  when validating a payment card. One of these codes is returned as part of a
     *  Status object when a unsuccessful call to the <code>VerifyPaymentCard</code>
     *  or <code>VerifyCreditCard</code> pipelet is made. The same codes are used
     *  when calling <a href="class_dw_order_PaymentCard.html#dw_order_PaymentCard_verify_Number_Number_String_DetailAnchor">PaymentCard.verify(Number, Number, String)</a> or
     *  <a href="class_dw_order_PaymentCard.html#dw_order_PaymentCard_verify_Number_Number_String_String_DetailAnchor">PaymentCard.verify(Number, Number, String, String)</a>.
     */
    class PaymentStatusCodes {
      /**
       * The code indicates that the credit card number is incorrect.
       */
      static readonly CREDITCARD_INVALID_CARD_NUMBER =
        "CREDITCARD_INVALID_CARD_NUMBER";
      /**
       * The code indicates that the credit card is expired.
       */
      static readonly CREDITCARD_INVALID_EXPIRATION_DATE =
        "CREDITCARD_INVALID_EXPIRATION_DATE";
      /**
       * The code indicates that the credit card security code length is invalid.
       */
      static readonly CREDITCARD_INVALID_SECURITY_CODE =
        "CREDITCARD_INVALID_SECURITY_CODE";

      constructor();
    }

    /**
     * The PaymentTransaction class represents a payment transaction.
     */
    class PaymentTransaction extends dw.object.ExtensibleObject {
      /**
       * Constant representing the authorization type of payment transaction.
       */
      static readonly TYPE_AUTH = "AUTH";
      /**
       * Constant representing the authorization reversal type of payment transaction.
       */
      static readonly TYPE_AUTH_REVERSAL = "AUTH_REVERSAL";
      /**
       * Constant representing the capture type of payment transaction.
       */
      static readonly TYPE_CAPTURE = "CAPTURE";
      /**
       * Constant representing the credit type of payment transaction.
       */
      static readonly TYPE_CREDIT = "CREDIT";

      /**
       * The amount of the transaction.
       */
      amount: dw.value.Money;
      /**
       * The payment instrument related to this payment transaction.
       */
      readonly paymentInstrument: dw.order.OrderPaymentInstrument;
      /**
       * The payment processor related to this payment transaction.
       */
      paymentProcessor: dw.order.PaymentProcessor;
      /**
       * The payment service-specific transaction id.
       */
      transactionID: string;
      /**
       * The value of the transaction type where the
       *  value is one of TYPE_AUTH, TYPE_AUTH_REVERSAL, TYPE_CAPTURE
       *  or TYPE_CREDIT.
       */
      type: dw.value.EnumValue;

      /**
       * Returns the amount of the transaction.
       *
       * @return the amount of the transaction.
       */
      getAmount(): dw.value.Money;
      /**
       * Returns the payment instrument related to this payment transaction.
       *
       * @return the order payment instrument related to this payment transaction.
       */
      getPaymentInstrument(): dw.order.OrderPaymentInstrument;
      /**
       * Returns the payment processor related to this payment transaction.
       *
       * @return the payment processor related to this payment transaction.
       */
      getPaymentProcessor(): dw.order.PaymentProcessor;
      /**
       * Returns the payment service-specific transaction id.
       *
       * @return the payment service-specific transaction id.
       */
      getTransactionID(): string;
      /**
       * Returns the value of the transaction type where the
       *  value is one of TYPE_AUTH, TYPE_AUTH_REVERSAL, TYPE_CAPTURE
       *  or TYPE_CREDIT.
       *
       * @return the value of the transaction type where the value is one of TYPE_AUTH, TYPE_AUTH_REVERSAL, TYPE_CAPTURE or TYPE_CREDIT.
       */
      getType(): dw.value.EnumValue;
      /**
       * Sets the amount of the transaction.
       * @param amount the amount of the transaction.
       */
      setAmount(amount: dw.value.Money): void;
      /**
       * Sets the payment processor related to this payment transaction.
       * @param paymentProcessor the payment processor related to this payment transaction.
       */
      setPaymentProcessor(paymentProcessor: dw.order.PaymentProcessor): void;
      /**
       * Sets the payment service-specific transaction id.
       * @param transactionID the payment service-specific transaction id.
       */
      setTransactionID(transactionID: string): void;
      /**
       * Sets the value of the transaction type where permissible
       *  values are TYPE_AUTH, TYPE_AUTH_REVERSAL, TYPE_CAPTURE or TYPE_CREDIT.
       * @param type the value of the transaction type where the value is one of TYPE_AUTH, TYPE_AUTH_REVERSAL, TYPE_CAPTURE or TYPE_CREDIT.
       */
      setType(type: string): void;
    }

    /**
     * The PriceAdjustment class represents an adjustment to the price of an order.
     *  A PriceAdjustment can apply to a ProductLineItem, ShippingLineItem,
     *  ProductShippingLineItem, or a LineItemCtnr, and are generally categorized as
     *  product-level, shipping-level, or order-level. PriceAdjustments are generated
     *  by the Commerce Cloud Digital promotions engine when applying discounts. See
     *  <a href="class_dw_campaign_PromotionMgr.html#dw_campaign_PromotionMgr_applyDiscounts_DiscountPlan_DetailAnchor">PromotionMgr.applyDiscounts(DiscountPlan)</a>.
     *  They may also be generated by custom code through the API. See for example
     *  <a href="class_dw_order_ProductLineItem.html#dw_order_ProductLineItem_createPriceAdjustment_String_DetailAnchor">ProductLineItem.createPriceAdjustment(String)</a>. In the latter
     *  case, the PriceAdjustment is called &quot;custom&quot;; in the former case, it is
     *  called &quot;system&quot;. System price adjustments are associated with the promotion
     *  that triggered their creation. If the promotion was coupon-based, then the
     *  price adjustment will additionally be associated with a coupon line item in
     *  the LineItemCtnr.
     */
    class PriceAdjustment extends dw.order.LineItem {
      /**
       * The Commerce Cloud Digital AB-test this price adjustment is associated with.
       *  The associated AB-test is determined from the ABTestID attribute which is
       *  set by the promotions engine when applying discounts.
       *
       *  If the AB-test has been removed from the system since this price
       *  adjustment was created, this method returns null. This method always
       *  returns null for custom price adjustments.
       */
      readonly ABTest: dw.campaign.ABTest;
      /**
       * The ID of the AB-test related to this price adjustment.
       */
      readonly ABTestID: string;
      /**
       * The Commerce Cloud Digital AB-test segment this price adjustment is
       *  associated with. The associated AB-test segment is determined from the
       *  ABTestSegmentID attribute which is set by the promotions engine when
       *  applying discounts.
       *
       *  If the AB-test, or this segment, has been removed from the system since
       *  this price adjustment was created, this method returns null. This method
       *  always returns null for custom price adjustments.
       */
      readonly ABTestSegment: dw.campaign.ABTestSegment;
      /**
       * The ID of the AB-test segment related to this price adjustment.
       */
      readonly ABTestSegmentID: string;
      /**
       * A Discount instance describing the discount applied to
       *  obtain this price-adjustment. This method only returns a non-null value
       *  if the price-adjustment was created
       *
       *  when a discount-plan was applied to a basket, or
       *  as a custom price-adjustment using one of the methods
       *  ProductLineItem.createPriceAdjustment(String, Discount),
       *  ShippingLineItem.createShippingPriceAdjustment(String, Discount)
       *  or LineItemCtnr.createPriceAdjustment(String, Discount).
       *
       *
       *   Note an instance of the Discount subclasses is
       *  returned, such as AmountDiscount or
       *  PriceBookPriceDiscount, use
       *  Discount.getType() and the constants in
       *  Discount to distinguish between types. Each subclass
       *  provides access to specific properties.
       */
      readonly appliedDiscount: dw.campaign.Discount;
      /**
       * Returns true if the price adjustment was generated by the Commerce Cloud Digital
       *  promotions engine when applying a promotion assigned to an AB-test.
       */
      readonly basedOnABTest: boolean;
      /**
       * Returns true if the price adjustment was generated by the Commerce Cloud Digital
       *  promotions engine when applying a promotion assigned to a Campaign or an
       *  AB-test.
       */
      readonly basedOnCampaign: boolean;
      /**
       * Identifies if the promotion line item results from a coupon.
       */
      readonly basedOnCoupon: boolean;
      /**
       * The Commerce Cloud Digital campaign this price adjustment is associated with.
       *  The associated campaign is determined from the campaignID attribute which
       *  is set by the promotions engine when applying discounts.
       *
       *  If the campaign has been removed from the system since this price
       *  adjustment was created, this method returns null. This method always
       *  returns null for custom price adjustments.
       *
       *  Note: If the price adjustment was generated by a Commerce Cloud Digital promotion as
       *  part of an AB-test, then a Campaign object will be returned, but it is a
       *  mock implementation, and not a true Campaign. This behavior is required
       *  for backwards compatibility and should not be relied upon as it may
       *  change in future releases.
       */
      readonly campaign: dw.campaign.Campaign;
      /**
       * The ID of the campaign the price adjustment was based on.
       *
       *  Note:If the price adjustment was generated by a Commerce Cloud Digital promotion as
       *  part of an AB-test, then an ID will be returned but it is not the ID of a
       *  true campaign. This behavior is required for backwards compatibility and
       *  should not be relied upon as it may change in future releases.
       */
      readonly campaignID: string;
      /**
       * The coupon line item related to this price adjustment.
       *  If the price adjustment is not based on a coupon, null is returned.
       */
      readonly couponLineItem: dw.order.CouponLineItem;
      /**
       * The name of the user who created the price adjustment.
       *  This method returns a value if the price-adjustment was
       *  created as a custom price-adjustment using one of the methods
       *  ProductLineItem.createPriceAdjustment(String, Discount),
       *  ShippingLineItem.createShippingPriceAdjustment(String, Discount)
       *  or LineItemCtnr.createPriceAdjustment(String, Discount).
       *
       *  If an agent user has created the price adjustment, the agent user's name
       *  is returned. Otherwise "Customer" is returned.
       */
      readonly createdBy: string;
      /**
       * Returns true if this PriceAdjustment was added manually by a user.
       *
       *  A manual PriceAdjustment is one which has been added as a result of
       *  a user interaction e.g. by a user editing an order.
       *
       *  A non-manual PriceAdjustment is one which has been added for a different
       *  reason, e.g. by custom logic which automatically adjusts the price of
       *  particular products when certain conditions are met.
       */
      manual: boolean;
      /**
       * The promotion associated with this price adjustment. The
       *  associated promotion is determined from the promotionID and campaignID
       *  attributes which are set by the promotions engine when applying
       *  discounts. Alternatively if the promotion applied as part of an AB-test,
       *  then the associated promotion is determined from the promotionID
       *  attribute and the hidden attributes, abTestID and abTestGroupID.
       *
       *  If the promotion has been removed from the system since this price
       *  adjustment was created, or if the promotion still exists but is not
       *  assigned to any campaign or AB-test, this method returns null. If the
       *  promotion has been reassigned to a different campaign or AB-test since
       *  this price adjustment was created, then the system will return an
       *  appropriate Promotion instance. This method always returns null for
       *  custom price adjustments.
       */
      readonly promotion: dw.campaign.Promotion;
      /**
       * The ID of the promotion related to this price adjustment.
       */
      readonly promotionID: string;
      /**
       * A map representing the product line items to which this price
       *  adjustment is "related" (in the sense defined below) and the portion of
       *  this adjustment's price which applies to each after discount prorating is
       *  performed. This information is sometimes useful to display in the
       *  storefront but is more often useful for integrating with backend
       *  order-management and accounting systems which require all discounts to be
       *  itemized.
       *
       *  The definition of "related" product line items depends on the type of
       *  promotion which generated this price adjustment:
       *
       *
       *  For order promotions, price adjustments are prorated across all
       *  product line items which are not explicitly excluded by the promotion.
       *  Custom order price adjustments apply to all items in the LineItemCtnr.
       *  For Buy-X-Get-Y product promotions, price adjustments are prorated
       *  across all items all product line items that are involved in the
       *  promotion, meaning that the PLI has one or more items contributing to the
       *  qualifying product count (i.e. the item is one of the X) or receiving the
       *  discount (i.e. the item is one of the Y).
       *  Other product promotions are not prorated and simply adjust the
       *  parent product line item, and so the returned map is of size 1.
       *  For shipping promotions, this method returns an empty map.
       *
       *
       *  Buy-X-Get-Y product promotions are prorated as follows: Each price
       *  adjustment generated by the promotion is sequentially prorated upon the
       *  related items according to the items' adjusted prices after all non-BOGO
       *  product promotions are considered, but before order promotions are
       *  considered.
       *
       *  Order promotions are prorated sequentially upon non-excluded items
       *  according to the order in which they applied during promotion processing.
       *
       *  The values in the map are inclusive of tax if this price adjustment is
       *  based on gross pricing, and exclusive of tax otherwise. The sum of the
       *  prorated prices always equals the price of this price adjustment.
       */
      readonly proratedPrices: dw.util.Map<
        dw.order.ProductLineItem,
        dw.value.Money
      >;
      /**
       * The number of items this price adjustment applies to. This value
       *  is always equal to 1 for price adjustments generated by order or shipping
       *  promotions. For price adjustments generated by product promotions, this
       *  value represents the number of units of the parent product line item to
       *  which the adjustment applies. Because promotions may have a maximum
       *  number of applications this value may be less than the product line item
       *  quantity.
       *
       *  For custom price adjustments, not generated by the promotions engine,
       *  this method always returns 0.
       */
      readonly quantity: number;
      /**
       * The reason code of the price adjustment. The list of available
       *  reason codes is editable system meta-data. An example for using the
       *  reason code is that in a call center application the CSR will explain
       *  why he gave a discount to the customer.
       */
      reasonCode: dw.value.EnumValue;

      /**
       * Returns the Commerce Cloud Digital AB-test this price adjustment is associated with.
       *  The associated AB-test is determined from the ABTestID attribute which is
       *  set by the promotions engine when applying discounts.
       *
       *  If the AB-test has been removed from the system since this price
       *  adjustment was created, this method returns null. This method always
       *  returns null for custom price adjustments.
       *
       * @return the Commerce Cloud Digital AB-test the price adjustment was based on, or null if it was not based on an AB-test.
       */
      getABTest(): dw.campaign.ABTest;
      /**
       * Returns the ID of the AB-test related to this price adjustment.
       *
       * @return ID of related AB-test, or null.
       */
      getABTestID(): string;
      /**
       * Returns the Commerce Cloud Digital AB-test segment this price adjustment is
       *  associated with. The associated AB-test segment is determined from the
       *  ABTestSegmentID attribute which is set by the promotions engine when
       *  applying discounts.
       *
       *  If the AB-test, or this segment, has been removed from the system since
       *  this price adjustment was created, this method returns null. This method
       *  always returns null for custom price adjustments.
       *
       * @return the Commerce Cloud Digital AB-test segment the price adjustment was based on, or null if it was not based on an AB-test.
       */
      getABTestSegment(): dw.campaign.ABTestSegment;
      /**
       * Returns the ID of the AB-test segment related to this price adjustment.
       *
       * @return ID of related AB-test segment, or null.
       */
      getABTestSegmentID(): string;
      /**
       * A Discount instance describing the discount applied to
       *  obtain this price-adjustment. This method only returns a non-null value
       *  if the price-adjustment was created
       *
       *  when a discount-plan was applied to a basket, or
       *  as a custom price-adjustment using one of the methods
       *  ProductLineItem.createPriceAdjustment(String, Discount),
       *  ShippingLineItem.createShippingPriceAdjustment(String, Discount)
       *  or LineItemCtnr.createPriceAdjustment(String, Discount).
       *
       *
       *   Note an instance of the Discount subclasses is
       *  returned, such as AmountDiscount or
       *  PriceBookPriceDiscount, use
       *  Discount.getType() and the constants in
       *  Discount to distinguish between types. Each subclass
       *  provides access to specific properties.
       *
       * @return null or the discount applied
       */
      getAppliedDiscount(): dw.campaign.Discount;
      /**
       * Returns the Commerce Cloud Digital campaign this price adjustment is associated with.
       *  The associated campaign is determined from the campaignID attribute which
       *  is set by the promotions engine when applying discounts.
       *
       *  If the campaign has been removed from the system since this price
       *  adjustment was created, this method returns null. This method always
       *  returns null for custom price adjustments.
       *
       *  Note: If the price adjustment was generated by a Commerce Cloud Digital promotion as
       *  part of an AB-test, then a Campaign object will be returned, but it is a
       *  mock implementation, and not a true Campaign. This behavior is required
       *  for backwards compatibility and should not be relied upon as it may
       *  change in future releases.
       *
       * @return the Commerce Cloud Digital campaign the price adjustment was based on, or null if it was not based on a campaign.
       */
      getCampaign(): dw.campaign.Campaign;
      /**
       * Returns the ID of the campaign the price adjustment was based on.
       *
       *  Note:If the price adjustment was generated by a Commerce Cloud Digital promotion as
       *  part of an AB-test, then an ID will be returned but it is not the ID of a
       *  true campaign. This behavior is required for backwards compatibility and
       *  should not be relied upon as it may change in future releases.
       *
       * @return the ID of the Commerce Cloud Digital campaign the price adjustment was based on, or null if it was not based on a campaign.
       */
      getCampaignID(): string;
      /**
       * Returns the coupon line item related to this price adjustment.
       *  If the price adjustment is not based on a coupon, null is returned.
       *
       * @return Coupon line item or null.
       */
      getCouponLineItem(): dw.order.CouponLineItem;
      /**
       * Returns the name of the user who created the price adjustment.
       *  This method returns a value if the price-adjustment was
       *  created as a custom price-adjustment using one of the methods
       *  ProductLineItem.createPriceAdjustment(String, Discount),
       *  ShippingLineItem.createShippingPriceAdjustment(String, Discount)
       *  or LineItemCtnr.createPriceAdjustment(String, Discount).
       *
       *  If an agent user has created the price adjustment, the agent user's name
       *  is returned. Otherwise "Customer" is returned.
       *
       * @return the name of the user who created the price adjustment
       */
      getCreatedBy(): string;
      /**
       * Returns the promotion associated with this price adjustment. The
       *  associated promotion is determined from the promotionID and campaignID
       *  attributes which are set by the promotions engine when applying
       *  discounts. Alternatively if the promotion applied as part of an AB-test,
       *  then the associated promotion is determined from the promotionID
       *  attribute and the hidden attributes, abTestID and abTestGroupID.
       *
       *  If the promotion has been removed from the system since this price
       *  adjustment was created, or if the promotion still exists but is not
       *  assigned to any campaign or AB-test, this method returns null. If the
       *  promotion has been reassigned to a different campaign or AB-test since
       *  this price adjustment was created, then the system will return an
       *  appropriate Promotion instance. This method always returns null for
       *  custom price adjustments.
       *
       * @return the associated promotion, or null.
       */
      getPromotion(): dw.campaign.Promotion;
      /**
       * Returns the ID of the promotion related to this price adjustment.
       *
       * @return ID of related promotion.
       */
      getPromotionID(): string;
      /**
       * Returns a map representing the product line items to which this price
       *  adjustment is "related" (in the sense defined below) and the portion of
       *  this adjustment's price which applies to each after discount prorating is
       *  performed. This information is sometimes useful to display in the
       *  storefront but is more often useful for integrating with backend
       *  order-management and accounting systems which require all discounts to be
       *  itemized.
       *
       *  The definition of "related" product line items depends on the type of
       *  promotion which generated this price adjustment:
       *
       *
       *  For order promotions, price adjustments are prorated across all
       *  product line items which are not explicitly excluded by the promotion.
       *  Custom order price adjustments apply to all items in the LineItemCtnr.
       *  For Buy-X-Get-Y product promotions, price adjustments are prorated
       *  across all items all product line items that are involved in the
       *  promotion, meaning that the PLI has one or more items contributing to the
       *  qualifying product count (i.e. the item is one of the X) or receiving the
       *  discount (i.e. the item is one of the Y).
       *  Other product promotions are not prorated and simply adjust the
       *  parent product line item, and so the returned map is of size 1.
       *  For shipping promotions, this method returns an empty map.
       *
       *
       *  Buy-X-Get-Y product promotions are prorated as follows: Each price
       *  adjustment generated by the promotion is sequentially prorated upon the
       *  related items according to the items' adjusted prices after all non-BOGO
       *  product promotions are considered, but before order promotions are
       *  considered.
       *
       *  Order promotions are prorated sequentially upon non-excluded items
       *  according to the order in which they applied during promotion processing.
       *
       *  The values in the map are inclusive of tax if this price adjustment is
       *  based on gross pricing, and exclusive of tax otherwise. The sum of the
       *  prorated prices always equals the price of this price adjustment.
       *
       * @return map of ProductLineItems to Money instances representing the product line items across which this price adjustment is prorated and the portion of this adjustment which applies towards each.
       */
      getProratedPrices(): dw.util.Map<
        dw.order.ProductLineItem,
        dw.value.Money
      >;
      /**
       * Returns the number of items this price adjustment applies to. This value
       *  is always equal to 1 for price adjustments generated by order or shipping
       *  promotions. For price adjustments generated by product promotions, this
       *  value represents the number of units of the parent product line item to
       *  which the adjustment applies. Because promotions may have a maximum
       *  number of applications this value may be less than the product line item
       *  quantity.
       *
       *  For custom price adjustments, not generated by the promotions engine,
       *  this method always returns 0.
       *
       * @return The number of items this price adjustment applies to.
       */
      getQuantity(): number;
      /**
       * Returns the reason code of the price adjustment. The list of available
       *  reason codes is editable system meta-data. An example for using the
       *  reason code is that in a call center application the CSR will explain
       *  why he gave a discount to the customer.
       *
       * @return reason code of the price adjustment
       */
      getReasonCode(): dw.value.EnumValue;
      /**
       * Returns true if the price adjustment was generated by the Commerce Cloud Digital
       *  promotions engine when applying a promotion assigned to an AB-test.
       *
       * @return true if the price adjustment was generated by the Commerce Cloud Digital promotions engine when applying a promotion assigned to an AB-test, false otherwise.
       */
      isBasedOnABTest(): boolean;
      /**
       * Returns true if the price adjustment was generated by the Commerce Cloud Digital
       *  promotions engine when applying a promotion assigned to a Campaign or an
       *  AB-test.
       *
       * @return true if the price adjustment was generated by the Commerce Cloud Digital promotions engine, false otherwise.
       */
      isBasedOnCampaign(): boolean;
      /**
       * Identifies if the promotion line item results from a coupon.
       *
       * @return true if the promotion line item results from a coupon, false otherwise.
       */
      isBasedOnCoupon(): boolean;
      /**
       * Returns true if this PriceAdjustment was created by custom script code.
       *
       * @return true if this PriceAdjustment was created by custom script code, or false if it was created by Commerce Cloud Digital promotions engine.
       */
      isCustom(): boolean;
      /**
       * Returns true if this PriceAdjustment was added manually by a user.
       *
       *  A manual PriceAdjustment is one which has been added as a result of
       *  a user interaction e.g. by a user editing an order.
       *
       *  A non-manual PriceAdjustment is one which has been added for a different
       *  reason, e.g. by custom logic which automatically adjusts the price of
       *  particular products when certain conditions are met.
       *
       * @return true if this PriceAdjustment was added manually by a user, otherwise - false
       */
      isManual(): boolean;
      /**
       * Marks the current PriceAdjustment as manual/non-manual.
       *
       *  Note that only custom PriceAdjustment can be marked as manual/non-manual.
       *
       *  A manual PriceAdjustment is one which has been added as a result of
       *  a user interaction e.g. by a user editing an order.
       *
       *  A non-manual PriceAdjustment is one which has been added for a different
       *  reason, e.g. by custom logic which automatically adjusts the price of
       *  particular products when certain conditions are met.
       * @param aFlag the manual flag to set
       */
      setManual(aFlag: boolean): void;
      /**
       * Set the reason code, using the internal non-localizable value. Standard values are 'PRICE_MATCH',
       *  'BACKORDER' and 'EVEN_EXCHANGE', but the available list is editable system meta-data.
       * @param reasonCode reason code
       */
      setReasonCode(reasonCode: string): void;
    }

    /**
     * Helper class containing price adjustment limit types.
     */
    class PriceAdjustmentLimitTypes {
      /**
       * Constant for Price Adjustment Limit Type Item.
       *  The price adjustment limit was created at the item level.
       */
      static readonly TYPE_ITEM = "ITEM";
      /**
       * Constant for Price Adjustment Limit Type Order.
       *  The price adjustment limit was created at the order level.
       */
      static readonly TYPE_ORDER = "ORDER";
      /**
       * Constant for Price Adjustment Limit Type Shipping.
       *  The price adjustment limit was created at the shipping item level.
       */
      static readonly TYPE_SHIPPING = "SHIPPING";
    }

    /**
     * Represents a specific product line item.
     */
    class ProductLineItem extends dw.order.LineItem {
      /**
       * The gross price of the product line item after applying all product-level
       *  adjustments.
       */
      readonly adjustedGrossPrice: dw.value.Money;
      /**
       * The net price of the product line item after applying all product-level
       *  adjustments.
       */
      readonly adjustedNetPrice: dw.value.Money;
      /**
       * The price of the product line item after applying all product-level
       *  adjustments. For net pricing the adjusted net price is returned
       *  (see getAdjustedNetPrice()). For gross pricing, the adjusted
       *  gross price is returned (see getAdjustedGrossPrice()).
       */
      readonly adjustedPrice: dw.value.Money;
      /**
       * The tax of the unit after applying adjustments, in the purchase currency.
       */
      readonly adjustedTax: dw.value.Money;
      /**
       * The parent bonus discount line item of this line item.  Only
       *  bonus product line items that have been selected by the customer as
       *  part of a BONUS_CHOICE discount have one of these.
       */
      readonly bonusDiscountLineItem: dw.order.BonusDiscountLineItem;
      /**
       * Identifies if the product line item represents a bonus line item.
       */
      readonly bonusProductLineItem: boolean;
      /**
       * Identifies if the product line item represents a bundled line item.
       */
      readonly bundledProductLineItem: boolean;
      /**
       * A collection containing the bundled product line items.
       */
      readonly bundledProductLineItems: dw.util.Collection<
        dw.order.ProductLineItem
      >;
      /**
       * Returns true if the product line item represents a catalog product.
       *
       *  That flag is determined during product line item creation with
       *  LineItemCtnr.createProductLineItem(String, Shipment), stored at the line item container and can
       *  be accessed as productLineItem.catalogProduct. It represents what can be evaluated with
       *
       *   dw.catalog.ProductMgr.getProduct( productID ) != null
       *      && dw.catalog.ProductMgr.getProduct( productID ).isAssignedToSiteCatalog()
       *
       *
       *  If the product is not available during product line item creation it is considered a non catalog product line item without
       *  connection to a product.
       */
      readonly catalogProduct: boolean;
      /**
       * The category the product line item is associated with. If the
       *  line item is not associated with a category, or the category does not
       *  exist in the site catalog, the method returns null.
       */
      category: dw.catalog.Category;
      /**
       * The ID of the category the product line item is associated with.
       */
      categoryID: string;
      /**
       * The value set for the external line item status
       *  or null if no value set.
       */
      externalLineItemStatus: string;
      /**
       * The value set for the external line item text
       *  or null if no value set.
       */
      externalLineItemText: string;
      /**
       * Returns true if this line item represents a gift, false otherwise.
       */
      gift: boolean;
      /**
       * The value set for gift message or null if no value set.
       */
      giftMessage: string;
      /**
       * The name of the manfacturer of the product.
       */
      manufacturerName: string;
      /**
       * The name of the manfacturer's SKU of this product line item.
       */
      manufacturerSKU: string;
      /**
       * The minimal order quantity allowed for the product represented by the
       *  ProductLineItem (copied from product on initialization).
       *  Note: the quantity of a ProductLineItem must obey the limits set by the
       *  ProductLineItem's attributes 'MinOrderQuantity' and 'StepQuantity', i.e.
       *  for a 'MinOrderQuantity' of 2.0 and a 'StepQuantity' of 2.5 then values
       *  2.0, 4.5, 7.0... are allowed values.
       */
      readonly minOrderQuantity: dw.value.Quantity;
      /**
       * Return the value portion of getMinOrderQuantity().
       */
      minOrderQuantityValue: number;
      /**
       * The ID of the product option this product line item
       *  represents. If the product line item does not represent an option,
       *  null is returned.
       */
      readonly optionID: string;
      /**
       * The product option model for a product line item representing an option product.
       *
       *  The returned option model has preselected values based on the dependent option line items of this product line
       *  item. Null is returned if this line item does not represent an option product.
       */
      readonly optionModel: dw.catalog.ProductOptionModel;
      /**
       * Identifies if the product line item represents an option line item.
       *  Option line items do not represent true products but rather options of
       *  products.  An option line item always has a parent product line item
       *  representing a true product.
       */
      readonly optionProductLineItem: boolean;
      /**
       * A collection containing option product line items.
       */
      readonly optionProductLineItems: dw.util.Collection<
        dw.order.ProductLineItem
      >;
      /**
       * The ID of the product option value this product line item
       *  represents. If the product line item does not represent an option,
       *  null is returned.
       */
      readonly optionValueID: string;
      /**
       * The  order-item extension for this item, or null. An order-item
       *  extension will only exist for a ProductLineItem which belongs to an Order.
       *
       *  Order post-processing APIs (gillian) are now inactive by default and will throw
       *  an exception if accessed. On sandboxes the APIs can be activated with a feature
       *  switch "Order Post Processing APIs on Sandboxes". On PIGs an activation needs
       *  preliminary approval by Product Management. Please contact support in this case.
       *  Existing customers using these APIs are not affected by this change and can use the
       *  APIs until further notice.
       */
      readonly orderItem: dw.order.OrderItem;
      /**
       * The parent line item of this line item or null if the line item
       *  is independent.
       */
      readonly parent: dw.order.ProductLineItem;
      /**
       * The position within the line item container assigned to the ProductLineItem upon its creation, may be
       *  used as a sort-order.
       *
       *  The position is updated in the following way:
       *
       *  When a ProductLineItem is added to the LineItemCtnr, it is assigned the next available position, based on the
       *  current count
       *  When a ProductLineItem is removed from the LineItemCtnr then LineItemCtnr method reassignPositions is called,
       *  so that the 'gap' left by the removed line-item is refilled. This method is dependent on no 2 ProductLineItem
       *  having the same position.
       *  When a LineItemCtnr is copied (e.g. when a PlacedOrder is created from a Basket), no special position
       *  handling is necessary as the ProductLineItems are added according to their current position ordering in the
       *  source LineItemCtnr.
       */
      position: number;
      /**
       * An iterator of price adjustments that have been applied to this
       *  product line item such as promotions on the purchase price
       *  (i.e. $10 Off or 10% Off).
       */
      readonly priceAdjustments: dw.util.Collection<dw.order.PriceAdjustment>;
      /**
       * The product associated with the product line item.
       *
       *  The product line item might not be related to an actual catalog product, for example if it represents an option,
       *  or was not created from a catalog product, or if the product does not exist in the catalog anymore. In these
       *  cases, the method returns null.
       */
      readonly product: dw.catalog.Product;
      /**
       * The ID of the related product.
       *
       *  Returns empty if no product is related.
       */
      readonly productID: string;
      /**
       * The inventory list the product line item is associated with. If the
       *  line item is not associated with a inventory list, or the inventory list does not
       *  exist, the method returns null.
       */
      productInventoryList: dw.catalog.ProductInventoryList;
      /**
       * The ID of the inventory list the product line item is associated with.
       */
      productInventoryListID: string;
      /**
       * The associated ProductListItem.
       */
      readonly productListItem: dw.customer.ProductListItem;
      /**
       * The name of the product that was copied when
       *  product was added to line item container.
       */
      productName: string;
      /**
       * The price of this product line item after considering all
       *  dependent price adjustments and prorating all Buy-X-Get-Y
       *  and order-level discounts, according to the scheme described in
       *  PriceAdjustment.getProratedPrices(). For net pricing the
       *  net price is returned. For gross pricing, the gross price is returned.
       */
      readonly proratedPrice: dw.value.Money;
      /**
       * A Map of PriceAdjustment to Money instances. They keys to this
       *  map are the price adjustments that apply to this ProductLineItem either
       *  directly or indirectly when discounts are prorated according to the
       *  scheme described in PriceAdjustment.getProratedPrices().
       *  The values in the map are the portion of the adjustment which applies to
       *  this particular product line item.
       */
      readonly proratedPriceAdjustmentPrices: dw.util.Map<
        dw.order.ProductLineItem,
        dw.value.Money
      >;
      /**
       * The ProductLineItem that qualified the basket for this bonus product.
       *
       *  This method is only applicable if the product line item is a bonus product line item, and if the promotion is a
       *  product promotion with number of qualifying products granting a bonus-product discount. If these conditions
       *  aren't met, the method returns null. If there are multiple product line items that triggered this bonus product,
       *  this method returns the last one by position within the order.
       */
      readonly qualifyingProductLineItemForBonusProduct: dw.order.ProductLineItem;
      /**
       * The quantity of the product represented by this ProductLineItem.
       */
      readonly quantity: dw.value.Quantity;
      /**
       * The value of the quantity of this ProductLineItem.
       */
      quantityValue: number;
      /**
       * All bonus product line items for which this line item is a
       *  qualifying product line item. This method is usually called when
       *  rendering the cart so that bonus products can be shown next to the
       *  products that triggered their creation.
       */
      readonly relatedBonusProductLineItems: dw.util.Collection<
        dw.order.ProductLineItem
      >;
      /**
       * Returns if the product line item is reserved.
       *
       *  Reservations for the basket can be created with e.g. Basket.reserveInventory(Number).
       *
       *  Method must only be called for basket product line items. Exception is thrown if called for order product line
       *  item.
       */
      readonly reserved: boolean;
      /**
       * The associated Shipment.
       */
      shipment: dw.order.Shipment;
      /**
       * The dependent shipping line item of this line item.
       *  The shipping line item can define product-specific shipping
       *  costs for this product line item.
       */
      readonly shippingLineItem: dw.order.ProductShippingLineItem;
      /**
       * Returns step quantity allowed for the product represented by the ProductLineItem
       *  (copied from product on initialization).
       *  Note: the quantity of a ProductLineItem must obey the limits set by the
       *  ProductLineItem's attributes 'MinOrderQuantity' and 'StepQuantity', i.e.
       *  for a 'MinOrderQuantity' of 2.0 and a 'StepQuantity' of 2.5 then values
       *  2.0, 4.5, 7.0... are allowed values.
       */
      readonly stepQuantity: dw.value.Quantity;
      /**
       * Return the value portion of getStepQuantity().
       */
      stepQuantityValue: number;

      /**
       * Creates a product price adjustment.
       *
       *  The price adjustment line item is being initialized with the tax class code and tax rate of the product line
       *  item. The promotion ID is mandatory and must not be the ID of any actual promotion defined in Commerce Cloud
       *  Digital. If there already exists a price adjustment for the same promotionID, an exception is thrown.
       * @param promotionID Promotion ID
       * @return The new price adjustment
       */
      createPriceAdjustment(promotionID: string): dw.order.PriceAdjustment;
      /**
       * Creates a product price adjustment representing a specific discount. The price adjustment line item is
       *  initialized with the tax class code and tax rate of the product line item.
       *
       *  The promotion ID is mandatory and must not be the ID of any actual promotion defined in Commerce Cloud Digital.
       *  If a price adjustment already exists for the same promotionID, an exception is thrown.
       *
       *
       *  The possible discounts are FixedPriceDiscount, AmountDiscount,
       *  PercentageDiscount. Example:
       *
       *
       *   var myProductItem : dw.order.ProductLineItem; // assume known
       *  var paFixedUnitPrice100 : dw.order.PriceAdjustment = myProductItem.createPriceAdjustment("myPromotionID1", new FixedPriceDiscount(100.00));
       *  var paTenPercent : dw.order.PriceAdjustment = myProductItem.createPriceAdjustment("myPromotionID2", new PercentageDiscount(10));
       *  var paReduceBy20 : dw.order.PriceAdjustment = myProductItem.createPriceAdjustment("myPromotionID3", new AmountDiscount(20.00);
       * @param promotionID Unique custom promotion ID, not null
       * @param discount The desired discount, not null
       * @return The new custom price adjustment
       */
      createPriceAdjustment(
        promotionID: string,
        discount: dw.campaign.Discount
      ): dw.order.PriceAdjustment;
      /**
       * Creates the dependent shipping line item for this line item.
       *  The shipping line item can define product-specific shipping
       *  costs for this product line item.
       *  This method has replace semantics: If there is an existing
       *  shipping line item it will be replaced
       *  with a new shipping line item.
       *
       * @return the created shipping line item
       */
      createShippingLineItem(): dw.order.ProductShippingLineItem;
      /**
       * Returns the gross price of the product line item after applying all product-level
       *  adjustments.
       *
       * @return gross price after applying product-level adjustments
       */
      getAdjustedGrossPrice(): dw.value.Money;
      /**
       * Returns the net price of the product line item after applying all product-level
       *  adjustments.
       *
       * @return net price after applying product-level adjustments
       */
      getAdjustedNetPrice(): dw.value.Money;
      /**
       * Returns the price of the product line item after applying all product-level
       *  adjustments. For net pricing the adjusted net price is returned
       *  (see getAdjustedNetPrice()). For gross pricing, the adjusted
       *  gross price is returned (see getAdjustedGrossPrice()).
       *
       * @return Adjusted net or gross price
       */
      getAdjustedPrice(): dw.value.Money;
      /**
       * Returns the price of this product line item after considering all
       *  dependent price adjustments and optionally prorating all order-level
       *  price adjustments. For net pricing the net price is returned. For gross
       *  pricing, the gross price is returned.
       * @param applyOrderLevelAdjustments If true, order-level adjustments will be applied to line item price.
       * @return Adjusted net or gross price
       */
      getAdjustedPrice(applyOrderLevelAdjustments: boolean): dw.value.Money;
      /**
       * Returns the tax of the unit after applying adjustments, in the purchase currency.
       *
       * @return the tax of the unit after applying adjustments, in the purchase currency.
       */
      getAdjustedTax(): dw.value.Money;
      /**
       * Returns the parent bonus discount line item of this line item.  Only
       *  bonus product line items that have been selected by the customer as
       *  part of a BONUS_CHOICE discount have one of these.
       *
       * @return the bonus discount line item of this line item or null
       */
      getBonusDiscountLineItem(): dw.order.BonusDiscountLineItem;
      /**
       * Returns a collection containing the bundled product line items.
       *
       * @return a collection containing the bundled product line items.
       */
      getBundledProductLineItems(): dw.util.Collection<
        dw.order.ProductLineItem
      >;
      /**
       * Returns the category the product line item is associated with. If the
       *  line item is not associated with a category, or the category does not
       *  exist in the site catalog, the method returns null.
       *
       * @return Category or null
       */
      getCategory(): dw.catalog.Category;
      /**
       * Returns the ID of the category the product line item is associated with.
       *
       * @return Category ID or null.
       */
      getCategoryID(): string;
      /**
       * Returns the value set for the external line item status
       *  or null if no value set.
       *
       * @return the value set for the external line item status or null if no value set.
       */
      getExternalLineItemStatus(): string;
      /**
       * Returns the value set for the external line item text
       *  or null if no value set.
       *
       * @return the value set for the external line item text or null if no value set.
       */
      getExternalLineItemText(): string;
      /**
       * Returns the value set for gift message or null if no value set.
       *
       * @return the value set for gift message or null if no value set.
       */
      getGiftMessage(): string;
      /**
       * Returns the name of the manfacturer of the product.
       *
       * @return The name of the manfacturer of the product.
       */
      getManufacturerName(): string;
      /**
       * Returns the name of the manfacturer's SKU of this product line item.
       *
       * @return the name of the manfacturer's SKU of this product line item.
       */
      getManufacturerSKU(): string;
      /**
       * Returns the minimal order quantity allowed for the product represented by the
       *  ProductLineItem (copied from product on initialization).
       *  Note: the quantity of a ProductLineItem must obey the limits set by the
       *  ProductLineItem's attributes 'MinOrderQuantity' and 'StepQuantity', i.e.
       *  for a 'MinOrderQuantity' of 2.0 and a 'StepQuantity' of 2.5 then values
       *  2.0, 4.5, 7.0... are allowed values.
       *
       * @return the minimal order quantity allowed for the product.
       */
      getMinOrderQuantity(): dw.value.Quantity;
      /**
       * Return the value portion of getMinOrderQuantity().
       *
       * @return the minimal order quantity value allowed for the product.
       */
      getMinOrderQuantityValue(): number;
      /**
       * Returns the ID of the product option this product line item
       *  represents. If the product line item does not represent an option,
       *  null is returned.
       *
       * @return the ID of the product option this product line item represents.
       */
      getOptionID(): string;
      /**
       * Returns the product option model for a product line item representing an option product.
       *
       *  The returned option model has preselected values based on the dependent option line items of this product line
       *  item. Null is returned if this line item does not represent an option product.
       *
       * @return the product option model for a product line item representing an option product.
       */
      getOptionModel(): dw.catalog.ProductOptionModel;
      /**
       * Returns a collection containing option product line items.
       *
       * @return a collection containing option product line items.
       */
      getOptionProductLineItems(): dw.util.Collection<dw.order.ProductLineItem>;
      /**
       * Returns the ID of the product option value this product line item
       *  represents. If the product line item does not represent an option,
       *  null is returned.
       *
       * @return the ID of the product option value this product line item represents.
       */
      getOptionValueID(): string;
      /**
       * Returns the  order-item extension for this item, or null. An order-item
       *  extension will only exist for a ProductLineItem which belongs to an Order.
       *
       *  Order post-processing APIs (gillian) are now inactive by default and will throw
       *  an exception if accessed. On sandboxes the APIs can be activated with a feature
       *  switch "Order Post Processing APIs on Sandboxes". On PIGs an activation needs
       *  preliminary approval by Product Management. Please contact support in this case.
       *  Existing customers using these APIs are not affected by this change and can use the
       *  APIs until further notice.
       *
       * @return null or the order-item extension
       */
      getOrderItem(): dw.order.OrderItem;
      /**
       * Returns the parent line item of this line item or null if the line item
       *  is independent.
       *
       * @return the parent line item of this line item or null if the line item is independent.
       */
      getParent(): dw.order.ProductLineItem;
      /**
       * Returns the position within the line item container assigned to the ProductLineItem upon its creation, may be
       *  used as a sort-order.
       *
       *  The position is updated in the following way:
       *
       *  When a ProductLineItem is added to the LineItemCtnr, it is assigned the next available position, based on the
       *  current count
       *  When a ProductLineItem is removed from the LineItemCtnr then LineItemCtnr method reassignPositions is called,
       *  so that the 'gap' left by the removed line-item is refilled. This method is dependent on no 2 ProductLineItem
       *  having the same position.
       *  When a LineItemCtnr is copied (e.g. when a PlacedOrder is created from a Basket), no special position
       *  handling is necessary as the ProductLineItems are added according to their current position ordering in the
       *  source LineItemCtnr.
       *
       * @return the position within the line item container assigned to the ProductLineItem upon its creation.
       */
      getPosition(): number;
      /**
       * Returns the first price adjustment associated to the specified promotion ID. It is highly recommended to use
       *  getPriceAdjustmentsByPromotionID(String) instead. If there are multiple price adjustments for the same
       *  promotion, this method will return the first found. Alternatively, to uniquely identify a price adjustment using
       *  its promotion id and coupon code, use getPriceAdjustmentByPromotionIDAndCouponCode(String, String)
       * @param promotionID Promotion id
       * @return The price adjustment associated with the promotion ID or null
       */
      getPriceAdjustmentByPromotionID(
        promotionID: string
      ): dw.order.PriceAdjustment;
      /**
       * Returns the price adjustment associated to the specified promotion ID and coupon code combination.
       * @param promotionID Promotion id
       * @param couponCode the code of the coupon used to apply the promotion, or null if the promotion is not coupon based.
       * @return The price adjustment associated with the promotion ID and coupon code combination, or null
       */
      getPriceAdjustmentByPromotionIDAndCouponCode(
        promotionID: string,
        couponCode: string
      ): dw.order.PriceAdjustment;
      /**
       * Returns an iterator of price adjustments that have been applied to this
       *  product line item such as promotions on the purchase price
       *  (i.e. $10 Off or 10% Off).
       *
       * @return a collection of price adjustments that have been applied to this product line item.
       */
      getPriceAdjustments(): dw.util.Collection<dw.order.PriceAdjustment>;
      /**
       * Returns the collection of price adjustments associated to the specified promotion ID. If only one coupon code is
       *  allowed per order, then the collection should only ever have a single entry in it. The multiple coupon code
       *  feature can cause multiple price adjustments to be returned.
       * @param promotionID Promotion id
       * @return The collection of price adjustments associated with the promotion ID or null if the promotionID was null. If there are no price adjustments for the passed promotion, the collection will be empty.
       */
      getPriceAdjustmentsByPromotionID(
        promotionID: string
      ): dw.util.Collection<dw.order.PriceAdjustment>;
      /**
       * Returns the product associated with the product line item.
       *
       *  The product line item might not be related to an actual catalog product, for example if it represents an option,
       *  or was not created from a catalog product, or if the product does not exist in the catalog anymore. In these
       *  cases, the method returns null.
       *
       * @return the product of the line item, or null
       */
      getProduct(): dw.catalog.Product;
      /**
       * Returns the ID of the related product.
       *
       *  Returns empty if no product is related.
       *
       * @return the ID of the related product.
       */
      getProductID(): string;
      /**
       * Returns the inventory list the product line item is associated with. If the
       *  line item is not associated with a inventory list, or the inventory list does not
       *  exist, the method returns null.
       *
       * @return ProductInventoryList or null
       */
      getProductInventoryList(): dw.catalog.ProductInventoryList;
      /**
       * Returns the ID of the inventory list the product line item is associated with.
       *
       * @return ProductInventoryList ID or null.
       */
      getProductInventoryListID(): string;
      /**
       * Returns the associated ProductListItem.
       *
       * @return item or null.
       */
      getProductListItem(): dw.customer.ProductListItem;
      /**
       * Returns the name of the product that was copied when
       *  product was added to line item container.
       *
       * @return the name of the product.
       */
      getProductName(): string;
      /**
       * Returns the price of this product line item after considering all
       *  dependent price adjustments and prorating all Buy-X-Get-Y
       *  and order-level discounts, according to the scheme described in
       *  PriceAdjustment.getProratedPrices(). For net pricing the
       *  net price is returned. For gross pricing, the gross price is returned.
       *
       * @return Adjusted and prorated net or gross price
       */
      getProratedPrice(): dw.value.Money;
      /**
       * Returns a Map of PriceAdjustment to Money instances. They keys to this
       *  map are the price adjustments that apply to this ProductLineItem either
       *  directly or indirectly when discounts are prorated according to the
       *  scheme described in PriceAdjustment.getProratedPrices().
       *  The values in the map are the portion of the adjustment which applies to
       *  this particular product line item.
       *
       * @return Map of PriceAdjustment to Money instances, representing the prorated adjustments applied to this ProductLineItem.
       */
      getProratedPriceAdjustmentPrices(): dw.util.Map<
        dw.order.ProductLineItem,
        dw.value.Money
      >;
      /**
       * Returns the ProductLineItem that qualified the basket for this bonus product.
       *
       *  This method is only applicable if the product line item is a bonus product line item, and if the promotion is a
       *  product promotion with number of qualifying products granting a bonus-product discount. If these conditions
       *  aren't met, the method returns null. If there are multiple product line items that triggered this bonus product,
       *  this method returns the last one by position within the order.
       *
       * @return the ProductLineItem that qualified the basket for this bonus product. Returns null if this is not a bonus product, or if there was no distinct qualifying product.
       */
      getQualifyingProductLineItemForBonusProduct(): dw.order.ProductLineItem;
      /**
       * Returns the quantity of the product represented by this ProductLineItem.
       *
       * @return the quantity of the product.
       */
      getQuantity(): dw.value.Quantity;
      /**
       * Returns the value of the quantity of this ProductLineItem.
       *
       * @return quantity value of product line item
       */
      getQuantityValue(): number;
      /**
       * Returns all bonus product line items for which this line item is a
       *  qualifying product line item. This method is usually called when
       *  rendering the cart so that bonus products can be shown next to the
       *  products that triggered their creation.
       *
       * @return the bonus product line items triggered by the addition of this product to the cart.
       */
      getRelatedBonusProductLineItems(): dw.util.Collection<
        dw.order.ProductLineItem
      >;
      /**
       * Returns the associated Shipment.
       *
       * @return The shipment of the product line item
       */
      getShipment(): dw.order.Shipment;
      /**
       * Returns the dependent shipping line item of this line item.
       *  The shipping line item can define product-specific shipping
       *  costs for this product line item.
       *
       * @return the shipping line item of this line item or null
       */
      getShippingLineItem(): dw.order.ProductShippingLineItem;
      /**
       * Returns step quantity allowed for the product represented by the ProductLineItem
       *  (copied from product on initialization).
       *  Note: the quantity of a ProductLineItem must obey the limits set by the
       *  ProductLineItem's attributes 'MinOrderQuantity' and 'StepQuantity', i.e.
       *  for a 'MinOrderQuantity' of 2.0 and a 'StepQuantity' of 2.5 then values
       *  2.0, 4.5, 7.0... are allowed values.
       *
       * @return step quantity allowed for the product.
       */
      getStepQuantity(): dw.value.Quantity;
      /**
       * Return the value portion of getStepQuantity().
       *
       * @return step quantity value allowed for the product.
       */
      getStepQuantityValue(): number;
      /**
       * Identifies if the product line item represents a bonus line item.
       *
       * @return true if the product line item represents a bonus line item, false otherwise.
       */
      isBonusProductLineItem(): boolean;
      /**
       * Identifies if the product line item represents a bundled line item.
       *
       * @return true if the product line item represents a bundled line item.
       */
      isBundledProductLineItem(): boolean;
      /**
       * Returns true if the product line item represents a catalog product.
       *
       *  That flag is determined during product line item creation with
       *  LineItemCtnr.createProductLineItem(String, Shipment), stored at the line item container and can
       *  be accessed as productLineItem.catalogProduct. It represents what can be evaluated with
       *
       *   dw.catalog.ProductMgr.getProduct( productID ) != null
       *      && dw.catalog.ProductMgr.getProduct( productID ).isAssignedToSiteCatalog()
       *
       *
       *  If the product is not available during product line item creation it is considered a non catalog product line item without
       *  connection to a product.
       *
       * @return true if product line item represents catalog product, otherwise false
       */
      isCatalogProduct(): boolean;
      /**
       * Returns true if this line item represents a gift, false otherwise.
       *
       * @return true if this line item represents a gift, false otherwise.
       */
      isGift(): boolean;
      /**
       * Identifies if the product line item represents an option line item.
       *  Option line items do not represent true products but rather options of
       *  products.  An option line item always has a parent product line item
       *  representing a true product.
       *
       * @return true if the product line item represents an option line item, false otherwise.
       */
      isOptionProductLineItem(): boolean;
      /**
       * Returns if the product line item is reserved.
       *
       *  Reservations for the basket can be created with e.g. Basket.reserveInventory(Number).
       *
       *  Method must only be called for basket product line items. Exception is thrown if called for order product line
       *  item.
       *
       * @return true if line item is reserved, false otherwise.
       */
      isReserved(): boolean;
      /**
       * Removes the specified price adjustment from the product line item.
       * @param priceAdjustmentLineItem The price adjustment to remove
       */
      removePriceAdjustment(
        priceAdjustmentLineItem: dw.order.PriceAdjustment
      ): void;
      /**
       * Removes the dependent shipping line item for this line item.
       *
       */
      removeShippingLineItem(): void;
      /**
       * Replaces the current product of the product line item with the product specified in parameter newProduct.
       *
       *  The following rules apply:
       *
       *  Preserve line item attributes UUID, Quantity, CategoryID, ExternalLineItemStatus, ExternalLineItemText,
       *  isGift, GiftMessage, Position, Parent, Shipment
       *  Replace product-specific attributes ProductID, ProductName, MinOrderQuantity, StepQuantity, ManufacturerName,
       *  ManufacturerSKU
       *  Remove all price adjustments related to the product line item
       *  Remove the shipping line item related to the product line item
       *  Remove all bundled line items of current product, and add bundled line items if new product is a bundle
       *  Remove all option line items of current product, and add option line items if new product is an option
       *  product; use default option selections
       *  Set all price attributes to N/A
       *  Preserve all custom attributes of line item, but override order-required attributes with values from new
       *  product
       *
       *
       *
       *  The primary use is to replace one variation product with another, without having to both create a new line item
       *  for the replacement and remove the line item for the replaced product.
       * @param newProduct The new product of the product line item
       */
      replaceProduct(newProduct: dw.catalog.Product): void;
      /**
       * Sets the specified category as the product line item category context.
       * @param category Category instance or null
       */
      setCategory(category: dw.catalog.Category): void;
      /**
       * Sets the ID of the category the product line item is associated with.
       * @param categoryID the Category ID or null.
       */
      setCategoryID(categoryID: string): void;
      /**
       * Sets the value to set for the external line item status.
       * @param status the value to set for the external line item status.
       */
      setExternalLineItemStatus(status: string): void;
      /**
       * Sets the value to set for the external line item text.
       * @param text the value to set for the external line item text.
       */
      setExternalLineItemText(text: string): void;
      /**
       * Controls if this line item is a gift or not.
       * @param isGift set to true if you want this line item to represent a gift.
       */
      setGift(isGift: boolean): void;
      /**
       * Sets the value to set for the gift message.
       * @param message the value to set for the gift message.
       */
      setGiftMessage(message: string): void;
      /**
       * Sets the name of the manufacturer of this product.
       * @param name The name of the manfacturer of this product
       */
      setManufacturerName(name: string): void;
      /**
       * Sets the SKU of the manufacturer of this product.
       * @param sku The SKU of the manfacturer of this product
       */
      setManufacturerSKU(sku: string): void;
      /**
       * Set the minimum order quantity value for this object.
       *
       *  This will be used to validate and adjust quantities when setQuantityValue() is called. For typical catalog
       *  product line items, it is usually desirable to have this value inherited from the product attributes, but for
       *  non-catalog products, it is sometimes desirable to set this value programmatically.
       *
       *
       *  Null is accepted and represents Quantity.NA. Otherwise, the quantity value must be > 0.
       * @param quantityValue The minimal order quantity allowed for the product or null.
       */
      setMinOrderQuantityValue(quantityValue: number): void;
      /**
       * Sets the position within the line item container. This value may be used as a sort-order.
       *
       *  The position is updated in the following way:
       *
       *  When a ProductLineItem is added to the LineItemCtnr, it is assigned the next available position, based on the
       *  current count
       *  When a ProductLineItem is removed from the LineItemCtnr then LineItemCtnr method reassignPositions is called,
       *  so that the 'gap' left by the removed line-item is refilled. This method is dependent on no 2 ProductLineItem
       *  having the same position.
       *  When a LineItemCtnr is copied (e.g. when an Order is created from a Basket), no special position handling is
       *  necessary as the ProductLineItems are added according to their current position ordering in the source
       *  LineItemCtnr.
       * @param aValue the position within the line item container.
       */
      setPosition(aValue: number): void;
      /**
       * Sets price attributes of the line item based on the current
       *  purchase currency, taxation policy and line item quantity.
       *
       *  The method sets the 'basePrice' attribute of the line item.
       *  Additionally, it sets the 'netPrice' attribute of the line item
       *  if the current taxation policy is 'net', and the 'grossPrice'
       *  attribute, if the current taxation policy is 'gross'. The
       *  'netPrice'/'grossPrice' attributes are set by multiplying the
       *  specified price value with the line item quantity.
       *
       *
       *  If null is specified as value, the price attributes are reset to
       *  Money.NA.
       * @param value Price value or null
       */
      setPriceValue(value: number): void;
      /**
       * Sets the specified inventory list as the product line item inventory context.
       * @param productInventoryList ProductInventoryList instance or null
       */
      setProductInventoryList(
        productInventoryList: dw.catalog.ProductInventoryList
      ): void;
      /**
       * Sets the ID of the inventory list the product line item is associated with.
       * @param productInventoryListID the ProductInventoryList ID or null.
       */
      setProductInventoryListID(productInventoryListID: string): void;
      /**
       * Sets the name of the product.
       * @param aValue the name of the product.
       */
      setProductName(aValue: string): void;
      /**
       * Updates the quantity value of the product line item.
       *
       *  Validates the specified quantity value against the line item's min order and step quantity and adjusts it if
       *  necessary. In particular, if 0 is passed, then the value will be adjusted to the min order quantity, not removed
       *  from the line item container.
       *
       *
       *  Null values or values < 0.0 are not accepted.
       * @param quantityValue Quantity value.
       */
      setQuantityValue(quantityValue: number): void;
      /**
       * Associates the specified product line item with the specified shipment.
       *
       *  The method is only applicable for independent product line items. If called for any dependent line item (option
       *  or bundled line item), the method will throw an exception. The shipment for all dependent line items will be
       *  updated automatically by the method. Product line item and shipment must belong to the same line item ctnr.
       * @param shipment The new shipment of the product line item
       */
      setShipment(shipment: dw.order.Shipment): void;
      /**
       * Set the step quantity value for this object.
       *
       *  This will be used to validate and adjust quantities when updateQuantity() is called. For typical catalog product
       *  line items, it is usually desirable to have this value inherited from the product attributes, but for non-catalog
       *  products, it is sometimes desirable to set this value programmatically.
       *
       *
       *  Null is accepted and represents Quantity.NA. Otherwise, the quantity value must be > 0.
       * @param quantityValue The minimal order quantity allowed for the product or null.
       */
      setStepQuantityValue(quantityValue: number): void;
      /**
       * Determines and sets the price of a option line item based on the
       *  selected option value the line item represents.
       *
       */
      updateOptionPrice(): void;
      /**
       * Updates an option line item with a new option value.
       *
       *  This method will not do anything if the current line item is no
       *  option line item, if the specified value does not exist for the
       *  current option or if this value is already selected.
       *
       *  Note, that this method will update the attributes optionValueID,
       *  productID, productName and lineItemText. It will not update the price
       *  attributes of the line item. To update the price of the line item you
       *  need to call updateOptionPrice() in addition. This is
       *  usually done during calculation in the calculate hook.
       * @param optionValue The value to update the option line item with
       */
      updateOptionValue(optionValue: dw.catalog.ProductOptionValue): void;
      /**
       * Updates the price attributes of the line item based
       *  on the specified price.  The base price is set to the specified
       *  value.  If the line item is based on net pricing then the net price
       *  attribute is set.  If the line item is based on  gross pricing then the
       *  gross price attribute is set.  Whether or not a line item is based
       *  on net or gross pricing is a site-wide configuration parameter.
       *  In either case, this price is equal to the product of the base price
       *  and the quantity of this line item in its container.
       * @param price The price to use when performing the update. This price must not be null and must either be equal to NOT_AVAIALBLE or must have a currency code equal to that of the parent container.
       */
      updatePrice(price: dw.value.Money): void;
      /**
       * Updates the quantity value of the product line item and all its dependent product line items.
       *
       *  Validates the specified quantity value against the line item's min order and step quantity and adjusts it if
       *  necessary. The adjusted quantity value is returned.
       *
       *
       *  In general, quantity values < 0.0 are not accepted.
       * @param quantityValue Numeric quantity value.
       * @return Adjusted quantity value
       */
      updateQuantity(quantityValue: number): number;
    }

    /**
     * Instances of ProductShippingCost represent product specific shipping costs.
     *  <br>
     *
     *  Use <a href="class_dw_order_ProductShippingModel.html#dw_order_ProductShippingModel_getShippingCost_ShippingMethod_DetailAnchor">ProductShippingModel.getShippingCost(ShippingMethod)</a> to get
     *  the shipping cost for a specific product.
     */
    class ProductShippingCost {
      /**
       * The shipping amount.
       */
      readonly amount: dw.value.Money;
      /**
       * Returns true if shipping cost is a fixed-price shipping cost,
       *  and false if surcharge shipping cost.
       */
      readonly fixedPrice: boolean;
      /**
       * Returns true if shipping cost is a surcharge to the shipment
       *  shipping cost, and false if fixed-price shipping cost.
       */
      readonly surcharge: boolean;

      /**
       * Returns the shipping amount.
       *
       * @return Shipping amount
       */
      getAmount(): dw.value.Money;
      /**
       * Returns true if shipping cost is a fixed-price shipping cost,
       *  and false if surcharge shipping cost.
       *
       * @return true of fixed-price shipping cost, else false
       */
      isFixedPrice(): boolean;
      /**
       * Returns true if shipping cost is a surcharge to the shipment
       *  shipping cost, and false if fixed-price shipping cost.
       *
       * @return true of surcharge shipping cost, else false
       */
      isSurcharge(): boolean;
    }

    /**
     * Represents a specific line item in a shipment. A ProductShippingLineItem defines
     *  lineitem-specific shipping costs.
     */
    class ProductShippingLineItem extends dw.order.LineItem {
      /**
       * Reserved constant.
       */
      static readonly PRODUCT_SHIPPING_ID = "PRODUCT_SHIPPING";

      /**
       * The gross price of the product shipping line item after applying
       *  all product-shipping-level adjustments.
       */
      readonly adjustedGrossPrice: dw.value.Money;
      /**
       * The net price of the product shipping line item after applying
       *  all product-shipping-level adjustments.
       */
      readonly adjustedNetPrice: dw.value.Money;
      /**
       * The price of the product shipping line item after applying all
       *  pproduct-shipping-level adjustments. For net pricing the adjusted net
       *  price is returned (see getAdjustedNetPrice()). For gross
       *  pricing, the adjusted gross price is returned (see
       *  getAdjustedGrossPrice()).
       */
      readonly adjustedPrice: dw.value.Money;
      /**
       * The tax of the unit after applying adjustments, in the purchase
       *  currency.
       */
      readonly adjustedTax: dw.value.Money;
      /**
       * An iterator of price adjustments that have been applied to this
       *  product shipping line item.
       */
      readonly priceAdjustments: dw.util.Collection<dw.order.PriceAdjustment>;
      /**
       * The parent product line item this shipping line item belongs to.
       */
      readonly productLineItem: dw.order.ProductLineItem;
      /**
       * The quantity of the shipping cost.
       */
      quantity: dw.value.Quantity;
      /**
       * The shipment this shipping line item belongs to.
       */
      readonly shipment: dw.order.Shipment;
      /**
       * The 'surcharge' flag.
       */
      surcharge: boolean;

      /**
       * Returns the gross price of the product shipping line item after applying
       *  all product-shipping-level adjustments.
       *
       * @return gross price after applying product-shipping-level adjustments
       */
      getAdjustedGrossPrice(): dw.value.Money;
      /**
       * Returns the net price of the product shipping line item after applying
       *  all product-shipping-level adjustments.
       *
       * @return net price after applying product-shipping-level adjustments
       */
      getAdjustedNetPrice(): dw.value.Money;
      /**
       * Returns the price of the product shipping line item after applying all
       *  pproduct-shipping-level adjustments. For net pricing the adjusted net
       *  price is returned (see getAdjustedNetPrice()). For gross
       *  pricing, the adjusted gross price is returned (see
       *  getAdjustedGrossPrice()).
       *
       * @return Adjusted net or gross price
       */
      getAdjustedPrice(): dw.value.Money;
      /**
       * Returns the tax of the unit after applying adjustments, in the purchase
       *  currency.
       *
       * @return the tax of the unit after applying adjustments, in the purchase currency.
       */
      getAdjustedTax(): dw.value.Money;
      /**
       * Returns an iterator of price adjustments that have been applied to this
       *  product shipping line item.
       *
       * @return a collection of price adjustments that have been applied to this product shipping line item.
       */
      getPriceAdjustments(): dw.util.Collection<dw.order.PriceAdjustment>;
      /**
       * Returns the parent product line item this shipping line item belongs to.
       *
       * @return the product line item
       */
      getProductLineItem(): dw.order.ProductLineItem;
      /**
       * Returns the quantity of the shipping cost.
       *
       * @return the shipping quantity
       */
      getQuantity(): dw.value.Quantity;
      /**
       * Returns the shipment this shipping line item belongs to.
       *
       * @return the shipment
       */
      getShipment(): dw.order.Shipment;
      /**
       * Returns the 'surcharge' flag.
       *
       * @return true if this is a surcharge shipping cost, false if fixed shipping cost
       */
      isSurcharge(): boolean;
      /**
       * Sets price attributes of the line item based on the
       *  purchase currency, taxation policy and line item quantity.
       *
       *  The method sets the 'basePrice' attribute of the line item.
       *  Additionally, it sets the 'netPrice' attribute of the line item
       *  if the current taxation policy is 'net', and the 'grossPrice'
       *  attribute, if the current taxation policy is 'gross'. The
       *  'netPrice'/'grossPrice' attributes are set by multiplying the
       *  specified price value with the line item quantity.
       *
       *  If null is specified as value, the price attributes are reset to
       *  Money.NA.
       * @param value Price value or null
       */
      setPriceValue(value: number): void;
      /**
       * Sets the quantity of the shipping cost.
       * @param quantity the shipping quantity
       */
      setQuantity(quantity: dw.value.Quantity): void;
      /**
       * Sets the 'surcharge' flag.
       * @param flag true if this is a surcharge shipping cost, false if this is a fixed shipping cost.
       */
      setSurcharge(flag: boolean): void;
    }

    /**
     * Instances of ProductShippingModel provide access to product-level
     *  shipping information, such as applicable or inapplicable shipping methods
     *  and shipping cost defined for the product for a specified shipping
     *  method. <br>
     *
     *  Use <a href="class_dw_order_ShippingMgr.html#dw_order_ShippingMgr_getProductShippingModel_Product_DetailAnchor">ShippingMgr.getProductShippingModel(Product)</a> to get
     *  the shipping model for a specific product.
     */
    class ProductShippingModel {
      /**
       * The active applicable shipping methods for the product related
       *  to this shipping model, i.e. shipping methods the product can be shipped
       *  with. A product can be shipping with a shipping methods if the shipping
       *  method is not explicitely marked as inapplicable for this product.
       */
      readonly applicableShippingMethods: dw.util.Collection<
        dw.order.ShippingMethod
      >;
      /**
       * The active inapplicable shipping methods for the product related
       *  to this shipping model, i.e. shipping methods the product cannot be
       *  shipped with. A product cannot be shipping with a shipping methods if the
       *  shipping method is explicitely marked as inapplicable for this product.
       */
      readonly inapplicableShippingMethods: dw.util.Collection<
        dw.order.ShippingMethod
      >;
      /**
       * The active shipping methods for which either any fixed-price or
       *  surcharge product-level shipping cost is defined for the specified product.
       *  Note that this can include inapplicable shipping methods
       *  (see getInapplicableShippingMethods()).
       */
      readonly shippingMethodsWithShippingCost: dw.util.Collection<
        dw.order.ShippingMethod
      >;

      /**
       * Returns the active applicable shipping methods for the product related
       *  to this shipping model, i.e. shipping methods the product can be shipped
       *  with. A product can be shipping with a shipping methods if the shipping
       *  method is not explicitely marked as inapplicable for this product.
       *
       * @return Applicable shipping methods for the product
       */
      getApplicableShippingMethods(): dw.util.Collection<
        dw.order.ShippingMethod
      >;
      /**
       * Returns the active inapplicable shipping methods for the product related
       *  to this shipping model, i.e. shipping methods the product cannot be
       *  shipped with. A product cannot be shipping with a shipping methods if the
       *  shipping method is explicitely marked as inapplicable for this product.
       *
       * @return Inapplicable shipping methods for the product
       */
      getInapplicableShippingMethods(): dw.util.Collection<
        dw.order.ShippingMethod
      >;
      /**
       * Returns the shipping cost object for the related product and
       *  the specified shipping method, or null if no product-level fixed-price or
       *  surcharge shipping cost are defined for the specified product.
       *  The following rules apply:
       *
       *  if fixed and surcharge shipping cost is defined for a product, the fixed cost takes precedence
       *  if a product is member of multiple shipping cost groups, the lowest shipping cost takes precedence
       * @param shippingMethod the shipping method to use.
       * @return Product shipping cost
       */
      getShippingCost(
        shippingMethod: dw.order.ShippingMethod
      ): dw.order.ProductShippingCost;
      /**
       * Returns the active shipping methods for which either any fixed-price or
       *  surcharge product-level shipping cost is defined for the specified product.
       *  Note that this can include inapplicable shipping methods
       *  (see getInapplicableShippingMethods()).
       *
       * @return Shipping methods with shipping cost
       */
      getShippingMethodsWithShippingCost(): dw.util.Collection<
        dw.order.ShippingMethod
      >;
    }

    /**
     * The Return represents a physical customer return, and contains 1..n
     *  <a href="class_dw_order_ReturnItem.html">ReturnItem</a>s. The Return is associated with one <a href="class_dw_order_ReturnCase.html">ReturnCase</a>, and each
     *  ReturnItem is associated with one <a href="class_dw_order_ReturnCaseItem.html">ReturnCaseItem</a> and (via the
     *  ReturnCaseItem) a single <a href="class_dw_order_OrderItem.html">OrderItem</a> usually representing an <a href="class_dw_order_Order.html">Order</a>
     *  <a href="class_dw_order_ProductLineItem.html">ProductLineItem</a>. <br>
     *  The ReturnItem records the quantity returned.
     *  <br>The Return can have one of these status values:
     *  <ul>
     *  <li>NEW - the return is new, i.e. needs to undergo a check before it can be
     *  marked as COMPLETED</li>
     *  <li>COMPLETED - the return is complete, this is a precondition for refunding the
     *  customer for a return.</li>
     *  </ul>
     *  <p>
     *  Order post-processing APIs (gillian) are now inactive by default and will throw
     *  an exception if accessed. On sandboxes the APIs can be activated with a feature
     *  switch &quot;Order Post Processing APIs on Sandboxes&quot;. On PIGs an activation needs
     *  preliminary approval by Product Management. Please contact support in this case.
     *  Existing customers using these APIs are not affected by this change and can use the
     *  APIs until further notice.</p>
     */
    class Return extends dw.order.AbstractItemCtnr {
      /**
       * Sorting by item id. Use with method getItems() as an argument to method FilteringCollection.sort(Object).
       */
      static readonly ORDERBY_ITEMID: any;
      /**
       * Sorting by the position of the related oder item. Use with method getItems() as an argument to method FilteringCollection.sort(Object).
       */
      static readonly ORDERBY_ITEMPOSITION: any;
      /**
       * Unsorted , as it is. Use with method getItems() as an argument to method FilteringCollection.sort(Object).
       */
      static readonly ORDERBY_UNSORTED: any;
      /**
       * Selects the product items. Use with method getItems() as an argument to method FilteringCollection.select(Object).
       */
      static readonly QUALIFIER_PRODUCTITEMS: any;
      /**
       * Selects for the service items. Use with method getItems() as an argument to method FilteringCollection.select(Object).
       */
      static readonly QUALIFIER_SERVICEITEMS: any;
      /**
       * Constant for Return Status COMPLETED
       */
      static readonly STATUS_COMPLETED = "COMPLETED";
      /**
       * Constant for Return Status NEW
       */
      static readonly STATUS_NEW = "NEW";

      /**
       * Returns null or the previously created Invoice.
       */
      readonly invoice: dw.order.Invoice;
      /**
       * Returns null or the invoice-number.
       */
      readonly invoiceNumber: string;
      /**
       * The ReturnItems contained in the Return, created with method
       *  createItem(String).
       *
       *
       *  This FilteringCollection can be sorted / filtered using:
       *
       *  FilteringCollection.sort(Object) with ORDERBY_ITEMID
       *  FilteringCollection.sort(Object) with
       *  ORDERBY_ITEMPOSITION
       *  FilteringCollection.sort(Object) with ORDERBY_UNSORTED
       *  FilteringCollection.select(Object) with QUALIFIER_PRODUCTITEMS
       *  FilteringCollection.select(Object) with QUALIFIER_SERVICEITEMS
       */
      readonly items: dw.util.FilteringCollection<dw.order.ReturnItem>;
      /**
       * A note for the return.
       */
      note: string;
      /**
       * The ReturnCase with which this Return is associated. The ReturnCase
       *  may represent an RMA (return merchandise authorization).
       */
      readonly returnCase: dw.order.ReturnCase;
      /**
       * The return number identifying this return.
       */
      readonly returnNumber: string;
      /**
       * Gets the return status.
       *
       *  Possible values are STATUS_NEW, STATUS_COMPLETED.
       */
      status: dw.value.EnumValue;

      /**
       * Creates a new Invoice based on this Return.
       *  The return-number will be used as the invoice-number. The
       *  Invoice can then be accessed using getInvoice() or its
       *  number using getInvoiceNumber(). The method must not be called
       *  more than once for a Return, nor may 2 Invoices exist
       *  with the same invoice-number.
       *
       *  The new Invoice is a credit-invoice with a Invoice.STATUS_NOT_PAID status, and
       *  will be passed to the refund payment-hook in a separate database
       *  transaction for processing.
       *
       * @return new invoice
       */
      createInvoice(): dw.order.Invoice;
      /**
       * Creates a new Invoice based on this Return. The
       *  invoice-number must be specified as an argument. The
       *  Invoice can then be accessed using getInvoice() or its
       *  number using getInvoiceNumber(). The method must not be called
       *  more than once for a Return, nor may 2 Invoices exist
       *  with the same invoice-number.
       *
       *  The new Invoice is a credit-invoice with a Invoice.STATUS_NOT_PAID status, and
       *  will be passed to the refund payment-hook in a separate database
       *  transaction for processing.
       * @param invoiceNumber the invoice-number to use
       * @return the new invoice
       */
      createInvoice(invoiceNumber: string): dw.order.Invoice;
      /**
       * Create a ReturnItem based on a ReturnCaseItem.
       * @param returnCaseItemID the id of the return case item
       * @return the created return item
       */
      createItem(returnCaseItemID: string): dw.order.ReturnItem;
      /**
       * Returns null or the previously created Invoice.
       *
       * @return null or the previously created invoice.
       */
      getInvoice(): dw.order.Invoice;
      /**
       * Returns null or the invoice-number.
       *
       * @return null or the previously created invoice.
       */
      getInvoiceNumber(): string;
      /**
       * Returns the ReturnItems contained in the Return, created with method
       *  createItem(String).
       *
       *
       *  This FilteringCollection can be sorted / filtered using:
       *
       *  FilteringCollection.sort(Object) with ORDERBY_ITEMID
       *  FilteringCollection.sort(Object) with
       *  ORDERBY_ITEMPOSITION
       *  FilteringCollection.sort(Object) with ORDERBY_UNSORTED
       *  FilteringCollection.select(Object) with QUALIFIER_PRODUCTITEMS
       *  FilteringCollection.select(Object) with QUALIFIER_SERVICEITEMS
       *
       * @return the return items
       */
      getItems(): dw.util.FilteringCollection<dw.order.ReturnItem>;
      /**
       * A note for the return.
       *
       * @return the note or null
       */
      getNote(): string;
      /**
       * Returns the ReturnCase with which this Return is associated. The ReturnCase
       *  may represent an RMA (return merchandise authorization).
       *
       * @return the return case
       */
      getReturnCase(): dw.order.ReturnCase;
      /**
       * The return number identifying this return.
       *
       * @return the return number
       */
      getReturnNumber(): string;
      /**
       * Gets the return status.
       *
       *  Possible values are STATUS_NEW, STATUS_COMPLETED.
       *
       * @return the status
       */
      getStatus(): dw.value.EnumValue;
      /**
       * Sets a note for the return.
       * @param note the note
       */
      setNote(note: string): void;
      /**
       * Sets the return status.
       *
       *  Possible values are STATUS_NEW, STATUS_COMPLETED
       *
       *  When set to status COMPLETED, only the the custom attributes of the return itself and its return items can be changed.
       * @param statusName the status
       */
      setStatus(statusName: string): void;
    }

    /**
     * All returns exist in the context of a ReturnCase, each <a href="class_dw_order_Order.html">Order</a>
     *  can have any number of ReturnCases. <br>
     *  The ReturnCase has <a href="class_dw_order_ReturnCaseItem.html">ReturnCaseItem</a>s, each of which is associated with an
     *  <a href="class_dw_order_OrderItem.html">OrderItem</a> (an extension to either a <a href="class_dw_order_ProductLineItem.html">ProductLineItem</a> or a <a href="class_dw_order_ShippingLineItem.html">ShippingLineItem</a>). <br>
     *  Each ReturnCaseItem defines <a href="class_dw_order_ReturnCaseItem.html#dw_order_ReturnCaseItem_getAuthorizedQuantity_DetailAnchor">ReturnCaseItem.getAuthorizedQuantity()</a> representing the maximum
     *  quantity expected to be returned. The ReturnCaseItem may be associated with
     *  0..n <a href="class_dw_order_ReturnItem.html">ReturnItem</a>s - ReturnItems are added to the ReturnCaseItem when
     *  <a href="class_dw_order_Return.html">Return</a>s are created.
     *  <p>
     *  <i>Either</i> - a ReturnCase may be used as an RMA, in which case they are
     *  created when a customer first shows a wish to return item(s). The customer
     *  then includes the RMA number with the returned item(s). The Return created as
     *  a result is then associated with the existing ReturnCase. <br>
     *  <i>Or</i> - a ReturnCase is automatically created as part of the return
     *  creation, i.e. the customer returns some item(s) leading to a creation of
     *  both a Return and an associated ReturnCase.
     *  </p>
     *  <p>
     *  The scripting api allows access to the ReturnCases, whether the ReturnCase is an RMA or not,
     *  and the ReturnCase status. Both the ReturnCaseItems and any Returns
     *  associated with the ReturnCase can be accessed.
     *  </p><p>
     *  A ReturnCase has one of these status values:
     *  </p><ul>
     *  <li>NEW - the ReturnCase has been created and can be edited previous to
     *  its authorization</li>
     *  <li>CONFIRMED - the ReturnCase is CONFIRMED, can no longer be edited, no
     *  Returns have been associated with it. Only a NEW- ReturnCase can be
     *  CONFIRMED</li>
     *  <li>PARTIAL_RETURNED - the ReturnCase has been associated with at least one Return,
     *  but is not yet complete. Only a CONFIRMED- ReturnCase can be set to
     *  PARTIAL_RETURNED</li>
     *  <li>RETURNED - the ReturnCase has been associated with Returns which match
     *  the expected authorized quantity. Only an CONFIRMED- or PARTIAL_RETURNED- return-case
     *  can be set to RETURNED</li>
     *  <li>CANCELLED - the ReturnCase has been cancelled (only a NEW- or
     *  CONFIRMED- ReturnCase can be cancelled)</li>
     *  </ul>
     *  <p>
     *  Order post-processing APIs (gillian) are now inactive by default and will throw
     *  an exception if accessed. On sandboxes the APIs can be activated with a feature
     *  switch &quot;Order Post Processing APIs on Sandboxes&quot;. On PIGs an activation needs
     *  preliminary approval by Product Management. Please contact support in this case.
     *  Existing customers using these APIs are not affected by this change and can use the
     *  APIs until further notice.</p>
     */
    class ReturnCase extends dw.order.AbstractItemCtnr {
      /**
       * Sorting by item id. Use with method getItems() as an argument to method FilteringCollection.sort(Object).
       */
      static readonly ORDERBY_ITEMID: any;
      /**
       * Sorting by the position of the related oder item. Use with method getItems() as an argument to method FilteringCollection.sort(Object).
       */
      static readonly ORDERBY_ITEMPOSITION: any;
      /**
       * Unsorted , as it is. Use with method getItems() as an argument to method FilteringCollection.sort(Object).
       */
      static readonly ORDERBY_UNSORTED: any;
      /**
       * Selects the product items. Use with method getItems() as an argument to method FilteringCollection.select(Object).
       */
      static readonly QUALIFIER_PRODUCTITEMS: any;
      /**
       * Selects for the service items. Use with method getItems() as an argument to method FilteringCollection.select(Object).
       */
      static readonly QUALIFIER_SERVICEITEMS: any;
      /**
       * constant for ReturnCase Status CANCELLED
       */
      static readonly STATUS_CANCELLED = "CANCELLED";
      /**
       * constant for ReturnCase Status CONFIRMED
       */
      static readonly STATUS_CONFIRMED = "CONFIRMED";
      /**
       * constant for ReturnCase Status NEW
       */
      static readonly STATUS_NEW = "NEW";
      /**
       * constant for ReturnCase Status PARTIAL RETURNED
       */
      static readonly STATUS_PARTIAL_RETURNED = "PARTIAL_RETURNED";
      /**
       * constant for ReturnCase Status RETURNED
       */
      static readonly STATUS_RETURNED = "RETURNED";

      /**
       * Returns null or the previously created Invoice.
       */
      readonly invoice: dw.order.Invoice;
      /**
       * Returns null or the invoice-number.
       */
      readonly invoiceNumber: string;
      /**
       * Access the collection of ReturnCaseItems.
       *
       *  This FilteringCollection can be sorted / filtered using:
       *
       *  FilteringCollection.sort(Object) with ORDERBY_ITEMID
       *  FilteringCollection.sort(Object) with
       *  ORDERBY_ITEMPOSITION
       *  FilteringCollection.sort(Object) with ORDERBY_UNSORTED
       *  FilteringCollection.select(Object) with QUALIFIER_PRODUCTITEMS
       *  FilteringCollection.select(Object) with QUALIFIER_SERVICEITEMS
       */
      readonly items: dw.util.FilteringCollection<dw.order.ReturnCaseItem>;
      /**
       * The mandatory return case number identifying this document.
       */
      readonly returnCaseNumber: string;
      /**
       * Return the collection of Returns associated with this ReturnCase.
       */
      readonly returns: dw.util.Collection<dw.order.Return>;
      /**
       * Return whether this is an RMA. This is specified when calling Order.createReturnCase(String, Boolean).
       */
      readonly RMA: boolean;
      /**
       * Gets the return case item status. The status of a ReturnCase is read-only and calculated from the status of
       *  the associated ReturnCaseItems.
       *
       *  The possible values are STATUS_NEW,STATUS_CONFIRMED,
       *  STATUS_PARTIAL_RETURNED, STATUS_RETURNED,
       *  STATUS_CANCELLED.
       */
      readonly status: dw.value.EnumValue;

      /**
       * Attempt to confirm the ReturnCase.
       *  Without items the return case will be canceled
       *  When confirmed, only the the custom attributes of its return case items can be changed.
       *
       */
      confirm(): void;
      /**
       * Creates a new Invoice based on this
       *  ReturnCase. The return-case-number will
       *  be used as the invoice-number. The Invoice can then be
       *  accessed using getInvoice() or its number using
       *  getInvoiceNumber(). The method must not be called more than once
       *  for a ReturnCase, nor may 2 Invoices
       *  exist with the same invoice-number.
       *
       *  The new Invoice is a credit-invoice with a
       *  Invoice.STATUS_NOT_PAID status, and will be passed to
       *  the refund payment-hook in a separate database transaction for
       *  processing.
       *
       * @return new invoice
       */
      createInvoice(): dw.order.Invoice;
      /**
       * Creates a new Invoice based on this
       *  ReturnCase. The invoice-number must be specified as an
       *  argument. The Invoice can then be
       *  accessed using getInvoice() or its number using
       *  getInvoiceNumber(). The method must not be called more than once
       *  for a ReturnCase, nor may 2 Invoices
       *  exist with the same invoice-number.
       *
       *  The new Invoice is a credit-invoice with a
       *  Invoice.STATUS_NOT_PAID status, and will be passed to
       *  the refund payment-hook in a separate database transaction for
       *  processing.
       * @param invoiceNumber the invoice-number to be used for the invoice creation
       * @return new invoice
       */
      createInvoice(invoiceNumber: string): dw.order.Invoice;
      /**
       * Creates a new item for a given order item. Note: a ReturnCase may have
       *  only one item per order item.
       * @param orderItemID order item id
       * @return null or item for given order item
       */
      createItem(orderItemID: string): dw.order.ReturnCaseItem;
      /**
       * Creates a new Return with the given number and associates it with this ReturnCase.
       * @param returnNumber return number to assign
       * @return new Return instance
       */
      createReturn(returnNumber: string): dw.order.Return;
      /**
       * Creates a new Return with a generated number and associates it with this ReturnCase.
       *
       * @return new Return instance
       */
      createReturn(): dw.order.Return;
      /**
       * Returns null or the previously created Invoice.
       *
       * @return null or the previously created invoice.
       */
      getInvoice(): dw.order.Invoice;
      /**
       * Returns null or the invoice-number.
       *
       * @return null or the previously created invoice.
       */
      getInvoiceNumber(): string;
      /**
       * Access the collection of ReturnCaseItems.
       *
       *  This FilteringCollection can be sorted / filtered using:
       *
       *  FilteringCollection.sort(Object) with ORDERBY_ITEMID
       *  FilteringCollection.sort(Object) with
       *  ORDERBY_ITEMPOSITION
       *  FilteringCollection.sort(Object) with ORDERBY_UNSORTED
       *  FilteringCollection.select(Object) with QUALIFIER_PRODUCTITEMS
       *  FilteringCollection.select(Object) with QUALIFIER_SERVICEITEMS
       *
       * @return the items
       */
      getItems(): dw.util.FilteringCollection<dw.order.ReturnCaseItem>;
      /**
       * Returns the mandatory return case number identifying this document.
       *
       * @return the return case number
       */
      getReturnCaseNumber(): string;
      /**
       * Return the collection of Returns associated with this ReturnCase.
       *
       * @return the collection of Returns.
       */
      getReturns(): dw.util.Collection<dw.order.Return>;
      /**
       * Gets the return case item status. The status of a ReturnCase is read-only and calculated from the status of
       *  the associated ReturnCaseItems.
       *
       *  The possible values are STATUS_NEW,STATUS_CONFIRMED,
       *  STATUS_PARTIAL_RETURNED, STATUS_RETURNED,
       *  STATUS_CANCELLED.
       *
       * @return the status
       */
      getStatus(): dw.value.EnumValue;
      /**
       * Return whether this is an RMA. This is specified when calling Order.createReturnCase(String, Boolean).
       *
       * @return whether this is an RMA.
       */
      isRMA(): boolean;
    }

    /**
     * An item of a <a href="class_dw_order_ReturnCase.html">ReturnCase</a>, created using method
     *  <a href="class_dw_order_ReturnCase.html#dw_order_ReturnCase_createItem_String_DetailAnchor">ReturnCase.createItem(String)</a>. Initially the
     *  ReturnCaseItem is NEW. No <a href="class_dw_order_Return.html">Return</a> can be
     *  created at this point. From NEW the item transitions in CONFIRMED state.
     *  Now Return can be created. Next transition is either to
     *  PARTIAL_RETURNED or to CANCELLED. At the end the item can be RETURNED (no other
     *  Returns can be created.
     *
     *  The custom code implementing the ReturnHooks is
     *  responsible to provide the logic for the transitions. Please refer to the
     *  documentation of <a href="class_dw_order_hooks_ReturnHooks.html">ReturnHooks</a> for further
     *  information.
     *  <br>
     *  When the related ReturnCase were confirmed, only the the custom attributes of the return case item can be changed.
     *  <p>
     *  Order post-processing APIs (gillian) are now inactive by default and will throw
     *  an exception if accessed. On sandboxes the APIs can be activated with a feature
     *  switch &quot;Order Post Processing APIs on Sandboxes&quot;. On PIGs an activation needs
     *  preliminary approval by Product Management. Please contact support in this case.
     *  Existing customers using these APIs are not affected by this change and can use the
     *  APIs until further notice.</p>
     */
    class ReturnCaseItem extends dw.order.AbstractItem {
      /**
       * constant for ReturnCase Status CANCELLED
       */
      static readonly STATUS_CANCELLED = "CANCELLED";
      /**
       * constant for ReturnCase Status CONFIRMED
       */
      static readonly STATUS_CONFIRMED = "CONFIRMED";
      /**
       * constant for ReturnCase Status NEW
       */
      static readonly STATUS_NEW = "NEW";
      /**
       * constant for ReturnCase Status PARTIAL RETURNED
       */
      static readonly STATUS_PARTIAL_RETURNED = "PARTIAL_RETURNED";
      /**
       * constant for ReturnCase Status RETURNED
       */
      static readonly STATUS_RETURNED = "RETURNED";

      /**
       * Return the Quantity authorized for this ReturnCaseItem, may be N/A.
       */
      authorizedQuantity: dw.value.Quantity;
      /**
       * Price of a single unit before discount application.
       */
      readonly basePrice: dw.value.Money;
      /**
       * Return the note for this return case item.
       */
      note: string;
      /**
       * Returns null or the parent item.
       */
      parentItem: dw.order.ReturnCaseItem;
      /**
       * The reason code for return case item.
       */
      reasonCode: dw.value.EnumValue;
      /**
       * Mandatory number of ReturnCase to which this item belongs
       */
      readonly returnCaseNumber: string;
      /**
       * Unsorted collection of ReturnItems associated with this ReturnCaseItem.
       */
      readonly returnItems: dw.util.Collection<dw.order.ReturnItem>;
      /**
       * Gets the return case item status.
       *
       *  The possible values are STATUS_NEW,STATUS_CONFIRMED,
       *  STATUS_PARTIAL_RETURNED, STATUS_RETURNED,
       *  STATUS_CANCELLED.
       */
      status: dw.value.EnumValue;

      /**
       * Create a new ReturnItem for this ReturnCaseItem and assign it to the
       *  given Return.
       * @param returnNumber number of Return to which new item is assigned.
       * @return new ReturnItem
       */
      createReturnItem(returnNumber: string): dw.order.ReturnItem;
      /**
       * Return the Quantity authorized for this ReturnCaseItem, may be N/A.
       *
       * @return the authorized quantity or N/A
       */
      getAuthorizedQuantity(): dw.value.Quantity;
      /**
       * Price of a single unit before discount application.
       *
       * @return Price of a single unit before discount application.
       */
      getBasePrice(): dw.value.Money;
      /**
       * Return the note for this return case item.
       *
       * @return the note or null
       */
      getNote(): string;
      /**
       * Returns null or the parent item.
       *
       * @return null or the parent item.
       */
      getParentItem(): dw.order.ReturnCaseItem;
      /**
       * Returns the reason code for return case item.
       *
       * @return the return reason code
       */
      getReasonCode(): dw.value.EnumValue;
      /**
       * Mandatory number of ReturnCase to which this item belongs
       *
       * @return number of ReturnCase to which this item belongs
       */
      getReturnCaseNumber(): string;
      /**
       * Unsorted collection of ReturnItems associated with this ReturnCaseItem.
       *
       * @return unsorted collection of ReturnItems associated with this ReturnCaseItem
       */
      getReturnItems(): dw.util.Collection<dw.order.ReturnItem>;
      /**
       * Gets the return case item status.
       *
       *  The possible values are STATUS_NEW,STATUS_CONFIRMED,
       *  STATUS_PARTIAL_RETURNED, STATUS_RETURNED,
       *  STATUS_CANCELLED.
       *
       * @return the status
       */
      getStatus(): dw.value.EnumValue;
      /**
       * Set the optional authorized Quantity for this item. Passing null will result in an N/A Quantity
       *  being set.
       * @param authorizedQuantity null or the quantity
       */
      setAuthorizedQuantity(authorizedQuantity: dw.value.Quantity): void;
      /**
       * Sets a note for this return case item.
       * @param note the note for this return case item to set
       */
      setNote(note: string): void;
      /**
       * Set a parent item. The parent item must belong to the same
       *  ReturnCase. An infinite parent-child loop is disallowed
       *  as is a parent-child depth greater than 10. Setting a parent item
       *  indicates a dependency of the child item on the parent item, and can be
       *  used to form a parallel structure to that accessed using
       *  ProductLineItem.getParent().
       * @param parentItem The parent item, null is allowed
       */
      setParentItem(parentItem: dw.order.ReturnCaseItem): void;
      /**
       * Changes the reason code. Initially the reason code is set on return case
       *  item creation.
       * @param reasonCode the reason code to set
       */
      setReasonCode(reasonCode: string): void;
      /**
       * Sets the status.
       *
       *  The possible values are STATUS_NEW,STATUS_CONFIRMED,
       *  STATUS_PARTIAL_RETURNED, STATUS_RETURNED,
       *  STATUS_CANCELLED.
       * @param statusString the status
       */
      setStatus(statusString: string): void;
    }

    /**
     * An item of a <a href="class_dw_order_Return.html">Return</a>, created using <a href="class_dw_order_Return.html#dw_order_Return_createItem_String_DetailAnchor">Return.createItem(String)</a>.
     *  Represents a physically returned order line item. Please refer to the documentation of <a href="class_dw_order_hooks_ReturnHooks.html">ReturnHooks</a>
     *  for further information.
     *  <br>
     *  When the related Return were set to status COMPLETED, only the the custom attributes of the return item can be changed.
     *  <p>
     *  Order post-processing APIs (gillian) are now inactive by default and will throw
     *  an exception if accessed. On sandboxes the APIs can be activated with a feature
     *  switch &quot;Order Post Processing APIs on Sandboxes&quot;. On PIGs an activation needs
     *  preliminary approval by Product Management. Please contact support in this case.
     *  Existing customers using these APIs are not affected by this change and can use the
     *  APIs until further notice.</p>
     */
    class ReturnItem extends dw.order.AbstractItem {
      /**
       * Price of a single unit before discount application.
       */
      readonly basePrice: dw.value.Money;
      /**
       * Return the note for this return item.
       */
      note: string;
      /**
       * Returns null or the parent item.
       */
      parentItem: dw.order.ReturnItem;
      /**
       * The reason code for return item. The list of reason codes can be updated
       *  by updating meta-data for ReturnItem.
       */
      reasonCode: dw.value.EnumValue;
      /**
       * The return case item related to this item. Should never return null.
       */
      readonly returnCaseItem: dw.order.ReturnCaseItem;
      /**
       * The Quantity returned. This may return an N/A quantity.
       */
      returnedQuantity: dw.value.Quantity;
      /**
       * The mandatory returnNumber of the Return to which this item belongs.
       */
      readonly returnNumber: string;

      /**
       * Create a new  tax-item and add to this item.
       * @param amount amount to assign to the tax-item
       * @param taxGroup the TaxGroup to which the item belongs
       * @return the new tax-item
       */
      addTaxItem(
        amount: dw.util.Decimal,
        taxGroup: dw.order.TaxGroup
      ): dw.order.TaxItem;
      /**
       * Apply a rate of (factor / divisor) to the prices in this item, with the option to half round up or half round down to the
       *  nearest cent if necessary.
       *  Examples:
       *  TaxBasis beforefactordivisorroundupCalculationTaxBasis after
       *  $10.0012true10*1/2=$5.00
       *  $10.00910true10*9/10=$9.00
       *  $10.0013true10*1/3=3.3333=$3.33
       *   $2.4712true2.47*1/2=1.235=$1.24
       *   $2.4712false2.47*1/2=1.235=$1.23
       *
       *  Which prices are updated?:
       *  The rate described above is applied to tax-basis and tax then the net-price and gross-price are recalculated by adding / subtracting
       *  depending on whether the order is based on net price.
       *  Example (order based on net price)
       *  New TaxBasis:$10.00, Tax:$1.00, NetPrice=TaxBasis=$10.00, GrossPrice=TaxBasis+Tax=$11.00
       *  Example (order based on gross price)
       *  New TaxBasis:$10.00, Tax:$1.00, NetPrice=TaxBasis-tax=$9.00, GrossPrice=TaxBasis=$10.00
       * @param factor factor used to calculate rate
       * @param divisor divisor used to calculate rate
       * @param roundUp whether to round up or down on 0.5
       */
      applyPriceRate(
        factor: dw.util.Decimal,
        divisor: dw.util.Decimal,
        roundUp: boolean
      ): void;
      /**
       * Price of a single unit before discount application.
       *
       * @return Price of a single unit before discount application.
       */
      getBasePrice(): dw.value.Money;
      /**
       * Return the note for this return item.
       *
       * @return the note or null
       */
      getNote(): string;
      /**
       * Returns null or the parent item.
       *
       * @return null or the parent item.
       */
      getParentItem(): dw.order.ReturnItem;
      /**
       * Returns the reason code for return item. The list of reason codes can be updated
       *  by updating meta-data for ReturnItem.
       *
       * @return the return reason code
       */
      getReasonCode(): dw.value.EnumValue;
      /**
       * Returns the return case item related to this item. Should never return null.
       *
       * @return the return case item related to this item
       */
      getReturnCaseItem(): dw.order.ReturnCaseItem;
      /**
       * The Quantity returned. This may return an N/A quantity.
       *
       * @return the quantity returned, may be N/A
       */
      getReturnedQuantity(): dw.value.Quantity;
      /**
       * The mandatory returnNumber of the Return to which this item belongs.
       *
       * @return the returnNumber of the Return to which this item belongs
       */
      getReturnNumber(): string;
      /**
       * Sets a note for this return item.
       * @param note the note for this return item to set
       */
      setNote(note: string): void;
      /**
       * Set a parent item. The parent item must belong to the same
       *  Return. An infinite parent-child loop is disallowed
       *  as is a parent-child depth greater than 10. Setting a parent item
       *  indicates a dependency of the child item on the parent item, and can be
       *  used to form a parallel structure to that accessed using
       *  ProductLineItem.getParent().
       * @param parentItem The parent item, null is allowed
       */
      setParentItem(parentItem: dw.order.ReturnItem): void;
      /**
       * Set the reason code. The list of reason codes can be updated by updating meta-data for ReturnItem.
       * @param reasonCode the reason code to set
       */
      setReasonCode(reasonCode: string): void;
      /**
       * Set the Quantity returned. Passing null results in an exception being thrown.
       *  The quantity must be higher than zero and not be higher than the remaining quantity to return.
       *
       *  The item prices are recalculated in this method as described in applyPriceRate(Decimal, Decimal, Boolean)
       *  with the quantity argument as the factor, and ordered quantity as divisor
       *  and true as the roundup parameter.
       * @param quantity the quantity returned, null not allowed
       */
      setReturnedQuantity(quantity: dw.value.Quantity): void;
      /**
       * Set the tax-basis price for this item.
       * @param taxBasis the tax basis value.
       */
      setTaxBasis(taxBasis: dw.value.Money): void;
      /**
       * Set the tax-items for this item.
       * @param taxItems items
       */
      setTaxItems(taxItems: dw.util.Collection<any>): void;
    }

    /**
     * Represents an order shipment.
     */
    class Shipment extends dw.object.ExtensibleObject {
      /**
       * Shipment shipping status representing 'Not shipped'.
       */
      static readonly SHIPMENT_NOTSHIPPED = 0;
      /**
       * Shipment shipping status representing 'Shipped'.
       */
      static readonly SHIPMENT_SHIPPED = 2;
      /**
       * Shipment shipping status representing 'Not shipped'.
       */
      static readonly SHIPPING_STATUS_NOTSHIPPED = 0;
      /**
       * Shipment shipping status representing 'Shipped'.
       */
      static readonly SHIPPING_STATUS_SHIPPED = 2;

      /**
       * The adjusted total gross price, including tax, in the purchase currency.
       *
       *  Adjusted merchandize prices represent the sum of product prices before
       *  services such as shipping have been added, but after adjustments from i.e.
       *  promotions have been added.
       */
      readonly adjustedMerchandizeTotalGrossPrice: dw.value.Money;
      /**
       * The adjusted net price, excluding tax, in the purchase currency.
       *
       *  Adjusted merchandize prices represent the sum of product prices before
       *  services such as shipping have been added, but after adjustments from i.e.
       *  promotions have been added.
       */
      readonly adjustedMerchandizeTotalNetPrice: dw.value.Money;
      /**
       * The merchandize total price after all product discounts.
       *  If the line item container is based on net pricing the adjusted
       *  merchandize total net price is returned.
       *  If the line item container is based on gross pricing the adjusted
       *  merchandize total gross price is returned.
       */
      readonly adjustedMerchandizeTotalPrice: dw.value.Money;
      /**
       * The total tax in purchase currency.
       *
       *  Adjusted merchandize prices represent the sum of product prices before
       *  services such as shipping have been added, but after adjustments from i.e.
       *  promotions have been added.
       */
      readonly adjustedMerchandizeTotalTax: dw.value.Money;
      /**
       * The adjusted sum of all shipping line items of the shipment,
       *  including tax after shipping adjustments have been applied.
       */
      readonly adjustedShippingTotalGrossPrice: dw.value.Money;
      /**
       * The sum of all shipping line items of the shipment, excluding tax
       *  after shipping adjustments have been applied.
       */
      readonly adjustedShippingTotalNetPrice: dw.value.Money;
      /**
       * The adjusted shipping total price. If the line item container
       *  is based on net pricing the adjusted shipping total net price is
       *  returned. If the line item container is based on gross pricing the adjusted
       *  shipping total gross price is returned.
       */
      readonly adjustedShippingTotalPrice: dw.value.Money;
      /**
       * The tax of all shipping line items of the shipment after shipping
       *  adjustments have been applied.
       */
      readonly adjustedShippingTotalTax: dw.value.Money;
      /**
       * All line items related to the shipment.
       *
       *  The returned collection may include line items of the following types:
       *
       *  ProductLineItem
       *  ShippingLineItem
       *  GiftCertificateLineItem
       *  PriceAdjustment
       *
       *  Their common type is LineItem.
       *
       *  Each ProductLineItem in the collection
       *  may itself contain bundled or option product line items,
       *  as well as a product-level shipping line item.
       */
      readonly allLineItems: dw.util.Collection<dw.order.LineItem>;
      /**
       * Return true if this shipment is the default shipment.
       */
      readonly default: boolean;
      /**
       * Returns true if this line item represents a gift, false otherwise.
       */
      gift: boolean;
      /**
       * All gift certificate line items of the shipment.
       */
      readonly giftCertificateLineItems: dw.util.Collection<
        dw.order.GiftCertificateLineItem
      >;
      /**
       * The value set for gift message or null if no value set.
       */
      giftMessage: string;
      /**
       * The ID of this shipment.
       */
      readonly ID: string;
      /**
       * The total gross price, including tax, in the purchase currency.
       *
       *  Merchandize total prices represent the sum of product prices before
       *  services such as shipping or adjustments from i.e. promotions have
       *  been added.
       */
      readonly merchandizeTotalGrossPrice: dw.value.Money;
      /**
       * The net price, excluding tax, in the purchase currency.
       *
       *  Merchandize total prices represent the sum of product prices before
       *  services such as shipping or adjustments from i.e. promotions have
       *  been added.
       */
      readonly merchandizeTotalNetPrice: dw.value.Money;
      /**
       * The merchandize total price. If the line item container is based
       *  on net pricing the merchandize total net price is returned. If the line
       *  item container is based on gross pricing the merchandize total gross price
       *  is returned.
       */
      readonly merchandizeTotalPrice: dw.value.Money;
      /**
       * A collection of price adjustments that have been applied to the
       *  totals such as promotion on the purchase value (i.e. $10 Off or 10% Off).
       */
      readonly merchandizeTotalPriceAdjustments: dw.util.Collection<
        dw.order.PriceAdjustment
      >;
      /**
       * The total tax in purchase currency.
       *
       *  Merchandize total prices represent the sum of product prices before
       *  services such as shipping or adjustments from i.e. promotions have
       *  been added.
       */
      readonly merchandizeTotalTax: dw.value.Money;
      /**
       * A collection of all product line items related
       *  to this shipment.
       */
      readonly productLineItems: dw.util.Collection<dw.order.ProductLineItem>;
      /**
       * The merchandise total price of the shipment after considering all
       *  product price adjustments and prorating all Buy-X-Get-Y and order-level
       *  discounts, according to the scheme described in
       *  PriceAdjustment.getProratedPrices(). For net pricing the
       *  net price is returned. For gross pricing, the gross price is returned.
       */
      readonly proratedMerchandizeTotalPrice: dw.value.Money;
      /**
       * The shipment number for this shipment.
       *
       *  When an order is placed (OrderMgr.placeOrder(Order)) shipment number will be filled using a
       *  sequence. Before order was placed null will be returned.
       */
      readonly shipmentNo: string;
      /**
       * The shipping address or null if none is set.
       */
      readonly shippingAddress: dw.order.OrderAddress;
      /**
       * A collection of all shipping line items of the shipment,
       *  excluding any product-level shipping costs that are
       *  associated with ProductLineItems of the shipment.
       */
      readonly shippingLineItems: dw.util.Collection<dw.order.ShippingLineItem>;
      /**
       * The shipping method or null if none is set.
       */
      shippingMethod: dw.order.ShippingMethod;
      /**
       * The shipping method ID or null if none is set.
       */
      readonly shippingMethodID: string;
      /**
       * A collection of price adjustments that have been applied to the
       *  shipping costs of the shipment, for example by the promotions engine.
       *
       *  Note that this method returns all shipping price adjustments in this
       *  shipment regardless of which shipping line item they belong to. Use
       *  ShippingLineItem.getShippingPriceAdjustments() to
       *  retrieve the shipping price adjustments associated with a specific
       *  shipping line item.
       */
      readonly shippingPriceAdjustments: dw.util.Collection<
        dw.order.PriceAdjustment
      >;
      /**
       * The shipping status. Possible values are
       *  SHIPMENT_NOTSHIPPED or SHIPMENT_SHIPPED.
       */
      shippingStatus: dw.value.EnumValue;
      /**
       * The sum of all shipping line items of the shipment,
       *  including tax before shipping adjustments have been applied.
       */
      readonly shippingTotalGrossPrice: dw.value.Money;
      /**
       * The sum of all shipping line items of the shipment, excluding tax
       *  before shipping adjustments have been applied.
       */
      readonly shippingTotalNetPrice: dw.value.Money;
      /**
       * The shipping total price. If the line item container is based on
       *  net pricing the shipping total net price is returned. If the line item
       *  container is based on gross pricing the shipping total gross price is
       *  returned.
       */
      readonly shippingTotalPrice: dw.value.Money;
      /**
       * The tax of all shipping line items of the shipment before
       *  shipping adjustments have been applied.
       */
      readonly shippingTotalTax: dw.value.Money;
      /**
       * Convenenience method. Same as
       *  getShippingLineItem(ShippingLineItem.STANDARD_SHIPPING_ID)
       */
      readonly standardShippingLineItem: dw.order.ShippingLineItem;
      /**
       * The grand total price gross of tax for the shipment, in purchase currency.
       *
       *  Total prices represent the sum of product prices, services prices and adjustments.
       */
      readonly totalGrossPrice: dw.value.Money;
      /**
       * The grand total price for the shipment net of tax, in purchase currency.
       *
       *  Total prices represent the sum of product prices, services prices and adjustments.
       */
      readonly totalNetPrice: dw.value.Money;
      /**
       * The total tax for the shipment, in purchase currency.
       *
       *  Total prices represent the sum of product prices, services prices and adjustments.
       */
      readonly totalTax: dw.value.Money;
      /**
       * The tracking number of this shipment.
       */
      trackingNumber: string;

      /**
       * A shipment has initially no shipping address. This method creates a
       *  shipping address for the shipment and replaces an existing shipping
       *  address.
       *
       * @return The new shipping address of the shipment
       */
      createShippingAddress(): dw.order.OrderAddress;
      /**
       * Creates a new shipping line item for this shipment.
       *  If the specified ID is already assigned to any of the existing
       *  shipping line items of the shipment, the method throws an exception.
       * @param id The id to use to locate the new shipping line item.
       * @return The new shipping line item.
       */
      createShippingLineItem(id: string): dw.order.ShippingLineItem;
      /**
       * Creates a shipping price adjustment to be applied to the shipment. The
       *  price adjustment implicitly belongs to the standard shipping line item
       *  if this line item exists, otherwise it belongs to the shipment itself.
       *
       *  The promotion ID is mandatory and must not be the ID of any actual
       *  promotion defined in Commerce Cloud Digital.
       *
       *  If there already exists a shipping price adjustment line item referring
       *  to the specified promotion ID, an exception is thrown.
       * @param promotionID Promotion ID
       * @return The new price adjustment line item.
       */
      createShippingPriceAdjustment(
        promotionID: string
      ): dw.order.PriceAdjustment;
      /**
       * Returns the adjusted total gross price, including tax, in the purchase currency.
       *
       *  Adjusted merchandize prices represent the sum of product prices before
       *  services such as shipping have been added, but after adjustments from i.e.
       *  promotions have been added.
       *
       * @return the adjusted total gross price, including tax, in the purchase currency.
       */
      getAdjustedMerchandizeTotalGrossPrice(): dw.value.Money;
      /**
       * Returns the adjusted net price, excluding tax, in the purchase currency.
       *
       *  Adjusted merchandize prices represent the sum of product prices before
       *  services such as shipping have been added, but after adjustments from i.e.
       *  promotions have been added.
       *
       * @return the adjusted net price, excluding tax, in the purchase currency.
       */
      getAdjustedMerchandizeTotalNetPrice(): dw.value.Money;
      /**
       * Returns the merchandize total price after all product discounts.
       *  If the line item container is based on net pricing the adjusted
       *  merchandize total net price is returned.
       *  If the line item container is based on gross pricing the adjusted
       *  merchandize total gross price is returned.
       *
       * @return either the adjusted merchandize total net or gross price.
       */
      getAdjustedMerchandizeTotalPrice(): dw.value.Money;
      /**
       * Returns the merchandise total price of the shipment after considering all
       *  product price adjustments and, optionally, prorating all order-level
       *  discounts. For net pricing the net price is returned. For gross pricing,
       *  the gross price is returned.
       * @param applyOrderLevelAdjustments If true, order-level adjustments will be applied to total price
       * @return Adjusted net or gross merchandise total price
       */
      getAdjustedMerchandizeTotalPrice(
        applyOrderLevelAdjustments: boolean
      ): dw.value.Money;
      /**
       * Returns the total tax in purchase currency.
       *
       *  Adjusted merchandize prices represent the sum of product prices before
       *  services such as shipping have been added, but after adjustments from i.e.
       *  promotions have been added.
       *
       * @return the total tax in purchase currency.
       */
      getAdjustedMerchandizeTotalTax(): dw.value.Money;
      /**
       * Returns the adjusted sum of all shipping line items of the shipment,
       *  including tax after shipping adjustments have been applied.
       *
       * @return the adjusted sum of all shipping line items of the shipment, including tax after shipping adjustments have been applied.
       */
      getAdjustedShippingTotalGrossPrice(): dw.value.Money;
      /**
       * Returns the sum of all shipping line items of the shipment, excluding tax
       *  after shipping adjustments have been applied.
       *
       * @return the sum of all shipping line items of the shipment, excluding tax after shipping adjustments have been applied.
       */
      getAdjustedShippingTotalNetPrice(): dw.value.Money;
      /**
       * Returns the adjusted shipping total price. If the line item container
       *  is based on net pricing the adjusted shipping total net price is
       *  returned. If the line item container is based on gross pricing the adjusted
       *  shipping total gross price is returned.
       *
       * @return either the adjusted shipping total net or gross price
       */
      getAdjustedShippingTotalPrice(): dw.value.Money;
      /**
       * Returns the tax of all shipping line items of the shipment after shipping
       *  adjustments have been applied.
       *
       * @return the tax of all shipping line items of the shipment after shipping adjustments have been applied.
       */
      getAdjustedShippingTotalTax(): dw.value.Money;
      /**
       * Returns all line items related to the shipment.
       *
       *  The returned collection may include line items of the following types:
       *
       *  ProductLineItem
       *  ShippingLineItem
       *  GiftCertificateLineItem
       *  PriceAdjustment
       *
       *  Their common type is LineItem.
       *
       *  Each ProductLineItem in the collection
       *  may itself contain bundled or option product line items,
       *  as well as a product-level shipping line item.
       *
       * @return all line items related to ths shipment.
       */
      getAllLineItems(): dw.util.Collection<dw.order.LineItem>;
      /**
       * Returns all gift certificate line items of the shipment.
       *
       * @return A collection of all GiftCertificateLineItems of the shipment.
       */
      getGiftCertificateLineItems(): dw.util.Collection<
        dw.order.GiftCertificateLineItem
      >;
      /**
       * Returns the value set for gift message or null if no value set.
       *
       * @return the value set for gift message or null if no value set.
       */
      getGiftMessage(): string;
      /**
       * Returns the ID of this shipment.
       *
       * @return the ID of this shipment
       */
      getID(): string;
      /**
       * Returns the total gross price, including tax, in the purchase currency.
       *
       *  Merchandize total prices represent the sum of product prices before
       *  services such as shipping or adjustments from i.e. promotions have
       *  been added.
       *
       * @return the total gross price, including tax, in the purchase currency.
       */
      getMerchandizeTotalGrossPrice(): dw.value.Money;
      /**
       * Returns the net price, excluding tax, in the purchase currency.
       *
       *  Merchandize total prices represent the sum of product prices before
       *  services such as shipping or adjustments from i.e. promotions have
       *  been added.
       *
       * @return the net price, excluding tax, in the purchase currency.
       */
      getMerchandizeTotalNetPrice(): dw.value.Money;
      /**
       * Returns the merchandize total price. If the line item container is based
       *  on net pricing the merchandize total net price is returned. If the line
       *  item container is based on gross pricing the merchandize total gross price
       *  is returned.
       *
       * @return either the merchandize total net or gross price
       */
      getMerchandizeTotalPrice(): dw.value.Money;
      /**
       * Returns a collection of price adjustments that have been applied to the
       *  totals such as promotion on the purchase value (i.e. $10 Off or 10% Off).
       *
       * @return a collection of price adjustments that have been applied to the totals such as promotion on the purchase value (i.e. $10 Off or 10% Off).
       */
      getMerchandizeTotalPriceAdjustments(): dw.util.Collection<
        dw.order.PriceAdjustment
      >;
      /**
       * Returns the total tax in purchase currency.
       *
       *  Merchandize total prices represent the sum of product prices before
       *  services such as shipping or adjustments from i.e. promotions have
       *  been added.
       *
       * @return the total tax in purchase currency.
       */
      getMerchandizeTotalTax(): dw.value.Money;
      /**
       * Returns a collection of all product line items related
       *  to this shipment.
       *
       * @return a collection of all product line items related to this shipment.
       */
      getProductLineItems(): dw.util.Collection<dw.order.ProductLineItem>;
      /**
       * Returns the merchandise total price of the shipment after considering all
       *  product price adjustments and prorating all Buy-X-Get-Y and order-level
       *  discounts, according to the scheme described in
       *  PriceAdjustment.getProratedPrices(). For net pricing the
       *  net price is returned. For gross pricing, the gross price is returned.
       *
       * @return Adjusted and prorated net or gross merchandise total price
       */
      getProratedMerchandizeTotalPrice(): dw.value.Money;
      /**
       * Returns the shipment number for this shipment.
       *
       *  When an order is placed (OrderMgr.placeOrder(Order)) shipment number will be filled using a
       *  sequence. Before order was placed null will be returned.
       *
       * @return the shipment number for this shipment.
       */
      getShipmentNo(): string;
      /**
       * Returns the shipping address or null if none is set.
       *
       * @return the shipping address or null if none is set.
       */
      getShippingAddress(): dw.order.OrderAddress;
      /**
       * Returns the shipping line item identified by the specified ID, or
       *  null if not found.
       *
       *  To get the standard shipping line item for this shipment,
       *  use the identifier ShippingLineItem.STANDARD_SHIPPING_ID.
       * @param id the identifier to use to locate the shipping line item.
       * @return the shipping line item identified by the specified ID, or null if not found.
       */
      getShippingLineItem(id: string): dw.order.ShippingLineItem;
      /**
       * Returns a collection of all shipping line items of the shipment,
       *  excluding any product-level shipping costs that are
       *  associated with ProductLineItems of the shipment.
       *
       * @return a collection of all shipping line items of the shipment, excluding any product-level shipping costs.
       */
      getShippingLineItems(): dw.util.Collection<dw.order.ShippingLineItem>;
      /**
       * Returns the shipping method or null if none is set.
       *
       * @return the shipping method or null if none is set.
       */
      getShippingMethod(): dw.order.ShippingMethod;
      /**
       * Returns the shipping method ID or null if none is set.
       *
       * @return the shipping method ID or null if none is set.
       */
      getShippingMethodID(): string;
      /**
       * Returns the shipping price adjustment associated with the
       *  specified promotion ID.
       * @param promotionID the promotion ID
       * @return The price adjustment associated with the given promotion ID
       */
      getShippingPriceAdjustmentByPromotionID(
        promotionID: string
      ): dw.order.PriceAdjustment;
      /**
       * Returns a collection of price adjustments that have been applied to the
       *  shipping costs of the shipment, for example by the promotions engine.
       *
       *  Note that this method returns all shipping price adjustments in this
       *  shipment regardless of which shipping line item they belong to. Use
       *  ShippingLineItem.getShippingPriceAdjustments() to
       *  retrieve the shipping price adjustments associated with a specific
       *  shipping line item.
       *
       * @return a collection of price adjustments that have been applied to the shipping costs of the shipment.
       */
      getShippingPriceAdjustments(): dw.util.Collection<
        dw.order.PriceAdjustment
      >;
      /**
       * Returns the shipping status. Possible values are
       *  SHIPMENT_NOTSHIPPED or SHIPMENT_SHIPPED.
       *
       * @return the shipping status. Possible values are SHIPMENT_NOTSHIPPED or SHIPMENT_SHIPPED.
       */
      getShippingStatus(): dw.value.EnumValue;
      /**
       * Returns the sum of all shipping line items of the shipment,
       *  including tax before shipping adjustments have been applied.
       *
       * @return the sum of all shipping line items of the shipment, including tax before shipping adjustments have been applied.
       */
      getShippingTotalGrossPrice(): dw.value.Money;
      /**
       * Returns the sum of all shipping line items of the shipment, excluding tax
       *  before shipping adjustments have been applied.
       *
       * @return the sum of all shipping line items of the shipment, excluding tax before shipping adjustments have been applied.
       */
      getShippingTotalNetPrice(): dw.value.Money;
      /**
       * Returns the shipping total price. If the line item container is based on
       *  net pricing the shipping total net price is returned. If the line item
       *  container is based on gross pricing the shipping total gross price is
       *  returned.
       *
       * @return either the shipping total net or gross price
       */
      getShippingTotalPrice(): dw.value.Money;
      /**
       * Returns the tax of all shipping line items of the shipment before
       *  shipping adjustments have been applied.
       *
       * @return the tax of all shipping line items of the shipment before shipping adjustments have been applied.
       */
      getShippingTotalTax(): dw.value.Money;
      /**
       * Convenenience method. Same as
       *  getShippingLineItem(ShippingLineItem.STANDARD_SHIPPING_ID)
       *
       * @return The standard shipping line item, or null if it does not exist.
       */
      getStandardShippingLineItem(): dw.order.ShippingLineItem;
      /**
       * Returns the grand total price gross of tax for the shipment, in purchase currency.
       *
       *  Total prices represent the sum of product prices, services prices and adjustments.
       *
       * @return the grand total price gross of tax for the shipment, in purchase currency.
       */
      getTotalGrossPrice(): dw.value.Money;
      /**
       * Returns the grand total price for the shipment net of tax, in purchase currency.
       *
       *  Total prices represent the sum of product prices, services prices and adjustments.
       *
       * @return the grand total price for the shipment net of tax, in purchase currency.
       */
      getTotalNetPrice(): dw.value.Money;
      /**
       * Returns the total tax for the shipment, in purchase currency.
       *
       *  Total prices represent the sum of product prices, services prices and adjustments.
       *
       * @return the total tax for the shipment, in purchase currency.
       */
      getTotalTax(): dw.value.Money;
      /**
       * Returns the tracking number of this shipment.
       *
       * @return the tracking number of this shipment.
       */
      getTrackingNumber(): string;
      /**
       * Return true if this shipment is the default shipment.
       *
       * @return true if this shipment is the default shipment.
       */
      isDefault(): boolean;
      /**
       * Returns true if this line item represents a gift, false otherwise.
       *
       * @return true if this line item represents a gift, false otherwise.
       */
      isGift(): boolean;
      /**
       * Removes the specified shipping line item and any of its dependent
       *  shipping price adjustments.
       * @param shippingLineItem The shipping line item to be removed.
       */
      removeShippingLineItem(shippingLineItem: dw.order.ShippingLineItem): void;
      /**
       * Removes the specified shipping price adjustment from the shipment.
       * @param priceAdjustment The price adjustment line item to remove
       */
      removeShippingPriceAdjustment(
        priceAdjustment: dw.order.PriceAdjustment
      ): void;
      /**
       * Controls if this line item is a gift or not.
       * @param isGift set to true if you want this line item to represent a gift.
       */
      setGift(isGift: boolean): void;
      /**
       * Sets the value to set for the gift message.
       * @param message the value to set for the gift message.
       */
      setGiftMessage(message: string): void;
      /**
       * Set the specified shipping method for the specified shipment.
       * @param method the shipping method to use.
       */
      setShippingMethod(method: dw.order.ShippingMethod): void;
      /**
       * Sets the shipping status of the shipment.
       *  Possible values are SHIPPING_STATUS_NOTSHIPPED or
       *  SHIPPING_STATUS_SHIPPED.
       * @param status Shipment shipping status
       */
      setShippingStatus(status: number): void;
      /**
       * Sets the tracking number of this shipment.
       * @param aValue the tracking number of this shipment.
       */
      setTrackingNumber(aValue: string): void;
    }

    /**
     * Represents shipping cost applied to shipments. <br>
     *
     *  Returned by
     *  <a href="class_dw_order_ShipmentShippingModel.html#dw_order_ShipmentShippingModel_getShippingCost_ShippingMethod_DetailAnchor">ShipmentShippingModel.getShippingCost(ShippingMethod)</a>.
     */
    class ShipmentShippingCost {
      /**
       * The shipping amount.
       */
      readonly amount: dw.value.Money;

      /**
       * Returns the shipping amount.
       *
       * @return Shipping amount
       */
      getAmount(): dw.value.Money;
    }

    /**
     * Instances of ShipmentShippingModel provide access to shipment-level
     *  shipping information, such as applicable and inapplicable shipping methods
     *  and shipping cost. <br>
     *
     *  Use <a href="class_dw_order_ShippingMgr.html#dw_order_ShippingMgr_getShipmentShippingModel_Shipment_DetailAnchor">ShippingMgr.getShipmentShippingModel(Shipment)</a> to get
     *  the shipping model for a specific shipment.
     */
    class ShipmentShippingModel {
      /**
       * The active applicable shipping methods for the shipment related
       *  to this shipping model. A shipping method is applicable for a shipment
       *  if it does not exclude any of the products in the shipment, and does
       *  not exclude the shipment's shipping address, if this is set. Also checks
       *  that the the shipment customer belongs to an assigned customer group of the shipment
       *  (if any are assigned).
       */
      readonly applicableShippingMethods: dw.util.Collection<
        dw.order.ShippingMethod
      >;
      /**
       * The active inapplicable shipping methods for the shipment related
       *  to this shipping model. A shipping method is inapplicable for a shipment
       *  if it is inapplicable for at least one product contained in the
       *  shipment, or the shipping address is excluded by the shipping method, or the
       *  shipping method is restricted to customer groups that the shipment customer
       *  is not a part of.
       */
      readonly inapplicableShippingMethods: dw.util.Collection<
        dw.order.ShippingMethod
      >;

      /**
       * Returns the active applicable shipping methods for the shipment related
       *  to this shipping model. A shipping method is applicable for a shipment
       *  if it does not exclude any of the products in the shipment, and does
       *  not exclude the shipment's shipping address, if this is set. Also checks
       *  that the the shipment customer belongs to an assigned customer group of the shipment
       *  (if any are assigned).
       *
       * @return Applicable shipping methods for the shipment
       */
      getApplicableShippingMethods(): dw.util.Collection<
        dw.order.ShippingMethod
      >;
      /**
       * Returns the active applicable shipping methods for the shipment related
       *  to this shipping model and the specified shipping address. A shipping
       *  method is applicable if it does not exclude any of the products in the
       *  shipment, it does not exclude the specified shipping address, and the
       *  shipment customer belongs to an assigned customer group for the shipment (if
       *  any are assigned).
       *
       *  The parameter shippingAddressObj must be a JavaScript literal with the
       *  same properties as an OrderAddress object, or alternatively a Map.
       *  For example:
       *
       *
       *  model.getApplicableShippingMethods (
       *     { countryCode: "US",
       *       stateCode: "MA,
       *       custom { POBox : true }
       *     }
       *  )
       *
       *
       *  This method is useful when it is needed to retrieve the list of
       *  applicable shipping methods for an address before the address is saved to
       *  the shipment.
       * @param shippingAddressObj A JavaScript object representing an order address, must not be null.
       * @return Applicable shipping methods for the shipment
       */
      getApplicableShippingMethods(
        shippingAddressObj: any
      ): dw.util.Collection<dw.order.ShippingMethod>;
      /**
       * Returns the active inapplicable shipping methods for the shipment related
       *  to this shipping model. A shipping method is inapplicable for a shipment
       *  if it is inapplicable for at least one product contained in the
       *  shipment, or the shipping address is excluded by the shipping method, or the
       *  shipping method is restricted to customer groups that the shipment customer
       *  is not a part of.
       *
       * @return Inapplicable shipping methods for the shipment
       */
      getInapplicableShippingMethods(): dw.util.Collection<
        dw.order.ShippingMethod
      >;
      /**
       * Returns the active inapplicable shipping methods for the shipment related
       *  to this shipping model and the specified shipping address. A shipping
       *  method is inapplicable if it is inapplicable for at least one product
       *  contained in the shipment, or the specified shipping address is excluded
       *  by the shipping method, or the shipping method is restricted to customer
       *  groups that the shipment customer is not a part of.
       *
       *  The parameter shippingAddressObj must be a JavaScript literal with the
       *  same properties as an OrderAddress object, or alternatively a Map.
       *  For example:
       *
       *
       *   model.getApplicableShippingMethods (
       *     { countryCode: "US",
       *       stateCode: "MA,
       *       custom { POBox : true }
       *     }
       *  )
       *
       *
       *  This method is useful when it is needed to retrieve the list of
       *  applicable shipping methods for an address before the address is saved to
       *  the shipment.
       * @param shippingAddressObj A JavaScript object representing an order address.
       * @return Inapplicable shipping methods for the shipment
       */
      getInapplicableShippingMethods(
        shippingAddressObj: any
      ): dw.util.Collection<dw.order.ShippingMethod>;
      /**
       * Returns the shipping cost object for the related shipment and
       *  the specified shipping method. Shipping cost for shipments
       *  depended on the merchandise total of the shipment. The method
       *  uses the adjusted merchandise total after product and order discounts,
       *  and excluding products with product-level fixed-price shipping
       *  cost.
       * @param shippingMethod the shipping method to use.
       * @return Product shipping cost
       */
      getShippingCost(
        shippingMethod: dw.order.ShippingMethod
      ): dw.order.ShipmentShippingCost;
    }

    /**
     * Represents a specific line item in a shipment. The ShippingLineItem defines
     *  the general shipping costs of a shipment.
     */
    class ShippingLineItem extends dw.order.LineItem {
      /**
       * Constant used to get the standard shipping line item.
       */
      static readonly STANDARD_SHIPPING_ID = "STANDARD_SHIPPING";

      /**
       * The price of this shipping line item including tax after
       *  shipping adjustments have been applied.
       */
      readonly adjustedGrossPrice: dw.value.Money;
      /**
       * The price of this shipping line item, excluding tax after
       *  shipping adjustments have been applied.
       */
      readonly adjustedNetPrice: dw.value.Money;
      /**
       * The adjusted price of this shipping line item. If the line item
       *  container is based on net pricing, the adjusted net price is returned. If
       *  the line item container is based on gross pricing, the adjusted gross
       *  price is returned.
       */
      readonly adjustedPrice: dw.value.Money;
      /**
       * The tax of this shipping line item after shipping adjustments
       *  have been applied.
       */
      readonly adjustedTax: dw.value.Money;
      /**
       * The ID of this ShippingLineItem.
       */
      readonly ID: string;
      /**
       * The  order-item extension for this item, or null.
       *  An order-item extension will only exist for a ShippingLineItem which
       *  belongs to an Order.
       *
       *  Order post-processing APIs (gillian) are now inactive by default and will throw
       *  an exception if accessed. On sandboxes the APIs can be activated with a feature
       *  switch "Order Post Processing APIs on Sandboxes". On PIGs an activation needs
       *  preliminary approval by Product Management. Please contact support in this case.
       *  Existing customers using these APIs are not affected by this change and can use the
       *  APIs until further notice.
       */
      readonly orderItem: dw.order.OrderItem;
      /**
       * The collection of shipping price adjustments that have been
       *  applied to this shipping line item.
       */
      readonly shippingPriceAdjustments: dw.util.Collection<
        dw.order.PriceAdjustment
      >;

      /**
       * Creates a shipping price adjustment to be applied to the shipping line
       *  item.
       *
       *  The promotion ID is mandatory and must not be the ID of any actual
       *  promotion defined in Commerce Cloud Digital.
       *
       *  If there already exists a shipping price adjustment on this shipping line
       *  item referring to the specified promotion ID, an exception is thrown.
       * @param promotionID Promotion ID
       * @return The new price adjustment line item.
       */
      createShippingPriceAdjustment(
        promotionID: string
      ): dw.order.PriceAdjustment;
      /**
       * Creates a shipping price adjustment to be applied to the shipping line
       *  item.
       *
       *  The promotion ID is mandatory and must not be the ID of any actual
       *  promotion defined in Commerce Cloud Digital. If a shipping price adjustment on this shipping line
       *  item referring to the specified promotion ID already exists, an exception is thrown.
       *
       *  The possible values for discount are PercentageDiscount,
       *  AmountDiscount, FixedPriceShippingDiscount.
       *
       *  Examples:
       *
       *
       *  var myShippingItem : dw.order.ShippingLineItem; // assume known
       *  var paFixedShippingPrice12 : dw.order.PriceAdjustment = myShippingItem.createPriceAdjustment("myPromotionID1", new FixedPriceShippingDiscount(12));
       *  var paTenPercent : dw.order.PriceAdjustment = myShippingItem.createPriceAdjustment("myPromotionID2", new PercentageDiscount(10));
       *  var paReduceBy2 : dw.order.PriceAdjustment = myShippingItem.createPriceAdjustment("myPromotionID3", new AmountDiscount(2));
       * @param promotionID Promotion ID
       * @param discount The desired discount, not null
       * @return The new price adjustment line item.
       */
      createShippingPriceAdjustment(
        promotionID: string,
        discount: dw.campaign.Discount
      ): dw.order.PriceAdjustment;
      /**
       * Returns the price of this shipping line item including tax after
       *  shipping adjustments have been applied.
       *
       * @return the price of this shipping line item, including tax after shipping adjustments have been applied.
       */
      getAdjustedGrossPrice(): dw.value.Money;
      /**
       * Returns the price of this shipping line item, excluding tax after
       *  shipping adjustments have been applied.
       *
       * @return the price of this shipping line item, excluding tax after shipping adjustments have been applied.
       */
      getAdjustedNetPrice(): dw.value.Money;
      /**
       * Returns the adjusted price of this shipping line item. If the line item
       *  container is based on net pricing, the adjusted net price is returned. If
       *  the line item container is based on gross pricing, the adjusted gross
       *  price is returned.
       *
       * @return either the adjusted net or gross price of this shipping line item.
       */
      getAdjustedPrice(): dw.value.Money;
      /**
       * Returns the tax of this shipping line item after shipping adjustments
       *  have been applied.
       *
       * @return the tax of this shipping line item after shipping adjustments have been applied.
       */
      getAdjustedTax(): dw.value.Money;
      /**
       * Returns the ID of this ShippingLineItem.
       *
       * @return ID of this ShippingLineItem
       */
      getID(): string;
      /**
       * Returns the  order-item extension for this item, or null.
       *  An order-item extension will only exist for a ShippingLineItem which
       *  belongs to an Order.
       *
       *  Order post-processing APIs (gillian) are now inactive by default and will throw
       *  an exception if accessed. On sandboxes the APIs can be activated with a feature
       *  switch "Order Post Processing APIs on Sandboxes". On PIGs an activation needs
       *  preliminary approval by Product Management. Please contact support in this case.
       *  Existing customers using these APIs are not affected by this change and can use the
       *  APIs until further notice.
       *
       * @return null or the order-item
       */
      getOrderItem(): dw.order.OrderItem;
      /**
       * Returns the collection of shipping price adjustments that have been
       *  applied to this shipping line item.
       *
       * @return the collection of shipping price adjustments that have been applied to this shipping line item.
       */
      getShippingPriceAdjustments(): dw.util.Collection<
        dw.order.PriceAdjustment
      >;
      /**
       * Removes the specified shipping price adjustment from this shipping line
       *  item.
       * @param priceAdjustment The price adjustment line item to remove
       */
      removeShippingPriceAdjustment(
        priceAdjustment: dw.order.PriceAdjustment
      ): void;
    }

    /**
     * Represents a specific location for a shipment.
     *  <p>
     *  <b>Note:</b> this class allows access to sensitive personal and private information.
     *  Pay attention to appropriate legal and regulatory requirements related to this data.</p>
     */
    class ShippingLocation {
      /**
       * The shipping location's first address.
       */
      address1: string;
      /**
       * The shipping location's second address.
       */
      address2: string;
      /**
       * The shipping location's city.
       */
      city: string;
      /**
       * The shipping location's country code.
       */
      countryCode: string;
      /**
       * The shipping location's postal code.
       */
      postalCode: string;
      /**
       * The shipping location's post box.
       */
      postBox: string;
      /**
       * The shipping location's state code.
       */
      stateCode: string;
      /**
       * The shipping location's suite.
       */
      suite: string;

      /**
       * Constructs a new shipping location.
       *
       */
      constructor();
      /**
       * Constructs a new shipping location and initializes it with the values of the
       *  specified address object.
       * @param address the address that the shipping location represents.
       */
      constructor(address: dw.customer.CustomerAddress);
      /**
       * Constructs a new shipping location and initializes it with the values of the
       *  specified address object.
       * @param address the address that the shipping location represents.
       */
      constructor(address: dw.order.OrderAddress);

      /**
       * Returns the shipping location's first address.
       *
       * @return the shipping location's first address.
       */
      getAddress1(): string;
      /**
       * Returns the shipping location's second address.
       *
       * @return the shipping location's second address.
       */
      getAddress2(): string;
      /**
       * Returns the shipping location's city.
       *
       * @return the shipping location's city.
       */
      getCity(): string;
      /**
       * Returns the shipping location's country code.
       *
       * @return the shipping location's country code.
       */
      getCountryCode(): string;
      /**
       * Returns the shipping location's postal code.
       *
       * @return the shipping location's postal code.
       */
      getPostalCode(): string;
      /**
       * Returns the shipping location's post box.
       *
       * @return the shipping location's post box.
       */
      getPostBox(): string;
      /**
       * Returns the shipping location's state code.
       *
       * @return the shipping location's state code.
       */
      getStateCode(): string;
      /**
       * Returns the shipping location's suite.
       *
       * @return the shipping location's suite.
       */
      getSuite(): string;
      /**
       * Sets the shipping location's first address.
       * @param aValue the shipping location's first address.
       */
      setAddress1(aValue: string): void;
      /**
       * Sets the shipping location's second address.
       * @param aValue the shipping location's second address.
       */
      setAddress2(aValue: string): void;
      /**
       * Sets the shipping location's city.
       * @param aValue the shipping location's city.
       */
      setCity(aValue: string): void;
      /**
       * Sets the shipping location's country code.
       * @param aValue the shipping location's country code.
       */
      setCountryCode(aValue: string): void;
      /**
       * Sets the shipping location's postal code.
       * @param aValue the shipping location's postal code.
       */
      setPostalCode(aValue: string): void;
      /**
       * Sets the shipping location's post box.
       * @param aValue the shipping location's post box.
       */
      setPostBox(aValue: string): void;
      /**
       * Sets the shipping location's state code.
       * @param aValue the shipping location's state code.
       */
      setStateCode(aValue: string): void;
      /**
       * Sets the shipping location's suite.
       * @param aValue the shipping location's suite.
       */
      setSuite(aValue: string): void;
    }

    /**
     * ShippingMethod represents how the shipment will be shipped.
     */
    class ShippingMethod extends dw.object.ExtensibleObject {
      /**
       * The base shipping method or null if undefined.
       */
      readonly baseMethod: dw.order.ShippingMethod;
      /**
       * The currency code associated with the shipping method
       */
      readonly currencyCode: string;
      /**
       * The customer groups assigned to the shipping method.
       *  Assigned ids that do not belong to an existing customer group are ignored.
       */
      readonly customerGroups: dw.util.Collection<dw.customer.CustomerGroup>;
      /**
       * Returns 'true' if the shipping method is marked as 'default' for the current session's currency.
       *  Otherwise 'false' is returned.
       */
      readonly defaultMethod: boolean;
      /**
       * The dependent shipping methods of this shipping method,
       *  regardless of the online status of the methods.
       *  Dependent shipping methods have this method as their base method.
       */
      readonly dependentMethods: dw.util.Collection<dw.order.ShippingMethod>;
      /**
       * The description of the shipping method as specified in the current locale or
       *  null if it could not be found.
       */
      readonly description: string;
      /**
       * The display name of the shipping method in the current locale or
       *  null if it could not be found.
       */
      readonly displayName: string;
      /**
       * The ID of the shipping method.
       */
      readonly ID: string;
      /**
       * Returns true if shipping method is online, false otherwise
       */
      readonly online: boolean;
      /**
       * The tax class id of the shipping method.
       */
      readonly taxClassID: string;

      /**
       * Returns the base shipping method or null if undefined.
       *
       * @return Base shipping method
       */
      getBaseMethod(): dw.order.ShippingMethod;
      /**
       * Returns the currency code associated with the shipping method
       *
       * @return currency code
       */
      getCurrencyCode(): string;
      /**
       * Returns the customer groups assigned to the shipping method.
       *  Assigned ids that do not belong to an existing customer group are ignored.
       *
       * @return customer groups
       */
      getCustomerGroups(): dw.util.Collection<dw.customer.CustomerGroup>;
      /**
       * Returns the dependent shipping methods of this shipping method,
       *  regardless of the online status of the methods.
       *  Dependent shipping methods have this method as their base method.
       *
       * @return Dependent shipping methods
       */
      getDependentMethods(): dw.util.Collection<dw.order.ShippingMethod>;
      /**
       * Returns the description of the shipping method as specified in the current locale or
       *  null if it could not be found.
       *
       * @return he description of the shipping method as specified in the current locale or null if it could not be found.
       */
      getDescription(): string;
      /**
       * Returns the display name of the shipping method in the current locale or
       *  null if it could not be found.
       *
       * @return the display name of the shipping method or null if it could not be found.
       */
      getDisplayName(): string;
      /**
       * Returns the ID of the shipping method.
       *
       * @return the ID of the shipping method.
       */
      getID(): string;
      /**
       * Returns the tax class id of the shipping method.
       *
       * @return the tax class id of the shipping method.
       */
      getTaxClassID(): string;
      /**
       * Returns 'true' if the shipping method is marked as 'default' for the current session's currency.
       *  Otherwise 'false' is returned.
       *
       * @return 'true' if it is the default shipping method of the site
       */
      isDefaultMethod(): boolean;
      /**
       * Returns true if shipping method is online, false otherwise
       *
       */
      isOnline(): boolean;
    }

    /**
     * Provides methods to access the shipping information.
     */
    class ShippingMgr {
      /**
       * The active shipping methods of the current site applicable to the session currency and current customer group.
       */
      static readonly allShippingMethods: dw.util.Collection<
        dw.order.ShippingMethod
      >;
      /**
       * The default shipping method of the current site applicable to the session currency.
       *
       *  Does an additional check if there is a base method and if their currencies are
       *  the same. Returns NULL if the two currencies are different.
       */
      static readonly defaultShippingMethod: dw.order.ShippingMethod;

      /**
       * Applies product and shipment-level shipping cost to the specified line
       *  item container.
       *
       *
       *  For each product line item in the specified line item container, a
       *  product shipping line item is created if product-level shipping cost is
       *  defined for the product. If no product-level shipping cost is defined for
       *  the product, an existing product shipping line item is removed.
       *
       *  For each shipment in the specified line item container, shipment-level
       *  shipping cost is calculated. This cost is determined based on the
       *  merchandise total of the shipment after all product and order discounts.
       *  Only products without or with surcharge product-specific shipping cost
       *  count towards this merchandise total. Products with fixed
       *  product-specific shipping cost don't count towards the merchandise total
       *  used to calculate shipment-level shipping cost. The calculated shipping
       *  cost is set at the standard shipping line item of the shipment.
       *
       *  If 'net' taxation is configured for the site, the merchandise total
       *  before tax is used. If 'gross' taxation is configured for the site, the
       *  merchandise total after tax is used.
       *
       *  If no shipping method is set for a shipment, neither product nor
       *  shipment-level shipping cost can be calculated. In this case, the amount
       *  of the standard shipment shipping line item will be set to N/A, and
       *  shipping line items of product line items in this shipment will be
       *  removed from the line item container.
       *
       *  Special cases for product-level shipping cost:
       *
       *  if a product is member of multiple shipping cost groups, the lowest
       *  shipping cost takes precedence
       *  if fixed and surcharge shipping cost is defined for a product, the
       *  fixed cost takes precedence
       *  shipping cost defined for a master product is also defined for all
       *  variants of this master
       *  shipping cost is not applied to bundled product line items or options
       *  line items
       * @param lineItemCtnr the line item container to use.
       */
      static applyShippingCost(lineItemCtnr: dw.order.LineItemCtnr): void;
      /**
       * Returns the active shipping methods of the current site applicable to the session currency and current customer group.
       *
       * @return the active shipping methods of the current site applicable to the session currency and current customer group.
       */
      static getAllShippingMethods(): dw.util.Collection<
        dw.order.ShippingMethod
      >;
      /**
       * Returns the default shipping method of the current site applicable to the session currency.
       *
       *  Does an additional check if there is a base method and if their currencies are
       *  the same. Returns NULL if the two currencies are different.
       *
       * @return the default shipping method of the current site applicable to the session currency or null.
       */
      static getDefaultShippingMethod(): dw.order.ShippingMethod;
      /**
       * Returns the shipping model for the specified product.
       * @param product Product
       * @return Shipping model for specified product
       */
      static getProductShippingModel(
        product: dw.catalog.Product
      ): dw.order.ProductShippingModel;
      /**
       * Returns the shipping model for the specified shipment.
       * @param shipment the shipment to use.
       * @return Shipping model for specified product
       */
      static getShipmentShippingModel(
        shipment: dw.order.Shipment
      ): dw.order.ShipmentShippingModel;
      /**
       * Returns the shipping cost amount for the specified shipping method and
       *  the specified order value.
       *  If shipping cost cannot be calculated for any reason, Money.NA is
       *  returned.
       * @param shippingMethod Selected shipping method
       * @param orderValue Order value
       * @return Shipping cost
       */
      static getShippingCost(
        shippingMethod: dw.order.ShippingMethod,
        orderValue: dw.value.Money
      ): dw.value.Money;
    }

    /**
     * A shipping order is used to specify items that should be shipped, and is
     *  typically exported to, and updated by a back-office warehouse management
     *  system.
     *  <p>
     *  An <a href="class_dw_order_Order.html">Order</a> can have n shipping orders expressing how the order
     *  is to be shipped. The creation, export and update of shipping orders is
     *  largely handled by custom logic in scripts by implementing
     *  <a href="class_dw_order_hooks_ShippingOrderHooks.html">ShippingOrderHooks</a>. Use method
     *  <a href="class_dw_order_Order.html#dw_order_Order_createShippingOrder_DetailAnchor">Order.createShippingOrder()</a> for creation and add items using
     *  <a href="class_dw_order_ShippingOrder.html#dw_order_ShippingOrder_createShippingOrderItem_OrderItem_Quantity_DetailAnchor">createShippingOrderItem(OrderItem, Quantity)</a> - each item is related
     *  to an order item which in turn represents a product- or shipping- line item
     *  in the order.
     *  </p><p>
     *  A shipping order has a status calculated from its item status, one of
     *  </p><ul>
     *  <li>CONFIRMED - shipping order not yet exported, with 0 items, or all items
     *  in status CONFIRMED.</li>
     *  <li>WAREHOUSE - shipping order exported, with all items in status WAREHOUSE.</li>
     *  <li>SHIPPED - exported shipping order has been updated, with 1-n items in
     *  status SHIPPED and 0-n CANCELLED.</li>
     *  <li>CANCELLED - exported shipping order has been updated, with all items in
     *  status CANCELLED.</li>
     *  </ul>
     *  <br>
     *  The following status transitions are supported. Every status transition is
     *  documented by the addition of an order note such as &apos;Shipping order 123456
     *  status changed to WAREHOUSE.&apos;:
     *  <table>
     *  <tbody><tr>
     *  <th>From</th>
     *  <th>To</th>
     *  <th>When</th>
     *  <th>Use</th>
     *  </tr>
     *  <tr>
     *  <td>CONFIRMED</td>
     *  <td>WAREHOUSE</td>
     *  <td>Shipping order exported</td>
     *  <td>Call <a href="class_dw_order_ShippingOrder.html#dw_order_ShippingOrder_setStatusWarehouse_DetailAnchor">setStatusWarehouse()</a> - note this is the only way to set the
     *  items to status WAREHOUSE</td>
     *  </tr>
     *  <tr>
     *  <td>WAREHOUSE</td>
     *  <td>SHIPPED</td>
     *  <td>One or more items have been SHIPPED</td>
     *  <td>Call <a href="class_dw_order_ShippingOrderItem.html#dw_order_ShippingOrderItem_setStatus_String_DetailAnchor">ShippingOrderItem.setStatus(String)</a> using
     *  <a href="class_dw_order_ShippingOrderItem.html#dw_order_ShippingOrderItem_STATUS_SHIPPED_DetailAnchor">ShippingOrderItem.STATUS_SHIPPED</a></td>
     *  </tr>
     *  <tr>
     *  <td>WAREHOUSE</td>
     *  <td>CANCELLED</td>
     *  <td>All items have been CANCELLED</td>
     *  <td>Call <a href="class_dw_order_ShippingOrderItem.html#dw_order_ShippingOrderItem_setStatus_String_DetailAnchor">ShippingOrderItem.setStatus(String)</a> using
     *  <a href="class_dw_order_ShippingOrderItem.html#dw_order_ShippingOrderItem_STATUS_CANCELLED_DetailAnchor">ShippingOrderItem.STATUS_CANCELLED</a></td>
     *  </tr>
     *  </tbody></table>
     *  <p>
     *  Order post-processing APIs (gillian) are now inactive by default and will throw
     *  an exception if accessed. On sandboxes the APIs can be activated with a feature
     *  switch &quot;Order Post Processing APIs on Sandboxes&quot;. On PIGs an activation needs
     *  preliminary approval by Product Management. Please contact support in this case.
     *  Existing customers using these APIs are not affected by this change and can use the
     *  APIs until further notice.</p>
     */
    class ShippingOrder extends dw.order.AbstractItemCtnr {
      /**
       * Sorting by item id. Use with method getItems() as an argument to
       *  method FilteringCollection.sort(Object).
       */
      static readonly ORDERBY_ITEMID: any;
      /**
       * Sorting by the position of the related oder item. Use with method
       *  getItems() as an argument to method
       *  FilteringCollection.sort(Object).
       */
      static readonly ORDERBY_ITEMPOSITION: any;
      /**
       * Unsorted , as it is. Use with method getItems() as an argument
       *  to method FilteringCollection.sort(Object).
       */
      static readonly ORDERBY_UNSORTED: any;
      /**
       * Selects the product items. Use with method getItems() as an
       *  argument to method FilteringCollection.select(Object).
       */
      static readonly QUALIFIER_PRODUCTITEMS: any;
      /**
       * Selects for the service items. Use with method getItems() as an
       *  argument to method FilteringCollection.select(Object).
       */
      static readonly QUALIFIER_SERVICEITEMS: any;
      /**
       * Constant for Shipping Order Status CANCELLED
       */
      static readonly STATUS_CANCELLED = "CANCELLED";
      /**
       * Constant for Shipping Order Status CONFIRMED
       */
      static readonly STATUS_CONFIRMED = "CONFIRMED";
      /**
       * Constant for Shipping Order Status SHIPPED
       */
      static readonly STATUS_SHIPPED = "SHIPPED";
      /**
       * Constant for Shipping Order Status WAREHOUSE
       */
      static readonly STATUS_WAREHOUSE = "WAREHOUSE";

      /**
       * Returns null or the previously created Invoice.
       */
      readonly invoice: dw.order.Invoice;
      /**
       * Returns null or the invoice-number.
       */
      readonly invoiceNumber: string;
      /**
       * A filtering collection of the shipping order items belonging to the
       *  shipping order.
       *
       *  This FilteringCollection could be sorted / filtered
       *  using:
       *
       *  FilteringCollection.sort(Object) with
       *  ORDERBY_ITEMID
       *  FilteringCollection.sort(Object) with
       *  ORDERBY_ITEMPOSITION
       *  FilteringCollection.sort(Object) with
       *  ORDERBY_UNSORTED
       *  FilteringCollection.select(Object) with
       *  QUALIFIER_PRODUCTITEMS
       *  FilteringCollection.select(Object) with
       *  QUALIFIER_SERVICEITEMS
       */
      readonly items: dw.util.FilteringCollection<dw.order.ShippingOrderItem>;
      /**
       * Gets the shipping date.
       *
       *  Returns null if this shipping order is not yet shipped.
       */
      shipDate: Date;
      /**
       * The shipping address (optional, can be null).
       *
       *
       *  Note: the shipping address is not copied into the
       *  ShippingOrder but is a link to a
       *  OrderAddress held in the Order.
       */
      shippingAddress: dw.order.OrderAddress;
      /**
       * The shipping method of the shipping order.
       *
       *  Can be null.
       */
      readonly shippingMethod: dw.order.ShippingMethod;
      /**
       * Gets the shipping order number.
       */
      readonly shippingOrderNumber: string;
      /**
       * Gets the status of this shipping order. The status is read-only and
       *  calculated from the item status. See class documentation for more
       *  details.
       *  The possible values are STATUS_CONFIRMED,
       *  STATUS_WAREHOUSE, STATUS_SHIPPED,
       *  STATUS_CANCELLED.
       */
      readonly status: dw.value.EnumValue;
      /**
       * Gets all tracking informations for this shipping order.
       */
      readonly trackingInfos: dw.util.Collection<dw.order.TrackingInfo>;

      /**
       * Adds a tracking info to this shipping order with the given ID.
       * @param trackingInfoID the tracking info id
       * @return the new tracking info
       */
      addTrackingInfo(trackingInfoID: string): dw.order.TrackingInfo;
      /**
       * Creates a new Invoice based on this
       *  ShippingOrder.
       *
       *  The shipping-order-number will be used as the
       *  invoice-number. The Invoice can then be accessed using
       *  getInvoice() or getInvoiceNumber() can be used.
       *  The method must not be called more than once for a ShippingOrder,
       *  nor may 2 Invoices exist with the same invoice-number.
       *
       *  The new Invoice is a debit-invoice with a status
       *  Invoice.STATUS_NOT_PAID, and will be passed to the
       *  capture payment-hook in a separate database transaction for processing.
       *
       * @return new invoice
       */
      createInvoice(): dw.order.Invoice;
      /**
       * Creates a new Invoice based on this ShippingOrder.
       *
       *  The invoice-number must be specified as an argument.The Invoice can then be accessed using
       *  getInvoice() or getInvoiceNumber() can be used.
       *  The method must not be called more than once for a ShippingOrder,
       *  nor may 2 Invoices exist with the same invoice-number.
       *
       *  The new Invoice is a debit-invoice with a status Invoice.STATUS_NOT_PAID, and
       *  will be passed to the capture payment-hook in a separate database
       *  transaction for processing.
       * @param invoiceNumber the invoice-number to use
       * @return new invoice
       */
      createInvoice(invoiceNumber: string): dw.order.Invoice;
      /**
       * Create a ShippingOrderItem in the shipping order with
       *  the number shippingOrderNumber.
       *
       *  The quantity of the new item can be optionally specified. A quantity of
       *  null indicates the new item should be based on the entire order item and
       *  is recommended for ShippingLineItems. If a quantity is
       *  specified for a ProductLineItem which is less than
       *  ProductLineItem.getQuantity() the
       *  ProductLineItem will be split, creating a new
       *  ProductLineItem. The new
       *  ShippingOrderItem will be associated with the new
       *  ProductLineItem, which will receive the specified
       *  quantity.
       *  See also createShippingOrderItem(OrderItem, Quantity, Boolean).
       * @param orderItem the order item for which the shipping order item is to be created
       * @param quantity the quantity for which the shipping order item will be created
       * @return the created shipping order item
       */
      createShippingOrderItem(
        orderItem: dw.order.OrderItem,
        quantity: dw.value.Quantity
      ): dw.order.ShippingOrderItem;
      /**
       * Create a ShippingOrderItem in the shipping order with
       *  the number shippingOrderNumber.
       *
       *  The quantity of the new item can be optionally specified. A quantity of
       *  null indicates the new item should be based on the entire order item and
       *  is recommended for ShippingLineItems.
       *  If the specified quantity is less than ProductLineItem.getQuantity() the
       *  ProductLineItem will be split or not depending on splitIfPartial parameter.
       *  When split is true, the method is equivalent to
       *  createShippingOrderItem(OrderItem, Quantity).
       * @param orderItem the order item for which the shipping order item is to be created
       * @param quantity the quantity for which the shipping order item will be created, not null
       * @param splitIfPartial the flag whether ProductLineItem should be split when requested quantity is less than ProductLineItem's quantity
       * @return the created shipping order item
       */
      createShippingOrderItem(
        orderItem: dw.order.OrderItem,
        quantity: dw.value.Quantity,
        splitIfPartial: boolean
      ): dw.order.ShippingOrderItem;
      /**
       * Returns null or the previously created Invoice.
       *
       * @return null or the previously created invoice.
       */
      getInvoice(): dw.order.Invoice;
      /**
       * Returns null or the invoice-number.
       *
       * @return null or the previously created invoice number.
       */
      getInvoiceNumber(): string;
      /**
       * A filtering collection of the shipping order items belonging to the
       *  shipping order.
       *
       *  This FilteringCollection could be sorted / filtered
       *  using:
       *
       *  FilteringCollection.sort(Object) with
       *  ORDERBY_ITEMID
       *  FilteringCollection.sort(Object) with
       *  ORDERBY_ITEMPOSITION
       *  FilteringCollection.sort(Object) with
       *  ORDERBY_UNSORTED
       *  FilteringCollection.select(Object) with
       *  QUALIFIER_PRODUCTITEMS
       *  FilteringCollection.select(Object) with
       *  QUALIFIER_SERVICEITEMS
       *
       * @return the filtering collection of the shipping items.
       */
      getItems(): dw.util.FilteringCollection<dw.order.ShippingOrderItem>;
      /**
       * Gets the shipping date.
       *
       *  Returns null if this shipping order is not yet shipped.
       *
       * @return the shipping date or null
       */
      getShipDate(): Date;
      /**
       * Returns the shipping address (optional, can be null).
       *
       *
       *  Note: the shipping address is not copied into the
       *  ShippingOrder but is a link to a
       *  OrderAddress held in the Order.
       *
       * @return the shipping address or null
       */
      getShippingAddress(): dw.order.OrderAddress;
      /**
       * Returns the shipping method of the shipping order.
       *
       *  Can be null.
       *
       * @return the shipping method or null
       */
      getShippingMethod(): dw.order.ShippingMethod;
      /**
       * Gets the shipping order number.
       *
       * @return the shipping order number
       */
      getShippingOrderNumber(): string;
      /**
       * Gets the status of this shipping order. The status is read-only and
       *  calculated from the item status. See class documentation for more
       *  details.
       *  The possible values are STATUS_CONFIRMED,
       *  STATUS_WAREHOUSE, STATUS_SHIPPED,
       *  STATUS_CANCELLED.
       *
       * @return the status
       */
      getStatus(): dw.value.EnumValue;
      /**
       * Gets a tracking info for this shipping order.
       * @param trackingInfoID the tracking info id
       * @return the tracking info or null
       */
      getTrackingInfo(trackingInfoID: string): dw.order.TrackingInfo;
      /**
       * Gets all tracking informations for this shipping order.
       *
       * @return all tracking informations for this shipping order
       */
      getTrackingInfos(): dw.util.Collection<dw.order.TrackingInfo>;
      /**
       * Sets the shipping date.
       * @param date the ship date
       */
      setShipDate(date: Date): void;
      /**
       * Set a shipping address for the shipping order.
       * @param address the shipping address
       */
      setShippingAddress(address: dw.order.OrderAddress): void;
      /**
       * Set the id of shipping method.
       * @param shippingMethodID the id of the shipping method
       */
      setShippingMethodID(shippingMethodID: string): void;
      /**
       * Set a CONFIRMED shipping order (all items in status CONFIRMED) to status
       *  WAREHOUSE (all items in status WAREHOUSE).
       *  Note - this method is the only way to transition a shipping order from
       *  CONFIRMED to WAREHOUSE.
       *
       */
      setStatusWarehouse(): void;
    }

    /**
     * One or more ShippingOrderItems are contained in a
     *  <a href="class_dw_order_ShippingOrder.html">ShippingOrder</a>, created using
     *  <a href="class_dw_order_ShippingOrder.html#dw_order_ShippingOrder_createShippingOrderItem_OrderItem_Quantity_DetailAnchor">ShippingOrder.createShippingOrderItem(OrderItem, Quantity)</a>
     *  and can be retrieved by
     *  <a href="class_dw_order_ShippingOrder.html#dw_order_ShippingOrder_getItems_DetailAnchor">ShippingOrder.getItems()</a>. A
     *  ShippingOrderItem references a single
     *  <a href="class_dw_order_OrderItem.html">OrderItem</a> which in turn references a
     *  <a href="class_dw_order_LineItem.html">LineItem</a> associated with an <a href="class_dw_order_Order.html">Order</a>.
     *  <p>
     *  Order post-processing APIs (gillian) are now inactive by default and will throw
     *  an exception if accessed. On sandboxes the APIs can be activated with a feature
     *  switch &quot;Order Post Processing APIs on Sandboxes&quot;. On PIGs an activation needs
     *  preliminary approval by Product Management. Please contact support in this case.
     *  Existing customers using these APIs are not affected by this change and can use the
     *  APIs until further notice.</p>
     */
    class ShippingOrderItem extends dw.order.AbstractItem {
      /**
       * Constant for Order Item Status CANCELLED
       */
      static readonly STATUS_CANCELLED = "CANCELLED";
      /**
       * Constant for Order Item Status CONFIRMED
       */
      static readonly STATUS_CONFIRMED = "CONFIRMED";
      /**
       * Constant for Order Item Status SHIPPED
       */
      static readonly STATUS_SHIPPED = "SHIPPED";
      /**
       * Constant for Order Item Status WAREHOUSE
       */
      static readonly STATUS_WAREHOUSE = "WAREHOUSE";

      /**
       * Price of a single unit before discount application.
       */
      readonly basePrice: dw.value.Money;
      /**
       * Returns null or the parent item.
       */
      parentItem: dw.order.ShippingOrderItem;
      /**
       * The quantity of the shipping order item.
       *
       *  The Quantity is equal to the related line item quantity.
       */
      readonly quantity: dw.value.Quantity;
      /**
       * The mandatory shipping order number of the related
       *  ShippingOrder.
       */
      readonly shippingOrderNumber: string;
      /**
       * Gets the order item status.
       *
       *  The possible values are STATUS_CONFIRMED,
       *  STATUS_WAREHOUSE, STATUS_SHIPPED,
       *  STATUS_CANCELLED.
       */
      status: dw.value.EnumValue;
      /**
       * Gets the tracking refs (tracking infos) the shipping order item is
       *  assigned to.
       */
      readonly trackingRefs: dw.util.FilteringCollection<dw.order.TrackingRef>;

      /**
       * A shipping order item can be assigned
       *  to one or many  tracking infos with
       *  different quantities. For example an item with quantity 3 may have been
       *  shipped in 2 packages, each represented by its own
       *  tracking info - 2
       *  TrackingRefs would exist with quantities 1 and 2.
       *
       *  This method creates and adds a new tracking
       *  reference to this shipping order item for a given
       *  tracking info and quantity. The new
       *  instance is returned.
       * @param trackingInfoID the id of the tracking info
       * @param quantity the quantity the which is assigned to the tracking info for this shipping order item. Optional (null is allowed).
       * @return the new tracking reference
       */
      addTrackingRef(
        trackingInfoID: string,
        quantity: dw.value.Quantity
      ): dw.order.TrackingRef;
      /**
       * Apply a rate of (factor / divisor) to the prices in this item, with the option to half round up or half round down to the
       *  nearest cent if necessary.
       *  Examples:
       *  TaxBasis beforefactordivisorroundupCalculationTaxBasis after
       *  $10.0012true10*1/2=$5.00
       *  $10.00910true10*9/10=$9.00
       *  $10.0013true10*1/3=3.3333=$3.33
       *   $2.4712true2.47*1/2=1.235=$1.24
       *   $2.4712false2.47*1/2=1.235=$1.23
       *
       *  Which prices are updated?:
       *  The rate described above is applied to tax-basis and tax then the net-price and gross-price are recalculated by adding / subtracting
       *  depending on whether the order is based on net price.
       *  Example (order based on net price)
       *  New TaxBasis:$10.00, Tax:$1.00, NetPrice=TaxBasis=$10.00, GrossPrice=TaxBasis+Tax=$11.00
       *  Example (order based on gross price)
       *  New TaxBasis:$10.00, Tax:$1.00, NetPrice=TaxBasis-tax=$9.00, GrossPrice=TaxBasis=$10.00
       * @param factor factor used to calculate rate
       * @param divisor divisor used to calculate rate
       * @param roundUp whether to round up or down on 0.5
       */
      applyPriceRate(
        factor: dw.util.Decimal,
        divisor: dw.util.Decimal,
        roundUp: boolean
      ): void;
      /**
       * Price of a single unit before discount application.
       *
       * @return Price of a single unit before discount application.
       */
      getBasePrice(): dw.value.Money;
      /**
       * Returns null or the parent item.
       *
       * @return null or the parent item.
       */
      getParentItem(): dw.order.ShippingOrderItem;
      /**
       * The quantity of the shipping order item.
       *
       *  The Quantity is equal to the related line item quantity.
       *
       * @return the quantity
       */
      getQuantity(): dw.value.Quantity;
      /**
       * The mandatory shipping order number of the related
       *  ShippingOrder.
       *
       * @return the shipping order number.
       */
      getShippingOrderNumber(): string;
      /**
       * Gets the order item status.
       *
       *  The possible values are STATUS_CONFIRMED,
       *  STATUS_WAREHOUSE, STATUS_SHIPPED,
       *  STATUS_CANCELLED.
       *
       * @return the status
       */
      getStatus(): dw.value.EnumValue;
      /**
       * Gets the tracking refs (tracking infos) the shipping order item is
       *  assigned to.
       *
       * @return the tracking refs ( tracking infos - TrackingRef ) the shipping order item is assigned to.
       */
      getTrackingRefs(): dw.util.FilteringCollection<dw.order.TrackingRef>;
      /**
       * Set a parent item. The parent item must belong to the same
       *  ShippingOrder. An infinite parent-child loop is disallowed
       *  as is a parent-child depth greater than 10. Setting a parent item
       *  indicates a dependency of the child item on the parent item, and can be
       *  used to form a parallel structure to that accessed using
       *  ProductLineItem.getParent().
       * @param parentItem The parent item, null is allowed
       */
      setParentItem(parentItem: dw.order.ShippingOrderItem): void;
      /**
       * Sets the status. See ShippingOrder for details of
       *  shipping order status transitions. Do not use this method to set a
       *  shipping order to status WAREHOUSE, instead use
       *  ShippingOrder.setStatusWarehouse()
       *
       *  This also triggers the setting of the status of the
       *  LineItem when appropriate. Setting this status can also have an impact on
       *  the order status, accessed using Order.getStatus() and the
       *  shipping order status, accessed using ShippingOrder.getStatus().
       * @param status the status
       */
      setStatus(status: string): void;
      /**
       * Split the shipping order item.
       *
       *  This will also lead to a split of the related LineItem.
       *  Split means that for the passed quantity a new item is created with this
       *  quantity as an exact copy of this item. The remaining amount will stay in
       *  this item.
       *
       *  If quantity is equal to getQuantity() no split is done and this
       *  item is returned itself.
       *
       *  This method is equivalent to split(Quantity, Boolean) called
       *  with splitOrderItem equals to true.
       * @param quantity the quantity for the newly created item
       * @return the newly created item or this item
       */
      split(quantity: dw.value.Quantity): dw.order.ShippingOrderItem;
      /**
       * Split the shipping order item.
       *
       *  This will also lead to a split of the related LineItem
       *  when splitOrderItem is true.
       *  Split means that for the passed quantity a new item is created with this
       *  quantity as an exact copy of this item. The remaining amount will stay in
       *  this item.
       *
       *  If quantity is equal to getQuantity() no split is done and this
       *  item is returned itself.
       * @param quantity the quantity for the newly created item
       * @param splitOrderItem true the related LineItem will be splitted too false the related LineItem will not be splitted
       * @return the newly created item or this item
       */
      split(
        quantity: dw.value.Quantity,
        splitOrderItem: boolean
      ): dw.order.ShippingOrderItem;
    }

    /**
     * Container used to represent an subtotal or grandtotal item which contains various prices and a tax breakdown
     *  held in a collection of tax-items.
     *  <p>Usage example:
     *  <code>
     *  <br>var invoice : Invoice = ...;
     *  <br>var productNet = invoice.productSubTotal.netPrice;
     *  <br>var serviceNet = invoice.serviceSubTotal.netPrice;
     *  <br>var grandNet   = invoice.grandTotal.netPrice;
     *  <br>var grandTax   = invoice.grandTotal.tax;
     *  <br>var grandGross = invoice.grandTotal.grossPrice;
     *  <br>
     *  <br> # tax breakdown
     *  <br>for each(taxItem : TaxItem in invoice.grandTotal.taxItems) {
     *  <br>  var tax : Money         = taxItem.amount;
     *  <br>  var taxGroup : TaxGroup = taxItem.taxGroup;
     *  <br>  var rate : Double       = taxGroup.rate;
     *  <br>  var caption :String     = taxGroup.caption;
     *  <br>  var taxType :String     = taxGroup.taxType;
     *  <br>}
     *  </code></p>
     */
    class SumItem {
      /**
       * Gross price of SumItem.
       */
      readonly grossPrice: dw.value.Money;
      /**
       * Net price of SumItem.
       */
      readonly netPrice: dw.value.Money;
      /**
       * Total tax for SumItem.
       */
      readonly tax: dw.value.Money;
      /**
       * Price of entire SumItem on which tax calculation is based. Same as getNetPrice()
       *  or getGrossPrice() depending on whether the order is based on net or gross prices.
       */
      readonly taxBasis: dw.value.Money;
      /**
       * Tax items representing a tax breakdown for the SumItem.
       */
      readonly taxItems: dw.util.Collection<dw.order.TaxItem>;

      /**
       * Gross price of SumItem.
       *
       * @return Gross price of SumItem.
       */
      getGrossPrice(): dw.value.Money;
      /**
       * Net price of SumItem.
       *
       * @return Net price of SumItem.
       */
      getNetPrice(): dw.value.Money;
      /**
       * Total tax for SumItem.
       *
       * @return Total tax for SumItem.
       */
      getTax(): dw.value.Money;
      /**
       * Price of entire SumItem on which tax calculation is based. Same as getNetPrice()
       *  or getGrossPrice() depending on whether the order is based on net or gross prices.
       *
       * @return Price of entire item on which tax calculation is based
       */
      getTaxBasis(): dw.value.Money;
      /**
       * Tax items representing a tax breakdown for the SumItem.
       *
       * @return tax items representing a tax breakdown for the SumItem
       */
      getTaxItems(): dw.util.Collection<dw.order.TaxItem>;
    }

    /**
     * Contains the formal definition of a tax including a type (it&apos;s just the key),
     *  a <a href="class_dw_order_TaxGroup.html#dw_order_TaxGroup_getRate_DetailAnchor"> percentage value</a> if provided, a <a href="class_dw_order_TaxGroup.html#dw_order_TaxGroup_getCaption_DetailAnchor"> caption</a> and a <a href="class_dw_order_TaxGroup.html#dw_order_TaxGroup_getDescription_DetailAnchor"> description</a>.
     */
    class TaxGroup {
      /**
       * Gets the caption.
       */
      readonly caption: string;
      /**
       * Gets the description.
       */
      readonly description: string;
      /**
       * Gets the percentage amount of the rate.
       */
      readonly rate: number;
      /**
       * Gets the tax type.
       */
      readonly taxType: string;

      /**
       * Creates a TaxGroup.
       *  This TaxGroup can be used for example in ReturnItem.addTaxItem(Decimal, TaxGroup).
       * @param taxType the tax type
       * @param caption the caption
       * @param description the description
       * @param taxRate the tax rate as floating point.  1.0 means 100 %.
       * @return the tax group
       */
      static create(
        taxType: string,
        caption: string,
        description: string,
        taxRate: dw.util.Decimal
      ): dw.order.TaxGroup;
      /**
       * Gets the caption.
       *
       * @return the caption
       */
      getCaption(): string;
      /**
       * Gets the description.
       *
       * @return the description
       */
      getDescription(): string;
      /**
       * Gets the percentage amount of the rate.
       *
       * @return the tax rate percentage value
       */
      getRate(): number;
      /**
       * Gets the tax type.
       *
       * @return the tax type
       */
      getTaxType(): string;
    }

    /**
     * An item containing tax information allowing a tax breakdown between a number of <a href="class_dw_order_TaxGroup.html">TaxGroup</a>s.
     */
    class TaxItem {
      /**
       * Gets the amount.
       */
      readonly amount: dw.value.Money;
      /**
       * The  tax group.
       */
      readonly taxGroup: dw.order.TaxGroup;

      /**
       * Gets the amount.
       *
       * @return the amount
       */
      getAmount(): dw.value.Money;
      /**
       * Returns the  tax group.
       *
       * @return the tax rate
       */
      getTaxGroup(): dw.order.TaxGroup;
    }

    /**
     * Provides methods to access the tax table.
     */
    class TaxMgr {
      /**
       * Constant representing the gross taxation policy.
       */
      static readonly TAX_POLICY_GROSS = 0;
      /**
       * Constant representing the net taxation policy.
       */
      static readonly TAX_POLICY_NET = 1;

      /**
       * The ID of the tax class that represents items with a custom tax rate.
       *  The standard order calculation process assumes that such line items
       *  are initialized with a tax rate and a being ignored during the tax rate
       *  lookup sequence of the calculation process.
       *
       *  Note that this tax class does not appear in the Business Manager
       *  tax module.
       */
      static readonly customRateTaxClassID: string;
      /**
       * The ID of the default tax class defined for the site.
       *  This class might be used in case a product or service does not define
       *  a tax class.
       *  If no default tax class is defined, the method returns null.
       */
      static readonly defaultTaxClassID: string;
      /**
       * The ID of the default tax jurisdiction defined for the site.
       *  This jurisdiction might be used in case no jurisdiction is defined for
       *  a specific address.
       *  If no default tax jurisdiction is defined, this method returns null.
       */
      static readonly defaultTaxJurisdictionID: string;
      /**
       * The taxation policy (net/gross) configured for the current site.
       */
      static readonly taxationPolicy: number;
      /**
       * The ID of the tax class that represents tax exempt items.
       *  The tax manager will return a tax rate of 0.0 for this tax class.
       *
       *  Note that this tax class does not appear in the Business Manager
       *  tax module.
       */
      static readonly taxExemptTaxClassID: string;

      /**
       * Returns the ID of the tax class that represents items with a custom tax rate.
       *  The standard order calculation process assumes that such line items
       *  are initialized with a tax rate and a being ignored during the tax rate
       *  lookup sequence of the calculation process.
       *
       *  Note that this tax class does not appear in the Business Manager
       *  tax module.
       *
       */
      static getCustomRateTaxClassID(): string;
      /**
       * Returns the ID of the default tax class defined for the site.
       *  This class might be used in case a product or service does not define
       *  a tax class.
       *  If no default tax class is defined, the method returns null.
       *
       * @return the ID of the default tax class defined for the site or null.
       */
      static getDefaultTaxClassID(): string;
      /**
       * Returns the ID of the default tax jurisdiction defined for the site.
       *  This jurisdiction might be used in case no jurisdiction is defined for
       *  a specific address.
       *  If no default tax jurisdiction is defined, this method returns null.
       *
       * @return the ID of the default tax jurisdiction defined for the site or null.
       */
      static getDefaultTaxJurisdictionID(): string;
      /**
       * Returns the taxation policy (net/gross) configured for the current site.
       *
       * @return Taxation policy configured for current site
       */
      static getTaxationPolicy(): number;
      /**
       * Returns the ID of the tax class that represents tax exempt items.
       *  The tax manager will return a tax rate of 0.0 for this tax class.
       *
       *  Note that this tax class does not appear in the Business Manager
       *  tax module.
       *
       */
      static getTaxExemptTaxClassID(): string;
      /**
       * Returns the ID of the tax jurisdiction for the specified
       *  address.
       *  If no tax jurisdiction defined for the site matches the specified
       *  address, this method returns null.
       * @param location The shipping location
       * @return the ID of the tax jurisdiction for the specified address or null.
       */
      static getTaxJurisdictionID(location: dw.order.ShippingLocation): string;
      /**
       * Returns the tax rate defined for the specified combination of tax class
       *  and tax jurisdiction.
       *  Method returns null if no tax rate is defined.
       *  Method returns 0.0 of 'nontaxable' tax rate is specified (see
       *  method 'getNontaxableTaxClassID'.
       * @param taxClassID ID of the tax class
       * @param taxJurisdictionID ID of tax jusrisdiction
       * @return the tax rate defined for the specified combination of tax class and tax jurisdiction.
       */
      static getTaxRate(taxClassID: string, taxJurisdictionID: string): number;
    }

    /**
     * Provides basic information about a tracking info. An instance is identified by an ID and can be referenced from n ShippingOrderItems
     *  using <a href="class_dw_order_TrackingRef.html">TrackingRef</a>s. This also allows one <a href="class_dw_order_ShippingOrderItem.html">ShippingOrderItem</a> to be associated with n TrackingInfo.
     */
    class TrackingInfo extends dw.object.Extensible {
      /**
       * Get the Carrier.
       */
      carrier: string;
      /**
       * Get the service(ship method) of the used carrier.
       */
      carrierService: string;
      /**
       * Get the mandatory identifier for this tracking information. The id allows the tracking information to be referenced from
       *  TrackingRefs. To support short shipping a shipping-order-item can manage a list of
       *  TrackingRefs, each with an optional quantity value allowing individual items to ship in multiple
       *  parcels with known item quantity in each.
       */
      readonly ID: string;
      /**
       * Get the ship date.
       */
      shipDate: Date;
      /**
       * Gets the shipping order.
       */
      readonly shippingOrder: dw.order.ShippingOrder;
      /**
       * Get the tracking number.
       */
      trackingNumber: string;
      /**
       * Gets the tracking refs (shipping order items) which are assigned to this tracking info.
       */
      readonly trackingRefs: dw.util.Collection<dw.order.TrackingRef>;
      /**
       * Get the id of the shipping warehouse.
       */
      warehouseID: string;

      /**
       * Get the Carrier.
       *
       * @return the Carrier
       */
      getCarrier(): string;
      /**
       * Get the service(ship method) of the used carrier.
       *
       * @return the carrier service (ship method)
       */
      getCarrierService(): string;
      /**
       * Get the mandatory identifier for this tracking information. The id allows the tracking information to be referenced from
       *  TrackingRefs. To support short shipping a shipping-order-item can manage a list of
       *  TrackingRefs, each with an optional quantity value allowing individual items to ship in multiple
       *  parcels with known item quantity in each.
       *
       * @return the id
       */
      getID(): string;
      /**
       * Get the ship date.
       *
       * @return the ship date
       */
      getShipDate(): Date;
      /**
       * Gets the shipping order.
       *
       * @return the shipping order
       */
      getShippingOrder(): dw.order.ShippingOrder;
      /**
       * Get the tracking number.
       *
       * @return the TrackingNumber
       */
      getTrackingNumber(): string;
      /**
       * Gets the tracking refs (shipping order items) which are assigned to this tracking info.
       *
       * @return the tracking refs (shipping order items) which are assigned to this tracking info.
       */
      getTrackingRefs(): dw.util.Collection<dw.order.TrackingRef>;
      /**
       * Get the id of the shipping warehouse.
       *
       * @return the id of the shipping warehouse
       */
      getWarehouseID(): string;
      /**
       * Set the Carrier.
       * @param carrier the Carrier
       */
      setCarrier(carrier: string): void;
      /**
       * Set the service(ship method) of the used carrier.
       * @param carrierService the carrier service, eg. the ship method
       */
      setCarrierService(carrierService: string): void;
      /**
       * Set the ship date.
       * @param shipDate the ship date
       */
      setShipDate(shipDate: Date): void;
      /**
       * Set the TrackingNumber.
       * @param trackingNumber the TrackingNumber
       */
      setTrackingNumber(trackingNumber: string): void;
      /**
       * Set the id of the shipping warehouse.
       * @param warehouseID the id of the shipping warehouse
       */
      setWarehouseID(warehouseID: string): void;
    }

    /**
     * Provides basic information about the <a href="class_dw_order_TrackingInfo.html">TrackingInfo</a> a
     *  <a href="class_dw_order_ShippingOrderItem.html">ShippingOrderItem</a> is contained.
     */
    class TrackingRef {
      /**
       * Gets the quantity, the shipping order item is assigned to the tracking
       *  info.
       */
      quantity: dw.value.Quantity;
      /**
       * Gets the shipping order item which is assigned to the tracking info.
       */
      readonly shippingOrderItem: dw.order.ShippingOrderItem;
      /**
       * Gets the tracking info, the shipping order item is assigned to.
       */
      readonly trackingInfo: dw.order.TrackingInfo;

      /**
       * Gets the quantity, the shipping order item is assigned to the tracking
       *  info.
       *
       * @return the quantity the shipping order item is assigned to the tracking info.
       */
      getQuantity(): dw.value.Quantity;
      /**
       * Gets the shipping order item which is assigned to the tracking info.
       *
       * @return the shipping order item
       */
      getShippingOrderItem(): dw.order.ShippingOrderItem;
      /**
       * Gets the tracking info, the shipping order item is assigned to.
       *
       * @return the tracking info
       */
      getTrackingInfo(): dw.order.TrackingInfo;
      /**
       * Sets the quantity, the shipping order item is assigned to the tracking
       *  info.
       * @param quantity the quantity, the shipping order item is assigned to the tracking info.
       */
      setQuantity(quantity: dw.value.Quantity): void;
    }

    namespace hooks {
      /**
       * This interface represents all script hooks that can be registered to customize the order and basket calculation
       *  functionality. It contains the extension points (hook names), and the functions that are called by each extension
       *  point. A function must be defined inside a JavaScript source and must be exported. The script with the exported hook
       *  function must be located inside a site cartridge. Inside the site cartridge a &apos;package.json&apos; file with a &apos;hooks&apos;
       *  entry must exist.
       *
       *  <pre> &quot;hooks&quot;: &quot;./hooks.json&quot;
       *  </pre>
       *
       *  The hooks entry links to a json file, relative to the &apos;package.json&apos; file. This file lists all registered hooks
       *  inside the hooks property:
       *
       *  <pre> &quot;hooks&quot;: [
       *       {&quot;name&quot;: &quot;dw.order.calculate&quot;, &quot;script&quot;: &quot;./calculate.js&quot;}
       *  ]
       *  </pre>
       *
       *  A hook entry has a &apos;name&apos; and a &apos;script&apos; property.
       *  <ul>
       *  <li>The &apos;name&apos; contains the extension point, the hook name.</li>
       *  <li>The &apos;script&apos; contains the script relative to the hooks file, with the exported hook function.</li>
       *  </ul>
       */
      class CalculateHooks {
        /**
         * The extension point name dw.order.calculate.
         */
        static readonly extensionPointCalculate = "dw.order.calculate";
        /**
         * The extension point name dw.order.calculateShipping.
         */
        static readonly extensionPointCalculateShipping =
          "dw.order.calculateShipping";
        /**
         * The extension point name dw.order.calculateTax.
         */
        static readonly extensionPointCalculateTax = "dw.order.calculateTax";

        /**
         * The function is called by extension point extensionPointCalculate. It provides a single place for
         *  the line item container calculation.
         *
         *  To provide a fallback for existing implementations, the default implementation calls the hook
         *  dw.ocapi.shop.basket.calculate. However, this hook is deprecated, and calling it will create entries in the
         *  deprecated API usage logs. You should override this function to use dw.order.calculate instead.
         *
         *
         *  If you provide your own implementation, you should provide and use the following hooks. Best practice is
         *  to use the hook manager to retrieve them in the calculate hook, and avoid calling them directly.
         *
         *
         *  extensionPointCalculateTax for tax calculation
         *  extensionPointCalculateShipping for shipping calculation
         * @param lineItemCtnr the line item container to be (re)calculated.
         */
        calculate(lineItemCtnr: dw.order.LineItemCtnr): dw.system.Status;
        /**
         * The function is called by extension point extensionPointCalculateShipping. It provides a single
         *  place for shipping calculation during the line item container calculation.
         * @param lineItemCtnr the line item container to be (re)calculated.
         */
        calculateShipping(
          lineItemCtnr: dw.order.LineItemCtnr
        ): dw.system.Status;
        /**
         * The function is called by extension point extensionPointCalculateTax. It provides a single place
         *  for tax calculation during the line item container calculation.
         * @param lineItemCtnr the line item container to be (re)calculated.
         */
        calculateTax(lineItemCtnr: dw.order.LineItemCtnr): dw.system.Status;
      }

      /**
       * This interface represents all script hooks that can be registered to customize the order logic. It contains the
       *  extension points (hook names), and the functions that are called by each extension point. A function must be defined
       *  inside a JavaScript source and must be exported. The script with the exported hook function must be located inside a
       *  site cartridge. Inside the site cartridge a &apos;package.json&apos; file with a &apos;hooks&apos; entry must exist.
       *  <p>
       *  &quot;hooks&quot;: &quot;./hooks.json&quot;
       *  </p>
       *  The hooks entry links to a json file, relative to the &apos;package.json&apos; file. This file lists all registered hooks
       *  inside the hooks property:
       *  <p>
       *
       *  </p><pre> &quot;hooks&quot;: [
       *     {&quot;name&quot;: &quot;dw.order.createOrderNo&quot;, &quot;script&quot;: &quot;./orders.ds&quot;},
       *  ]
       *  </pre>
       *  <p></p>
       *  A hook entry has a &apos;name&apos; and a &apos;script&apos; property.
       *  <ul>
       *  <li>The &apos;name&apos; contains the extension point, the hook name.</li>
       *  <li>The &apos;script&apos; contains the script relative to the hooks file, with the exported hook function.</li>
       *  </ul>
       */
      class OrderHooks {
        /**
         * The extension point name dw.order.createOrderNo.
         */
        static readonly extensionPointCreateOrderNo = "dw.order.createOrderNo";

        /**
         * This hook is responsible for creating a new order number.
         *
         *  By default order numbers are generated by using OrderMgr.createOrderSequenceNo(). Use this hook
         *  to customize the order number generation. E.g. a prefix or suffix could be added.
         *
         *          exports.createOrderNo = function(){
         *             var orderSeqNo = OrderMgr.createOrderSequenceNo();
         *             var prefix = Site.getCurrent().getSiteId();
         *             return prefix + "_"+orderSeqNo;
         *         };
         *
         *
         *
         *  If the method returns null or an blank string order number generation will fall
         *  back to OrderMgr.createOrderSequenceNo().
         *
         *  The maximum length of the order number is 50 characters.
         *
         * @return the order number
         */
        createOrderNo(): string;
      }

      /**
       * This interface represents all script hooks that can be registered to
       *  customize the order center payment functionality. It contains the extension
       *  points (hook names), and the functions that are called by each extension
       *  point. A function must be defined inside a JavaScript source and must be
       *  exported. The script with the exported hook function must be located inside a
       *  site cartridge. Inside the site cartridge a &apos;package.json&apos; file with a
       *  &apos;hooks&apos; entry must exist.
       *  <p>
       *  &quot;hooks&quot;: &quot;./hooks.json&quot;
       *  </p>
       *  The hooks entry links to a json file, relative to the &apos;package.json&apos; file.
       *  This file lists all registered hooks inside the hooks property:
       *  <p>
       *
       *  </p><pre> &quot;hooks&quot;: [
       *       {&quot;name&quot;: &quot;dw.order.payment.authorize&quot;, &quot;script&quot;: &quot;./authorize.js&quot;},
       *       {&quot;name&quot;: &quot;dw.order.payment.validateAuthorization&quot;, &quot;script&quot;: &quot;./validateAuthorization.js&quot;},
       *  ]
       *  </pre>
       *
       *  <p></p>
       *  A hook entry has a &apos;name&apos; and a &apos;script&apos; property.
       *  <ul>
       *  <li>The &apos;name&apos; contains the extension point, the hook name.</li>
       *  <li>The &apos;script&apos; contains the script relative to the hooks file, with the
       *  exported hook function.</li>
       *  </ul>
       */
      class PaymentHooks {
        /**
         * The extension point name dw.order.payment.authorize.
         *   This hook is optional.
         */
        static readonly extensionPointAuthorize = "dw.order.payment.authorize";
        /**
         * The extension point name dw.order.payment.authorizeCreditCard.
         *   This hook is optional.
         */
        static readonly extensionPointAuthorizeCreditCard =
          "dw.order.payment.authorizeCreditCard";
        /**
         * The extension point name dw.order.payment.capture.
         */
        static readonly extensionPointCapture = "dw.order.payment.capture";
        /**
         * The extension point name dw.order.payment.reauthorize.
         */
        static readonly extensionPointReauthorize =
          "dw.order.payment.reauthorize";
        /**
         * The extension point name dw.order.payment.refund.
         */
        static readonly extensionPointRefund = "dw.order.payment.refund";
        /**
         * The extension point name dw.order.payment.releaseAuthorization.
         */
        static readonly extensionPointReleaseAuthorization =
          "dw.order.payment.releaseAuthorization";
        /**
         * The extension point name dw.order.payment.validateAuthorization.
         */
        static readonly extensionPointValidateAuthorization =
          "dw.order.payment.validateAuthorization";

        /**
         * The function is called by extension point extensionPointAuthorize. Custom payment authorization - modify the
         *  order as needed.
         *
         *
         *  Prerequisite: An order has been created using the data api or via the storefront.
         *  Return Status.OK: Corresponding payment transaction is marked as authorized (usually a custom property is used for this).
         *  Return Status.ERROR: Order is held, authorization needs to be repeated.
         * @param order the order
         * @param paymentDetails specified payment details
         * @return Status.OK successful authorization. Status.ERROR authorization failed.
         */
        authorize(
          order: dw.order.Order,
          paymentDetails: dw.order.OrderPaymentInstrument
        ): dw.system.Status;
        /**
         * The function is called by extension point
         *  extensionPointAuthorizeCreditCard. Custom payment authorization
         *  of a credit card - modify the order as needed.
         *
         *
         *
         *  Prerequisite: An order has been created using the data api or via the
         *  storefront.
         *  Return Status.OK: Corresponding payment transaction is marked as
         *  authorized (usually a custom property is used for this).
         *  Return Status.ERROR: Order is held, authorization needs to be
         *  repeated.
         * @param order the order
         * @param paymentDetails specified payment details
         * @param cvn the credit card verification number
         * @return Status.OK successful authorization. Status.ERROR authorization failed.
         */
        authorizeCreditCard(
          order: dw.order.Order,
          paymentDetails: dw.order.OrderPaymentInstrument,
          cvn: string
        ): dw.system.Status;
        /**
         * The function is called by extension point extensionPointCapture. Custom payment capture - modify the order as needed.
         *
         *  Prerequisite:
         *  [ either ] As a result of shipping (or part-shipping) a shipping -order the warehouse updates the status of the shipping-order
         *  resulting in the creation of an unpaid debit invoice (the creation of the invoice is usually handled in
         *  ShippingOrderHooks.changeStatus(ShippingOrder, ShippingOrderWO)).
         *  [ or ] A unpaid debit invoice has been created using the data api.
         *  Context: An unpaid debit invoice is passed to the payment system for capture. The capture attempt can either succeed (complete
         *  invoice amount captured) or fail. As a result the invoice status is updated by ordercenter for further processing. See Invoice.
         *  Hook responsibility: The hook should attempt to capture the amount located in invoice.grandTotal.grossPrice. When successful,
         *  the capture hook should also update the invoice by calling
         *  Invoice.addCaptureTransaction(OrderPaymentInstrument, Money)
         *  which serves to record the capturedAmount and associate the invoice with the payment-transaction.
         *  Return Status.OK: Indicates capture succeeded: Order Center sets the Invoice status to Invoice.STATUS_PAID.
         *  Return Status.ERROR: Indicates capture failed: Order Center sets the Invoice status to Invoice.STATUS_FAILED for
         *  further processing.
         *  Post processing:  When the capture hook returns with success, order center not only sets the relevant invoice status, but also
         *  sets the relevant capturedAmount values on the invoice item. Returning success means the entire invoice total has been captured, so each item
         *  within the invoice can also be marked as completely captured. Note the script implementing the hook can take responsibility for this if desired
         *  order center will not overwrite existing values, but normally the standard implementation fits. As a result each invoice item and the related
         *  order item can return a capturedAmount, useful for calculating possible refunds.
         * @param invoice the invoice
         * @return Status.OK for successful capture of entire invoice amount. Status.ERROR capture failed
         */
        capture(invoice: dw.order.Invoice): dw.system.Status;
        /**
         * The function is called by extension point extensionPointReauthorize. Custom payment authorization - modify the
         *  order as needed.
         *
         *
         *  Prerequisite:
         *  [ either ] Based on a selected Order, a ShippingOrder (which represents the whole or part of the order which can be shipped)
         *  is to be created ready for export to the warehouse system.
         *  [ or ] A ShippingOrder is to be directly created using the data api.
         *  Context: The related order is passed to the payment hook to check its authorization has not become invalid. Two hooks are called:
         *  a. validateAuthorization(Order) is used to check the orders authorization is still valid
         *  b. reauthorize(Order) is called if step a. returns Error
         *
         *  Return Status.OK: Corresponding payment transaction is marked as authorized (usually a custom property is used for this).
         *  If the order had been previously authorized, the custom property values may be overwritten during reauthorization.
         *  Return Status.ERROR: Order is held, authorization needs to be repeated.
         * @param order the order
         * @return Status.OK successful authorization. Status.ERROR authorization failed
         */
        reauthorize(order: dw.order.Order): dw.system.Status;
        /**
         * The function is called by extension point extensionPointRefund. Custom payment refund - modify the order as needed.
         *
         *  Prerequisite:
         *  [ either ] Goods returned by the customer result in the creation of one or more return documents, resulting in the creation of an
         *  unpaid customer credit invoice (the creation of the invoice is usually handled in ReturnHooks.changeStatus(Return, ReturnWO)).
         *  [ or ] An unpaid customer credit invoice is created using the data api (perhaps as a result of the creation of a customer appeasement).
         *  Context: An unpaid credit invoice is passed to the payment system for refund. The refund attempt can either succeed (complete
         *  invoice amount refunded) or fail. As a result the invoice status is updated by ordercenter for further processing. See Invoice.
         *  Hook responsibility: The hook should attempt to refund the amount located in invoice.grandTotal.grossPrice. When successful,
         *  the refund hook should also update the invoice by calling
         *  Invoice.addRefundTransaction(OrderPaymentInstrument, Money)
         *  which serves to record the refundedAmount and associate the invoice with the payment-transaction.
         *  Return Status.OK: Indicates refund succeeded: Order Center sets the Invoice status to Invoice.STATUS_PAID.
         *  Return Status.ERROR: Indicates refund failed: Order Center sets the Invoice status to Invoice.STATUS_FAILED for
         *  further processing.
         *  Post processing:  When the refund hook returns with success, order center not only sets the relevant invoice status, but also
         *  sets the relevant refundAmount values on the invoice item. Returning success means the entire invoice total has been refunded, so each item
         *  within the invoice can also be marked as completely refunded. Note the script implementing the hook can take responsibility for this if desired
         *  order center will not overwrite existing values, but normally the standard implementation fits. As a result each invoice item and the related
         *  order item can return a refundedAmount, useful for calculating further possible refunds.
         * @param invoice the invoice
         * @return Status.OK for successful refund of entire invoice amount. Status.ERROR refund failed
         */
        refund(invoice: dw.order.Invoice): dw.system.Status;
        /**
         * The function is called by extension point extensionPointReleaseAuthorization.
         *  Custom payment release authorization - modify the order as needed.
         *
         *  Prerequisite: an authorized order is updated resulting in a need to release the remaining authorization. This happens when:
         *  - order is cancelled
         *  - order is complete after remaining order items are cancelled.
         *  Return Status.OK - successful release authorization
         *  Return Status.ERROR - failed release authorization
         * @param order the order
         * @return Status.OK for successful release authorization. Status.ERROR failed release authorization
         */
        releaseAuthorization(order: dw.order.Order): dw.system.Status;
        /**
         * The function is called by extension point extensionPointValidateAuthorization. Custom payment authorization - modify the
         *  order as needed.
         *
         *  Context: This hook is called to validate whether a payment authorization exists for the order. It should usually check:
         *  - Whether the authorize or reauthorize hook was previously successfully executed for the order, e.g. by checking whether custom property has been previously set.
         *  - Whether an existing authorization has expired e.g. by comparing a timestamp set on authorization with the current time.
         *  Return Status.OK: indicates the order has a valid payment authorization.
         *  Return Status.ERROR: indicates reauthorize(Order) should be called.
         *  See reauthorize(Order) for more details.
         * @param order the order
         * @return Status.OK order has a valid payment authorization. Status.ERROR order has no valid payment authorization, reauthorize(Order) should be called
         */
        validateAuthorization(order: dw.order.Order): dw.system.Status;
      }

      /**
       * This interface represents all script hooks that can be registered to
       *  customizing the order center return resource. It contains the extension
       *  points (hook names), and the functions that are called by each extension
       *  point. A function must be defined inside a JavaScript source and must be
       *  exported. The script with the exported hook function must be located inside a
       *  site cartridge. Inside the site cartridge a &apos;package.json&apos; file with a
       *  &apos;hooks&apos; entry must exist.
       *  <p>
       *  &quot;hooks&quot;: &quot;./hooks.json&quot;
       *  </p>
       *  The hooks entry links to a json file, relative to the &apos;package.json&apos; file.
       *  This file lists all registered hooks inside the hooks property:
       *  <p>
       *
       *  </p><pre> &quot;hooks&quot;: [
       *     {&quot;name&quot;: &quot;dw.order.return.createReturn&quot;,           &quot;script&quot;: &quot;./returns.ds&quot;},
       *     {&quot;name&quot;: &quot;dw.order.return.addReturnItem&quot;,          &quot;script&quot;: &quot;./returns.ds&quot;},
       *     {&quot;name&quot;: &quot;dw.order.return.changeStatus&quot;,           &quot;script&quot;: &quot;./returns.ds&quot;},
       *  ]
       *  </pre>
       *
       *  <p></p>
       *  A hook entry has a &apos;name&apos; and a &apos;script&apos; property.
       *  <ul>
       *  <li>The &apos;name&apos; contains the extension point, the hook name.</li>
       *  <li>The &apos;script&apos; contains the script relative to the hooks file, with the
       *  exported hook function.</li>
       *  </ul>
       *
       *  <h2>Overview Return Functionality</h2> <h3>Business objects</h3> <h4>
       *  <a href="class_dw_order_ReturnCase.html">ReturnCase</a></h4> All returns exist in the context of a
       *  <a href="class_dw_order_ReturnCase.html">ReturnCase</a>, each <a href="class_dw_order_Order.html">Order</a> can have any number
       *  of <a href="class_dw_order_ReturnCase.html">ReturnCase</a>s. <br>
       *  A <a href="class_dw_order_ReturnCase.html">ReturnCase</a> has <a href="class_dw_order_ReturnCaseItem.html">ReturnCaseItem</a>s, each of
       *  which is associated with an <a href="class_dw_order_OrderItem.html">OrderItem</a> (an extension to
       *  either a <a href="class_dw_order_ProductLineItem.html">ProductLineItem</a> or a
       *  <a href="class_dw_order_ShippingLineItem.html">ShippingLineItem</a>). <br>
       *  Each <a href="class_dw_order_ReturnCaseItem.html">ReturnCaseItem</a> defines an
       *  <a href="class_dw_order_ReturnCaseItem.html#dw_order_ReturnCaseItem_getAuthorizedQuantity_DetailAnchor">ReturnCaseItem.getAuthorizedQuantity()</a> representing the
       *  maximum quantity expected to be returned. A <a href="class_dw_order_ReturnCaseItem.html">ReturnCaseItem</a>
       *  may be associated with 0..n <a href="class_dw_order_ReturnItem.html">ReturnItem</a>s -
       *  <a href="class_dw_order_ReturnItem.html">ReturnItem</a>s are added to the <a href="class_dw_order_ReturnCaseItem.html">ReturnCaseItem</a>
       *  when <a href="class_dw_order_Return.html">Return</a>s are created.
       *  <p>
       *  <i>Either</i> - a <a href="class_dw_order_ReturnCase.html">ReturnCase</a> may be used as an RMA, in which
       *  case they are created when a customer first shows a wish to return item(s).
       *  The customer then includes the RMA number with the returned item(s). The
       *  <a href="class_dw_order_Return.html">Return</a> created as a result is then associated with the
       *  existing <a href="class_dw_order_ReturnCase.html">ReturnCase</a>. <br>
       *  <i>Or</i> - a <a href="class_dw_order_ReturnCase.html">ReturnCase</a> is automatically created as part of
       *  the return creation, i.e. the customer returns some item(s) leading to a
       *  creation of both a <a href="class_dw_order_Return.html">Return</a> and an associated
       *  <a href="class_dw_order_ReturnCase.html">ReturnCase</a>.
       *  </p>
       *  <p>
       *  The scripting api allows access to the <a href="class_dw_order_ReturnCase.html">ReturnCase</a>s, whether
       *  the <a href="class_dw_order_ReturnCase.html">ReturnCase</a> is an RMA or not, and the
       *  <a href="class_dw_order_ReturnCase.html">ReturnCase</a> status. Both the <a href="class_dw_order_ReturnCaseItem.html">ReturnCaseItem</a>s
       *  and any <a href="class_dw_order_Return.html">Return</a>s associated with the
       *  <a href="class_dw_order_ReturnCase.html">ReturnCase</a> can be accessed.
       *  </p><p>
       *  A <a href="class_dw_order_ReturnCase.html">ReturnCase</a> has one of these status values:
       *  </p><ul>
       *  <li>New - the <a href="class_dw_order_ReturnCase.html">ReturnCase</a> has been created and can be edited
       *  previous to its authorization</li>
       *  <li>CONFIRMED - the <a href="class_dw_order_ReturnCase.html">ReturnCase</a> is CONFIRMED, can no longer
       *  be edited, no <a href="class_dw_order_Return.html">Return</a>s have been associated with it. Only an
       *  New- <a href="class_dw_order_ReturnCase.html">ReturnCase</a> can be CONFIRMED</li>
       *  <li>PARTIAL_RETURNED - the <a href="class_dw_order_ReturnCase.html">ReturnCase</a> has been associated
       *  with at least one <a href="class_dw_order_Return.html">Return</a>, but is not yet complete. Only an
       *  CONFIRMED- <a href="class_dw_order_ReturnCase.html">ReturnCase</a> can be set to PARTIAL_RETURNED</li>
       *  <li>RETURNED - the <a href="class_dw_order_ReturnCase.html">ReturnCase</a> has been associated with
       *  <a href="class_dw_order_Return.html">Return</a>s which match the expected authorized quantity. Only
       *  an CONFIRMED- or PARTIAL_RETURNED- return-case can be set to RETURNED</li>
       *  <li>Cancelled - the <a href="class_dw_order_ReturnCase.html">ReturnCase</a> has been cancelled (only a
       *  New- or CONFIRMED- <a href="class_dw_order_ReturnCase.html">ReturnCase</a> can be cancelled)</li>
       *  </ul>
       *
       *  <h4><a href="class_dw_order_Return.html">Return</a></h4>
       *  A <a href="class_dw_order_Return.html">Return</a> represents a physical customer return, and contains
       *  1..n <a href="class_dw_order_ReturnItem.html">ReturnItem</a>s. A <a href="class_dw_order_Return.html">Return</a> is associated
       *  with one <a href="class_dw_order_ReturnCase.html">ReturnCase</a>, and each <a href="class_dw_order_ReturnItem.html">ReturnItem</a> is
       *  associated with one <a href="class_dw_order_ReturnCaseItem.html">ReturnCaseItem</a> and (via the
       *  <a href="class_dw_order_ReturnCaseItem.html">ReturnCaseItem</a>) a single <a href="class_dw_order_OrderItem.html">OrderItem</a> usually
       *  representing an <a href="class_dw_order_Order.html">Order</a> <a href="class_dw_order_ProductLineItem.html">ProductLineItem</a>. <br>
       *  A <a href="class_dw_order_ReturnItem.html">ReturnItem</a> records the quantity returned. <br>
       *  A <a href="class_dw_order_Return.html">Return</a> can have one of these status values:
       *  <ul>
       *  <li>NEW - the <a href="class_dw_order_Return.html">Return</a> is new, i.e. needs to undergo a check
       *  before it can be marked as COMPLETED</li>
       *  <li>COMPLETED - the return is complete, this is a precondition for refunding
       *  the customer for a return.</li>
       *  </ul>
       *  <h4>Credit Invoice</h4>
       *  As a result of making a <a href="class_dw_order_Return.html">Return</a>, the customer may be
       *  refunded. The refund amount is held in a credit <a href="class_dw_order_Invoice.html">Invoice</a>
       *  which may be associated <i>either</i> with one <a href="class_dw_order_Return.html">Return</a>
       *  <i>or</i> with one <a href="class_dw_order_ReturnCase.html">ReturnCase</a>. The <a href="class_dw_order_Invoice.html">Invoice</a>
       *  is passed to the <i>refund</i> payment hook allowing custom code to handle
       *  the payment refund.
       *
       *  <h3>Process overview</h3>
       *  <h4>Create <a href="class_dw_order_ReturnCase.html">ReturnCase</a></h4>
       *  The creation of <a href="class_dw_order_ReturnCase.html">ReturnCase</a>s is supported using the data-api.
       *  The api supports, within the context of an <a href="class_dw_order_Order.html">Order</a>, the
       *  specification of an (optional) RMA-number and addition of
       *  <a href="class_dw_order_ReturnCaseItem.html">ReturnCaseItem</a>s for a given order-item and quantity.
       *  <h4>Authorize <a href="class_dw_order_ReturnCase.html">ReturnCase</a></h4>
       *  Following its creation, a <a href="class_dw_order_ReturnCase.html">ReturnCase</a> needs to be CONFIRMED -
       *  an CONFIRMED <a href="class_dw_order_ReturnCase.html">ReturnCase</a> cannot be modified.
       *  <h4>Cancel <a href="class_dw_order_ReturnCase.html">ReturnCase</a></h4>
       *  Following its creation or authorization, a <a href="class_dw_order_ReturnCase.html">ReturnCase</a> may be
       *  cancelled.
       *  <h4>Create <a href="class_dw_order_Return.html">Return</a></h4>
       *  <a href="class_dw_order_Return.html">Return</a>s may be imported or created via the data-api. These
       *  apis specify an (optional) RMA allowing a <a href="class_dw_order_Return.html">Return</a> to be
       *  associated with a <a href="class_dw_order_ReturnCase.html">ReturnCase</a>, and
       *  <a href="class_dw_order_ReturnItem.html">ReturnItem</a>s with a quantity and a key allowing them to be
       *  associated with an order-item. The process is delegated to custom scripts
       *  which control the creation of the <a href="class_dw_order_Return.html">Return</a> and the addition of
       *  the <a href="class_dw_order_ReturnItem.html">ReturnItem</a>s:
       *
       *  <h5>Hook <a href="class_dw_order_hooks_ReturnHooks.html#dw_order_hooks_ReturnHooks_extensionPointCreateReturn_DetailAnchor">extensionPointCreateReturn</a></h5>
       *  The creation of the new <a href="class_dw_order_Return.html">Return</a> is delegated to the custom
       *  script when this hook is called, passing the order, and details of the
       *  <a href="class_dw_order_Return.html">Return</a> to be created to the script. Typically the script
       *  accesses the <a href="class_dw_order_ReturnCase.html">ReturnCase</a> from the order and creates the
       *  return with the provided return-number. It may also update the
       *  <a href="class_dw_order_Order.html">Order</a>, <a href="class_dw_order_ReturnCase.html">ReturnCase</a> or
       *  <a href="class_dw_order_Return.html">Return</a> using custom values passed in the
       *  <a href="class_dw_order_Return.html">Return</a> details. <br>
       *  <code>
       *    <br>exports.createReturn = function (order:Order, returnDetails) {
       *    <br>  var returnNumber=returnDetails.returnNumber;
       *    <br>  var returnCase = order.getReturnCase(returnDetails.returnCaseNumber);
       *    <br>  var newReturn = returnCase.createReturn(returnNumber);
       *    <br> return newReturn;
       *    <br>}</code>
       *
       *  <h5>Hook <a href="class_dw_order_hooks_ReturnHooks.html#dw_order_hooks_ReturnHooks_extensionPointAddReturnItem_DetailAnchor">extensionPointAddReturnItem</a></h5>
       *  This call delegates the creation of individual <a href="class_dw_order_ReturnItem.html">ReturnItem</a>s
       *  to a custom script, passing the <a href="class_dw_order_Order.html">Order</a>, returnNumber,
       *  returnCaseItemId and return-item-details. Typically the script will access
       *  the <a href="class_dw_order_ReturnCaseItem.html">ReturnCaseItem</a> from the order and create a new
       *  <a href="class_dw_order_ReturnItem.html">ReturnItem</a> for it. <br>
       *  <code>exports.addReturnItem = function (retrn:Return, returnItemDetails) {
       *    <br> var returnCaseItem = order.getReturnCaseItem(returnCaseItemId);
       *    <br> var item = returnCaseItem.createReturnItem(returnNr);
       *    <br></code>
       *
       *  <h5>Hook <a href="class_dw_order_hooks_ReturnHooks.html#dw_order_hooks_ReturnHooks_extensionPointChangeStatus_DetailAnchor">extensionPointChangeStatus</a></h5>
       *  This call delegates the update of the return-status to a custom script,
       *  passing the <a href="class_dw_order_Order.html">Order</a>, returnNumber and new status. The custom
       *  script is responsible for setting the status and taking any other actions
       *  necessary, including the possibility of creating a credit invoice: <br>
       *  <code>changeStatus = function (retrn:Return, status) {
       *    <br> retrn.status=status;
       *    <br></code>
       *
       *  <h5>Hook <a href="class_dw_order_hooks_ReturnHooks.html#dw_order_hooks_ReturnHooks_extensionPointAfterStatusChange_DetailAnchor">extensionPointAfterStatusChange</a></h5>
       *  This call delegates the update of the return-status to a custom script,
       *  passing the <a href="class_dw_order_Order.html">Order</a>, returnNumber and new status. The custom
       *  script is responsible for setting the status and taking any other actions
       *  necessary, including the possibility of creating a credit invoice: <br>
       *  <code>changeStatus = function (retrn:Return, status) {
       *    <br> retrn.status=status;
       *    <br></code>
       *  <p>
       *  Order post-processing APIs (gillian) are now inactive by default and will throw
       *  an exception if accessed. On sandboxes the APIs can be activated with a feature
       *  switch &quot;Order Post Processing APIs on Sandboxes&quot;. On PIGs an activation needs
       *  preliminary approval by Product Management. Please contact support in this case.
       *  Existing customers using these APIs are not affected by this change and can use the
       *  APIs until further notice.</p>
       */
      class ReturnHooks {
        /**
         * The extension point name dw.order.return.addReturnItem.
         */
        static readonly extensionPointAddReturnItem =
          "dw.order.return.addReturnItem";
        /**
         * The extension point name dw.order.return.afterStatusChange.
         */
        static readonly extensionPointAfterStatusChange =
          "dw.order.return.afterStatusChange";
        /**
         * The extension point name dw.order.return.changeStatus.
         */
        static readonly extensionPointChangeStatus =
          "dw.order.return.changeStatus";
        /**
         * The extension point name dw.order.return.createReturn.
         */
        static readonly extensionPointCreateReturn =
          "dw.order.return.createReturn";
        /**
         * The extension point name dw.order.return.notifyStatusChange.
         */
        static readonly extensionPointNotifyStatusChange =
          "dw.order.return.notifyStatusChange";

        /**
         * The hook provides customization in the process of assigning the returned
         *  amount, quantity etc. Here it is possible to refund differently based on
         *  the return reason code for example. Also one could correct the inventory
         *  based on the return information. Utilize
         *  ReturnCaseItem.createReturnItem(String) to create a new
         *  ReturnItem.
         * @param retrn the return for which an return item should be created
         * @param inputData the return item
         * @return Status.OK return item is successfully added Status.ERROR return item addition failed.
         */
        addReturnItem(
          retrn: dw.order.Return,
          inputData: dw.order.ReturnItem
        ): dw.system.Status;
        /**
         * Called after method changeStatus(Return, ReturnWO) returns
         *  Status.OK. The call is made in a separate database transaction allowing
         *  the script implementation to make an independent remote call if desired.
         * @param retrn the return
         * @return Status.OK status successful Status.ERROR on failure
         */
        afterStatusChange(retrn: dw.order.Return): dw.system.Status;
        /**
         * Responsible to change the status of a Return: the custom
         *  script is responsible for setting the new status using
         *  Return.setStatus(String).
         *
         *
         *  The invoice handling should be implemented here using
         *  Return.createInvoice(String) or
         *  ReturnCase.createInvoice(String). For example create an
         *  Invoice for a Return moving to status
         *  Return.STATUS_COMPLETED.
         * @param retrn the return which status should change
         * @param inputData the data in which the new status is included
         * @return Status.OK status successfully changed Status.ERROR status not changed.
         */
        changeStatus(
          retrn: dw.order.Return,
          inputData: dw.order.Return
        ): dw.system.Status;
        /**
         * This hook is responsible for creating a new Return,
         *  based on a ReturnCase. 2 basic workflows are supported:
         *
         *
         *  On-the-fly return: create the parent ReturnCase using
         *  Order.createReturnCase(String, Boolean).
         *
         *  Return-merchandise-authorization (RMA) workflow: resolve an existing
         *  ReturnCase using
         *  Order.getReturnCase(String).
         *
         *  In both cases use  this
         *  method to create the Return based on the inputData.
         *
         *  Additional functionality like creating history entry, handling the return
         *  fees or the shipping cost credit can be implemented in the hook after the
         *  Return is created.
         * @param inputData the return
         * @return the created return
         */
        createReturn(inputData: dw.order.Return): dw.order.Return;
        /**
         * Called after method changeStatus(Return, ReturnWO) returns
         *  Status.OK (and after method afterStatusChange(Return))
         *  to inform of a successful status change. The call is made outside any
         *  database transaction. This is the best hook in which to send customer
         *  notifications as the status change has already been successfully written
         *  to the database
         * @param retrn the return
         * @return Status.OK status successful Status.ERROR on failure
         */
        notifyStatusChange(retrn: dw.order.Return): dw.system.Status;
      }

      /**
       * This interface represents all script hooks that can be registered around
       *  shipping order lifecycle. It contains the extension points (hook names), and
       *  the functions that are called by each extension point. A function must be
       *  defined inside a JavaScript source and must be exported. The script with the
       *  exported hook function must be located inside a site cartridge. Inside the
       *  site cartridge a &apos;package.json&apos; file with a &apos;hooks&apos; entry must exist.
       *  <p>
       *  &quot;hooks&quot;: &quot;./hooks.json&quot;
       *  </p>
       *  The hooks entry links to a json file, relative to the &apos;package.json&apos; file.
       *  This file lists all registered hooks inside the hooks property:
       *  <p>
       *
       *  </p><pre> &quot;hooks&quot;: [
       *       {&quot;name&quot;: &quot;dw.order.shippingorder.updateShippingOrderItem&quot;, &quot;script&quot;: &quot;./shippingOrderUpdate.ds&quot;},
       *  ]
       *  </pre>
       *
       *  <p></p>
       *  A hook entry has a &apos;name&apos; and a &apos;script&apos; property.
       *  <ul>
       *  <li>The &apos;name&apos; contains the extension point, the hook name.</li>
       *  <li>The &apos;script&apos; contains the script relative to the hooks file, with the
       *  exported hook function.</li>
       *  </ul>
       *  <p>
       *  Order post-processing APIs (gillian) are now inactive by default and will throw
       *  an exception if accessed. On sandboxes the APIs can be activated with a feature
       *  switch &quot;Order Post Processing APIs on Sandboxes&quot;. On PIGs an activation needs
       *  preliminary approval by Product Management. Please contact support in this case.
       *  Existing customers using these APIs are not affected by this change and can use the
       *  APIs until further notice.</p>
       */
      class ShippingOrderHooks {
        /**
         * The extension point name dw.order.shippingorder.afterStatusChange.
         */
        static readonly extensionPointAfterStatusChange =
          "dw.order.shippingorder.afterStatusChange";
        /**
         * The extension point name dw.order.shippingorder.changeStatus.
         */
        static readonly extensionPointChangeStatus =
          "dw.order.shippingorder.changeStatus";
        /**
         * The extension point name dw.order.shippingorder.createShippingOrders.
         */
        static readonly extensionPointCreateShippingOrders =
          "dw.order.shippingorder.createShippingOrders";
        /**
         * The extension point name dw.order.shippingorder.notifyStatusChange.
         */
        static readonly extensionPointNotifyStatusChange =
          "dw.order.shippingorder.notifyStatusChange";
        /**
         * The extension point name
         *  dw.order.shippingorder.prepareCreateShippingOrders.
         */
        static readonly extensionPointPrepareCreateShippingOrders =
          "dw.order.shippingorder.prepareCreateShippingOrders";
        /**
         * The extension point name dw.order.shippingorder.resolveShippingOrder .
         */
        static readonly extensionPointResolveShippingOrder =
          "dw.order.shippingorder.resolveShippingOrder";
        /**
         * The extension point name dw.order.shippingorder.setShippingOrderCancelled.
         */
        static readonly extensionPointShippingOrderCancelled =
          "dw.order.shippingorder.setShippingOrderCancelled";
        /**
         * The extension point name dw.order.shippingorder.setShippingOrderShipped.
         */
        static readonly extensionPointShippingOrderShipped =
          "dw.order.shippingorder.setShippingOrderShipped";
        /**
         * The extension point name dw.order.shippingorder.setShippingOrderWarehouse.
         */
        static readonly extensionPointShippingOrderWarehouse =
          "dw.order.shippingorder.setShippingOrderWarehouse";
        /**
         * The extension point name dw.order.shippingorder.updateShippingOrderItem.
         */
        static readonly extensionPointUpdateShippingOrderItem =
          "dw.order.shippingorder.updateShippingOrderItem";

        /**
         * After Status change hook.
         *
         *  The function is called by extension point
         *  extensionPointAfterStatusChange.
         *
         *  The implementation of this hook is optional. If defined the hook is
         *  called after extensionPointChangeStatus or respectively after
         *  extensionPointShippingOrderShipped,
         *  extensionPointShippingOrderCancelled or
         *  extensionPointShippingOrderWarehouse
         *
         *  Runs inside of a transaction.
         * @param shippingOrder the shipping order to be updated
         * @return the resulting status
         */
        afterStatusChange(
          shippingOrder: dw.order.ShippingOrder
        ): dw.system.Status;
        /**
         * Change the status of a shipping order.
         *
         *  The function is called by extension point
         *  extensionPointChangeStatus.
         *
         *  Runs inside a transaction together with the hooks
         *  extensionPointResolveShippingOrder
         *  extensionPointUpdateShippingOrderItem.
         *
         *  Runs after the iteration over the input's items collection as the last
         *  step in this transaction. The implementation of this hook is mandatory.
         * @param shippingOrder the shipping order to be updated
         * @param updateData the input data
         * @return the resulting status
         */
        changeStatus(
          shippingOrder: dw.order.ShippingOrder,
          updateData: dw.order.ShippingOrder
        ): dw.system.Status;
        /**
         * Called during shipping order creation for an order.
         *
         *  The function is called by extension point
         *  extensionPointCreateShippingOrders. It is responsible for
         *  creating shipping orders and its items for the order. Preparations for
         *  shipping order creation can be done before in hook
         *  extensionPointPrepareCreateShippingOrders.
         *
         *  Runs inside of a transaction. The implementation of this hook is
         *  mandatory.
         * @param order the order to create shipping orders for
         * @return the resulting status
         */
        createShippingOrders(order: dw.order.Order): dw.system.Status;
        /**
         * Notify Status change hook.
         *
         *  The function is called by extension point
         *  extensionPointNotifyStatusChange.
         *
         *  The implementation of this hook is optional. If defined the hook is
         *  called after extensionPointAfterStatusChange as the last step
         *  in the shipping order update process.
         *
         *  Runs outside of a transaction.
         * @param shippingOrder the shipping order to be updated
         * @return the resulting status
         */
        notifyStatusChange(
          shippingOrder: dw.order.ShippingOrder
        ): dw.system.Status;
        /**
         * Called before shipping order creation for an order takes place. Typically
         *  the hook is used to check the payment authorization status of the order.
         *
         *  The function is called by extension point
         *  extensionPointPrepareCreateShippingOrders.
         *
         *  Runs inside its own transaction. The value of the return status is used
         *  to control whether hook createShippingOrders(Order) is called
         *  for the order or not. The implementation of this hook is mandatory.
         * @param order the order to create shipping orders for
         * @return Status.OK successful preparation - continue with shipping order creation for this order. Status.ERROR failed preparation - skip shipping order creation for this order.
         */
        prepareCreateShippingOrders(order: dw.order.Order): dw.system.Status;
        /**
         * Resolve the shipping order. Will be called as first step of the update.
         *
         *  The function is called by extension point
         *  extensionPointResolveShippingOrder.
         *
         *  Runs inside a transaction together with the hooks
         *
         *  extensionPointUpdateShippingOrderItem
         *  extensionPointChangeStatus. The implementation of this hook is
         *  mandatory.
         * @param updateData the input data
         * @return the shipping order to update
         */
        resolveShippingOrder(
          updateData: dw.order.ShippingOrder
        ): dw.order.ShippingOrder;
        /**
         * Change the status of a shipping order to cancelled.
         *
         *  The function is called by extension point
         *  extensionPointShippingOrderCancelled.
         *
         *  This is an optional hook that can be implemented to have full control
         *  over status change to destination status Cancelled. The following hooks
         *  will be skipped if an implementation for this hook is registered:
         *  extensionPointResolveShippingOrder,
         *  extensionPointUpdateShippingOrderItem,
         *  extensionPointChangeStatus.
         *
         *  Runs inside of a transaction.
         * @param updateData the input data
         * @return the changed order or {code}null{code}
         */
        setShippingOrderCancelled(
          updateData: dw.order.ShippingOrder
        ): dw.order.Order;
        /**
         * Change the status of a shipping order to shipped.
         *
         *  The function is called by extension point
         *  extensionPointShippingOrderShipped.
         *
         *  This is an optional hook that can be implemented to have full control
         *  over status change to destination status Shipped. The following hooks
         *  will be skipped if an implementation for this hook is registered:
         *  extensionPointResolveShippingOrder
         *  extensionPointUpdateShippingOrderItem,
         *  extensionPointChangeStatus.
         *
         *  Runs inside of a transaction.
         * @param updateData the input data
         * @return the changed order or {code}null{code}
         */
        setShippingOrderShipped(
          updateData: dw.order.ShippingOrder
        ): dw.order.Order;
        /**
         * Change the status of a shipping order to warehouse.
         *
         *  The function is called by extension point
         *  extensionPointShippingOrderWarehouse.
         *
         *  This is an optional hook that can be implemented to have full control
         *  over status change to destination status Warehouse. The following hooks
         *  will be skipped if an implementation for this hook is registered:
         *  extensionPointResolveShippingOrder,
         *  extensionPointUpdateShippingOrderItem,
         *  extensionPointChangeStatus.
         *
         *  Runs inside of a transaction.
         * @param updateData the input data
         * @return the changed order or {code}null{code}
         */
        setShippingOrderWarehouse(
          updateData: dw.order.ShippingOrder
        ): dw.order.Order;
        /**
         * Updates the status of a shipping order item.
         *
         *  The function is called by extension point
         *  extensionPointUpdateShippingOrderItem.
         *
         *  Runs inside a transaction together with the hooks
         *
         *  extensionPointResolveShippingOrder
         *  extensionPointChangeStatus. The implementation of this hook is
         *  mandatory.
         * @param shippingOrder the shipping order
         * @param updateItem the input data
         * @return the resulting status
         */
        updateShippingOrderItem(
          shippingOrder: dw.order.ShippingOrder,
          updateItem: dw.order.ShippingOrderItem
        ): dw.system.Status;
      }
    }
  }

  namespace rpc {
    /**
     * Utility class for working with SOAP web services.  This class provides
     *  methods for setting SOAP headers and a set of constants representing the
     *  supported header names.<br>
     *  If you want to use ws-security features, such as signing and encryption,
     *  with your RPC-style SOAP web service, use this class to construct a HashMap with
     *  security constants and values.<br>
     *  <b>Note:</b> this method handles sensitive security-related data.
     *  Pay special attention to PCI DSS v3. requirements 2, 4, and 12.
     *  The following example configures the ws-security actions taken for the request and response to a web service.
     *   <br><pre><code>
     *  importPackage( dw.system );
     *  importPackage( dw.util );
     *  importPackage( dw.rpc );
     *
     *
     *  function execute( args : PipelineDictionary ) : Number
     *  {
     *      var WSU_NS : String = &quot;http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd&quot;;
     *
     *      try
     *      {
     *
     *      // define a map with all the secrets
     *      var secretsMap   : Map = new HashMap();
     *      secretsMap.put(&quot;myclientkey&quot;, &quot;ckpass&quot;);
     *      secretsMap.put(&quot;myservicekey&quot;, &quot;ckpass&quot;);
     *      secretsMap.put(&quot;username&quot;, &quot;password&quot;);
     *
     *      var requestCfg   : Map = new HashMap();
     *
     *      // define the ws actions to be performed
     *      requestCfg.put(SOAPUtil.WS_ACTION, SOAPUtil.WS_USERNAME_TOKEN + &quot; &quot; +
     *                                         SOAPUtil.WS_TIMESTAMP + &quot; &quot; +
     *                                         SOAPUtil.WS_SIGNATURE + &quot; &quot; +
     *                                         SOAPUtil.WS_ENCRYPT);
     *      requestCfg.put(SOAPUtil.WS_USER, &quot;username&quot;);
     *      requestCfg.put(SOAPUtil.WS_PASSWORD_TYPE, SOAPUtil.WS_PW_DIGEST );
     *      requestCfg.put(SOAPUtil.WS_SIG_DIGEST_ALGO, &quot;http://www.w3.org/2001/04/xmlenc#sha256&quot; );
     *
     *      // define signature properties
     *      // the keystore file has the basename of the WSDL file and the
     *      // file extension based on the keystore type (e.g. HelloWorld.jks).
     *      // The keystore file has to be placed beside the WSDL file.
     *      requestCfg.put(SOAPUtil.WS_SIG_PROP_KEYSTORE_TYPE, &quot;jks&quot;);
     *      requestCfg.put(SOAPUtil.WS_SIG_PROP_KEYSTORE_PW, &quot;cspass&quot;);
     *      requestCfg.put(SOAPUtil.WS_SIG_PROP_KEYSTORE_ALIAS, &quot;myclientkey&quot;);
     *
     *      requestCfg.put(SOAPUtil.WS_SIGNATURE_USER, &quot;myclientkey&quot;);
     *
     *      // define enrcryption properties
     *      requestCfg.put(SOAPUtil.WS_ENC_PROP_KEYSTORE_TYPE, &quot;jks&quot;);
     *      requestCfg.put(SOAPUtil.WS_ENC_PROP_KEYSTORE_PW, &quot;cspass&quot;);
     *      requestCfg.put(SOAPUtil.WS_ENC_PROP_KEYSTORE_ALIAS, &quot;myservicekey&quot;);
     *
     *      requestCfg.put(SOAPUtil.WS_ENCRYPTION_USER, &quot;myservicekey&quot;);
     *      requestCfg.put(SOAPUtil.WS_SIGNATURE_PARTS, &quot;{Element}{http://schemas.xmlsoap.org/soap/envelope/}Body&quot;);
     *      requestCfg.put(SOAPUtil.WS_ENCRYPTION_PARTS,&quot;{Element}{&quot; + WSU_NS + &quot;}
     *       Timestamp;&quot;+&quot;{Content}{http://schemas.xmlsoap.org/soap/envelope/}Body&quot;);
     *
     *      // set the secrets for the callback
     *      requestCfg.put(SOAPUtil.WS_SECRETS_MAP, secretsMap);
     *
     *      var responseCfg : Map = new HashMap();
     *
     *      // define the ws actions to be performed for the response
     *      responseCfg.put(SOAPUtil.WS_ACTION, SOAPUtil.WS_TIMESTAMP + &quot; &quot; +
     *                                          SOAPUtil.WS_SIGNATURE + &quot; &quot; +
     *                                          SOAPUtil.WS_ENCRYPT);
     *
     *      // define signature properties
     *      responseCfg.put(SOAPUtil.WS_SIG_PROP_KEYSTORE_TYPE, &quot;jks&quot;);
     *      responseCfg.put(SOAPUtil.WS_SIG_PROP_KEYSTORE_PW, &quot;cspass&quot;);
     *      responseCfg.put(SOAPUtil.WS_SIG_PROP_KEYSTORE_ALIAS, &quot;myservicekey&quot;);
     *
     *      responseCfg.put(SOAPUtil.WS_SIGNATURE_USER, &quot;myservicekey&quot;);
     *
     *      // define decryption properties
     *      responseCfg.put(SOAPUtil.WS_ENC_PROP_KEYSTORE_TYPE, &quot;jks&quot;);
     *      responseCfg.put(SOAPUtil.WS_ENC_PROP_KEYSTORE_PW, &quot;cspass&quot;);
     *      responseCfg.put(SOAPUtil.WS_ENC_PROP_KEYSTORE_ALIAS, &quot;myclientkey&quot;);
     *
     *      responseCfg.put(SOAPUtil.WS_ENCRYPTION_USER, &quot;myclientkey&quot;);
     *
     *      // set the secrets for the callback
     *      responseCfg.put(SOAPUtil.WS_SECRETS_MAP, secretsMap);
     *
     *      // get the service and stub
     *      var helloWorldService : WebReference = webreferences.HelloWorld;
     *      var stub : Stub = helloWorldService.defaultService;
     *      // set the security
     *      SOAPUtil.setWSSecurityConfig(stub, requestCfg, responseCfg);
     *          //var h : Hello = new helloWorldService.Hello();
     *          var h = new helloWorldService.com.support.ws.security.test.Hello2();
     *
     *          h.setName(&apos;Send Text from client Axis ...&apos;);
     *
     *          // call the web service
     *          var response  = stub.hello2(h);
     *          //var response = stub.hello(h);
     *          var result = response.getHello2Return();
     *
     *
     *      args.OutStr = result;
     *      Logger.error(&quot;Hello World We Are SIGNED old version Send Text from client ...&quot;, result);
     *
     *      return PIPELET_NEXT;
     *
     *      }
     *      catch (e)
     *      {
     *          Logger.error(&quot;Error in helloWorldRpc.ds is: &quot; + e);
     *          return PIPELET_ERROR;
     *      }
     *
     *  }
     *  </code> </pre><br>
     */
    class SOAPUtil {
      /**
       * WS-Security action property name.
       *  Allowed property values are WS_NO_SECURITY, WS_TIMESTAMP, WS_ENCRYPT, WS_SIGNATURE, WS_USERNAME_TOKEN or
       *  a space separated String with multiple values.
       */
      static readonly WS_ACTION = "action";
      /**
       * WS-Security encryption: the encryption/decryption keystore alias name
       */
      static readonly WS_ENC_PROP_KEYSTORE_ALIAS =
        "__EncryptionPropKeystoreAlias";
      /**
       * WS-Security encryption: the encryption/decryption keystore password
       */
      static readonly WS_ENC_PROP_KEYSTORE_PW =
        "__EncryptionPropKeystorePassword";
      /**
       * WS-Security encryption: the encryption/decryption keystore type ( jks or pkcs12 ),
       *                          default is jks.
       *  Note: the keystore file must have the basename of the WSDL file and the
       *  file extension based on the keystore type. For example: MyService.jks.
       *  The keystore file must be placed in the same cartridge directory
       *  as the WSDL file.
       */
      static readonly WS_ENC_PROP_KEYSTORE_TYPE =
        "__EncryptionPropKeystoreType";
      /**
       * WS-Security action: encrypt the message.
       *  The encryption-specific parameters define how to encrypt, which keys
       *  to use, and other parameters.
       */
      static readonly WS_ENCRYPT = "Encrypt";
      /**
       * WS-Security encryption: defines which parts of the request are encrypted.
       */
      static readonly WS_ENCRYPTION_PARTS = "encryptionParts";
      /**
       * WS-Security encryption: the user's name for encryption.
       */
      static readonly WS_ENCRYPTION_USER = "encryptionUser";
      /**
       * WS-Security action: no security
       */
      static readonly WS_NO_SECURITY = "NoSecurity";
      /**
       * WS-Security password type: parameter for UsernameToken action to define the encoding
       *  of the password. Allowed values are PW_DIGEST or PW_TEXT.
       */
      static readonly WS_PASSWORD_TYPE = "passwordType";
      /**
       * WS-Security password of type digest: use a password digest to send the password information.
       */
      static readonly WS_PW_DIGEST = "PasswordDigest";
      /**
       * WS-Security password of type text: send the password information in clear text.
       */
      static readonly WS_PW_TEXT = "PasswordText";
      /**
       * A secrets map with the username/password entries is needed to create the password
       *  callback object.
       */
      static readonly WS_SECRETS_MAP = "__SecretsMap";
      /**
       * WS-Security signature: sets the signature digest algorithm to use.
       */
      static readonly WS_SIG_DIGEST_ALGO = "signatureDigestAlgorithm";
      /**
       * WS-Security signature: the signature keystore alias name
       */
      static readonly WS_SIG_PROP_KEYSTORE_ALIAS =
        "__SignaturePropKeystoreAlias";
      /**
       * WS-Security signature: the signature keystore password.
       */
      static readonly WS_SIG_PROP_KEYSTORE_PW =
        "__SignaturePropKeystorePassword";
      /**
       * WS-Security: the signature keystore type ( jks or pkcs12 ). The default is jks.
       *  Note: The keystore file must have the basename of the WSDL file and the
       *  file extension of the keystore type. For example: MyService.jks.
       *  The keystore file must be placed in the same cartridge directory
       *  as the WSDL file.
       */
      static readonly WS_SIG_PROP_KEYSTORE_TYPE = "__SignaturePropKeystoreType";
      /**
       * WS-Security action: sign the message.
       *  The signature-specific parameters define how to sign, which keys
       *  to use, and other parameters.
       */
      static readonly WS_SIGNATURE = "Signature";
      /**
       * WS-Security signature: defines which parts of the request are signed.
       */
      static readonly WS_SIGNATURE_PARTS = "signatureParts";
      /**
       * WS-Security signature: the user's name for signature.
       */
      static readonly WS_SIGNATURE_USER = "signatureUser";
      /**
       * WS-Security action: add a timestamp to the security header.
       */
      static readonly WS_TIMESTAMP = "Timestamp";
      /**
       * WS-Security user name.
       */
      static readonly WS_USER = "user";
      /**
       * WS-Security action: add a UsernameToken identification.
       */
      static readonly WS_USERNAME_TOKEN = "UsernameToken";

      constructor();

      /**
       * Returns an HTTP request header property value using the specified key. Null is returned
       *  if the key does not represent an HTTP header property.
       * @param svc a service stub returned from getService().
       * @param key the header property key.
       * @return an HTTP request header property value using the specified key or null.
       */
      static getHTTPRequestHeader(svc: any, key: string): string;
      /**
       * Returns an HTTP response header property value using the specified key. Null is returned
       *  if the key does not represent an HTTP response header property.
       * @param svc a service stub returned from getService().
       * @param key the header property key.
       * @return an HTTP response header property value using the specified key or null.
       */
      static getHTTPResponseHeader(svc: any, key: string): string;
      /**
       * Sets a new SOAPHeaderElement in the SOAP request with the namespace of
       *  the XML content.
       * @param svc a service stub returned from getService()
       * @param xml a string with arbitrary XML content
       */
      static setHeader(svc: any, xml: string): void;
      /**
       * Sets a new SOAPHeaderElement in the SOAP request  with the namespace of
       *  the XML content.
       * @param svc a service stub returned from getService()
       * @param xml a string with arbitrary XML content
       * @param mustUnderstand sets the SOAP header attribute 'mustUnderstand'
       */
      static setHeader(svc: any, xml: string, mustUnderstand: boolean): void;
      /**
       * Creates a new SOAPHeaderElement with the name and namespace and places
       *  the given XML into it.
       * @param svc a service stub returned from getService()
       * @param namespace the namespace of the header element
       * @param name the element name for the header element
       * @param xml a string with arbitrary XML content
       */
      static setHeader(
        svc: any,
        namespace: string,
        name: string,
        xml: string
      ): void;
      /**
       * Creates a new SOAPHeaderElement with the name and namespace and places
       *  the given XML into it.
       * @param svc a service stub returned from getService()
       * @param namespace the namespace of the header element
       * @param name the element name for the header element
       * @param xml a string with arbitrary XML content
       * @param mustUnderstand sets the SOAP header attribute mustUnderstand
       */
      static setHeader(
        svc: any,
        namespace: string,
        name: string,
        xml: string,
        mustUnderstand: boolean
      ): void;
      /**
       * Creates a new SOAPHeaderElement with the name and namespace and places
       *  the given XML into it.
       * @param svc a service stub returned from getService()
       * @param namespace the namespace of the header element
       * @param name the element name for the header element
       * @param xml a string with arbitrary XML content
       * @param mustUnderstand sets the SOAP header attribute mustUnderstand
       * @param actor the SOAP actor, which should be set for this header element. null removes any actor.
       */
      static setHeader(
        svc: any,
        namespace: string,
        name: string,
        xml: string,
        mustUnderstand: boolean,
        actor: string
      ): void;
      /**
       * Creates a new SOAPHeaderElement with the name and namespace and places
       *  the given XML into it.
       * @param svc a service stub returned from getService()
       * @param namespace the namespace of the header element
       * @param name the element name for the header element
       * @param xml a E4X XML object
       */
      static setHeader(
        svc: any,
        namespace: string,
        name: string,
        xml: any
      ): void;
      /**
       * Creates a new SOAPHeaderElement with the name and namespace and places
       *  the given XML into it.
       * @param svc a service stub returned from getService()
       * @param namespace the namespace of the header element
       * @param name the element name for the header element
       * @param xml a E4X XML object
       * @param mustUnderstand sets the SOAP header attribute mustUnderstand
       */
      static setHeader(
        svc: any,
        namespace: string,
        name: string,
        xml: any,
        mustUnderstand: boolean
      ): void;
      /**
       * Creates a new SOAPHeaderElement with the name and namespace and places
       *  the given XML into it.
       *
       *  var usernameToken : XML =
       *    <wsse:UsernameToken xmlns:wsse="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd">
       *        <wsse:Username>{merchantID}</wsse:Username>
       *        <wsse:Password Type="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordText">
       *            {merchantPassword}
       *        </wsse:Password>
       *    </wsse:UsernameToken>
       *  SOAPUtil.setHeader( service, "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd",
       *   "Security", usernameToken, true, null
       * @param svc a service stub returned from getService()
       * @param namespace the namespace of the header element
       * @param name the element name for the header element
       * @param xml a E4X XML object
       * @param mustUnderstand sets the SOAP header attribute 'mustUnderstand'
       * @param actor the SOAP actor, which should be set for this header element. null removes any actor.
       */
      static setHeader(
        svc: any,
        namespace: string,
        name: string,
        xml: any,
        mustUnderstand: boolean,
        actor: string
      ): void;
      /**
       * Sets an HTTP request header property using the specified key and value.
       * @param svc a service stub returned from getService().
       * @param key the header property key.
       * @param value the header property value. If the value is null, the property identified by the key is removed from the HTTP request header.
       */
      static setHTTPRequestHeader(svc: any, key: string, value: string): void;
      /**
       * Sets the WS-Security configuration for the request and response based on the
       *  constants defined.
       * @param svc a service stub returned from getService()
       * @param requestConfigMap the WS-Security request config
       * @param responseConfigMap the WS-Security response config
       */
      static setWSSecurityConfig(
        svc: any,
        requestConfigMap: any,
        responseConfigMap: any
      ): void;
    }

    /**
     * This is the base class for all service stubs accessible
     *  through a WebReference object. The Stub provides access to the WSDL operations.
     *  <p>
     *  Demandware recommends a low timeout to ensure responsiveness
     *  of the site and to avoid thread exhaustion. Use the Services module
     *  in Business Manager to set timeout values, not the methods for this class.
     *  The Services module provides better analytics and timeout management.
     *  </p><p>
     *  The default timeout, if not set, is 15 minutes when the web service is used in a job,
     *  and 2 minutes otherwise. If the timeout of the calling script is lower,
     *  the script timeout is used.
     *  <br></p><pre><code>
     *   // get WebReference
     *      var webref : WebReference = webreferences.myWSDLname;
     *   // get service stub
     *      var stub : Stub = webref.defaultService;
     *  </code> </pre>
     */
    class Stub {
      /**
       * This property allows the user to set the web service connection timeout value in milliseconds. By default,
       *  the web service connection timeout is 5000 milliseconds (5 seconds). The minimum allowed value is 100 milliseconds
       *  and the maximum allowed value is 15000 milliseconds (15 seconds). Demandware recommends setting timeout values
       *  in Business Manager Services module as it provides better analytics and timeout management.
       */
      static readonly CONNECTION_TIMEOUT: string;
      /**
       * Standard property: target service endpoint address. The
       *  URI scheme for the endpoint address specification must
       *  correspond to the protocol/transport binding for this
       *  stub class.
       */
      static readonly ENDPOINT_ADDRESS_PROPERTY: string;
      /**
       * Standard property: password for authentication.
       */
      static readonly PASSWORD_PROPERTY: string;
      /**
       * Standard property: this boolean property is used by a service
       *  client to indicate whether or not it wants to participate in
       *  a session with a service endpoint. If this property is set to
       *  true, the service client indicates that it wants the session
       *  to be maintained. If set to false, the session is not maintained.
       *  The default value for this property is false.
       */
      static readonly SESSION_MAINTAIN_PROPERTY: string;
      /**
       * Standard property: user name for authentication.
       */
      static readonly USERNAME_PROPERTY: string;

      /**
       * The password.
       */
      password: string;
      /**
       * The current read timeout value in milliseconds for this Stub.
       */
      timeout: number;
      /**
       * The user name.
       *
       *  Note: this method handles sensitive security-related data.
       *  Pay special attention to PCI DSS v3. requirements 2, 4, and 12.
       */
      username: string;

      constructor();

      /**
       * Gets the value of a specific configuration property.
       * @param name Name of the property whose value is to be retrieved
       * @return Value of the configuration property
       */
      _getProperty(name: string): any;
      /**
       * Sets the name and value of a configuration property
       *  for this Stub instance. If the Stub instance contains
       *  a value for the same property, the old value is replaced.
       *  Note: the _setProperty method may not
       *  perform a validity check on a configured property value. An
       *  example is the standard property for the target service
       *  endpoint address, which is not checked for validity in the
       *  _setProperty method.
       *  In this case, stub configuration errors are detected at
       *  the remote method invocation.
       * @param name Name of the configuration property
       * @param value Value of the property
       */
      _setProperty(name: string, value: any): void;
      /**
       * Returns the password.
       *
       * @return the password.  Note: this method handles sensitive security-related data. Pay special attention to PCI DSS v3. requirements 2, 4, and 12.
       */
      getPassword(): string;
      /**
       * Returns the current read timeout value in milliseconds for this Stub.
       *
       * @return the current timeout value for this Stub.
       */
      getTimeout(): number;
      /**
       * Returns the user name.
       *
       *  Note: this method handles sensitive security-related data.
       *  Pay special attention to PCI DSS v3. requirements 2, 4, and 12.
       *
       * @return the user name.
       */
      getUsername(): string;
      /**
       * Sets an additional SOAP header value for the next
       *  operation.
       * @param namespace the namespace to use.
       * @param name the name of the header item.
       * @param value the value for the header item.
       */
      setHeader(namespace: string, name: string, value: any): void;
      /**
       * Sets the password.
       * @param password the password to set.
       */
      setPassword(password: string): void;
      /**
       * Sets the timeout in milliseconds for the next call through this Stub.
       *
       *  This timeout value controls "read timeout" (how
       *  long, after connecting, it will wait without any data being read).
       *  To control "connection timeout" you use the _setProperty(String, Object)
       *  method where the name parameter is CONNECTION_TIMEOUT.
       * @param timeout the timeout for the next call through this stub.
       */
      setTimeout(timeout: number): void;
      /**
       * Sets the user name.
       * @param username the user name to set.
       */
      setUsername(username: string): void;
    }

    /**
     * Represents a web service defined in a WSDL file. The implementation is backed by a JAX-RPC framework. In general,
     *  you should use the newer dw.ws package and <a href="class_dw_ws_WebReference2.html">WebReference2</a> class for doc-style SOAP web service calls. However, if your web service WSDL
     *  is using RPC-style calls, you must use a WebReference object instead.
     *  <p>
     *  Use the Services module in Business Manager to set timeout values, not the methods for this class.
     *  The Services module provides better analytics and timeout management.
     *
     *  To create an instance of a WebReference object, in a B2C Commerce Script file, reference a WSDL file in the <code>webreferences</code>
     *  directory and request the service <a href="class_dw_rpc_Stub.html">Stub</a> using one of the get service methods.
     *  For example, if your WSDL file is <code>MyWSDL.wsdl</code>,
     *  to create an instance of WebReference and access the <a href="class_dw_rpc_Stub.html">Stub</a>:
     *  <br>
     *  </p><pre><code>
     *  var webref : WebReference = webreferences.MyWSDL;
     *  var stub : Stub = webref.getDefaultService();
     *  </code></pre>
     *
     *  <b>Note:</b> script classes representing your WSDL file are are generated by the platform and then placed in the <code>WebReferences</code>
     *  package. You do not need to include the <code>importPackage</code>
     *  statement in your B2C Commerce Script file to use classes in the <code>WebReferences</code> package.
     */
    class WebReference {
      /**
       * The default service of the WebReference object. If you have more than one service
       *  defined in your WSDL, the default service is the first service alphabetically. If the service
       *  has multiple ports defined, the default service uses the SOAP port name that is first alphabetically.
       */
      readonly defaultService: dw.rpc.Stub;

      constructor();

      /**
       * Returns the default service of the WebReference object. If you have more than one service
       *  defined in your WSDL, the default service is the first service alphabetically. If the service
       *  has multiple ports defined, the default service uses the SOAP port name that is first alphabetically.
       *
       * @return the default service of the WebReference object.
       */
      getDefaultService(): dw.rpc.Stub;
      /**
       * Returns a specific service from this WebReference.
       * @param service the service to locate.
       * @param port the port name to use.  var port = webref.getService("SampleServiceName","SamplePortName");
       * @return a specific service from this WebReference.
       */
      getService(service: string, port: string): dw.rpc.Stub;
    }
  }

  namespace sitemap {
    /**
     * Instances of this class represent sitemap files located in the appservers shared file system. Methods are used to get
     *  details of a sitemap file, such as the hostname it is associated with.
     */
    class SitemapFile {
      /**
       * The name of the file e.g. sitemap_index.xml
       */
      readonly fileName: string;
      /**
       * The size of the file in bytes.
       */
      readonly fileSize: number;
      /**
       * The URL used to access this file in a storefront request.
       */
      readonly fileURL: string;
      /**
       * The host name this file is associated with.
       */
      readonly hostName: string;
      /**
       * Checks if this instance of sitemap file is valid. Examples for invalid files are:
       *
       *  file size > 10mb
       *
       *  Additional violations might be added later.
       */
      readonly valid: boolean;

      /**
       * Returns the name of the file e.g. sitemap_index.xml
       *
       * @return The file's name, never null.
       */
      getFileName(): string;
      /**
       * Returns the size of the file in bytes.
       *
       * @return The fileSize in bytes.
       */
      getFileSize(): number;
      /**
       * Returns the URL used to access this file in a storefront request.
       *
       * @return The fileURL, never null.
       */
      getFileURL(): string;
      /**
       * Returns the host name this file is associated with.
       *
       * @return The hostname, never null.
       */
      getHostName(): string;
      /**
       * Checks if this instance of sitemap file is valid. Examples for invalid files are:
       *
       *  file size > 10mb
       *
       *  Additional violations might be added later.
       *
       * @return true if the {@code SitemapFile} is valid, false otherwise.
       */
      isValid(): boolean;
    }

    /**
     * <a href="class_dw_sitemap_SitemapMgr.html">SitemapMgr</a> is used to access and modify custom sitemap files.
     *  <p>
     *  To access custom sitemap files, use methods <a href="class_dw_sitemap_SitemapMgr.html#dw_sitemap_SitemapMgr_getCustomSitemapFiles_DetailAnchor">getCustomSitemapFiles()</a>.
     *  </p><p>
     *  To delete custom sitemap files, use methods <a href="class_dw_sitemap_SitemapMgr.html#dw_sitemap_SitemapMgr_deleteCustomSitemapFile_SitemapFile_DetailAnchor">deleteCustomSitemapFile(SitemapFile)</a>,
     *  <a href="class_dw_sitemap_SitemapMgr.html#dw_sitemap_SitemapMgr_deleteCustomSitemapFiles_String_DetailAnchor">deleteCustomSitemapFiles(String)</a> and <a href="class_dw_sitemap_SitemapMgr.html#dw_sitemap_SitemapMgr_deleteCustomSitemapFiles_DetailAnchor">deleteCustomSitemapFiles()</a>.
     *  </p><p>
     *  To add custom sitemap files, use methods <a href="class_dw_sitemap_SitemapMgr.html#dw_sitemap_SitemapMgr_addCustomSitemapFile_String_File_DetailAnchor">addCustomSitemapFile(String, File)</a>. The file will be copied from
     *  WebDAV (<a href="class_dw_io_File.html">File</a> represent a file in WebDAV) to the appservers shared file system.
     *  </p><p>
     *  Please note that all provided methods are operating in appservers shared file system. These modifications are visible
     *  via &quot;Custom Sitemaps&quot; tab under <i>Merchant Tools</i> =&gt; <i>SEO</i> =&gt; <i>Sitemaps - Custom Sitemaps</i> in
     *  Business Manager. To publish all changes, the system job &quot;Create Sitemap Schedule&quot; must be executed afterwards.</p>
     */
    class SitemapMgr {
      /**
       * Reads all existing custom sitemap files from files system of the appservers custom sitemap directory into memory
       *  and returns them in a Map containing mappings like
       *
       *  Hostname 1 => [SitemapFile hostname1_sitemapfile1, SitemapFile hostname1_sitemapfile2]
       *  Hostname 2 => [SitemapFile hostname2_sitemapfile1]
       */
      static readonly customSitemapFiles: dw.util.Map<
        string,
        dw.sitemap.SitemapFile
      >;

      /**
       * Adds the given File to the appservers custom sitemap directory. All content of the appservers
       *  custom sitemap directory is considered by the system job "Create Sitemap Schedule".
       *
       *  The files are added to the directory which is accessible via "Custom Sitemaps" tab under Merchant Tools =>
       *  SEO => Sitemaps - Custom Sitemaps in Business Manager. To publish that change, the system job
       *  "Create Sitemap Schedule" must be executed afterwards.
       * @param hostName The hostName to copy the File to. The hostName must be configured in sites alias file.
       * @param file The File to copy.
       */
      static addCustomSitemapFile(hostName: string, file: dw.io.File): void;
      /**
       * Deletes the given custom sitemap file from the appservers shared file system.
       *
       *  The file is deleted from the directory which is accessible via "Custom Sitemaps" tab under Merchant Tools
       *  => SEO => Sitemaps - Custom Sitemaps in Business Manager. To publish that change, the system job
       *  "Create Sitemap Schedule" must be executed afterwards.
       * @param sitemapFile - The sitemapFile to delete.
       */
      static deleteCustomSitemapFile(sitemapFile: dw.sitemap.SitemapFile): void;
      /**
       * Deletes all custom sitemap files for the given hostname from the appservers shared file system.
       *
       *  The files are deleted from the directory which is accessible via "Custom Sitemaps" tab under Merchant
       *  Tools => SEO => Sitemaps - Custom Sitemaps in Business Manager. To publish that change,
       *  the system job "Create Sitemap Schedule" must be executed afterwards.
       * @param hostName The hostName to delete the custom sitemap files for.
       */
      static deleteCustomSitemapFiles(hostName: string): void;
      /**
       * Deletes all custom sitemap files for all hostnames from the appservers shared file system.
       *
       *  The files are deleted from the directory which is accessible via "Custom Sitemaps" tab under Merchant
       *  Tools => SEO => Sitemaps - Custom Sitemaps in Business Manager. To publish that change,
       *  the system job "Create Sitemap Schedule" must be executed afterwards.
       *
       */
      static deleteCustomSitemapFiles(): void;
      /**
       * Reads all existing custom sitemap files from files system of the appservers custom sitemap directory into memory
       *  and returns them in a Map containing mappings like
       *
       *  Hostname 1 => [SitemapFile hostname1_sitemapfile1, SitemapFile hostname1_sitemapfile2]
       *  Hostname 2 => [SitemapFile hostname2_sitemapfile1]
       *
       * @return The created map containing the list of SitemapFiles.
       */
      static getCustomSitemapFiles(): dw.util.Map<
        string,
        dw.sitemap.SitemapFile
      >;
    }
  }

  namespace suggest {
    /**
     * The brands suggestion container provides access to
     *  brands found using the suggested terms.
     *  <p>
     *  The method <a href="class_dw_suggest_SearchPhraseSuggestions.html#dw_suggest_SearchPhraseSuggestions_getSuggestedPhrases_DetailAnchor">SearchPhraseSuggestions.getSuggestedPhrases()</a> can be used to
     *  get the list of found brand names. The brand lookup
     *  is being executed in the current catalog and locale.
     *  </p><p>
     *  Furthermore the list of suggested terms, after processing
     *  the original user input search query, is accessible
     *  through <a href="class_dw_suggest_SearchPhraseSuggestions.html#dw_suggest_SearchPhraseSuggestions_getSuggestedTerms_DetailAnchor">SearchPhraseSuggestions.getSuggestedTerms()</a> method.</p>
     */
    class BrandSuggestions extends dw.suggest.Suggestions {}

    /**
     * The category suggestion container provides access to
     *  categories found using the suggested terms as search criteria.
     *  The method <a href="class_dw_suggest_CategorySuggestions.html#dw_suggest_CategorySuggestions_getSuggestedCategories_DetailAnchor">getSuggestedCategories()</a> can be used to
     *  get the list of found categories.
     *  <p>
     *  Furthermore the list of suggested terms, after processing
     *  the original user input search query, is accessible
     *  through <a href="class_dw_suggest_SearchPhraseSuggestions.html#dw_suggest_SearchPhraseSuggestions_getSuggestedTerms_DetailAnchor">SearchPhraseSuggestions.getSuggestedTerms()</a> method.</p>
     */
    class CategorySuggestions extends dw.suggest.Suggestions {
      /**
       * This method returns a list of categories which were found
       *  using the suggested terms as search criteria.
       *  The category lookup is being executed in the current catalog and locale.
       */
      readonly suggestedCategories: dw.util.Iterator<dw.catalog.Category>;

      /**
       * This method returns a list of categories which were found
       *  using the suggested terms as search criteria.
       *  The category lookup is being executed in the current catalog and locale.
       *
       * @return a iterator containing a SuggestedCategory instance for each found category, the iterator might be empty
       */
      getSuggestedCategories(): dw.util.Iterator<dw.catalog.Category>;
    }

    /**
     * The content suggestion container provides access to
     *  content pages found using the suggested terms as search criteria.
     *  The method <a href="class_dw_suggest_ContentSuggestions.html#dw_suggest_ContentSuggestions_getSuggestedContent_DetailAnchor">getSuggestedContent()</a> can be used to
     *  get the list of found content pages.
     *  <p>
     *  Furthermore the list of suggested terms, after processing
     *  the original user input search query, is accessible
     *  through <a href="class_dw_suggest_SearchPhraseSuggestions.html#dw_suggest_SearchPhraseSuggestions_getSuggestedTerms_DetailAnchor">SearchPhraseSuggestions.getSuggestedTerms()</a> method.</p>
     */
    class ContentSuggestions extends dw.suggest.Suggestions {
      /**
       * This method returns a list of content pages which were found
       *  using the suggested terms as search criteria.
       *  The content lookup is being executed in the current library and locale.
       */
      readonly suggestedContent: dw.util.Iterator<dw.content.Content>;

      /**
       * This method returns a list of content pages which were found
       *  using the suggested terms as search criteria.
       *  The content lookup is being executed in the current library and locale.
       *
       * @return a iterator containing a SuggestedContent instance for each found content, the iterator might be empty
       */
      getSuggestedContent(): dw.util.Iterator<dw.content.Content>;
    }

    /**
     * The custom suggestion container provides access to
     *  merchant provided search phrases
     *  found using the suggested terms as search criteria.
     *  <p>
     *  The method <a href="class_dw_suggest_SearchPhraseSuggestions.html#dw_suggest_SearchPhraseSuggestions_getSuggestedPhrases_DetailAnchor">SearchPhraseSuggestions.getSuggestedPhrases()</a> can be used to
     *  get the list of found search phrases. The custom phrases
     *  lookup is being executed in the current site.
     *  </p><p>
     *  Furthermore the list of suggested terms is accessible
     *  through <a href="class_dw_suggest_SearchPhraseSuggestions.html#dw_suggest_SearchPhraseSuggestions_getSuggestedTerms_DetailAnchor">SearchPhraseSuggestions.getSuggestedTerms()</a> method.</p>
     */
    class CustomSuggestions extends dw.suggest.Suggestions {}

    /**
     * The product suggestion container provides access to
     *  products found using the suggested terms.
     *  The method <a href="class_dw_suggest_ProductSuggestions.html#dw_suggest_ProductSuggestions_getSuggestedProducts_DetailAnchor">getSuggestedProducts()</a> can be used to
     *  get the list of found products.
     *  <p>
     *  Furthermore the list of suggested terms, after processing
     *  the original user input search query, is accessible
     *  through <a href="class_dw_suggest_SearchPhraseSuggestions.html#dw_suggest_SearchPhraseSuggestions_getSuggestedTerms_DetailAnchor">SearchPhraseSuggestions.getSuggestedTerms()</a> method.</p>
     */
    class ProductSuggestions extends dw.suggest.Suggestions {
      /**
       * This method returns a list of products which were found
       *  using the suggested terms as search criteria.
       *  The product lookup is being executed in the current catalog and locale.
       */
      readonly suggestedProducts: dw.util.Iterator<dw.catalog.Product>;

      /**
       * This method returns a list of products which were found
       *  using the suggested terms as search criteria.
       *  The product lookup is being executed in the current catalog and locale.
       *
       * @return a iterator containing a SuggestedProduct instance for each found product, the iterator might be empty
       */
      getSuggestedProducts(): dw.util.Iterator<dw.catalog.Product>;
    }

    /**
     * The search phrase suggestions contain a list of suggested search phrases
     *  (see <a href="class_dw_suggest_SuggestedPhrase.html">SuggestedPhrase</a>)
     *  as well as, for each of the search phrase terms, a list with corrected and
     *  completed alternative terms.
     */
    class SearchPhraseSuggestions {
      /**
       * A list of SuggestedPhrase objects that relates to the
       *  user input search phrase.
       */
      readonly suggestedPhrases: dw.util.Iterator<dw.suggest.SuggestedPhrase>;
      /**
       * A list of SuggestedTerms objects. Each of the returned
       *  instances represents a set of terms suggested for a particular single term
       *  of the user input search phrase.
       */
      readonly suggestedTerms: dw.util.Iterator<dw.suggest.SuggestedTerms>;

      /**
       * Returns a list of SuggestedPhrase objects that relates to the
       *  user input search phrase.
       *
       * @return a list of SuggestedPhrases
       */
      getSuggestedPhrases(): dw.util.Iterator<dw.suggest.SuggestedPhrase>;
      /**
       * Returns a list of SuggestedTerms objects. Each of the returned
       *  instances represents a set of terms suggested for a particular single term
       *  of the user input search phrase.
       *
       * @return a list of SuggestedTerms for each term of the user input search phrase
       */
      getSuggestedTerms(): dw.util.Iterator<dw.suggest.SuggestedTerms>;
      /**
       * Returns whether this suggestions container has any suggested phrases.
       *
       *  Note that this method only looks for suggested phrases. It does not account
       *  for suggested terms.
       *
       * @return true only if there are phrases available
       */
      hasSuggestedPhrases(): boolean;
      /**
       * Returns whether this suggestions container has any suggested terms.
       *
       *  Note that this method checks suggested terms only,
       *  but not suggested phrases.
       *
       * @return true only if there are terms available
       */
      hasSuggestedTerms(): boolean;
    }

    /**
     * The Suggest model provides methods and functions
     *  to access search suggestions.
     *  <p>
     *  The search suggestion feature basically covers two functional areas.
     *  First is just to suggest words, based on the users input,
     *  utilizing spell correction or prediction (also known as auto completion).
     *  The second functional area is also often referred to as search-as-you-type,
     *  where, based on the users input, specific items are
     *  already looked up, before the user actually has completed typing a word
     *  or even fired up the search.
     *  </p><p>
     *  This model combines both functional areas and provides access to both - the
     *  suggested words and the items found while using the predicted words.
     *  </p><p>
     *  This model supports various types of items that are being suggested, like
     *  products, categories, brands, content pages as well merchant provided search phrases.
     *  For each type, there is a <a href="class_dw_suggest_Suggestions.html">Suggestions</a> implementation
     *  available and accessible through this model: <a href="class_dw_suggest_ProductSuggestions.html">ProductSuggestions</a>,
     *  <a href="class_dw_suggest_CategorySuggestions.html">CategorySuggestions</a>, <a href="class_dw_suggest_BrandSuggestions.html">BrandSuggestions</a>, <a href="class_dw_suggest_ContentSuggestions.html">ContentSuggestions</a>,
     *  and <a href="class_dw_suggest_CustomSuggestions.html">CustomSuggestions</a>.
     *  </p><p>
     *  For each type of suggestions, the actual suggested items (like
     *  products) can by obtained, and, on the other hand, a list of terms
     *  is provided which were used to lookup the found items.
     *  The terms can be used to present a advanced user experience in the
     *  storefront, e.g. show auto completed words, spell corrections and so on.
     *  The SuggestModel script API will always create suggestions with Autocorrections
     *  regardless of the value of &quot;Search Autocorrections&quot; search preference.</p>
     */
    class SuggestModel {
      /**
       * The maximum number of suggestions that can be obtain from this model: 10
       */
      static readonly MAX_SUGGESTIONS = 10;

      /**
       * A BrandSuggestions container for the current search phrase.
       *  The BrandSuggestions container provides access to the found brands (if any) and
       *  the terms suggested by the system with respect to the known product brands in the catalog.
       */
      readonly brandSuggestions: dw.suggest.BrandSuggestions;
      /**
       * A CategorySuggestions container for the current search phrase.
       *  The CategorySuggestions container provides access to the found categories (if any) and
       *  the terms suggested by the system with respect to the known categories in the catalog.
       */
      readonly categorySuggestions: dw.suggest.CategorySuggestions;
      /**
       * A ContentSuggestions container for the current search phrase.
       *  The ContentSuggestions container provides access to the found content pages (if any) and
       *  the terms suggested by the system with respect to the known content in the library.
       */
      readonly contentSuggestions: dw.suggest.ContentSuggestions;
      /**
       * A CustomSuggestions container for the current search phrase.
       *  The CustomSuggestions container provides access to matching
       *  custom phrases (if any) and the terms suggested
       *  by the system with respect to the merchant provided custom phrases.
       */
      readonly customSuggestions: dw.suggest.CustomSuggestions;
      /**
       * The method returns true, if the search suggestions are filtered by the folder. If this returns true it is not
       *  possible for search suggestions to contain Page Designer content as it belongs to no folder.
       */
      filteredByFolder: boolean;
      /**
       * Use this method to obtain a list of search phrases
       *  that currently are very popular among all users across the Site.
       *
       *  The search phrases are specific to the region (based on user's IP address),
       *  language (locale) and the user's browser type (agent).
       */
      readonly popularSearchPhrases: dw.util.Iterator<
        dw.suggest.SuggestedPhrase
      >;
      /**
       * A ProductSuggestions container for the current search phrase.
       *  The ProductSuggestions container provides access to the found products (if any) and
       *  the terms suggested by the system with respect to the known products in the catalog.
       */
      readonly productSuggestions: dw.suggest.ProductSuggestions;
      /**
       * Use this method to obtain a list of personalized search phrases
       *  that the current user entered recently.
       *
       *  The user is being identified by the CQuotient tracking cookie.
       */
      readonly recentSearchPhrases: dw.util.Iterator<
        dw.suggest.SuggestedPhrase
      >;

      /**
       * Constructs a new SuggestModel.
       *
       */
      constructor();

      /**
       * Adds a refinement for product suggestions.
       *  The method can be called to add an additional query
       *  parameter specified as name-value pair. The values string may encode
       *  multiple values delimited by the pipe symbol ('|').
       * @param attributeID The ID of the refinement attribute.
       * @param values the refinement value to set
       */
      addRefinementValues(attributeID: string, values: string): void;
      /**
       * Returns a BrandSuggestions container for the current search phrase.
       *  The BrandSuggestions container provides access to the found brands (if any) and
       *  the terms suggested by the system with respect to the known product brands in the catalog.
       *
       * @return a brand suggestions container for the current search phrase, returns null for insufficient search input
       */
      getBrandSuggestions(): dw.suggest.BrandSuggestions;
      /**
       * Returns a CategorySuggestions container for the current search phrase.
       *  The CategorySuggestions container provides access to the found categories (if any) and
       *  the terms suggested by the system with respect to the known categories in the catalog.
       *
       * @return a category suggestions container for the current search phrase, returns null for insufficient search input
       */
      getCategorySuggestions(): dw.suggest.CategorySuggestions;
      /**
       * Returns a ContentSuggestions container for the current search phrase.
       *  The ContentSuggestions container provides access to the found content pages (if any) and
       *  the terms suggested by the system with respect to the known content in the library.
       *
       * @return a content suggestions container for the current search phrase, returns null for insufficient search input
       */
      getContentSuggestions(): dw.suggest.ContentSuggestions;
      /**
       * Returns a CustomSuggestions container for the current search phrase.
       *  The CustomSuggestions container provides access to matching
       *  custom phrases (if any) and the terms suggested
       *  by the system with respect to the merchant provided custom phrases.
       *
       * @return a custom suggestions container for the current search phrase, returns null for insufficient search input
       */
      getCustomSuggestions(): dw.suggest.CustomSuggestions;
      /**
       * Use this method to obtain a list of search phrases
       *  that currently are very popular among all users across the Site.
       *
       *  The search phrases are specific to the region (based on user's IP address),
       *  language (locale) and the user's browser type (agent).
       *
       * @return a list of personalized popular search phrases
       */
      getPopularSearchPhrases(): dw.util.Iterator<dw.suggest.SuggestedPhrase>;
      /**
       * Returns a ProductSuggestions container for the current search phrase.
       *  The ProductSuggestions container provides access to the found products (if any) and
       *  the terms suggested by the system with respect to the known products in the catalog.
       *
       * @return a product suggestions container for the current search phrase, returns null for insufficient search input
       */
      getProductSuggestions(): dw.suggest.ProductSuggestions;
      /**
       * Use this method to obtain a list of personalized search phrases
       *  that the current user entered recently.
       *
       *  The user is being identified by the CQuotient tracking cookie.
       *
       * @return a list of recent search phrases of the current user
       */
      getRecentSearchPhrases(): dw.util.Iterator<dw.suggest.SuggestedPhrase>;
      /**
       * The method returns true, if the search suggestions are filtered by the folder. If this returns true it is not
       *  possible for search suggestions to contain Page Designer content as it belongs to no folder.
       *
       * @return True if search suggestions are filtered by the folder of the content asset.
       */
      isFilteredByFolder(): boolean;
      /**
       * Removes a refinement. The method can be called to remove previously added
       *  refinement values. The values string may encode multiple values delimited
       *  by the pipe symbol ('|').
       * @param attributeID The ID of the refinement attribute.
       * @param values the refinement value to remove or null to remove all values
       */
      removeRefinementValues(attributeID: string, values: string): void;
      /**
       * Apply a category ID to filter product, brand and category suggestions.
       *
       *  Suggested products, brands and categories, as well as corrected and completed
       *  terms are specific to the given category or one of it's sub categories.
       *
       *  For example, in the specified category "television", the search term "pla"
       *  will be auto completed to "plasma" (instead of e.g. "player") and
       *  only televisions will be included in the list of suggested products.
       * @param categoryID the category to filter suggestions for
       */
      setCategoryID(categoryID: string): void;
      /**
       * Set a flag to indicate if the search suggestions filter for elements that do not belong to a folder.
       *  Must be set to false to return content assets that do not belong to any folder.
       * @param filteredByFolder filter the search suggestions by folder
       */
      setFilteredByFolder(filteredByFolder: boolean): void;
      /**
       * Use this method to setup the maximum number of returned suggested
       *  items. For example, set this to 3 in order to only retrieve the
       *  3 most relevant suggested products.
       *
       *  The maximum number of suggestions that can be queried are defined as MAX_SUGGESTIONS.
       * @param maxSuggestions the number of suggested items to be returned by this model instance
       */
      setMaxSuggestions(maxSuggestions: number): void;
      /**
       * Sets product suggestion refinement values for an attribute.
       *  The method can be called to set
       *  an additional query parameter specified as name-value pair. The value
       *  string may encode multiple values delimited by the pipe symbol ('|').
       *  Existing refinement values for the attribute will be removed.
       * @param attributeID The ID of the refinement attribute.
       * @param values the refinement values to set (delimited by '|') or null to remove all values
       */
      setRefinementValues(attributeID: string, values: string): void;
      /**
       * Sets the user input search phrase. This search phrase is being processed
       *  by applying auto completion, spell correction and enhancement with alternative
       *  similar search terms.
       *
       *  The resulting search phrase is used to lookup the actual items,
       *  like products or categories (search-as-you-type).
       *
       *  In order to access the processed terms, one can use the
       *  SearchPhraseSuggestions.getSuggestedTerms() method of each of the respective
       *  results returned by the methods in this model.
       * @param searchPhrase the user input search phrase
       */
      setSearchPhrase(searchPhrase: string): void;
    }

    /**
     * This class represents a suggested catalog category.
     *  Use <a href="class_dw_suggest_SuggestedCategory.html#dw_suggest_SuggestedCategory_getCategory_DetailAnchor">getCategory()</a> method to get access to the actual <a href="class_dw_catalog_Category.html">Category</a> object.
     */
    class SuggestedCategory {
      /**
       * This method returns the actual Category object corresponding to this suggested category.
       */
      readonly category: dw.catalog.Category;

      /**
       * This method returns the actual Category object corresponding to this suggested category.
       *
       * @return the category object corresponding to this suggested category
       */
      getCategory(): dw.catalog.Category;
    }

    /**
     * This class represents a suggested content page.
     *  Use <a href="class_dw_suggest_SuggestedContent.html#dw_suggest_SuggestedContent_getContent_DetailAnchor">getContent()</a> method to get access to the actual <a href="class_dw_content_Content.html">Content</a> object.
     */
    class SuggestedContent {
      /**
       * This method returns the actual Content object corresponding to this suggested content.
       */
      readonly content: dw.content.Content;

      /**
       * This method returns the actual Content object corresponding to this suggested content.
       *
       * @return the content object corresponding to this suggested content
       */
      getContent(): dw.content.Content;
    }

    /**
     * This class represents a suggested phrase.
     *  Use <a href="class_dw_suggest_SuggestedPhrase.html#dw_suggest_SuggestedPhrase_getPhrase_DetailAnchor">getPhrase()</a> method to get access to the phrase.
     */
    class SuggestedPhrase {
      /**
       * This method returns a flag signaling whether this phrase is a exact match.
       */
      readonly exactMatch: boolean;
      /**
       * This method returns the actual phrase as a string value.
       */
      readonly phrase: string;

      /**
       * This method returns the actual phrase as a string value.
       *
       * @return the phrase
       */
      getPhrase(): string;
      /**
       * This method returns a flag signaling whether this phrase is a exact match.
       *
       * @return true if this phrase is a exact match, false otherwise
       */
      isExactMatch(): boolean;
    }

    /**
     * This class represents a suggested product.
     *  Use <a href="class_dw_suggest_SuggestedProduct.html#dw_suggest_SuggestedProduct_getProductSearchHit_DetailAnchor">getProductSearchHit()</a> method to get access to the actual <a href="class_dw_catalog_ProductSearchHit.html">ProductSearchHit</a> object.
     */
    class SuggestedProduct {
      /**
       * This method returns the actual ProductSearchHit object
       *  corresponding to this suggested product.
       */
      readonly productSearchHit: dw.catalog.ProductSearchHit;

      /**
       * This method returns the actual ProductSearchHit object
       *  corresponding to this suggested product.
       *
       * @return the product search hit corresponding to this suggested product
       */
      getProductSearchHit(): dw.catalog.ProductSearchHit;
    }

    /**
     * A single suggested term.
     *
     *  Each user input term of the search phrase
     *  is being processed separately by the suggestion engine. For each
     *  original term, a list of terms will be suggested, either completed terms,
     *  corrected terms or even the exact term if it is known to the engine.
     *  <p>
     *  Each suggested term is represented by a instance of this class. The list of suggested terms
     *  belonging to a single original term is represented by a instance of <a href="class_dw_suggest_SuggestedTerms.html">SuggestedTerms</a> class.
     *  </p><p>
     *  The suggested term value can either be the completed version of the original term,
     *  the corrected version of the original term or exactly the original term.</p>
     */
    class SuggestedTerm {
      /**
       * Returns whether this suggested term is a additional term that has no corresponding term in the original search phrase.
       */
      readonly additional: boolean;
      /**
       * Returns whether this suggested term is a auto completed version of the original term.
       *  In other words, this method returns true if the original term is a prefix of this suggested term.
       */
      readonly completed: boolean;
      /**
       * Returns whether this suggested term is a corrected version of the original term.
       */
      readonly corrected: boolean;
      /**
       * Returns whether this suggested term is exactly matching the original term.
       */
      readonly exactMatch: boolean;
      /**
       * Returns this suggested term as String value.
       */
      readonly value: string;

      /**
       * Returns this suggested term as String value.
       *
       * @return the string representation of this suggested term
       */
      getValue(): string;
      /**
       * Returns whether this suggested term is a additional term that has no corresponding term in the original search phrase.
       *
       * @return true if this suggested term is a additional term, false otherwise
       */
      isAdditional(): boolean;
      /**
       * Returns whether this suggested term is a auto completed version of the original term.
       *  In other words, this method returns true if the original term is a prefix of this suggested term.
       *
       * @return true if this suggested term is evaluated by auto completion, false otherwise
       */
      isCompleted(): boolean;
      /**
       * Returns whether this suggested term is a corrected version of the original term.
       *
       * @return true if this suggested term is a corrected version of the original term, false otherwise
       */
      isCorrected(): boolean;
      /**
       * Returns whether this suggested term is exactly matching the original term.
       *
       * @return true if this suggested term exactly matches the original term, false otherwise
       */
      isExactMatch(): boolean;
    }

    /**
     * This container represents a list of suggested terms, all belonging to a
     *  particular single original term of the users input search phrase.
     *
     *  Each user input term of the search phrase
     *  is being processed separately by the suggestion engine. For each
     *  original term, a list of terms will be suggested, either completed terms,
     *  corrected terms or even the exact term if they are known to the engine as they are.
     *
     *  A instance of this class refers to the original unmodified term, as well as
     *  to a list of <a href="class_dw_suggest_SuggestedTerm.html">SuggestedTerm</a>s objects representing a single suggested term.
     */
    class SuggestedTerms {
      /**
       * Returns true if this set of suggested terms is empty.
       */
      readonly empty: boolean;
      /**
       * This method returns the suggested term which is considered best matching
       *  with the original term. See getTerms() for a note on ordering of
       *  suggested terms.
       */
      readonly firstTerm: dw.suggest.SuggestedTerm;
      /**
       * The original term of the user input, for which this instance
       *  provides a list of suggested terms. Suggested terms can either be corrected,
       *  or completed or exact matching.
       */
      readonly originalTerm: string;
      /**
       * The list of SuggestedTerms suggested for the original term.
       */
      readonly terms: dw.util.Iterator<dw.suggest.SuggestedTerms>;

      /**
       * This method returns the suggested term which is considered best matching
       *  with the original term. See getTerms() for a note on ordering of
       *  suggested terms.
       *
       * @return the best matching term
       */
      getFirstTerm(): dw.suggest.SuggestedTerm;
      /**
       * Returns the original term of the user input, for which this instance
       *  provides a list of suggested terms. Suggested terms can either be corrected,
       *  or completed or exact matching.
       *
       * @return the original unmodified term of the user input search phrase
       */
      getOriginalTerm(): string;
      /**
       * Returns the list of SuggestedTerms suggested for the original term.
       *
       * @return a iterator of suggested terms, might be empty
       */
      getTerms(): dw.util.Iterator<dw.suggest.SuggestedTerms>;
      /**
       * Returns true if this set of suggested terms is empty.
       *
       * @return true if no suggested term is contained in this set, false otherwise
       */
      isEmpty(): boolean;
    }

    /**
     * This is the base class for suggestions containers.
     *  For each type of items, a sub class provides methods to
     *  access the actual items.
     *  <p>
     *  See the sub classes for more specific information.</p>
     */
    class Suggestions {
      /**
       * The suggested search phrases that are associated to this suggestions.
       *
       *  In contrast to the suggested items, the suggested phrases contains the corrected and
       *  completed versions of the original search phrase.
       */
      readonly searchPhraseSuggestions: dw.suggest.SearchPhraseSuggestions;
      /**
       * A list of SuggestedPhrase objects that relates to the
       *  user input search phrase.
       */
      readonly suggestedPhrases: dw.util.Iterator<dw.suggest.SuggestedPhrase>;
      /**
       * A list of SuggestedTerms objects. Each of the returned
       *  instances represents a set of terms suggested for a particular single term
       *  of the user input search phrase.
       */
      readonly suggestedTerms: dw.util.Iterator<dw.suggest.SuggestedTerms>;

      /**
       * Returns the suggested search phrases that are associated to this suggestions.
       *
       *  In contrast to the suggested items, the suggested phrases contains the corrected and
       *  completed versions of the original search phrase.
       *
       * @return the suggested search phrases for this suggestions
       */
      getSearchPhraseSuggestions(): dw.suggest.SearchPhraseSuggestions;
      /**
       * Returns a list of SuggestedPhrase objects that relates to the
       *  user input search phrase.
       *
       * @return a list of SuggestedPhrases
       */
      getSuggestedPhrases(): dw.util.Iterator<dw.suggest.SuggestedPhrase>;
      /**
       * Returns a list of SuggestedTerms objects. Each of the returned
       *  instances represents a set of terms suggested for a particular single term
       *  of the user input search phrase.
       *
       * @return a list of SuggestedTerms for each term of the user input search phrase
       */
      getSuggestedTerms(): dw.util.Iterator<dw.suggest.SuggestedTerms>;
      /**
       * Returns whether this suggestions container has any suggested phrases.
       *
       *  Note that this method only looks for suggested phrases. It does not account
       *  for suggested terms or suggested objects. In other words,
       *  even if there are suggested terms or objects, this method
       *  will return false if this suggestions container has no phrases.
       *
       * @return true only if there are phrases available
       */
      hasSuggestedPhrases(): boolean;
      /**
       * Returns whether this suggestions container has any suggested terms.
       *
       *  Note that this method checks suggested terms only,
       *  but not suggested phrases or suggested objects.
       *
       * @return true only if there are terms available
       */
      hasSuggestedTerms(): boolean;
      /**
       * Returns whether this suggestions container has any suggested items, i.e. products.
       *
       *  Note that this method only looks for concrete suggested items. It does not account
       *  for suggested terms. In other words, even if there are suggested terms, this method
       *  will return false if no matching items, like products or categories, were found
       *  for the suggested terms.
       *
       *  To find out whether there are suggested terms and how they match with respect to
       *  the original search phrase, one can use getSuggestedTerms() to obtain
       *  a list of SuggestedTerms.
       *
       * @return true only if there are items found using the suggested terms
       */
      hasSuggestions(): boolean;
    }
  }

  namespace svc {
    /**
     * Represents an FTP or SFTP Service.
     *  <p>
     *  There are two basic styles of configuration for this service.
     *  </p><p>
     *  In the first style, <code>createRequest</code> is implemented to call the setOperation method on the Service. This
     *  will cause the single operation to be performed and returned as the data object in the <code>parseResponse</code>
     *  method. Any error status is set automatically based on the returned value of the operation.
     *  </p><p>
     *  In the second style, <code>execute</code> is implemented to perform one or more operations using the serviceClient
     *  available on the Service object. This serviceClient will be either an <a href="class_dw_net_FTPClient.html">FTPClient</a> or an
     *  <a href="class_dw_net_SFTPClient.html">SFTPClient</a>. The return value of execute will be passed as the data object in the
     *  <code>parseResponse</code> method.</p>
     */
    class FTPService extends dw.svc.Service {
      /**
       * The status of whether the underlying FTP connection will be disconnected after the service call.
       */
      autoDisconnect: boolean;
      /**
       * The underlying client object.
       *
       *  This is either an FTPClient or SFTPClient, depending on the protocol.
       */
      readonly client: any;

      /**
       * Returns the underlying client object.
       *
       *  This is either an FTPClient or SFTPClient, depending on the protocol.
       *
       * @return (S)FTP Client object.
       */
      getClient(): any;
      /**
       * Returns the status of whether the underlying FTP connection will be disconnected after the service call.
       *
       * @return The auto-disconnect flag.
       */
      isAutoDisconnect(): boolean;
      /**
       * Sets the auto-disconnect flag.
       *
       *  If true, the underlying FTP connection will be disconnected after the service call. If false then it will remain
       *  open. The default value is true.
       * @param b true to enable auto-disconnect, false otherwise.
       * @return this FTP or SFTP Service.
       */
      setAutoDisconnect(b: boolean): dw.svc.FTPService;
      /**
       * Sets a single operation to perform during the execute phase of the service.
       *
       *  The given arguments make up a method name and arguments on the underlying getClient() object. This
       *  method will be invoked during execution, with the result passed into the callback's parseResponse method.
       *
       *  This is required unless the callback defines an execute method.
       * @param name Method name.
       * @param args Method arguments.
       * @return this FTP or SFTP Service.
       */
      setOperation(name: string, ...args: any[]): dw.svc.FTPService;
    }

    /**
     * Represents an FTP or SFTP Service Definition.
     *  <p>
     *  There are two basic styles of configuration for this service.
     *  </p><p>
     *  In the first style, <code>createRequest</code> is implemented to call the setOperation method on the Service. This
     *  will cause the single operation to be performed and returned as the data object in the <code>parseResponse</code>
     *  method. Any error status is set automatically based on the returned value of the operation.
     *  </p><p>
     *  In the second style, <code>execute</code> is implemented to perform one or more operations using the serviceClient
     *  available on the Service object. This serviceClient will be either an <a href="class_dw_net_FTPClient.html">FTPClient</a> or an
     *  <a href="class_dw_net_SFTPClient.html">SFTPClient</a>. The return value of execute will be passed as the data object in the
     *  <code>parseResponse</code> method.</p>
     */
    class FTPServiceDefinition extends dw.svc.ServiceDefinition {
      /**
       * The status of whether the underlying FTP connection will be disconnected after the service call.
       */
      autoDisconnect: boolean;

      /**
       * Returns the status of whether the underlying FTP connection will be disconnected after the service call.
       *
       * @return The auto-disconnect flag.
       */
      isAutoDisconnect(): boolean;
      /**
       * Sets the auto-disconnect flag.
       *
       *  If true, the underlying FTP connection will be disconnected after the service call. If false then it will remain
       *  open. The default value is true.
       * @param b true to enable auto-disconnect, false otherwise.
       * @return this FTP or SFTP Service Definition.
       */
      setAutoDisconnect(b: boolean): dw.svc.FTPServiceDefinition;
    }

    /**
     * Represents an HTTP Form POST Service.
     *  <p>
     *  All arguments passed to the <a href="class_dw_svc_Service.html#dw_svc_Service_call_Object_DetailAnchor"> call</a> method will be URL-encoded and set as name/value
     *  pairs in the HTTP request body. The HTTP request will be a POST with a content-type of
     *  <code>application/x-www-form-urlencoded</code>.</p>
     */
    class HTTPFormService extends dw.svc.HTTPService {}

    /**
     * Represents an HTTP Form POST Service Definition.
     */
    class HTTPFormServiceDefinition extends dw.svc.HTTPServiceDefinition {}

    /**
     * Represents an HTTP Service.
     *  <p>
     *  The HTTP Service will use the return value of the createRequest callback as the request body (if supported by the
     *  HTTP method). If this is an array of non-null <a href="class_dw_net_HTTPRequestPart.html">HTTPRequestPart</a> objects, then a multi-part request will
     *  be formed. Otherwise the object is converted to a String and used.
     *  </p><p>
     *  See also <a href="class_TopLevel_XML.html#TopLevel_XML_toXMLString_DetailAnchor">XML.toXMLString()</a> and <a href="class_TopLevel_JSON.html#TopLevel_JSON_stringify_Object_DetailAnchor">JSON.stringify(Object)</a>, which must be
     *  explicitly called if needed.</p>
     */
    class HTTPService extends dw.svc.Service {
      /**
       * The authentication type.
       */
      authentication: string;
      /**
       * The caching time to live value.
       */
      cachingTTL: number;
      /**
       * The underlying HTTP client object.
       */
      readonly client: dw.net.HTTPClient;
      /**
       * The request body encoding to declare.
       */
      encoding: string;
      /**
       * The output file, or null if there is none.
       */
      outFile: dw.io.File;
      /**
       * The request method.
       */
      requestMethod: string;

      /**
       * Adds an HTTP Header.
       * @param name Header name.
       * @param val Header value.
       * @return this HTTP Service.
       */
      addHeader(name: string, val: string): dw.svc.HTTPService;
      /**
       * Adds a query parameter that will be appended to the URL.
       * @param name Parameter name.
       * @param val Parameter value.
       * @return this HTTP Service.
       */
      addParam(name: string, val: string): dw.svc.HTTPService;
      /**
       * Returns the authentication type.
       *
       * @return Authentication type.
       */
      getAuthentication(): string;
      /**
       * Returns the caching time to live value.
       *
       * @return The caching time to live value in seconds.
       */
      getCachingTTL(): number;
      /**
       * Returns the underlying HTTP client object.
       *
       * @return HTTP client object.
       */
      getClient(): dw.net.HTTPClient;
      /**
       * Returns the request body encoding to declare.
       *
       * @return Request encoding.
       */
      getEncoding(): string;
      /**
       * Returns the output file, or null if there is none.
       *
       * @return Output file or null.
       */
      getOutFile(): dw.io.File;
      /**
       * Returns the request method.
       *
       * @return HTTP Request method.
       */
      getRequestMethod(): string;
      /**
       * Sets the type of authentication. Valid values include "BASIC" and "NONE".
       *
       *  The default value is BASIC.
       * @param authentication Type of authentication.
       * @return this HTTP Service.
       */
      setAuthentication(authentication: string): dw.svc.HTTPService;
      /**
       * Enables caching for GET requests.
       *
       *  This only caches status codes 2xx with a content length and size of less than 50k that are not immediately
       *  written to file. The URL and the user name are used as cache keys. The total size of cacheable content and the
       *  number of cached items is limited and automatically managed by the system.
       *
       *  Cache control information sent by the remote server is ignored.
       *
       *  Caching HTTP responses should be done very carefully. It is important to ensure that the response really depends
       *  only on the URL and doesn't contain any remote state information or time information which is independent of the
       *  URL. It is also important to verify that the application sends exactly the same URL multiple times.
       * @param ttl The time to live for the cached content in seconds. A value of 0 disables caching.
       */
      setCachingTTL(ttl: number): dw.svc.HTTPService;
      /**
       * Sets the encoding of the request body (if any).
       *
       *  The default value is UTF-8.
       * @param encoding Encoding of the request body.
       * @return this HTTP Service.
       */
      setEncoding(encoding: string): dw.svc.HTTPService;
      /**
       * Sets the output file in which to write the HTTP response body.
       *
       *  The default behavior is to not write a file.
       * @param outFile Output file, or null to disable.
       * @return this HTTP Service.
       */
      setOutFile(outFile: dw.io.File): dw.svc.HTTPService;
      /**
       * Sets the HTTP request method.
       *
       *  Valid values include GET, PUT, POST, and DELETE.
       *
       *  The default value is POST.
       * @param requestMethod HTTP request method.
       * @return this HTTP Service.
       */
      setRequestMethod(requestMethod: string): dw.svc.HTTPService;
    }

    /**
     * Represents an HTTP Service Definition.
     *  <p>
     *  The HTTP Service will use the return value of the createRequest callback as the request body (if supported by the
     *  HTTP method). If this is an array of non-null <a href="class_dw_net_HTTPRequestPart.html">HTTPRequestPart</a> objects, then a multi-part request will
     *  be formed. Otherwise the object is converted to a String and used.
     *  </p><p>
     *  See also <a href="class_TopLevel_XML.html#TopLevel_XML_toXMLString_DetailAnchor">XML.toXMLString()</a> and <a href="class_TopLevel_JSON.html#TopLevel_JSON_stringify_Object_DetailAnchor">JSON.stringify(Object)</a>, which must be
     *  explicitly called if needed.</p>
     */
    class HTTPServiceDefinition extends dw.svc.ServiceDefinition {
      /**
       * The authentication type.
       */
      authentication: string;
      /**
       * The caching time to live value.
       */
      cachingTTL: number;
      /**
       * The request body encoding to declare.
       */
      encoding: string;
      /**
       * The output file, or null if there is none.
       */
      outFile: dw.io.File;
      /**
       * The request method.
       */
      requestMethod: string;

      /**
       * Adds an HTTP Header.
       * @param name Header name.
       * @param val Header value.
       * @return this HTTP Service Definition.
       */
      addHeader(name: string, val: string): dw.svc.HTTPServiceDefinition;
      /**
       * Adds a query parameter that will be appended to the URL.
       * @param name Parameter name.
       * @param val Parameter value.
       * @return this HTTP Service Definition.
       */
      addParam(name: string, val: string): dw.svc.HTTPServiceDefinition;
      /**
       * Returns the authentication type.
       *
       * @return Authentication type.
       */
      getAuthentication(): string;
      /**
       * Returns the caching time to live value.
       *
       * @return The caching time to live value in seconds.
       */
      getCachingTTL(): number;
      /**
       * Returns the request body encoding to declare.
       *
       * @return Request encoding.
       */
      getEncoding(): string;
      /**
       * Returns the output file, or null if there is none.
       *
       * @return Output file or null.
       */
      getOutFile(): dw.io.File;
      /**
       * Returns the request method.
       *
       * @return HTTP Request method.
       */
      getRequestMethod(): string;
      /**
       * Sets the type of authentication. Valid values include "BASIC" and "NONE".
       *
       *  The default value is BASIC.
       * @param authentication Type of authentication.
       * @return this HTTP Service Definition.
       */
      setAuthentication(authentication: string): dw.svc.HTTPServiceDefinition;
      /**
       * Enables caching for GET requests.
       *
       *  This only caches status codes 2xx with a content length and size of less than 50k that are not immediately
       *  written to file. The URL and the user name are used as cache keys. The total size of cacheable content and the
       *  number of cached items is limited and automatically managed by the system.
       *
       *  Cache control information sent by the remote server is ignored.
       *
       *  Caching HTTP responses should be done very carefully. It is important to ensure that the response really depends
       *  only on the URL and doesn't contain any remote state information or time information which is independent of the
       *  URL. It is also important to verify that the application sends exactly the same URL multiple times.
       * @param ttl The time to live for the cached content in seconds. A value of 0 or less disables caching.
       */
      setCachingTTL(ttl: number): dw.svc.HTTPServiceDefinition;
      /**
       * Sets the encoding of the request body (if any).
       *
       *  The default value is UTF-8.
       * @param encoding Encoding of the request body.
       * @return this HTTP Service Definition.
       */
      setEncoding(encoding: string): dw.svc.HTTPServiceDefinition;
      /**
       * Sets the output file in which to write the HTTP response body.
       *
       *  The default behavior is to not write a file.
       * @param outFile Output file, or null to disable.
       * @return this HTTP Service Definition.
       */
      setOutFile(outFile: dw.io.File): dw.svc.HTTPServiceDefinition;
      /**
       * Sets the HTTP request method.
       *
       *  Valid values include GET, PUT, POST, and DELETE.
       *
       *  The default value is POST.
       * @param requestMethod HTTP request method.
       * @return this HTTP Service Definition.
       */
      setRequestMethod(requestMethod: string): dw.svc.HTTPServiceDefinition;
    }

    /**
     * The LocalServiceRegistry is responsible for managing Service instances.
     *  <p>
     *  Typical usage involves several steps:
     *  </p><ol>
     *  <li>The service is defined in the Business Manager and configured with necessary credentials.</li>
     *  <li>An instance of the service is created and configured in a script:
     *
     *  <pre> var myFTPService = LocalServiceRegistry.createService(&quot;MyFTPService&quot;, {
     *  &#xA0;&#xA0;&#xA0;&#xA0;mockExec : function(svc:FTPService, params) {
     *  &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;return [
     *  &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;{ &quot;name&quot;: &quot;file1&quot;, &quot;timestamp&quot;: new Date(2011, 02, 21)},
     *  &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;{ &quot;name&quot;: &quot;file2&quot;, &quot;timestamp&quot;: new Date(2012, 02, 21)},
     *  &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;{ &quot;name&quot;: &quot;file3&quot;, &quot;timestamp&quot;: new Date(2013, 02, 21)}
     *  &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;];
     *  &#xA0;&#xA0;&#xA0;&#xA0;},
     *  &#xA0;&#xA0;&#xA0;&#xA0;createRequest: function(svc:FTPService, params) {
     *  &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;svc.setOperation(&quot;list&quot;, &quot;/&quot;);
     *  &#xA0;&#xA0;&#xA0;&#xA0;},
     *  &#xA0;&#xA0;&#xA0;&#xA0;parseResponse : function(svc:FTPService, listOutput) {
     *  &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;var x : Array = [];
     *  &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;var resp : Array = listOutput;
     *  &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;for(var i = 0; i &lt; resp.length; i++) {
     *  &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;var f = resp[i];
     *  &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;x.push( { &quot;name&quot;: f[&apos;name&apos;], &quot;timestamp&quot;: f[&apos;timestamp&apos;] } );
     *  &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;}
     *  &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;return x;
     *  &#xA0;&#xA0;&#xA0;&#xA0;}
     *  });
     *  </pre>
     *
     *  </li>
     *  <li>The service is called in order to perform the operation:
     *
     *  <pre> var result : Result = myFTPService.call();
     *  if(result.status == &apos;OK&apos;) {
     *      // The result.object is the object returned by the &apos;after&apos; callback.
     *  } else {
     *      // Handle the error. See result.error for more information.
     *  }
     *  </pre>
     *
     *  </li>
     *  </ol>
     *
     *  Unlike <a href="class_dw_svc_ServiceRegistry.html">ServiceRegistry</a>, the configured service is local to the current script call,
     *  so this deals directly with <a href="class_dw_svc_Service.html">Service</a> instances rather than the intermediate <a href="class_dw_svc_ServiceDefinition.html">ServiceDefinition</a>.
     *  This means that a cartridge-level initialization script (and the package.json) is no longer needed.
     *  <p>
     *  See <a href="class_dw_svc_ServiceCallback.html">ServiceCallback</a> for all the callback options, and individual <a href="class_dw_svc_Service.html">Service</a>
     *  classes for customization specific to a service type.</p>
     */
    class LocalServiceRegistry {
      /**
       * Constructs and configures a service with a callback.
       * @param serviceId Unique Service ID.
       * @param configObj Configuration callback. See ServiceCallback for a description of available callback methods.
       * @return Associated Service, which can be used for further protocol-specific configuration.
       */
      static createService(serviceId: string, configObj: any): dw.svc.Service;
    }

    /**
     * Represents the result of a service call.
     */
    class Result {
      /**
       * Status indicating a general service error.
       */
      static readonly ERROR = "ERROR";
      /**
       * Status indicating a successful service call.
       */
      static readonly OK = "OK";
      /**
       * Status indicating the service is unavailable. This includes timeouts, rate limits, and remote server issues.
       */
      static readonly SERVICE_UNAVAILABLE = "SERVICE_UNAVAILABLE";
      /**
       * Unavailable reason: No call was made because the circuit breaker prevented it.
       */
      static readonly UNAVAILABLE_CIRCUIT_BROKEN = "CIRCUIT_BROKEN";
      /**
       * Unavailable reason: No call was made because the service was not configured correctly.
       */
      static readonly UNAVAILABLE_CONFIG_PROBLEM = "CONFIG_PROBLEM";
      /**
       * Unavailable reason: No call was made because the service is disabled.
       */
      static readonly UNAVAILABLE_DISABLED = "DISABLED";
      /**
       * Unavailable reason: No call was made because the rate limit was hit.
       */
      static readonly UNAVAILABLE_RATE_LIMITED = "RATE_LIMITED";
      /**
       * Unavailable reason: A real call was made but a timeout occurred.
       */
      static readonly UNAVAILABLE_TIMEOUT = "TIMEOUT";

      /**
       * An error-specific code if applicable. For example, this is the HTTP response code for an
       *  HTTPService.
       */
      readonly error: number;
      /**
       * An error message on a non-OK status.
       */
      readonly errorMessage: string;
      /**
       * The status of whether the response is the result of a "mock" service call.
       */
      readonly mockResult: boolean;
      /**
       * An extra error message on failure (if any).
       */
      readonly msg: string;
      /**
       * The actual object returned by the service when the status is OK.
       */
      readonly object: any;
      /**
       * The status of whether the service call was successful.
       */
      readonly ok: boolean;
      /**
       * The status. This is "OK" on success. Failure codes include "ERROR" and "SERVICE_UNAVAILABLE".
       *
       *  If the status is "SERVICE_UNAVAILABLE", then the unavailableReason is guaranteed to be non-null.
       */
      readonly status: string;
      /**
       * The reason the status is SERVICE_UNAVAILABLE.
       */
      readonly unavailableReason: string;

      /**
       * Constructs a new result instance.
       *
       */
      constructor();

      /**
       * Returns an error-specific code if applicable. For example, this is the HTTP response code for an
       *  HTTPService.
       *
       * @return Error-specific code (if applicable).
       */
      getError(): number;
      /**
       * Returns an error message on a non-OK status.
       *
       * @return Error message.
       */
      getErrorMessage(): string;
      /**
       * Returns an extra error message on failure (if any).
       *
       * @return Error message, or null.
       */
      getMsg(): string;
      /**
       * Returns the actual object returned by the service when the status is OK.
       *
       * @return Object returned by the service.
       */
      getObject(): any;
      /**
       * Returns the status. This is "OK" on success. Failure codes include "ERROR" and "SERVICE_UNAVAILABLE".
       *
       *  If the status is "SERVICE_UNAVAILABLE", then the unavailableReason is guaranteed to be non-null.
       *
       * @return Status code.
       */
      getStatus(): string;
      /**
       * Returns the reason the status is SERVICE_UNAVAILABLE.
       *
       * @return Unavailable reason code, or null if the status is not SERVICE_UNAVAILABLE.
       */
      getUnavailableReason(): string;
      /**
       * Returns the status of whether the response is the result of a "mock" service call.
       *
       * @return true if this was a mock service call, false otherwise.
       */
      isMockResult(): boolean;
      /**
       * Returns the status of whether the service call was successful.
       *
       * @return true on success, false otherwise.
       */
      isOk(): boolean;
      /**
       * Returns a string representation of the result.
       *
       * @return a string representation of the result.
       */
      toString(): string;
    }

    /**
     * Represents a SOAP WebService.
     */
    class SOAPService extends dw.svc.Service {
      /**
       * The authentication type.
       */
      authentication: string;
      /**
       * The serviceClient object.
       */
      serviceClient: any;

      /**
       * Returns the authentication type.
       *
       * @return Authentication type.
       */
      getAuthentication(): string;
      /**
       * Returns the serviceClient object.
       *
       * @return serviceClient object.
       */
      getServiceClient(): any;
      /**
       * Sets the type of authentication. Valid values include "BASIC" and "NONE".
       *
       *  The default value is BASIC.
       * @param authentication Type of authentication.
       * @return this SOAP WebService.
       */
      setAuthentication(authentication: string): dw.svc.SOAPService;
      /**
       * Sets the serviceClient object. This must be set in the prepareCall method, prior to execute being called.
       * @param o serviceClient object.
       * @return this SOAP WebService.
       */
      setServiceClient(o: any): dw.svc.SOAPService;
    }

    /**
     * Represents a SOAP WebService definition.
     */
    class SOAPServiceDefinition extends dw.svc.ServiceDefinition {}

    /**
     * Base class of Services.
     *  <p>
     *  A service represents a call-specific configuration. Any configuration set here is local to the currently executing
     *  call.
     *  </p><p></p>
     */
    class Service {
      /**
       * The Service Configuration.
       */
      readonly configuration: dw.svc.ServiceConfig;
      /**
       * The ID of the currently associated Credential.
       */
      credentialID: string;
      /**
       * The status of whether this service is executing in mock mode.
       */
      mock: boolean;
      /**
       * The property that stores the object returned by createRequest.
       */
      readonly requestData: any;
      /**
       * The property that stores the object returned by the service.
       *
       *  This property is only useful after the service call(Object...) completes, and is the same as the object
       *  inside the Result.
       */
      readonly response: any;
      /**
       * The status of whether this service will throw an error when encountering a problem.
       */
      throwOnError: boolean;
      /**
       * The current URL, excluding any custom query parameters.
       */
      URL: string;

      /**
       * Invokes the service.
       * @param args Arguments to pass. If there is a single argument and that argument is an array, then each item in the array will become a separate argument. For example, the following results in three separate arguments to the service:  svc.call( [1,2,3] )  and is functionally equivalent to  svc.call( 1, 2, 3 )  This can be avoided by explicitly forming a List, enclosing the array in another array, or by sending a second argument. The following will all send the array as a List in the first argument.  svc.call( ArrayList([1,2,3]) )   svc.call( [[1,2,3]] )   svc.call( [1,2,3], "" )  Another option is to change the definition of the associated ServiceCallback.createRequest(Service, Object...) to accept an object instead, and pass the array as a field of that object:  svc.call( { 'data': [1,2,3] } )
       * @return Result of the service.
       */
      call(...args: any[]): dw.svc.Result;
      /**
       * Returns the Service Configuration.
       *
       * @return Service Configuration.
       */
      getConfiguration(): dw.svc.ServiceConfig;
      /**
       * Returns the ID of the currently associated Credential.
       *
       * @return Credential Name.
       */
      getCredentialID(): string;
      /**
       * Returns the property that stores the object returned by createRequest.
       *
       * @return Object returned by createRequest.
       */
      getRequestData(): any;
      /**
       * Returns the property that stores the object returned by the service.
       *
       *  This property is only useful after the service call(Object...) completes, and is the same as the object
       *  inside the Result.
       *
       * @return Object returned by the service.
       */
      getResponse(): any;
      /**
       * Returns the current URL, excluding any custom query parameters.
       *
       * @return URL.
       */
      getURL(): string;
      /**
       * Returns the status of whether this service is executing in mock mode.
       *
       * @return true for mock mode, false otherwise.
       */
      isMock(): boolean;
      /**
       * Returns the status of whether this service will throw an error when encountering a problem.
       *
       * @return true to throw an error, false otherwise.
       */
      isThrowOnError(): boolean;
      /**
       * Override the Credential by the credential object with the given ID.
       *
       *  If the URL is also overridden, that URL will continue to override the URL in this credential.
       * @param id Credential ID. It must exist.
       * @return this Service.
       */
      setCredentialID(id: string): dw.svc.Service;
      /**
       * Forces the mock mode to be enabled.
       *
       * @return this Service.
       */
      setMock(): dw.svc.Service;
      /**
       * Forces a Service to throw an error when there is a problem instead of returning a Result with non-OK status.
       *
       * @return this Service.
       */
      setThrowOnError(): dw.svc.Service;
      /**
       * Override the URL to the given value. Any query parameters (if applicable) will be appended to this URL.
       * @param url Force the URL to the given value.
       * @return this Service.
       */
      setURL(url: string): dw.svc.Service;
    }

    /**
     * Defines callbacks for use with the <a href="class_dw_svc_LocalServiceRegistry.html">LocalServiceRegistry</a>.
     *  <p>
     *  Note this class itself is not used directly, and is present only for documentation of the available callback methods.
     *  </p><p>
     *  These methods are called in sequence when a service is called:
     *  </p><ol>
     *  <li><a href="class_dw_svc_ServiceCallback.html#dw_svc_ServiceCallback_initServiceClient_Service_DetailAnchor">initServiceClient(Service)</a> -- Creates the underlying client that will be used to make the call. This is
     *  intended for SOAP Services. Other client types will be created automatically.
     *  </li><li><a href="class_dw_svc_ServiceCallback.html#dw_svc_ServiceCallback_createRequest_Service_Object_DetailAnchor">createRequest(Service, Object...)</a> -- Given arguments to the <a href="class_dw_svc_Service.html#dw_svc_Service_call_Object_DetailAnchor">Service.call(Object...)</a>, configure
     *  the actual service request. This may include setting request headers, defining the message body, etc.
     *  </li><li><a href="class_dw_svc_ServiceCallback.html#dw_svc_ServiceCallback_execute_Service_Object_DetailAnchor">execute(Service, Object)</a> -- Perform the actual request. At this point the client has been configured
     *  with the relevant credentials, so the call should be made. This is required for SOAP services.
     *  </li><li><a href="class_dw_svc_ServiceCallback.html#dw_svc_ServiceCallback_parseResponse_Service_Object_DetailAnchor">parseResponse(Service, Object)</a> -- Convert the result of the call into an object to be returned from the
     *  <a href="class_dw_svc_Service.html#dw_svc_Service_call_Object_DetailAnchor">Service.call(Object...)</a> method.
     *  </li></ol>
     *  If the service is mocked (see <a href="class_dw_svc_Service.html#dw_svc_Service_isMock_DetailAnchor">Service.isMock()</a>), then <a href="class_dw_svc_ServiceCallback.html#dw_svc_ServiceCallback_mockFull_Service_Object_DetailAnchor">mockFull(Service, Object...)</a> takes the place
     *  of this entire sequence. If that is not implemented, then <a href="class_dw_svc_ServiceCallback.html#dw_svc_ServiceCallback_mockCall_Service_Object_DetailAnchor">mockCall(Service, Object)</a> takes the place of just
     *  the <a href="class_dw_svc_ServiceCallback.html#dw_svc_ServiceCallback_execute_Service_Object_DetailAnchor">execute(Service, Object)</a> method.
     *  <p>
     *  The URL, request, and response objects may be logged. To avoid logging sensitive data,
     *  <a href="class_dw_svc_ServiceCallback.html#dw_svc_ServiceCallback_filterLogMessage_String_DetailAnchor">filterLogMessage(String)</a> and/or <a href="class_dw_svc_ServiceCallback.html#dw_svc_ServiceCallback_getRequestLogMessage_Object_DetailAnchor">getRequestLogMessage(Object)</a> and
     *  <a href="class_dw_svc_ServiceCallback.html#dw_svc_ServiceCallback_getResponseLogMessage_Object_DetailAnchor">getResponseLogMessage(Object)</a> must be implemented. If they are not implemented then this logging will not be
     *  done on Production environments.
     *  </p><p>
     *  There are some special considerations for the combination of service type and callback:
     *  <table>
     *  <tbody><tr><th>
     *  </th></tr><tr>
     *  <td>Service Type</td>
     *  <td>initServiceClient</td>
     *  <td>createRequest</td>
     *  <td>execute</td>
     *  <td>parseResponse</td>
     *  </tr>
     *
     *  <tr>
     *  <td>HTTP</td>
     *  <td>Not normally implemented. Must return a <a href="class_dw_net_HTTPClient.html">HTTPClient</a></td>
     *  <td>Required unless execute is provided. The return value is expected to be either a String or array of
     *  <a href="class_dw_net_HTTPRequestPart.html">HTTPRequestPart</a>, which will be used as the request body</td>
     *  <td>Not called unless a boolean &quot;executeOverride:true&quot; is set on the callback. This is a temporary limitation, a
     *  future release will always call this callback if it is present</td>
     *  <td>Required unless execute is provided.</td>
     *  </tr>
     *  <tr>
     *  <td>HTTPForm</td>
     *  <td>Not normally implemented. Must return a <a href="class_dw_net_HTTPClient.html">HTTPClient</a></td>
     *  <td>Not normally implemented. Default behavior constructs an &quot;application/x-www-form-urlencoded&quot; request based on a
     *  Map given as an argument.</td>
     *  <td>Not normally implemented. The same limitations as HTTP regarding the &quot;executeOverride&quot; flag apply here.</td>
     *  <td>Optional. Default behavior is to return the response body as a String.</td>
     *  </tr>
     *  <tr>
     *  <td>SOAP</td>
     *  <td>Optional. This must return the Webservice stub or port</td>
     *  <td>Required. If initServiceClient was not provided, then this function must call
     *  <a href="class_dw_svc_SOAPService.html#dw_svc_SOAPService_setServiceClient_Object_DetailAnchor">SOAPService.setServiceClient(Object)</a> with the stub or port</td>
     *  <td>Required. A typical implementation will call the webservice via a method on the service client</td>
     *  <td>Optional. Default behavior returns the output of execute</td>
     *  </tr>
     *  <tr>
     *  <td>FTP</td>
     *  <td>Not normally implemented. Must return a <a href="class_dw_net_FTPClient.html">FTPClient</a> or <a href="class_dw_net_SFTPClient.html">SFTPClient</a></td>
     *  <td>Required unless execute is defined. If present, it should call
     *  <a href="class_dw_svc_FTPService.html#dw_svc_FTPService_setOperation_String_Object_DetailAnchor">FTPService.setOperation(String, Object...)</a></td>
     *  <td>Optional. An implementation may call any required methods on the given client. The default implementation calls
     *  the Operation that was set up and returns the result.</td>
     *  <td>Optional. Default behavior returns the output of execute</td>
     *  </tr>
     *  <tr>
     *  <td>GENERIC</td>
     *  <td>Optional.</td>
     *  <td>Optional.</td>
     *  <td>Required. The GENERIC type allows any code to be wrapped in the service framework layer, and it&apos;s up to this
     *  execute method to define what that logic is.</td>
     *  <td>Optional.</td>
     *  </tr>
     *  </tbody></table></p>
     */
    class ServiceCallback {
      /**
       * Allows overriding the URL provided by the service configuration.
       *
       *  It is usually better to call Service.setURL(String) within createRequest(Service, Object...)
       *  because that allows you to modify the existing URL based on call parameters.
       */
      readonly URL: string;

      /**
       * Creates a request object to be used when calling the service.
       *
       *  The type of the object expected is dependent on the service. For example, the HTTPService expects the
       *  HTTP request body to be returned.
       *
       *  This is required unless the execute method is implemented.
       *
       *  It is not recommended to have a service accept a single array or list as a parameter, since doing so requires
       *  some extra work when actually calling the service. See Service.call(Object...) for more details.
       * @param service Service being executed.
       * @param params Parameters given to the call method.
       * @return Request object to give to the execute method.
       */
      createRequest(service: dw.svc.Service, ...params: any[]): any;
      /**
       * Provides service-specific execution logic.
       *
       *  This can be overridden to execute a chain of FTP commands in the FTPService, or perform the actual remote
       *  call on a webservice stub in the SOAPService.
       * @param service Service being executed.
       * @param request Request object returned by createRequest(Service, Object...).
       * @return Response from the underlying call, to be sent to parseResponse(Service, Object).
       */
      execute(service: dw.svc.Service, request: any): any;
      /**
       * Allows filtering communication URL, request, and response log messages.
       *
       *  If not implemented, then no filtering will be performed and the message will be logged as-is.
       * @param msg Original log message.
       * @return Message to be logged.
       */
      filterLogMessage(msg: string): string;
      /**
       * Creates a communication log message for the given request.
       *
       *  If not implemented then the default logic will be used to convert the request into a log message.
       * @param request Request object.
       * @return Log message, or null to create and use the default message.
       */
      getRequestLogMessage(request: any): string;
      /**
       * Creates a response log message for the given request.
       *
       *  If not implemented then the default logic will be used to convert the response into a log message.
       * @param response Response object.
       * @return Log message, or null to create and use the default message.
       */
      getResponseLogMessage(response: any): string;
      /**
       * Allows overriding the URL provided by the service configuration.
       *
       *  It is usually better to call Service.setURL(String) within createRequest(Service, Object...)
       *  because that allows you to modify the existing URL based on call parameters.
       *
       * @return URL to use. The default behavior is to use the URL from the service configuration.
       */
      getURL(): string;
      /**
       * Creates a protocol-specific client object.
       *
       *  This does not normally need to be implemented, except in the case of SOAP services.
       *
       *  Example declaration:
       *   initServiceClient: function( svc:SOAPService ) {
       *  }
       * @param service the Service object.
       * @return Client object
       */
      initServiceClient(service: dw.svc.Service): any;
      /**
       * Override this method to mock the remote portion of the service call.
       *
       *  Other callbacks like createRequest and parseResponse are still called.
       * @param service Service being executed.
       * @param requestObj Request object returned by createRequest(Service, Object...).
       * @return Mock response, to be sent to parseResponse(Service, Object).
       */
      mockCall(service: dw.svc.Service, requestObj: any): any;
      /**
       * Override this method to mock the entire service call, including the createRequest, execute, and parseResponse phases.
       * @param service Service being executed.
       * @param args Arguments from the Service call method.
       * @return Object to return in the service call's Result.
       */
      mockFull(service: dw.svc.Service, ...args: any[]): any;
      /**
       * Creates a response object from a successful service call.
       *
       *  This response object will be the output object of the call method's Result.
       * @param service Service being executed.
       * @param response Service-specific response object. For example, the HTTPService service provides the underlying HTTPClient object that made the HTTP call.
       * @return Object to return in the service call's Result.
       */
      parseResponse(service: dw.svc.Service, response: any): any;
    }

    /**
     * Configuration object for Services.
     */
    class ServiceConfig extends dw.object.ExtensibleObject {
      /**
       * The related service credentials.
       */
      readonly credential: dw.svc.ServiceCredential;
      /**
       * The unique Service ID.
       */
      readonly ID: string;
      /**
       * The related service profile.
       */
      readonly profile: dw.svc.ServiceProfile;
      /**
       * The type of the service, such as HTTP or SOAP.
       */
      readonly serviceType: string;

      /**
       * Returns the related service credentials.
       *
       * @return Related service credentials.
       */
      getCredential(): dw.svc.ServiceCredential;
      /**
       * Returns the unique Service ID.
       *
       * @return unique Service ID.
       */
      getID(): string;
      /**
       * Returns the related service profile.
       *
       * @return Related service profile.
       */
      getProfile(): dw.svc.ServiceProfile;
      /**
       * Returns the type of the service, such as HTTP or SOAP.
       *
       * @return Type of the service, such as HTTP or SOAP.
       */
      getServiceType(): string;
    }

    /**
     * Configuration object for Service Credentials.
     */
    class ServiceCredential extends dw.customer.EncryptedObject {
      /**
       * Constant for specification of the public key encryption algorithm RSA.
       */
      static readonly ENCRYPTION_ALGORITHM_RSA = "RSA";

      /**
       * The unique Credential ID.
       */
      readonly ID: string;
      /**
       * The Password in plain text.
       */
      readonly password: string;
      /**
       * Return the URL.
       */
      readonly URL: string;
      /**
       * The User ID.
       */
      readonly user: string;

      /**
       * Encrypts the password from this object with the given algorithm
       *  and the public key taken from a certificate in the keystore.
       *  Returned is the base64-encoded representation of the result.
       *  See also Cipher.encrypt(String, CertificateRef, String, String, Number) on how to generate RSA key pairs.
       * @param algorithm The algorithm to be used for the encryption of this password. Currently only "RSA" is supported.
       * @param publicKey A reference to a trusted certificate entry containing the public key in the keystore.
       * @return the base64-encoded representation of the password.
       */
      getEncryptedPassword(
        algorithm: string,
        publicKey: dw.crypto.CertificateRef
      ): string;
      /**
       * Returns the unique Credential ID.
       *
       * @return unique Credential ID.
       */
      getID(): string;
      /**
       * Returns the Password in plain text.
       *
       * @return Password.
       */
      getPassword(): string;
      /**
       * Return the URL.
       *
       * @return URL.
       */
      getURL(): string;
      /**
       * Returns the User ID.
       *
       * @return User ID.
       */
      getUser(): string;
    }

    /**
     * Base class of Service Definitions.
     *  <p>
     *  A service definition represents configuration that is shared across all <a href="class_dw_svc_Service.html">Service</a> instances.</p>
     */
    class ServiceDefinition {
      /**
       * The Service Configuration stored in the database.
       */
      readonly configuration: dw.svc.ServiceConfig;
      /**
       * The status of whether mock mode is enabled for all instances of this definition.
       */
      mock: boolean;
      /**
       * The name of this service.
       */
      readonly serviceName: string;
      /**
       * The status of whether the shared throwOnError flag is set.
       */
      throwOnError: boolean;

      /**
       * Register a callback to handle custom portions of the service.
       *
       *  This callback may declare multiple methods:
       *
       *   {
       *    initServiceClient: function() {
       *        // Create and return the internal service client object.
       *        // This is usually optional, except in the case of SOAP services.
       *    },
       *
       *    // svc is the call-specific Service instance. For example, it may be an HTTPService or FTPService.
       *    // params are the arguments passed to the call method (if any).
       *    createRequest: function(svc:Service, params) {
       *         // Perform any required call-time configuration.
       *         // Optionally return a Service-specific object
       *    },
       *
       *    // svc is the call-specific Service instance.
       *    // arg is the output of createRequest.
       *    execute: function(svc:Service, arg:Object) {
       *         // Execute the service call and return a result
       *         // This method is not used by default for HTTP-related services unless executeOverride is set.
       *    },
       *
       *    // Use the execute function if it is present. This is only required to use the functionality with HTTP services.
       *    executeOverride: true,
       *
       *    // svc is the call-specific Service instance.
       *    // response is the output of execute.
       *    parseResponse: function(svc:Service, response: Object) {
       *         // Process the response object as needed.
       *         // The return value of this method will be the return value of the outer call method.
       *    },
       *
       *    // svc is the call-specific Service instance.
       *    // arg is the output of createRequest.
       *    mockCall: function(svc:Service, arg:Object) {
       *         // This method takes the place of the 'execute' phase when mocking is enabled.
       *         // Note initServiceClient, createRequest, and parseResponse still invoked.
       *    },
       *
       *    // svc is the call-specific Service instance.
       *    // params are the arguments passed to the call method (if any).
       *    mockFull: function(svc:Service, params) {
       *         // This method takes the place of the entire service call when mocking is enabled.
       *         // No other callbacks are invoked. The output of this method becomes the output of call.
       *    }
       *
       *  }
       * @param config Callback object.
       * @return this
       */
      configure(config: any): dw.svc.ServiceDefinition;
      /**
       * Returns the Service Configuration stored in the database.
       *
       * @return Service Configuration.
       */
      getConfiguration(): dw.svc.ServiceConfig;
      /**
       * Returns the name of this service.
       *
       * @return Service name.
       */
      getServiceName(): string;
      /**
       * Returns the status of whether mock mode is enabled for all instances of this definition.
       *
       * @return true for mock mode, false otherwise.
       */
      isMock(): boolean;
      /**
       * Returns the status of whether the shared throwOnError flag is set.
       *
       * @return throwOnError flag.
       */
      isThrowOnError(): boolean;
      /**
       * Sets the mock mode for all Service instances that use this definition.
       *
       * @return this Service Definition.
       */
      setMock(): dw.svc.ServiceDefinition;
      /**
       * Sets the throwOnError flag to true for all Service instances that use this definition.
       *
       * @return this Service Definition.
       */
      setThrowOnError(): dw.svc.ServiceDefinition;
    }

    /**
     * Configuration object for Service Profiles.
     */
    class ServiceProfile extends dw.object.ExtensibleObject {
      /**
       * The maximum number of errors in an interval allowed by the circuit breaker.
       */
      readonly cbCalls: number;
      /**
       * The interval of the circuit breaker in milliseconds.
       */
      readonly cbMillis: number;
      /**
       * The unique Service ID.
       */
      readonly ID: string;
      /**
       * The maximum number of calls in an interval allowed by the rate limiter.
       */
      readonly rateLimitCalls: number;
      /**
       * The interval of the rate limiter in milliseconds.
       */
      readonly rateLimitMillis: number;
      /**
       * The service call timeout in milliseconds.
       */
      readonly timeoutMillis: number;

      /**
       * Returns the maximum number of errors in an interval allowed by the circuit breaker.
       *
       * @return Maximum number of errors in an interval allowed by the circuit breaker.
       */
      getCbCalls(): number;
      /**
       * Returns the interval of the circuit breaker in milliseconds.
       *
       * @return Circuit breaker interval in milliseconds.
       */
      getCbMillis(): number;
      /**
       * Returns the unique Service ID.
       *
       * @return unique Service ID
       */
      getID(): string;
      /**
       * Returns the maximum number of calls in an interval allowed by the rate limiter.
       *
       * @return Maximum number of calls in an interval allowed by the rate limiter.
       */
      getRateLimitCalls(): number;
      /**
       * Returns the interval of the rate limiter in milliseconds.
       *
       * @return Interval of the rate limiter in milliseconds.
       */
      getRateLimitMillis(): number;
      /**
       * Returns the service call timeout in milliseconds.
       *
       * @return Service call timeout in milliseconds.
       */
      getTimeoutMillis(): number;
    }

    /**
     * The ServiceRegistry is responsible for managing Service definitions and their instances.
     *  <p>
     *  Typical usage involves several steps:
     *  </p><ol>
     *  <li>The service is defined in the Business Manager and configured with necessary credentials.</li>
     *  <li>The service callback is configured once during cartridge initialization:
     *
     *  <pre> ServiceRegistry.configure(&quot;MyFTPService&quot;, {
     *  &#xA0;&#xA0;&#xA0;&#xA0;mockExec : function(svc:FTPService, params) {
     *  &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;return [
     *  &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;{ &quot;name&quot;: &quot;file1&quot;, &quot;timestamp&quot;: new Date(2011, 02, 21)},
     *  &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;{ &quot;name&quot;: &quot;file2&quot;, &quot;timestamp&quot;: new Date(2012, 02, 21)},
     *  &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;{ &quot;name&quot;: &quot;file3&quot;, &quot;timestamp&quot;: new Date(2013, 02, 21)}
     *  &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;];
     *  &#xA0;&#xA0;&#xA0;&#xA0;},
     *  &#xA0;&#xA0;&#xA0;&#xA0;createRequest: function(svc:FTPService, params) {
     *  &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;svc.setOperation(&quot;list&quot;, &quot;/&quot;);
     *  &#xA0;&#xA0;&#xA0;&#xA0;},
     *  &#xA0;&#xA0;&#xA0;&#xA0;parseResponse : function(svc:FTPService, listOutput) {
     *  &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;var x : Array = [];
     *  &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;var resp : Array = listOutput;
     *  &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;for(var i = 0; i &lt; resp.length; i++) {
     *  &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;var f = resp[i];
     *  &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;x.push( { &quot;name&quot;: f[&apos;name&apos;], &quot;timestamp&quot;: f[&apos;timestamp&apos;] } );
     *  &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;}
     *  &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;return x;
     *  &#xA0;&#xA0;&#xA0;&#xA0;}
     *  });
     *  </pre>
     *
     *  </li>
     *  <li>A new service instance is created and called in order to perform the operation:
     *
     *  <pre> var result : Result = ServiceRegistry.get(&quot;MyFTPService&quot;).call();
     *  if(result.status == &apos;OK&apos;) {
     *      // The result.object is the object returned by the &apos;after&apos; callback.
     *  } else {
     *      // Handle the error. See result.error for more information.
     *  }
     *  </pre>
     *
     *  </li>
     *  </ol>
     *
     *  See <a href="class_dw_svc_ServiceCallback.html">ServiceCallback</a> for all the callback options, and individual <a href="class_dw_svc_ServiceDefinition.html">ServiceDefinition</a>
     *  classes for customization specific to a service type.
     */
    class ServiceRegistry {
      /**
       * Configure the given serviceId with a callback.
       *
       *  If the service is already configured, the given callback will replace any existing one.
       * @param serviceID Unique Service ID.
       * @param configObj Configuration callback. See ServiceCallback for a description of available callback methods.
       * @return Associated ServiceDefinition, which can be used for further protocol-specific configuration.
       */
      static configure(
        serviceID: string,
        configObj: any
      ): dw.svc.ServiceDefinition;
      /**
       * Constructs a new instance of the given service.
       * @param serviceID Unique Service ID.
       * @return Service instance.
       */
      static get(serviceID: string): dw.svc.Service;
      /**
       * Gets a Service Definition.
       *
       *  This Service Definition is shared across all Service instances returned by get(String).
       * @param serviceID Unique Service Id
       * @return ServiceDefinition
       */
      static getDefinition(serviceID: string): dw.svc.ServiceDefinition;
      /**
       * Returns the status of whether the given service has been configured with a callback.
       * @param serviceID Unique Service ID.
       * @return true if configure has already been called, false otherwise.
       */
      static isConfigured(serviceID: string): boolean;
    }
  }

  namespace system {
    /**
     * AgentUserStatusCodes contains constants representing status codes that can be
     *  used with a <a href="class_dw_system_Status.html">Status</a> object to indicate the success or failure of the agent
     *  user login process.
     */
    class AgentUserStatusCodes extends dw.customer.AgentUserStatusCodes {
      constructor();
    }

    /**
     * The Cache class represents a custom cache.
     *  <p>
     *  A cache stores data over multiple requests. Each cartridge can define its own
     *  caches for different business requirements. To limit the
     *  visibility of cache entries by scope, for example, by site, catalog, or
     *  external system, include the scope reference when constructing the
     *  key. For example:
     *
     *  </p><pre>    var cache = CacheMgr.getCache( &apos;SiteConfigurations&apos; );
     *     cache.get( Site.current.ID + &quot;config&quot;, function loadSiteConfiguration() {return loadCfg( Site.current );} );
     *  </pre>
     *
     *  <p>
     *  Do not build the cache key using personal user data, since the key might be
     *  visible in log messages.
     *
     *  </p><p>
     *  There is never a guarantee that a stored object can be retrieved from the
     *  cache. The storage allocated for entries is limited and clearing or
     *  invalidation might occur at any time. To maintain the cache size limits, the
     *  cache evicts entries that are less likely to be used again. For example, the
     *  cache might evict an entry because it hasn&apos;t been used recently or very
     *  often. Cache entries aren&apos;t synchronized between different application
     *  servers.
     *
     *  </p><p>
     *  The cache returns immutable copies of the original objects put into the
     *  cache. Lists are converted to arrays during this process. Only JavaScript
     *  primitive values and tree-like object structures can be stored as entries.
     *  Object structures can consist of arrays, lists, and native JavaScript
     *  objects. Script API classes are not supported, except <a href="class_dw_util_List.html">List</a>
     *  and its subclasses. <code>null</code> can be stored as a value.
     *  <code>undefined</code> can&apos;t be stored.
     *
     *  </p><p>
     *  See <a href="class_dw_system_CacheMgr.html">CacheMgr</a> for details about how to configure a custom cache.</p>
     */
    class Cache {
      /**
       * Returns the value associated with key in this cache, or invokes the loader function to generate the entry if
       *  there is no entry found. The generated entry is stored for future retrieval. If the loader function returns
       *  undefined, this value is not stored in the cache.
       * @param key The cache key.
       * @param loader The loader function that is called if no value is stored in the cache.
       * @return The value found in the cache or the value returned from the loader function call.
       */
      get(key: string, loader: Function): any;
      /**
       * Returns the value associated with key in this cache. If there is no entry in the cache then
       *  undefined is returned.
       * @param key The cache key.
       * @return The stored value or undefined if no value is found in the cache.
       */
      get(key: string): any;
      /**
       * Removes the cache entry for key (if one exists) manually before the cache's eviction strategy goes into effect.
       * @param key The cache key.
       */
      invalidate(key: string): void;
      /**
       * Stores the specified entry directly into the cache, replacing any previously cached entry for key if one exists.
       *  Storing undefined as value has the same effect as calling invalidate(String) for that key.
       * @param key The cache key.
       * @param value The value to be store in the cache.
       */
      put(key: string, value: any): void;
    }

    /**
     * The CacheMgr class is the entry point for using custom caches.
     *  <p>
     *  The CacheMgr can manage multiple custom caches that share one storage space. Each individual cache has a unique ID
     *  and an optional expiration time that specifies the maximum time (in seconds) an entry is stored in the cache. For
     *  registering caches inside the cartridge root folder, a &apos;package.json&apos; file with a &apos;caches&apos; entry must exist. The
     *  registration of caches is independent of any site context.
     *
     *  </p><pre> &quot;caches&quot;: &quot;./caches.json&quot;
     *  </pre>
     *
     *  The caches entry links to a JSON file, with a path relative to the &apos;package.json&apos; file. This file lists all
     *  registered caches inside the caches property:
     *
     *  <pre> {
     *    &quot;caches&quot;: [
     *      {
     *        &quot;id&quot;: &quot;UnlimitedTestCache&quot;
     *      },
     *      {
     *        &quot;id&quot;: &quot;TestCacheWithExpiration&quot;,
     *        &quot;expireAfterSeconds&quot;: 10
     *      }
     *    ]
     *  }
     *  </pre>
     */
    class CacheMgr {
      /**
       * Returns the defined cache instance for the given ID. Throws an exception when the requested cache has not been
       *  defined in any caches.json descriptor.
       * @param cacheID The ID of the cache.
       * @return The registered cache.
       */
      static getCache(cacheID: string): dw.system.Cache;
    }

    /**
     * This class provides functionality to call hooks. A hook is an extension point in the business logic,
     *  where you can register scripts to customize functionality.
     */
    class HookMgr {
      /**
       * Calls a hook on base of the specified extensionPoint and function. If a hook throws an exception, then
       *  this method will also throw an exception. If no hook and no system default implementation is provided,
       *  then this method will return undefined.
       *
       *  Sample:
       *   dw.system.HookMgr.callHook( "dw.order.calculate", "calculate", basket );
       * @param extensionPoint the extension point to call
       * @param function the script function to call
       * @param args the Array of function parameters
       * @return the object returned by the hook or undefined
       */
      static callHook(extensionPoint: string, fn: string, ...args: any[]): any;
      /**
       * Checks whether a hook is registered or a system default implementation exists for this extension point.
       *  extensionPoint refers to the same name used to register a script as implementation. With this method it's only
       *  possible to check for a whole script registered but it is not possible to check, whether an individual function
       *  is implemented.
       *
       *  Sample:
       *   dw.system.HookMgr.hasHook( "dw.order.calculate" );
       * @param extensionPoint the extension point
       * @return true, if a hook is registered or a default implementation exists, otherwise false
       */
      static hasHook(extensionPoint: string): boolean;
    }

    /**
     * Class used to wrap internal objects to hide them from
     *  B2C Commerce Script code.
     */
    class InternalObject {
      /**
       * Returns a string representation of this object.
       *
       * @return a string representation of this object.
       */
      toString(): string;
      /**
       * Returns a string representation of this object.
       *
       * @return a string representation of this object.
       */
      valueOf(): string;
    }

    /**
     * <b><u>Reserved for future use</u></b>.
     */
    class JobProcessMonitor {
      /**
       * Reserved for future use. Gets the total work count.
       */
      totalWork: number;
      /**
       * Reserved for future use. Gets the work message.
       */
      workMessage: string;

      /**
       * Reserved for future use. Gets the total work count.
       *
       * @return the total work count.
       */
      getTotalWork(): number;
      /**
       * Reserved for future use. Gets the work message.
       *
       * @return the work message.
       */
      getWorkMessage(): string;
      /**
       * Reserved for future use. Sets the total work count.
       * @param totalWork the total work count.
       */
      setTotalWork(totalWork: number): void;
      /**
       * Reserved for future use. Sets the work message.
       * @param msg the messageto use. If msg is null, then an empty string will be used.
       */
      setWorkMessage(msg: string): void;
      /**
       * Reserved for future use. Increments the count of work items by the value of the specified
       *  parameter.
       * @param worked the number of items worked.
       */
      worked(worked: number): void;
    }

    /**
     * A log4j like logger instance. To obtain such an instance, use the <a href="class_dw_system_Logger.html#dw_system_Logger_getRootLogger_DetailAnchor">Logger.getRootLogger()</a> or
     *  <a href="class_dw_system_Logger.html#dw_system_Logger_getLogger_String_DetailAnchor">Logger.getLogger(String)</a> or <a href="class_dw_system_Logger.html#dw_system_Logger_getLogger_String_String_DetailAnchor">Logger.getLogger(String, String)</a> methods.
     */
    class Log {
      /**
       * This method returns true if debug logging is enabled for this logging instance.
       */
      readonly debugEnabled: boolean;
      /**
       * This method returns true if error logging is enabled for this logging instance.
       */
      readonly errorEnabled: boolean;
      /**
       * This method returns true if information logging is enabled for this logging instance.
       */
      readonly infoEnabled: boolean;
      /**
       * The Nested Diagnostic Context for this script call.
       */
      static readonly NDC: dw.system.LogNDC;
      /**
       * This method returns true if warning logging is enabled for this logging instance.
       */
      readonly warnEnabled: boolean;

      /**
       * The method reports an debug level message. Arguments can be embedded into the message, e.g. like "Failure {0} in
       *  {1}". The method implements the Java MessageFormat.format() syntax.
       * @param msg the message to log.
       * @param args the arguments to insert into the message.
       */
      debug(msg: string, ...args: any[]): void;
      /**
       * The method reports an error level message. Arguments can be embedded into the message, e.g. like "Failure {0} in
       *  {1}". The method implements the Java MessageFormat.format() syntax.
       * @param msg the message to log.
       * @param args the arguments to insert into the message.
       */
      error(msg: string, ...args: any[]): void;
      /**
       * The method reports an warning level message. Arguments can be embedded into the message, e.g. like "Failure {0}
       *  in {1}". The method implements the Java MessageFormat.format() syntax. Note: Fatal log messages are always
       *  enabled and optionally send via E-Mail.
       * @param msg the message to log.
       * @param args the arguments to insert into the message.
       */
      fatal(msg: string, ...args: any[]): void;
      /**
       * Returns the Nested Diagnostic Context for this script call.
       *
       * @return the nested diagnostic context
       */
      static getNDC(): dw.system.LogNDC;
      /**
       * The method reports an information level message. Arguments can be embedded into the message, e.g. like "Failure
       *  {0} in {1}". The method implements the Java MessageFormat.format() syntax.
       * @param msg the message to log.
       * @param args the arguments to insert into the message.
       */
      info(msg: string, ...args: any[]): void;
      /**
       * This method returns true if debug logging is enabled for this logging instance.
       *
       * @return true if logging of debug messages is enabled, false otherwise.
       */
      isDebugEnabled(): boolean;
      /**
       * This method returns true if error logging is enabled for this logging instance.
       *
       * @return true if logging of error messages is enabled, false otherwise.
       */
      isErrorEnabled(): boolean;
      /**
       * This method returns true if information logging is enabled for this logging instance.
       *
       * @return true if logging of information messages is enabled, false otherwise.
       */
      isInfoEnabled(): boolean;
      /**
       * This method returns true if warning logging is enabled for this logging instance.
       *
       * @return true if logging of warning messages is enabled, false otherwise.
       */
      isWarnEnabled(): boolean;
      /**
       * The method reports an warning level message. Arguments can be embedded into the message, e.g. like "Failure {0}
       *  in {1}". The method implements the Java MessageFormat.format() syntax.
       * @param msg the message to log.
       * @param args the arguments to insert into the message.
       */
      warn(msg: string, ...args: any[]): void;
    }

    /**
     * A Nested Diagnostic Context, or NDC in short, is an instrument to distinguish
     *  interleaved log output from different sources. Log output is typically
     *  interleaved when a server handles multiple script calls near-simultaneously.
     */
    class LogNDC {
      /**
       * Looks at the last diagnostic context at the top of this NDC without
       *  removing it.
       *  The returned value is the value that was pushed last. If no context is
       *  available, then the empty string "" is returned.
       *
       * @return String The innermost diagnostic context.
       */
      peek(): string;
      /**
       * Clients should call this method before leaving a diagnostic context.
       *  The returned value is the value that was pushed last.
       *  If no context is available, then the empty string "" is returned.
       *  NOTE: The NDC is removed after every script execution.
       *
       * @return String The innermost diagnostic context.
       */
      pop(): string;
      /**
       * Push new diagnostic context information for the current script execution.
       * @param message - The new diagnostic context information.
       */
      push(message: string): void;
      /**
       * Remove the diagnostic context for this script call.
       *
       */
      remove(): void;
    }

    /**
     * The Logger class provides logging utility methods.
     */
    class Logger {
      /**
       * This method returns true if debug logging is enabled.
       */
      readonly debugEnabled: boolean;
      /**
       * This method returns true if error logging is enabled.
       */
      readonly errorEnabled: boolean;
      /**
       * This method returns true if info logging is enabled.
       */
      readonly infoEnabled: boolean;
      /**
       * The root logger object.
       */
      static readonly rootLogger: dw.system.Log;
      /**
       * This method returns true if warning logging is enabled.
       */
      readonly warnEnabled: boolean;

      /**
       * The method reports an debug level message. Arguments can be embedded
       *  into the message, e.g. like "Failure {0} in {1}". The method implements
       *  the Java MessageFormat.format() syntax.
       * @param msg the message to log.
       * @param args the arguments to insert into the message.
       */
      static debug(msg: string, ...args: any[]): void;
      /**
       * The method reports an error level message. Arguments can be embedded
       *  into the message, e.g. like "Failure {0} in {1}". The method implements
       *  the Java MessageFormat.format() syntax.
       * @param msg the message to log.
       * @param args the arguments to insert into the message.
       */
      static error(msg: string, ...args: any[]): void;
      /**
       * Returns the logger object for the given category.
       * @param category - the category to get the logger for
       * @return the logger object for the given category.
       */
      static getLogger(category: string): dw.system.Log;
      /**
       * Returns the logger object for the given file name prefix and category.
       *  Throws an exception if maximum number of custom log files per day has already been obtained.
       * @param fileNamePrefix - the file name prefix to identify the logger must not be null or an empty string, must be at least 3 characters long, can contain characters a-z A-Z 0-9 '-' '_' only, can have up to 25 characters must not start or end with '-' or '_' can only start or end with a-z A-Z 0-9
       * @param category - the category to get the logger for, must not be null
       * @return the logger object for the given category.
       */
      static getLogger(fileNamePrefix: string, category: string): dw.system.Log;
      /**
       * Returns the root logger object.
       *
       * @return the root logger object.
       */
      static getRootLogger(): dw.system.Log;
      /**
       * The method reports an information level message. Arguments can be embedded
       *  into the message, e.g. like "Failure {0} in {1}". The method implements
       *  the Java MessageFormat.format() syntax.
       * @param msg the message to log.
       * @param args the arguments to insert into the message.
       */
      static info(msg: string, ...args: any[]): void;
      /**
       * This method returns true if debug logging is enabled.
       *
       * @return true if logging of debug messages is enabled, false otherwise.
       */
      static isDebugEnabled(): boolean;
      /**
       * This method returns true if error logging is enabled.
       *
       * @return true if logging of error messages is enabled, false otherwise.
       */
      static isErrorEnabled(): boolean;
      /**
       * This method returns true if info logging is enabled.
       *
       * @return true if logging of info messages is enabled, false otherwise.
       */
      static isInfoEnabled(): boolean;
      /**
       * This method returns true if warning logging is enabled.
       *
       * @return true if logging of warn messages is enabled, false otherwise.
       */
      static isWarnEnabled(): boolean;
      /**
       * The method reports an warning level message. Arguments can be embedded
       *  into the message, e.g. like "Failure {0} in {1}". The method implements
       *  the Java MessageFormat.format() syntax.
       * @param msg the message to log.
       * @param args the arguments to insert into the message.
       */
      static warn(msg: string, ...args: any[]): void;
    }

    /**
     * OrganizationPreferences is a container for custom global (i.e.
     *  organization-level) attributes. The object corresponds with system object
     *  definition &quot;OrganizationPreferences&quot;. It has no system attributes and exists
     *  only as a place for merchants to define custom attributes which need to be
     *  available to all of their sites.
     *  <p>
     *  An instance is obtained by calling <a href="class_dw_system_System.html#dw_system_System_getPreferences_DetailAnchor">System.getPreferences()</a>.
     *  Once an instance of the container is obtained, it is possible to read/write
     *  organization preference values by using the usual syntax for
     *  <a href="class_dw_object_ExtensibleObject.html">ExtensibleObject</a> instances. For example:
     *  </p><pre> var orgPrefs : OrganizationPreferences = dw.system.System.getPreferences();
     *  var myOrgPrefValue : String = orgPrefs.getCustom()[&quot;myOrgPref&quot;];
     *  </pre>
     *  <p>
     *  <b>Note:</b> this class allows access to sensitive security-related data.
     *  Pay special attention to PCI DSS v3. requirements 2, 4, and 12.
     *  </p><p>
     *  Commerce Cloud Digital defines many organization-level preferences, relating to
     *  locale, timezone, geolocations, etc, which can be managed within the
     *  &quot;Global Preferences&quot; module of the Business Manager, but these preferences
     *  are not accessible through this object.</p>
     */
    class OrganizationPreferences extends dw.object.ExtensibleObject {}

    /**
     * A helper for executing pipelines from JavaScript. The main purpose for this API is to invoke process pipelines from
     *  JavaScript controllers, e.g. pipelines that return with an end node and that do not perform user interactions.
     *  Pipelines that span across multiple requests (e.g. that contain Interaction-Continue-Nodes) are not supported and may
     *  not work as expected. The pipeline will be executed within the current request and not by a remote call, so this API
     *  works roughly like a Call node in a pipeline. The called pipeline will get its own local pipeline dictionary. The
     *  dictionary can be populated with initial values from an argument object. Any results from the pipeline can be read
     *  from the pipeline dictionary that is returned by the <a href="class_dw_system_Pipeline.html#dw_system_Pipeline_execute_String_DetailAnchor">execute(String)</a> methods.
     *  <p>
     *  If an exception occurs during the pipeline processing, the Error-branch of the pipeline will be called. If no error
     *  handling exists for the pipeline, the exception will be propagated and can be handled by the script code.
     *  </p><p>
     *  If the pipeline finishes with an End node, the name of the end node can be obtained from the returned pipeline
     *  dictionary under the key &apos;EndNodeName&apos;.
     *  </p><p>
     *  Example:
     *
     *  </p><pre> let Pipeline = require(&apos;dw/system/Pipeline&apos;);
     *  let pdict = Pipeline.execute(&apos;MyPipeline-Start&apos;, {
     *      MyArgString:     &apos;someStringValue&apos;,
     *      MyArgNumber:     12345,
     *      MyArgBoolean:    true
     *  });
     *  let result = pdict.MyReturnValue;
     *  </pre>
     *
     *  This feature requires an API version &gt;=15.5.
     */
    class Pipeline {
      /**
       * Executes a pipeline.
       * @param pipeline the pipeline identifier, must consist of the pipeline name and the start node name, like 'PipelineName-StartNodeName'
       * @return the pipeline dictionary with the pipeline results
       */
      static execute(pipeline: string): dw.system.PipelineDictionary;
      /**
       * Executes a pipeline. The pipeline dictionary will be initialized with the provided arguments.
       * @param pipeline the pipeline identifier, must consist of a pipeline name and a start node name, like 'PipelineName-StartNodeName'
       * @param args an object whose properties represent the initial values of the pipeline dictionary
       * @return the pipeline dictionary with the pipeline results
       */
      static execute(pipeline: string, args: any): dw.system.PipelineDictionary;
    }

    /**
     * The class provides access to the values in the pipeline dictionary. You use
     *  dynamic properties to access values, such as pdict.myvalue or
     *  pdict[&apos;myvalue&apos;];
     *  <p>
     *  The class is used in two different contexts, one where access is limited to
     *  the declared input/output values and second to a context with full access.
     *  Inside scripts, the PipelineDictionary allows you to access declared in/out
     *  values (regardless of the alias used in the pipeline and the actual key under
     *  which the value is stored). In templates and pipelines, all values can be
     *  accessed. In templates the pipeline dictionary is exposed as variable pdict
     *  (e.g. ${pdict.Product.ID}).
     *  </p><p>
     *  There are several values that are automatically stored in the
     *  PipelineDictionary with each request. These include but are not limited to:
     *
     *  </p><ul>
     *  <li>CurrentSession</li>
     *  <li>CurrentRequest</li>
     *  <li>CurrentHttpParameterMap</li>
     *  <li>CurrentForms</li>
     *  <li>CurrentCustomer</li>
     *  <li>etc.</li>
     *  </ul>
     */
    class PipelineDictionary {
      /**
       * Returns the attribute with this name
       */
      [name: string]: any;
    }

    /**
     * Represents a request in Commerce Cloud Digital. Each pipeline dictionary contains a CurrentRequest object, which is of
     *  type dw.system.Request. Most requests are HTTP requests, so you can use this object to get information about the HTTP
     *  request, such as the HTTP headers. You can also get a list of cookies, if any, associated with the request. If the
     *  request is issued from a job, the request is not an HTTP request, so HTTP-related methods return null.
     */
    class Request {
      /**
       * The client id of the current OCAPI request. If this is not an OCAPI request 'null' is returned. For
       *  client ids owned by Commerce Cloud Digital an alias is returned.
       */
      readonly clientId: string;
      /**
       * All of the custom attributes associated with the request. The attributes are stored for the life time of
       *  the request.
       */
      readonly custom: RequestCustomAttributes;
      /**
       * The physical location for the current request, if available. The
       *  location is calculated based on the IP address of the request. Note, if
       *  the geolocation tracking feature is not enabled, this method always
       *  returns null.
       */
      geolocation: dw.util.Geolocation;
      /**
       * The Cookies object, which can be used to read cookies sent by the client. Use the method
       *  Response.addHttpCookie() to add a cookie to the outgoing response.
       */
      readonly httpCookies: dw.web.Cookies;
      /**
       * A Map containing all HTTP header values.
       */
      readonly httpHeaders: dw.util.Map<string, string>;
      /**
       * The host name or null if there is no host name.
       */
      readonly httpHost: string;
      /**
       * The locale or null if there is no associated locale.
       */
      readonly httpLocale: string;
      /**
       * The name of the HTTP method with which this request was made, for example, GET, POST, or PUT.
       */
      readonly httpMethod: string;
      /**
       * The parameter map that contains the HTTP parameters for the current request.
       */
      readonly httpParameterMap: dw.web.HttpParameterMap;
      /**
       * A Map containing the raw HTTP parameters sent to the server. The Map contains name/value pairs. Each name
       *  is a String and each value is a String array.
       */
      readonly httpParameters: dw.util.Map<string, Array<string>>;
      /**
       * The path.
       */
      readonly httpPath: string;
      /**
       * The HTTP protocol used for this request. Possible values are "http" or "https". If the current activity
       *  is not related to an HTTP request, for example, when the request is part of a job, this method returns null.
       */
      readonly httpProtocol: string;
      /**
       * The query string or null if there is no query string.
       */
      readonly httpQueryString: string;
      /**
       * The referer or null if there is no referer.
       */
      readonly httpReferer: string;
      /**
       * The remote address or null if no remote address is found.
       */
      readonly httpRemoteAddress: string;
      /**
       * Identifies if this request is an HTTP request. The method returns true, if the current processing is related to a
       *  HTTP request. For example during a job execution this flag is false.
       */
      readonly httpRequest: boolean;
      /**
       * Returns whether the HTTP communication is secure, which basically means that the communication happens via https.
       *  If the current activity is not related to an HTTP request the method returns false.
       */
      readonly httpSecure: boolean;
      /**
       * The complete URL of the request which was received at the server.
       *  This URL does not include SEO optimizations.
       */
      readonly httpURL: dw.web.URL;
      /**
       * The HTTP user agent or null if there is no user agent.
       */
      readonly httpUserAgent: string;
      /**
       * Returns true if the request represents a request for a remote include, false if it is a top-level request.
       */
      readonly includeRequest: boolean;
      /**
       * The locale of the current request. This locale is set by the system based on the information in the URL.
       *  It may be different from the locale returned by getHttpLocale(), which is the preferred locale sent by the user agent.
       */
      locale: string;
      /**
       * The OCAPI version of the current request. If this is not
       *  an OCAPI request, 'null' is returned.
       */
      readonly ocapiVersion: string;
      /**
       * The page meta data that are associated with the current request.
       */
      readonly pageMetaData: dw.web.PageMetaData;
      /**
       * The unique identifier of the current request. The unique id is helpful for debugging purpose, e.g. relate
       *  debug messages to a particular request.
       */
      readonly requestID: string;
      /**
       * The session associated with this request.
       */
      readonly session: dw.system.Session;
      /**
       * The form that was submitted by the client if the request represents a form submission.
       */
      readonly triggeredForm: dw.web.Form;
      /**
       * The form action that was triggered by the client if the request represents a form submission.
       */
      readonly triggeredFormAction: dw.web.FormAction;

      /**
       * Adds the specified cookie to the outgoing response. This method can be called multiple times to set more than one
       *  cookie. If a cookie with the same cookie name, domain and path is set multiple times for the same response, only
       *  the last set cookie with this name is send to the client. This method can be used to set, update or delete
       *  cookies at the client. If the cookie doesn't exist at the client, it is set initially. If a cookie with the same
       *  name, domain and path already exists at the client, it is updated. A cookie can be deleted at the client by
       *  submitting a cookie with the maxAge attribute set to 0 (see Cookie.setMaxAge()
       *   for more information).
       *
       *   Example, how a cookie can be deleted at the client:
       *  var cookie : Cookie = new Cookie("SomeName", "Simple Value");
       *  cookie.setMaxAge(0);
       *  request.addHttpCookie(cookie);
       * @param cookie a Cookie object
       */
      addHttpCookie(cookie: dw.web.Cookie): void;
      /**
       * Returns the client id of the current OCAPI request. If this is not an OCAPI request 'null' is returned. For
       *  client ids owned by Commerce Cloud Digital an alias is returned.
       *
       * @return a client id or alias in case of an OCAPI request, otherwise null.
       */
      getClientId(): string;
      /**
       * Returns all of the custom attributes associated with the request. The attributes are stored for the life time of
       *  the request.
       *
       * @return all of the custom attributes associated with the request.
       */
      getCustom(): RequestCustomAttributes;
      /**
       * Returns the physical location for the current request, if available. The
       *  location is calculated based on the IP address of the request. Note, if
       *  the geolocation tracking feature is not enabled, this method always
       *  returns null.
       *
       * @return The geolocation of the current request, or null if this is not available.
       */
      getGeolocation(): dw.util.Geolocation;
      /**
       * Returns the Cookies object, which can be used to read cookies sent by the client. Use the method
       *  Response.addHttpCookie() to add a cookie to the outgoing response.
       *
       * @return Cookies object or null if this is not an HTTP request
       */
      getHttpCookies(): dw.web.Cookies;
      /**
       * Returns a Map containing all HTTP header values.
       *
       * @return a Map containing all HTTP header values.
       */
      getHttpHeaders(): dw.util.Map<string, string>;
      /**
       * Returns the host name or null if there is no host name.
       *
       * @return the host name or null if there is no host name.
       */
      getHttpHost(): string;
      /**
       * Returns the locale or null if there is no associated locale.
       *
       * @return the locale or null.
       */
      getHttpLocale(): string;
      /**
       * Returns the name of the HTTP method with which this request was made, for example, GET, POST, or PUT.
       *
       * @return the HTTP method
       */
      getHttpMethod(): string;
      /**
       * Returns the parameter map that contains the HTTP parameters for the current request.
       *
       * @return the HTTP parameter map
       */
      getHttpParameterMap(): dw.web.HttpParameterMap;
      /**
       * Returns a Map containing the raw HTTP parameters sent to the server. The Map contains name/value pairs. Each name
       *  is a String and each value is a String array.
       *
       * @return a Map containing all the raw HTTP parameters send to the server.
       */
      getHttpParameters(): dw.util.Map<string, Array<string>>;
      /**
       * Returns the path.
       *
       * @return the path or null.
       */
      getHttpPath(): string;
      /**
       * Returns the HTTP protocol used for this request. Possible values are "http" or "https". If the current activity
       *  is not related to an HTTP request, for example, when the request is part of a job, this method returns null.
       *
       * @return "http", "https" or null
       */
      getHttpProtocol(): string;
      /**
       * Returns the query string or null if there is no query string.
       *
       * @return the query string or null.
       */
      getHttpQueryString(): string;
      /**
       * Returns the referer or null if there is no referer.
       *
       * @return the referer or null if there is no referer.
       */
      getHttpReferer(): string;
      /**
       * Returns the remote address or null if no remote address is found.
       *
       * @return the remote address or null if no remote address is found.
       */
      getHttpRemoteAddress(): string;
      /**
       * Returns the complete URL of the request which was received at the server.
       *  This URL does not include SEO optimizations.
       *
       * @return the URL as URL object
       */
      getHttpURL(): dw.web.URL;
      /**
       * Returns the HTTP user agent or null if there is no user agent.
       *
       * @return the HTTP user agent or null if there is no user agent.
       */
      getHttpUserAgent(): string;
      /**
       * Returns the locale of the current request. This locale is set by the system based on the information in the URL.
       *  It may be different from the locale returned by getHttpLocale(), which is the preferred locale sent by the user agent.
       *
       * @return the locale of the current request, like 'en_US'
       */
      getLocale(): string;
      /**
       * Returns the OCAPI version of the current request. If this is not
       *  an OCAPI request, 'null' is returned.
       *
       * @return OCAPI version of the current request
       */
      getOcapiVersion(): string;
      /**
       * Returns the page meta data that are associated with the current request.
       *
       * @return the page meta data object
       */
      getPageMetaData(): dw.web.PageMetaData;
      /**
       * Returns the unique identifier of the current request. The unique id is helpful for debugging purpose, e.g. relate
       *  debug messages to a particular request.
       *
       * @return the unique identifier of the current request.
       */
      getRequestID(): string;
      /**
       * Returns the session associated with this request.
       *
       * @return the session associated with this request.
       */
      getSession(): dw.system.Session;
      /**
       * Returns the form that was submitted by the client if the request represents a form submission.
       *
       * @return the form which was triggered
       */
      getTriggeredForm(): dw.web.Form;
      /**
       * Returns the form action that was triggered by the client if the request represents a form submission.
       *
       * @return the action of the form that was triggered
       */
      getTriggeredFormAction(): dw.web.FormAction;
      /**
       * Identifies if this request is an HTTP request. The method returns true, if the current processing is related to a
       *  HTTP request. For example during a job execution this flag is false.
       *
       * @return true if the current processing is related to a HTTP request, false otherwise.
       */
      isHttpRequest(): boolean;
      /**
       * Returns whether the HTTP communication is secure, which basically means that the communication happens via https.
       *  If the current activity is not related to an HTTP request the method returns false.
       *
       */
      isHttpSecure(): boolean;
      /**
       * Returns true if the request represents a request for a remote include, false if it is a top-level request.
       *
       */
      isIncludeRequest(): boolean;
      /**
       * Sets the physical location for the current request and remembers the new
       *  value for the duration of the user session. So any subsequent calls to
       *  getGeolocation() will return this value
       * @param geoLocation the geolocation object to use
       */
      setGeolocation(geoLocation: dw.util.Geolocation): void;
      /**
       * Sets the given locale for the request. The locale is only set if it is valid, if it is active and if it is
       *  allowed for the current site.
       * @param localeID the locale ID to be set, like 'en_US'
       * @return true, if the locale was successfully set, false otherwise
       */
      setLocale(localeID: string): boolean;
    }

    /**
     * This class represents all script hooks that can be registered to receive notifications about storefront requests.
     *  It contains the extension points (hook names), and the functions that are called by each extension point.
     *  A function must be defined inside a JavaScript source and must be exported.
     *  The script with the exported hook function must be located inside a site cartridge.
     *  Inside the site cartridge a &apos;package.json&apos; file with a &apos;hooks&apos; entry must exist.
     *  <p>
     *  </p><pre> &quot;hooks&quot;: &quot;./hooks.json&quot;
     *  </pre>
     *  <p></p>
     *  The hooks entry links to a json file, relative to the &apos;package.json&apos; file.
     *  This file lists all registered hooks inside the hooks property:
     *  <p>
     *  </p><pre> &quot;hooks&quot;: [
     *       {&quot;name&quot;: &quot;dw.system.request.onSession&quot;, &quot;script&quot;: &quot;./script.js&quot;},
     *       {&quot;name&quot;: &quot;dw.system.request.onRequest&quot;, &quot;script&quot;: &quot;./script.js&quot;},
     *  ]
     *  </pre>
     *  <p></p>
     *  A hook entry has a &apos;name&apos; and a &apos;script&apos; property.
     *  <ul>
     *  <li>The &apos;name&apos; contains the extension point, the hook name.</li>
     *  <li>The &apos;script&apos; contains the script relative to the hooks file, with the exported hook function.</li>
     *  </ul>
     */
    class RequestHooks {
      /**
       * The extension point name dw.system.request.onRequest.
       */
      static readonly extensionPointOnRequest = "dw.system.request.onRequest";
      /**
       * The extension point name dw.system.request.onSession.
       */
      static readonly extensionPointOnSession = "dw.system.request.onSession";

      /**
       * The function is called by extension point extensionPointOnRequest.
       *  It is called when a storefront request was received from the client.
       *
       * @return Status.OK for success.Status.ERROR for error.
       */
      onRequest(): dw.system.Status;
      /**
       * The function is called by extension point extensionPointOnSession.
       *  It is called when a new storefront session was started.
       *
       * @return Status.OK for success.Status.ERROR for error.
       */
      onSession(): dw.system.Status;
    }

    /**
     * Represents an HTTP response in Commerce Cloud Digital. An instance of this class is implicitly available within
     *  Digital script under the variable &quot;response&quot;. The Response object can be used to set cookies and specific HTTP
     *  headers, for directly accessing the output stream or for sending redirects.
     */
    class Response {
      /**
       * An allowed header name constant for Access-Control-Allow-Credentials
       */
      static readonly ACCESS_CONTROL_ALLOW_CREDENTIALS =
        "Access-Control-Allow-Credentials";
      /**
       * An allowed header name constant for Access-Control-Allow-Headers
       */
      static readonly ACCESS_CONTROL_ALLOW_HEADERS =
        "Access-Control-Allow-Headers";
      /**
       * An allowed header name constant for Access-Control-Allow-Methods
       */
      static readonly ACCESS_CONTROL_ALLOW_METHODS =
        "Access-Control-Allow-Methods";
      /**
       * An allowed header name constant for Access-Control-Allow-Origin
       */
      static readonly ACCESS_CONTROL_ALLOW_ORIGIN =
        "Access-Control-Allow-Origin";
      /**
       * An allowed header name constant for Access-Control-Expose-Headers
       */
      static readonly ACCESS_CONTROL_EXPOSE_HEADERS =
        "Access-Control-Expose-Headers";
      /**
       * An allowed header name constant for Allow
       */
      static readonly ALLOW = "Allow";
      /**
       * An allowed header name constant for Content-Disposition
       */
      static readonly CONTENT_DISPOSITION = "Content-Disposition";
      /**
       * An allowed header name constant for Content-Language
       */
      static readonly CONTENT_LANGUAGE = "Content-Language";
      /**
       * An allowed header name constant for Content-Location
       */
      static readonly CONTENT_LOCATION = "Content-Location";
      /**
       * An allowed header name constant for Content-MD5
       */
      static readonly CONTENT_MD5 = "Content-MD5";
      /**
       * An allowed header name constant for Content-Security-Policy
       */
      static readonly CONTENT_SECURITY_POLICY = "Content-Security-Policy";
      /**
       * An allowed header name constant for Content-Type
       */
      static readonly CONTENT_TYPE = "Content-Type";
      /**
       * An allowed header name constant for Location
       */
      static readonly LOCATION = "Location";
      /**
       * An allowed header name constant for Platform for Privacy Preferences Project
       */
      static readonly PLATFORM_FOR_PRIVACY_PREFERENCES_PROJECT = "P3P";
      /**
       * An allowed header name constant for Referrer-Policy
       */
      static readonly REFERRER_POLICY = "Referrer-Policy";
      /**
       * An allowed header name constant for Refresh
       */
      static readonly REFRESH = "Refresh";
      /**
       * An allowed header name constant for Retry-After
       */
      static readonly RETRY_AFTER = "Retry-After";
      /**
       * An allowed header name constant for Vary
       */
      static readonly VARY = "Vary";
      /**
       * An allowed header name constant for X-Content-Type-Options
       */
      static readonly X_CONTENT_TYPE_OPTIONS = "X-Content-Type-Options";
      /**
       * An allowed header name constant for X-FRAME-OPTIONS
       */
      static readonly X_FRAME_OPTIONS = "X-FRAME-OPTIONS";
      /**
       * An allowed value ALLOW-FROM for X-FRAME-OPTIONS
       */
      static readonly X_FRAME_OPTIONS_ALLOW_FROM = "ALLOW-FROM";
      /**
       * An allowed value DENY for X-FRAME-OPTIONS
       */
      static readonly X_FRAME_OPTIONS_DENY_VALUE = "DENY";
      /**
       * An allowed value SAME-ORIGIN value for X-FRAME-OPTIONS
       */
      static readonly X_FRAME_OPTIONS_SAMEORIGIN_VALUE = "SAMEORIGIN";
      /**
       * An allowed header name constant for X-Robots-Tag
       */
      static readonly X_ROBOTS_TAG = "X-Robots-Tag";
      /**
       * An allowed header name constant for X-XSS-Protection
       */
      static readonly X_XSS_PROTECTION = "X-XSS-Protection";

      /**
       * A print writer which can be used to print content directly to the response.
       */
      readonly writer: dw.io.PrintWriter;

      /**
       * Adds the specified cookie to the outgoing response. This method can be called multiple times to set more than one
       *  cookie. If a cookie with the same cookie name, domain and path is set multiple times for the same response, only
       *  the last set cookie with this name is sent to the client. This method can be used to set, update or delete
       *  cookies at the client. If the cookie doesn't exist at the client, it is set initially. If a cookie with the same
       *  name, domain and path already exists at the client, it is updated. A cookie can be deleted at the client by
       *  submitting a cookie with the maxAge attribute set to 0 (see Cookie.setMaxAge()
       *   for more information).
       *
       *   Example, how a cookie can be deleted at the client:
       *  var cookie : Cookie = new Cookie("SomeName", "Simple Value");
       *  cookie.setMaxAge(0);
       *  response.addHttpCookie(cookie);
       *
       *
       *  You can't set a cookie's SameSite attribute using the API. The server sets SameSite to None if either the
       *  developer sets the cookie's Secure flag or the global security preference Enforce HTTPS is enabled, in which case
       *  the Secure flag is also set. Otherwise, the server doesn't set the SameSite attribute and the browser uses its
       *  own default SameSite setting. The SameSite attribute is not sent with a cookie if the server detects that the
       *  client doesn't correctly interpret the attribute.
       * @param cookie a Cookie object
       */
      addHttpCookie(cookie: dw.web.Cookie): void;
      /**
       * Adds a response header with the given name and value. This method allows response headers to have multiple
       *  values.
       *
       *  For public headers, only the names listed in the "Constants" section are allowed. Custom header names must begin
       *  with the prefix "X-SF-CC-" and can contain only alphanumeric characters, dash, and underscore.
       * @param name the name to use for the response header.
       * @param value the value to use.
       */
      addHttpHeader(name: string, value: string): void;
      /**
       * Checks whether the response message header has a field with the specified name.
       * @param name the name to use.
       */
      containsHttpHeader(name: string): boolean;
      /**
       * Returns a print writer which can be used to print content directly to the response.
       *
       */
      getWriter(): dw.io.PrintWriter;
      /**
       * Sends a temporary redirect response (HTTP status 302) to the client for the specified redirect location URL.
       * @param url the URL object for the target location, must be not null
       */
      redirect(url: dw.web.URL): void;
      /**
       * Sends a redirect response with the given status to the client for the specified redirect location URL.
       * @param url the URL object with the redirect location, must be not null
       * @param status the status code for this redirect, must be 301, 302 or 307
       */
      redirect(url: dw.web.URL, status: number): void;
      /**
       * Sends a temporary redirect response (HTTP status 302) to the client for the specified redirect location URL. The
       *  target location must be a relative or an absolute URL.
       * @param location the target location as a string, must be not empty
       */
      redirect(location: string): void;
      /**
       * Sends a redirect response with the given status to the client for the specified redirect location URL.
       * @param location the redirect location, must be not empty
       * @param status the status code for this redirect, must be 301, 302 or 307
       */
      redirect(location: string, status: number): void;
      /**
       * Sends a redirect response with the given status to the client for the specified redirect location URL.
       * @param redirect the URLRedirect object with the location and status, must be not null
       */
      redirect(redirect: dw.web.URLRedirect): void;
      /**
       * Sets whether the output should be buffered or streamed directly to the client. By default, buffering is enabled.
       *  The mode can only be changed before anything has been written to the response. Switching buffering off and using
       *  streaming mode is recommended for sending large responses.
       * @param buffered if true, buffering is used, if false the response will be streamed
       */
      setBuffered(buffered: boolean): void;
      /**
       * Sets the content type for this response. This method may only be called before any output is written to the
       *  response.
       * @param contentType the MIME type of the content, like "text/html", "application/json" etc.
       */
      setContentType(contentType: string): void;
      /**
       * Sets the cache expiration time for the response. The response will only be cached if caching was not disabled
       *  previously. By default, responses are not cached. This method can be called multiple times during request
       *  processing. If caching is enabled, the lowest expiration time, resulting from the invocations of the method
       *  becomes the cache expiration time. This is only used for HTTP requests. Streamed responses cannot be cached. This
       *  method is an alternative for setting the cache time using the <iscache> tag in ISML templates.
       * @param expires the expiration time in milliseconds since January 1, 1970, 00:00:00 GMT
       */
      setExpires(expires: number): void;
      /**
       * Convenience method for setExpires(Number) which takes a Date object.
       * @param expires a Date object.
       */
      setExpires(expires: Date): void;
      /**
       * Adds a response header with the given name and value. If one or more value(s) have already been set, the new
       *  value overwrites the previous one. The containsHttpHeader(String) method can be used to test for the
       *  presence of a header before setting its value.
       *
       *  For public headers, only the names listed in the "Constants" section are allowed. Custom header names must begin
       *  with the prefix "X-SF-CC-" and can contain only alphanumeric characters, dash, and underscore.
       * @param name the name to use for the response header.
       * @param value the value to use.
       */
      setHttpHeader(name: string, value: string): void;
      /**
       * Sets the HTTP response code.
       * @param status a standard-conform HTTP status code, for example 200 for "OK"
       */
      setStatus(status: number): void;
      /**
       * Marks the response as personalized with the given variant identifier. Commerce Cloud Digital identifies unique
       *  pages based on a combination of pricebook, promotion, sorting rule and A/B test segments, caches the different
       *  variants of the page, and then delivers the correct version to the user. If a page is personalized by means other
       *  than pricebook, promotion, sorting rule and A/B test, the page must not be cached, because the wrong variants of
       *  the page would be delivered to the user. For performance reasons, a page should only be marked as personalized if
       *  it really is. Otherwise, the performance can unnecessarily degrade.
       *
       *  This method has the same effect as using <iscache varyby="price_promotion" /> tag in an ISML template. Once
       *  the vary-by value was set, either using this method or by the <iscache> tag in a template, the entire
       *  response is treated as personalized.
       * @param varyBy the variation criteria, currently only "price_promotion" is supported, any other value has no effect
       */
      setVaryBy(varyBy: string): void;
    }

    /**
     * Represents a session in Commerce Cloud Digital. The session has some well-defined
     *  attributes like the current authenticated customer or the click stream, but also
     *  supports storing custom values in the session.
     *
     *  The Digital session handling works in the following way:
     *  <ul>
     *  <li>
     *  A session is created in Digital on the first user click. This is guaranteed even if
     *  Commerce Cloud Digital caches the HTML pages. It is not guaranteed when the pages are cached by a CDN.
     *  </li>
     *  <li>
     *  A session is identified with a unique ID, called the session ID.
     *  </li>
     *  <li>
     *  When a session is created, the application server calls the pipeline OnSession-Start. It can
     *  be used to pre-initialize the session, before the actual request hits the server.
     *  </li>
     *  <li>
     *  Digital uses session stickiness and always routes requests within a single session to the same
     *  application server.
     *  </li>
     *  <li>
     *  Session data is also stored in a persistent location.
     *  </li>
     *  <li>
     *  In case of a fail-over situation, requests are re-routed to another application server, which then
     *  loads the session data from the persistent storage.
     *  </li>
     *  <li>
     *  There are two timeouts: a soft one when the session is not used anymore, and a
     *  hard one, which renders a session ID invalid if it is too old, regardless of whether
     *  it is still used. The soft timeout takes care of automatic logout and clearing
     *  all privacy data, but it is still possible to use the session ID to re-open
     *  the session. The hard timeout prevents a session from being reopened
     *  after a certain time. For example, if the session ID is accidentally pasted into a URL after
     *  the hard timeout, it will not reopen the session.
     *  </li>
     *  </ul>
     *
     *  Certain rules apply for what and how much data can be stored in a session:
     *  <ul>
     *  <li>
     *  All primitive types (boolean, number, string, Number, String, Boolean, Date) are supported.
     *  </li>
     *  <li>
     *  All Commerce Cloud Digital value types (Money, Quantity, Decimal, Calendar) are supported.
     *  </li>
     *  <li>
     *  Strings are limited to 2000 characters.
     *  </li>
     *  <li>
     *  No other types can be stored in a session. In particular, persistent objects,
     *  collections, and scripted objects cannot be stored in a session. Commerce Cloud Digital
     *  will report unsupported values with a deprecation message in the log files.
     *  An unsupported value will be stored in the session, but the results are undefined.
     *  Since version compatibility mode 19.10 unsupported types will no longer be accepted,
     *  and an exception will be thrown.
     *  </li>
     *  <li>
     *  There is a 4k size limit for the overall serialized session.
     *  </li>
     *  </ul>
     */
    class Session {
      /**
       * The current click stream if this is an HTTP session, null otherwise.
       */
      readonly clickStream: dw.web.ClickStream;
      /**
       * Get the currency associated with the current session. The session
       *  currency is established at session construction time and is typically
       *  equal to the site default currency. In the case of a multi-currency site,
       *  the session currency may be different than the site default currency.
       */
      currency: dw.util.Currency;
      /**
       * The session's custom attributes. The
       *  attributes are stored for the lifetime of the session and are not
       *  cleared when the customer logs out.
       */
      readonly custom: SessionCustomAttributes;
      /**
       * The customer associated with this storefront session. The method
       *  always returns null if called for a non-storefront session
       *  (e.g., within a job or within Business Manager). For a storefront
       *  session, the method always returns a customer. The returned customer
       *  may be anonymous if the customer could not be identified via the
       *  customer cookie.
       */
      readonly customer: dw.customer.Customer;
      /**
       * Identifies whether the customer associated with this session
       *  is authenticated. This call is equivalent to customer.isAuthenticated().
       */
      readonly customerAuthenticated: boolean;
      /**
       * Identifies whether the customer associated with this session
       *  is externally authenticated.
       */
      readonly customerExternallyAuthenticated: boolean;
      /**
       * The forms object that provides access to all current forms of a customer in the session.
       */
      readonly forms: dw.web.Forms;
      /**
       * Returns information on the last source code handled by the session.
       *  This may or may not be the session's active source code, e.g., the
       *  last received source code was inactive and therefore was not
       *  set as the session's active source code.
       */
      readonly lastReceivedSourceCodeInfo: dw.campaign.SourceCodeInfo;
      /**
       * The session's custom privacy attributes.
       *  The attributes are stored for the lifetime of the session and are
       *  automatically cleared when the customer logs out.
       */
      readonly privacy: dw.object.CustomAttributes;
      /**
       * The unique session id. This can safely be used as an identifier
       *  against external systems.
       */
      readonly sessionID: string;
      /**
       * Returns information on the session's active source-code.
       */
      readonly sourceCodeInfo: dw.campaign.SourceCodeInfo;
      /**
       * Returns whether the tracking allowed flag is set in the session.
       *  The value for newly created sessions defaults to the Site Preference "TrackingAllowed" unless
       *  a cookie named "dw_dnt" is found in which case the cookie value takes precedence.
       */
      trackingAllowed: boolean;
      /**
       * Identifies whether the agent user associated with this session
       *  is authenticated.
       */
      readonly userAuthenticated: boolean;
      /**
       * The current agent user name associated with this session.
       *
       *  Note: this class allows access to sensitive security-related data.
       *  Pay special attention to PCI DSS v3 requirements 2, 4, and 12.
       */
      readonly userName: string;

      /**
       * Returns the current click stream if this is an HTTP session, null otherwise.
       *
       * @return the current click stream if this is an HTTP session, null otherwise.
       */
      getClickStream(): dw.web.ClickStream;
      /**
       * Get the currency associated with the current session. The session
       *  currency is established at session construction time and is typically
       *  equal to the site default currency. In the case of a multi-currency site,
       *  the session currency may be different than the site default currency.
       *
       * @return the currency associated with this storefront session, never null.
       */
      getCurrency(): dw.util.Currency;
      /**
       * Returns the session's custom attributes. The
       *  attributes are stored for the lifetime of the session and are not
       *  cleared when the customer logs out.
       *
       * @return the session's custom attributes.
       */
      getCustom(): SessionCustomAttributes;
      /**
       * Returns the customer associated with this storefront session. The method
       *  always returns null if called for a non-storefront session
       *  (e.g., within a job or within Business Manager). For a storefront
       *  session, the method always returns a customer. The returned customer
       *  may be anonymous if the customer could not be identified via the
       *  customer cookie.
       *
       * @return the customer associated with this storefront session.
       */
      getCustomer(): dw.customer.Customer;
      /**
       * Returns the forms object that provides access to all current forms of a customer in the session.
       *
       * @return the forms.
       */
      getForms(): dw.web.Forms;
      /**
       * Returns information on the last source code handled by the session.
       *  This may or may not be the session's active source code, e.g., the
       *  last received source code was inactive and therefore was not
       *  set as the session's active source code.
       *
       * @return source code information for the last received source code.
       */
      getLastReceivedSourceCodeInfo(): dw.campaign.SourceCodeInfo;
      /**
       * Returns the session's custom privacy attributes.
       *  The attributes are stored for the lifetime of the session and are
       *  automatically cleared when the customer logs out.
       *
       * @return the session's custom privacy attributes.
       */
      getPrivacy(): dw.object.CustomAttributes;
      /**
       * Returns the unique session id. This can safely be used as an identifier
       *  against external systems.
       *
       * @return the unique identifier for the session.
       */
      getSessionID(): string;
      /**
       * Returns information on the session's active source-code.
       *
       * @return the session's source-code information.
       */
      getSourceCodeInfo(): dw.campaign.SourceCodeInfo;
      /**
       * Returns the current agent user name associated with this session.
       *
       *  Note: this class allows access to sensitive security-related data.
       *  Pay special attention to PCI DSS v3 requirements 2, 4, and 12.
       *
       * @return the current agent user name associated with this session.
       */
      getUserName(): string;
      /**
       * Identifies whether the customer associated with this session
       *  is authenticated. This call is equivalent to customer.isAuthenticated().
       *
       * @return true if the customer is authenticated, false otherwise.
       */
      isCustomerAuthenticated(): boolean;
      /**
       * Identifies whether the customer associated with this session
       *  is externally authenticated.
       *
       * @return true if the customer is authenticated, false otherwise.
       */
      isCustomerExternallyAuthenticated(): boolean;
      /**
       * Returns whether the tracking allowed flag is set in the session.
       *  The value for newly created sessions defaults to the Site Preference "TrackingAllowed" unless
       *  a cookie named "dw_dnt" is found in which case the cookie value takes precedence.
       *
       * @return true if the tracking allowed flag is set in the session, false otherwise.
       */
      isTrackingAllowed(): boolean;
      /**
       * Identifies whether the agent user associated with this session
       *  is authenticated.
       *
       * @return true if the agent user is authenticated, false otherwise.
       */
      isUserAuthenticated(): boolean;
      /**
       * Sets the session currency.
       * @param newCurrency the new currency to use. Must not be null. Method will throw an exception if a currency not allowed by the current site is passed.
       */
      setCurrency(newCurrency: dw.util.Currency): void;
      /**
       * Applies the specified source code to the current session and basket. This API processes the source code exactly as if it
       *  were supplied on the URL query string, with the additional benefit of returning error information. If no input
       *  parameter is passed, then the active source code in the session and basket is removed. If a basket exists, and the modification fails,
       *  then the session is not written to either. This method may open and commit a transaction, if none is currently active.
       * @param sourceCode the source code to set as active in the session and basket. If a null parameter is passed, then the active source code in the session is removed.
       * @return an OK status if the source code was applied, otherwise an ERROR status. In the latter case, the possible error codes are: CODE_INVALID and CODE_INACTIVE. See documentation for SourceCodeStatusCodes for further descriptions.
       */
      setSourceCode(sourceCode: string): dw.system.Status;
      /**
       * Sets the tracking allowed flag for the session. If tracking is not allowed, multiple services
       *  depending on tracking will be restricted or disabled: Predictive Intelligence recommendations,
       *  Active Data, Analytics of the customer behavior in the storefront.
       *  Additionally, collected clicks in the session click stream will be cleared.
       *  Setting this property to either value also results in setting a session-scoped cookie named "dw_dnt"
       *  (1=DoNotTrack; 0=Track)
       * @param trackingAllowed true if tracking is allowed, false otherwise.
       */
      setTrackingAllowed(trackingAllowed: boolean): void;
    }

    /**
     * This class represents a site in Commerce Cloud Digital and provides access to
     *  several site-level configuration values which are managed from within the
     *  Business Manager. It is only possible to get a reference to the current site
     *  as determined by the current request. The static method
     *  <a href="class_dw_system_Site.html#dw_system_Site_getCurrent_DetailAnchor">getCurrent()</a> returns a reference to the current site.
     */
    class Site {
      /**
       * Constant that represents the Site under maintenance/offline
       */
      static readonly SITE_STATUS_MAINTENANCE = 3;
      /**
       * Constant that represents the Site is Online
       */
      static readonly SITE_STATUS_ONLINE = 1;
      /**
       * Constant that represents the Site is in preview mode or online/password (protected)
       */
      static readonly SITE_STATUS_PROTECTED = 5;

      /**
       * The allowed currencies of the current site as a collection of
       *  currency codes.
       */
      readonly allowedCurrencies: dw.util.List<string>;
      /**
       * The allowed locales of the current site as a collection of
       *  locale ID's.
       */
      readonly allowedLocales: dw.util.List<string>;
      /**
       * All sites.
       */
      static readonly allSites: dw.util.List<dw.system.Site>;
      /**
       * A new Calendar object in the time zone of the
       *  current site.
       */
      static readonly calendar: dw.util.Calendar;
      /**
       * The default currency code for the current site.
       */
      readonly currencyCode: string;
      /**
       * The current site.
       */
      static readonly current: dw.system.Site;
      /**
       * The default currency code for the current site.
       */
      readonly defaultCurrency: string;
      /**
       * Return default locale for the site.
       */
      readonly defaultLocale: string;
      /**
       * The Einstein site Id. Typically this is a concatenation of the realm, underscore character and the site id.
       *  It can be overwritten by support users to help with realm moves to continue using the Einstein data from the old realm.
       *  Used when making calls to the Einstein APIs.
       */
      readonly einsteinSiteID: string;
      /**
       * The configured HTTP host name. If no host name
       *  is configured the method returns the instance hostname.
       */
      readonly httpHostName: string;
      /**
       * The configured HTTPS host name. If no host name
       *  is configured the method returns the HTTP host name or the instance hostname, if
       *  that is not configured as well.
       */
      readonly httpsHostName: string;
      /**
       * The ID of the site.
       */
      readonly ID: string;
      /**
       * A descriptive name for the site.
       */
      readonly name: string;
      /**
       * Whether oms is active in the current site. This depends on a general
       *  property which states whether oms is active for the server,
       *  and a site-dependent preference whether oms is available for the current site.
       */
      readonly OMSEnabled: boolean;
      /**
       * All page meta tags, defined for this instance for which content can be generated.
       *
       *  The meta tag content is generated based on the home page meta tag context and rules.
       *  The rules are obtained from the current repository domain.
       */
      readonly pageMetaTags: Array<dw.web.PageMetaTag>;
      /**
       * This method returns a container of all site preferences of this site.
       */
      readonly preferences: dw.system.SitePreferences;
      /**
       * The status of this site.
       *
       *  Possible values are SITE_STATUS_ONLINE, SITE_STATUS_MAINTENANCE, SITE_STATUS_PROTECTED
       */
      readonly status: number;
      /**
       * The code for the time zone in which the storefront is
       *  running.
       */
      readonly timezone: string;
      /**
       * Returns time zone offset in which the storefront is running.
       */
      readonly timezoneOffset: number;

      /**
       * Returns the allowed currencies of the current site as a collection of
       *  currency codes.
       *
       * @return Collection of allowed site currencies
       */
      getAllowedCurrencies(): dw.util.List<string>;
      /**
       * Returns the allowed locales of the current site as a collection of
       *  locale ID's.
       *
       * @return Collection if allowed site locales
       */
      getAllowedLocales(): dw.util.List<string>;
      /**
       * Returns all sites.
       *
       * @return all sites for the current instance
       */
      static getAllSites(): dw.util.List<dw.system.Site>;
      /**
       * Returns a new Calendar object in the time zone of the
       *  current site.
       *
       * @return the Calendar object in the time zone of the current site.
       */
      static getCalendar(): dw.util.Calendar;
      /**
       * Returns the default currency code for the current site.
       *
       * @return the default currency code for the current site.
       */
      getCurrencyCode(): string;
      /**
       * Returns the current site.
       *
       * @return the current site.
       */
      static getCurrent(): dw.system.Site;
      /**
       * Returns a custom preference value. If the preference does not exist the
       *  method returns null.  This method is simply a shortcut method for
       *  accessing the value for a custom attribute defined on the
       *  SitePreferences object.
       *
       *   // Method #1
       *  var mySitePrefValue1 : String =  dw.system.Site.getCurrent().
       *      getCustomPreferenceValue("mySitePref");
       *
       *  // Method #2
       *  var sitePrefs : SitePreferences = dw.system.Site.getCurrent().getPreferences();
       *  var mySitePrefValue2 : String = sitePrefs.getCustom()["mySitePref"];
       * @param name preference name.
       * @return the preference value, or null if there is no preference with the given name.
       */
      getCustomPreferenceValue(name: string): any;
      /**
       * Returns the default currency code for the current site.
       *
       * @return the default currency code for the current site.
       */
      getDefaultCurrency(): string;
      /**
       * Return default locale for the site.
       *
       * @return default locale for the site.
       */
      getDefaultLocale(): string;
      /**
       * Returns the Einstein site Id. Typically this is a concatenation of the realm, underscore character and the site id.
       *  It can be overwritten by support users to help with realm moves to continue using the Einstein data from the old realm.
       *  Used when making calls to the Einstein APIs.
       *
       * @return the Einstein site Id
       */
      getEinsteinSiteID(): string;
      /**
       * Returns the configured HTTP host name. If no host name
       *  is configured the method returns the instance hostname.
       *
       * @return the configured HTTP host name or if it is not set the instance hostname.
       */
      getHttpHostName(): string;
      /**
       * Returns the configured HTTPS host name. If no host name
       *  is configured the method returns the HTTP host name or the instance hostname, if
       *  that is not configured as well.
       *
       * @return the configured HTTPS host name or HTTP host name or the instance hostname.
       */
      getHttpsHostName(): string;
      /**
       * Returns the ID of the site.
       *
       * @return the ID of the site.
       */
      getID(): string;
      /**
       * Returns a descriptive name for the site.
       *
       * @return a descriptive name for the site.
       */
      getName(): string;
      /**
       * Returns the page meta tag for the specified id.
       *
       *  The meta tag content is generated based on the home page meta tag context and rule.
       *  The rule is obtained from the current repository domain.
       *
       *  Null will be returned if the meta tag is undefined on the current instance, or if no rule can be found for the
       *  current context, or if the rule resolves to an empty string.
       * @param id the ID to get the page meta tag for
       * @return page meta tag containing content generated based on rules
       */
      getPageMetaTag(id: string): dw.web.PageMetaTag;
      /**
       * Returns all page meta tags, defined for this instance for which content can be generated.
       *
       *  The meta tag content is generated based on the home page meta tag context and rules.
       *  The rules are obtained from the current repository domain.
       *
       * @return page meta tags defined for this instance, containing content generated based on rules
       */
      getPageMetaTags(): Array<dw.web.PageMetaTag>;
      /**
       * This method returns a container of all site preferences of this site.
       *
       * @return a preferences object containing all system and custom site preferences of this site
       */
      getPreferences(): dw.system.SitePreferences;
      /**
       * Returns the status of this site.
       *
       *  Possible values are SITE_STATUS_ONLINE, SITE_STATUS_MAINTENANCE, SITE_STATUS_PROTECTED
       *
       * @return Status of the this site.
       */
      getStatus(): number;
      /**
       * Returns the code for the time zone in which the storefront is
       *  running.
       *
       * @return time zone code in which the storefront is running.
       */
      getTimezone(): string;
      /**
       * Returns time zone offset in which the storefront is running.
       *
       * @return time zone offset in which the storefront is running.
       */
      getTimezoneOffset(): number;
      /**
       * Whether oms is active in the current site. This depends on a general
       *  property which states whether oms is active for the server,
       *  and a site-dependent preference whether oms is available for the current site.
       *
       * @return whether oms is active in the site
       */
      isOMSEnabled(): boolean;
      /**
       * The method sets a value for a custom preference. The type of the value
       *  must match with the declared type of the preference definition.
       * @param name name of the preference
       * @param value new value for the preference
       */
      setCustomPreferenceValue(name: string, value: any): void;
    }

    /**
     * SitePreferences is a container for custom site-level attributes. The object
     *  corresponds with system object type &quot;SitePreferences&quot;. It has no system
     *  attributes and exists only as a place for merchants to define custom
     *  attributes which need to be available for each site.
     *  <p>
     *  Logically there is only one SitePreferences instance per site. The instance
     *  is obtained by calling <a href="class_dw_system_Site.html#dw_system_Site_getPreferences_DetailAnchor">Site.getPreferences()</a>. Once an
     *  instance of the container is obtained, it is possible to read/write site
     *  preference values by using the usual syntax for
     *  <a href="class_dw_object_ExtensibleObject.html">ExtensibleObject</a> instances. For example:
     *
     *  </p><pre> var sitePrefs : SitePreferences = dw.system.Site.getCurrent().getPreferences();
     *  var mySitePrefValue : String = sitePrefs.getCustom()[&quot;mySitePref&quot;];
     *  </pre>
     *  <p>
     *  <b>Note:</b> this class allows access to sensitive security-related data.
     *  Pay special attention to PCI DSS v3. requirements 2, 4, and 12.
     *  </p><p>
     *  Commerce Cloud Digital defines many site-level preferences, relating to
     *  baskets, timezone, locales, customers, etc, which can be managed within the
     *  &quot;Site Preferences&quot; module of the Business Manager, but these preferences are
     *  not accessible through this object. (SourceCodeURLParameterName is the one
     *  exception to this rule.)</p>
     */
    class SitePreferences extends dw.object.ExtensibleObject {
      /**
       * The name of the source code url paremeter configured for the
       *  site.
       */
      readonly sourceCodeURLParameterName: string;

      /**
       * Returns the name of the source code url paremeter configured for the
       *  site.
       *
       * @return source code url parameter name
       */
      getSourceCodeURLParameterName(): string;
    }

    /**
     * A Status is used for communicating an API status code back to a client. A status
     *  consists of multiple StatusItem. Most often a Status contains only one StatusItem.
     *  For convenience, a message with parameters is formatted using standard
     *  formatting patterns. If you want to display locale-specific messages in your
     *  application, you should use the Status.getCode() as key for a resource bundle.
     */
    class Status {
      /**
       * The status code either of the first ERROR StatusItem or when there
       *  is no ERROR StatusITEM, the first StatusItem in the overall list.
       *
       *  The status code is the unique identifier for the message and can be used by
       *  client programs to check for a specific status and to generate a localized
       *  message.
       */
      readonly code: string;
      /**
       * The details either of the first ERROR StatusItem or when there
       *  is no ERROR StatusItem, the first StatusItem in the overall list.
       */
      readonly details: dw.util.Map<string, string>;
      /**
       * Checks if the status is an ERROR. The Status is an ERROR if one of the
       *  contained StatusItems is an ERROR.
       */
      readonly error: boolean;
      /**
       * status value to indicate an ERROR status
       */
      static ERROR: number;
      /**
       * All status items.
       */
      readonly items: dw.util.List<dw.system.StatusItem>;
      /**
       * The message either of the first ERROR StatusItem or when there
       *  is no ERROR StatusItem, the first StatusItem in the overall list.
       *
       *  Note: Custom code and client programs must not use this message to identify
       *  a specific status. The getCode() must be used for that purpose. The actual
       *  message can change from release to release.
       */
      readonly message: string;
      /**
       * status value to indicate an OK status
       */
      static OK: number;
      /**
       * The parameters either of the first ERROR StatusItem or when there
       *  is no ERROR StatusItem, the first StatusItem in the overall list.
       */
      readonly parameters: dw.util.List<string>;
      /**
       * The overall status. If all StatusItems are OK, the method returns
       *  OK. If one StatusItem is an ERROR it returns ERROR.
       */
      readonly status: number;

      /**
       * Creates a Status object with no StatusItems.
       *
       */
      constructor();
      /**
       * Creates a Status with a single StatusItem. The status is set to the given
       *  value.
       * @param status either OK or ERROR
       */
      constructor(status: number);
      /**
       * Creates a Status with a single StatusItem. The StatusItem is initialized
       *  with the given values.
       * @param status either OK or ERROR
       * @param code a string representing a more detailed status code, e.g. "IMPEX-120"
       */
      constructor(status: number, code: string);
      /**
       * Creates a Status with a single StatusItem. The StatusItem is initialized
       *  with the given values.
       * @param status either OK or ERROR
       * @param code a string representing a more detailed status code, e.g. "IMPEX-120".
       * @param message a default human readable message
       * @param parameters a list of parameters to construct a custom message
       */
      constructor(
        status: number,
        code: string,
        message: string,
        ...parameters: any[]
      );

      /**
       * Add detail information for the given key of the first ERROR StatusItem
       *  or when there is no ERROR StatusItem, the first StatusItem in the overall list.
       * @param key the key of the first ERROR StatusItem or the first StatusItem in the list.
       * @param value the detail value.
       */
      addDetail(key: string, value: any): void;
      /**
       * Adds an additional status item to this status instance.
       * @param item the status item to add.
       */
      addItem(item: dw.system.StatusItem): void;
      /**
       * Returns the status code either of the first ERROR StatusItem or when there
       *  is no ERROR StatusITEM, the first StatusItem in the overall list.
       *
       *  The status code is the unique identifier for the message and can be used by
       *  client programs to check for a specific status and to generate a localized
       *  message.
       *
       * @return the status code
       */
      getCode(): string;
      /**
       * Returns the detail value for the given key of the first ERROR StatusItem
       *  or when there is no ERROR StatusItem, the first StatusItem in the
       *  overall list.
       * @param key the key for the detail to return.
       * @return the detail value for the given key of the first ERROR StatusItem or when there is no ERROR StatusItem, the first StatusItem in the overall list.
       */
      getDetail(key: string): any;
      /**
       * Returns the details either of the first ERROR StatusItem or when there
       *  is no ERROR StatusItem, the first StatusItem in the overall list.
       *
       * @return the details either of the first ERROR StatusItem or when there is no ERROR StatusItem, the first StatusItem in the overall list.
       */
      getDetails(): dw.util.Map<string, string>;
      /**
       * Returns all status items.
       *
       * @return all status items.
       */
      getItems(): dw.util.List<dw.system.StatusItem>;
      /**
       * Returns the message either of the first ERROR StatusItem or when there
       *  is no ERROR StatusItem, the first StatusItem in the overall list.
       *
       *  Note: Custom code and client programs must not use this message to identify
       *  a specific status. The getCode() must be used for that purpose. The actual
       *  message can change from release to release.
       *
       * @return the message either of the first ERROR StatusItem or when there is no ERROR StatusItem, the first StatusItem in the overall list.
       */
      getMessage(): string;
      /**
       * Returns the parameters either of the first ERROR StatusItem or when there
       *  is no ERROR StatusItem, the first StatusItem in the overall list.
       *
       * @return the parameters either of the first ERROR StatusItem or when there is no ERROR StatusItem, the first StatusItem in the overall list.
       */
      getParameters(): dw.util.List<string>;
      /**
       * Returns the overall status. If all StatusItems are OK, the method returns
       *  OK. If one StatusItem is an ERROR it returns ERROR.
       *
       * @return either OK or ERROR
       */
      getStatus(): number;
      /**
       * Checks if the status is an ERROR. The Status is an ERROR if one of the
       *  contained StatusItems is an ERROR.
       *
       * @return true if status is an ERROR, false otherwise.
       */
      isError(): boolean;
    }

    /**
     * A StatusItem holds all the status information. Multi StatusItems are bundled
     *  together into a Status.
     */
    class StatusItem {
      /**
       * The status code is the unique identifier for the message and can be used by
       *  client programs to check for a specific status and to generate a localized
       *  message.
       */
      code: string;
      /**
       * The optional details for this StatusItem.
       */
      readonly details: dw.util.Map<string, string>;
      /**
       * Returns whether this Status Item represents and error.
       */
      readonly error: boolean;
      /**
       * The default human readable message for this Status.
       *
       *  Note: Custom code and client programs must not use this message to identify
       *  a specific status. The getCode() must be used for that purpose. The actual
       *  message can change from release to release.
       */
      message: string;
      /**
       * The parameters to construct a custom message.
       */
      parameters: dw.util.List<string>;
      /**
       * The status.
       */
      status: number;

      /**
       * Constructs a new OK StatusItem.
       *
       */
      constructor();
      /**
       * Constructs a new StatusItem with the given status.
       * @param status either Status.OK or Status.ERROR.
       */
      constructor(status: number);
      /**
       * Constructs a new StatusItem with the given status and code.
       * @param status either Status.OK or Status.ERROR.
       * @param code a string representing a more detailed status code, e.g. "IMPEX-120".
       */
      constructor(status: number, code: string);
      /**
       * Constructs a new StatusItem with the given values.
       * @param status Status.OK or Status.ERROR.
       * @param code a string representing a more detailed status code, e.g. "IMPEX-120".
       * @param message a default human readable message
       * @param parameters a list of parameters to construct a custom message
       */
      constructor(
        status: number,
        code: string,
        message: string,
        ...parameters: any[]
      );

      /**
       * Add an additional detail to this StatusItem.
       * @param key the key for the detail.
       * @param value the detail value.
       */
      addDetail(key: string, value: any): void;
      /**
       * The status code is the unique identifier for the message and can be used by
       *  client programs to check for a specific status and to generate a localized
       *  message.
       *
       * @return the status code.
       */
      getCode(): string;
      /**
       * Returns the optional details for this StatusItem.
       *
       * @return the optional details for this StatusItem.
       */
      getDetails(): dw.util.Map<string, string>;
      /**
       * Returns the default human readable message for this Status.
       *
       *  Note: Custom code and client programs must not use this message to identify
       *  a specific status. The getCode() must be used for that purpose. The actual
       *  message can change from release to release.
       *
       * @return the default human readable message for this Status.
       */
      getMessage(): string;
      /**
       * Returns the parameters to construct a custom message.
       *
       * @return the parameters to construct a custom message.
       */
      getParameters(): dw.util.List<string>;
      /**
       * Returns the status.
       *
       * @return either Status.OK or Status.ERROR.
       */
      getStatus(): number;
      /**
       * Returns whether this Status Item represents and error.
       *
       * @return true is this item represents an error, false otherwise.
       */
      isError(): boolean;
      /**
       * Method to set the status code.
       *  The status code is the unique identifier for the message and can be used by
       *  client programs to check for a specific status and to generate a localized
       *  message.
       * @param code the status code.
       */
      setCode(code: string): void;
      /**
       * Sets the default human readable message for this Status.
       * @param message the default human readable message for this Status.
       */
      setMessage(message: string): void;
      /**
       * Sets the parameters for a custom message.
       * @param parameters the parameters for a custom message.
       */
      setParameters(...parameters: any[]): void;
      /**
       * Set the status.
       * @param status either Status.OK or Status.ERROR.
       */
      setStatus(status: number): void;
    }

    /**
     * Represents the Commerce Cloud Digital server instance. An application server instance is configured to be of one of three types,
     *  &quot;development system&quot;, &quot;staging system&quot; or &quot;production system&quot;.
     */
    class System {
      /**
       * Represents the development system.
       */
      static readonly DEVELOPMENT_SYSTEM = 0;
      /**
       * Represents the production system.
       */
      static readonly PRODUCTION_SYSTEM = 2;
      /**
       * Represents the staging system.
       */
      static readonly STAGING_SYSTEM = 1;

      /**
       * A new Calendar object in the time zone of the
       *  current instance.
       */
      static readonly calendar: dw.util.Calendar;
      /**
       * The compatibility mode of the custom code version that is currently active. The compatibility mode is
       *  returned as a number, e.g. compatibility mode "15.5" is returned as 1505.
       */
      static readonly compatibilityMode: number;
      /**
       * Returns instance hostname.
       */
      static readonly instanceHostname: string;
      /**
       * The instance time zone. The instance time zone is the time zone in which global actions like jobs or
       *  reporting are specified in the system. Keep in mind that the instance time zone is cached at the current session.
       *  Changes will affect only new sessions.
       */
      static readonly instanceTimeZone: string;
      /**
       * The type of the instance. An application server instance is configured to be of one of three types,
       *  "development system", "staging system" or "production system".
       *  This method returns a constant representing the instance type of this
       *  application server.
       */
      static readonly instanceType: number;
      /**
       * This method returns a container of all global preferences of this
       *  organization (instance).
       */
      static readonly preferences: dw.system.OrganizationPreferences;

      /**
       * Returns a new Calendar object in the time zone of the
       *  current instance.
       *
       * @return a Calendar object in the time zone of the instance.
       */
      static getCalendar(): dw.util.Calendar;
      /**
       * Returns the compatibility mode of the custom code version that is currently active. The compatibility mode is
       *  returned as a number, e.g. compatibility mode "15.5" is returned as 1505.
       *
       * @return The currently active compatibility mode.
       */
      static getCompatibilityMode(): number;
      /**
       * Returns instance hostname.
       *
       * @return instance hostname.
       */
      static getInstanceHostname(): string;
      /**
       * Returns the instance time zone. The instance time zone is the time zone in which global actions like jobs or
       *  reporting are specified in the system. Keep in mind that the instance time zone is cached at the current session.
       *  Changes will affect only new sessions.
       *
       * @return the instance time zone.
       */
      static getInstanceTimeZone(): string;
      /**
       * Returns the type of the instance. An application server instance is configured to be of one of three types,
       *  "development system", "staging system" or "production system".
       *  This method returns a constant representing the instance type of this
       *  application server.
       *
       * @return the instance type of the application server where this method was called.
       */
      static getInstanceType(): number;
      /**
       * This method returns a container of all global preferences of this
       *  organization (instance).
       *
       * @return a preferences object containing all global system and custom preferences of this instance
       */
      static getPreferences(): dw.system.OrganizationPreferences;
    }

    /**
     * Represents the current transaction. A transaction provides a context for performing atomic changes to persistent
     *  business objects. Before a business object can be created, changed, or deleted, a transaction must be started using
     *  the <a href="class_dw_system_Transaction.html#dw_system_Transaction_begin_DetailAnchor">begin()</a> method. All changes on the touched business objects will only be made durable when the
     *  transaction is committed with <a href="class_dw_system_Transaction.html#dw_system_Transaction_commit_DetailAnchor">commit()</a>. Without commit, the changes will be lost again after the request was
     *  served. If a transaction is rolled back, all changes so far will be reverted and the business object will have their
     *  previous state again. It is possible to begin a transaction multiple times in a nested way (like
     *  begin-begin-commit-commit). In this case, in order to commit the changes the commit method must be called
     *  symmetrically as often as begin. It is also possible to run multiple transactions within a single request, one after
     *  another (like begin-commit-begin-commit). In case of any exception while working with business objects inside of a
     *  transaction, the transaction cannot be committed anymore, but only be rolled back. Business code may try to take
     *  appropriate actions if it expects business-related problems at commit (for example, constraint violations).
     *  <p>
     *  Example 1 - explicit control:
     *
     *  </p><pre> var txn = require(&apos;dw/system/Transaction&apos;);
     *  txn.begin();
     *  // work with business objects here
     *  txn.commit();
     *  </pre>
     *  <p>
     *  Example 2 - implicit control:
     *
     *  </p><pre> var txn = require(&apos;dw/system/Transaction&apos;);
     *  txn.wrap(function(){
     *      // work with business objects here
     *  });
     *  </pre>
     */
    class Transaction {
      /**
       * Begins a transaction.
       *
       */
      static begin(): void;
      /**
       * Commits the current transaction. The transaction must have been started with begin() before.
       *
       */
      static commit(): void;
      /**
       * Rolls back the current transaction. The transaction must have been started with begin() before.
       *
       */
      static rollback(): void;
      /**
       * Encloses the provided callback function in a begin-commit transactional context. If the transaction cannot be
       *  committed successfully, it is rolled back instead and an exception is thrown.
       * @param callback a function that should be executed within a transactional context
       * @return the result of the callback function, if it returns something
       */
      static wrap(callback: Function): any;
    }
  }

  namespace template {
    /**
     * This class provides support for rendering ISML templates. For more details about the ISML syntax, refer to the
     *  Commerce Cloud Digital developer documentation. Templates are stored as *.isml files. They are located in a
     *  locale-specific folder under the &apos;/cartridge/templates&apos; folder, with &apos;/cartridge/template/default&apos; being the default
     *  locale. The template name arguments of the various render methods represent the template path (without file ending)
     *  within this folder structure.
     *  <p>
     *  Example for rendering a template with arguments from JavaScript code:
     *
     *  </p><pre> let isml = require(&apos;dw/template/ISML&apos;);
     *  isml.renderTemplate(&apos;helloworld&apos;, {
     *      Message: &apos;Hello, World!&apos;
     *  });
     *  </pre>
     *
     *  Example code for accessing the template arguments in the &apos;helloworld.isml&apos; template from the above code snippet:
     *
     *  <pre> The message is: &lt;isprint value=&quot;${pdict.Message}&quot; /&gt;
     *  </pre>
     */
    class ISML {
      /**
       * Renders an ISML template and writes the output to the current response. The template may contain ISML tags which
       *  control the character encoding, content type, caching behavior and so on of the response (see ISML
       *  documentation).
       * @param template the template path
       */
      static renderTemplate(template: string): void;
      /**
       * Renders an ISML template and writes the output to the current response. The template may contain ISML tags which
       *  control the character encoding, content type, caching behavior and so on of the response (see ISML
       *  documentation). This method takes an additional JavaScript object as argument. Its properties are accessible for
       *  script expressions in the template under the "pdict.*" variable.
       * @param template the template path
       * @param templateArgs the template arguments object
       */
      static renderTemplate(template: string, templateArgs: any): void;
    }

    /**
     * This class renders an Apache Velocity template. For Velocity template syntax, see
     *  <a href="https://velocity.apache.org/engine/releases/velocity-1.7/" target="_blank">Velocity 1.7</a>.
     *  <p>
     *  The render() methods identify the template to render from:
     *  </p><ul>
     *  <li>a template file name, which is resolved in the Dynamic WebDAV file location for the current site.
     *  Template file names must end with either &apos;.vm&apos; or &apos;.vs&apos;.</li>
     *  <li>a dw.io.File object, which can point to any file system location that is accessible from a script</li>
     *  <li>a string that holds the template content directly</li></ul>
     *  <b>Note:</b> Files included from an ISML template (either via <code>#parse</code> or <code>#include</code>) are always resolved
     *  in the Dynamic location, and it is not possible to provide an absolute path.
     *
     *  <p>
     *  On the target side of rendering, by default the render() methods write to the current response writer. When needed,
     *  a <code>dw.io.Writer</code> can be supplied as a target.
     *  </p><p>
     *  Parameters for rendering can be passed as a single object holding the parameters as properties.
     *  </p><p>
     *  To create a URL, pass the <code>URLUtils</code> class.
     *  <br>
     *  To access localized strings, pass the <code>Resource</code> class:
     *  </p><pre><code>
     *  var urlUtil = require(&apos;dw/web/URLUtils&apos;);
     *  velocity.render(&quot;$url.abs(&apos;Foo-Bar&apos;,&apos;cgid&apos;,$res.msg(&apos;key&apos;)&quot;, {&apos;url&apos; : urlUtil, &apos;res&apos; : dw.web.Resource});
     *  </code></pre>
     *  The complete set of <a href="https://velocity.apache.org/tools/releases/2.0/generic.html" target="_blank">VelocityTools</a>
     *   are provided to the template. You can use the tools to escape dynamic data, format text, and for other common tasks.
     *  <p>
     *  Template files are cached for different amounts of time, depending on the instance type.
     *  </p><p></p>
     */
    class Velocity {
      /**
       * Includes the rendered content of the specified action URL, which usually is a pipeline or controller. Must only be used inside a Velocity
       *  template, such as $velocity.remoteInclude('Product-Show','sku','42')
       * @param action the URL (pipeline or controller) to be included
       * @param namesAndParams several strings with name=value pairs , e.g.: 'pid', 'value1', 'cgid', value2'.
       * @return the string that needs to be added to the Velocity template to execute the remote include
       */
      static remoteInclude(action: string, ...namesAndParams: string[]): string;
      /**
       * Renders an inline template to the response writer.
       * @param templateContent the template content
       * @param args the argument object
       */
      static render(templateContent: string, args: any): void;
      /**
       * Renders an inline template to the provided writer.
       * @param templateContent the template content
       * @param args the argument object
       * @param writer the target writer
       */
      static render(
        templateContent: string,
        args: any,
        writer: dw.io.Writer
      ): void;
      /**
       * Renders a template file to the response writer.
       * @param templateFileName the file name of the template, relative to the current sites Dynamic file location. For example, for a file at a location similar to: https://mydomain.com/on/demandware.servlet/webdav/Sites/Dynamic/SiteGenesis/myfile.vm render the file in this way:  velocity.renderTemplate("myfile.vm", null);
       * @param args the argument object
       */
      static renderTemplate(templateFileName: string, args: any): void;
      /**
       * Renders a template file to the provided writer.
       * @param templateFileName the file name of the template, relative to the current sites Dynamic file location. For example, for a file at a location similar to: https://mydomain.com/on/demandware.servlet/webdav/Sites/Dynamic/SiteGenesis/mydir/myfile.vm render the file in this way:  velocity.renderTemplate("mydir/myfile.vm", null, result);
       * @param args the argument object to pass to the template
       * @param writer the target writer
       */
      static renderTemplate(
        templateFileName: string,
        args: any,
        writer: dw.io.Writer
      ): void;
      /**
       * Renders a template file to the response writer.
       * @param templateFile the file object denoting the template
       * @param args the argument object
       */
      static renderTemplate(templateFile: dw.io.File, args: any): void;
      /**
       * Renders a template file to the provided writer.
       * @param templateFile the file object denoting the template
       * @param args the argument object
       * @param writer the target writer
       */
      static renderTemplate(
        templateFile: dw.io.File,
        args: any,
        writer: dw.io.Writer
      ): void;
    }
  }

  namespace util {
    /**
     * The ArrayList class is a container for a list of objects.
     */
    class ArrayList<T> extends dw.util.List<T> {
      /**
       * Constructor for a new ArrayList.
       *
       */
      constructor();
      /**
       * Constructor for a new ArrayList. The constructor initializes the
       *  ArrayList with the elements of the given collection.
       * @param collection the elements to insert into the list.
       */
      constructor(collection: dw.util.Collection<T>);
      /**
       * Constructor for a new ArrayList. The constructor initializes the
       *  ArrayList with the elements of the given iterator.
       * @param iterator the iterator that provides access to the elements to insert into the list.
       */
      constructor(iterator: dw.util.Iterator<T>);
      /**
       * Constructor for a new ArrayList. The constructor initializes the
       *  ArrayList with the arguments given as constructor parameters. The method
       *  can also be called with an ECMA array as argument.
       *
       *  If called with a single ECMA array as argument the individual elements of
       *  that array are used to initialize the ArrayList. To create an ArrayList
       *  with a single array as element, create an empty ArrayList and then call
       *  the method add1() on it.
       * @param values the set of objects to insert into the list.
       */
      constructor(...values: T[]);

      /**
       * Returns a shallow copy of this array list.
       *
       * @return a shallow copy of this array list.
       */
      clone(): dw.util.ArrayList<T>;
    }

    /**
     * The Assert class provides utility methods for assertion events.
     */
    class Assert {
      /**
       * Propagates an assertion
       *  if the specified objects are not equal.
       * @param arg1 the first object to check.
       * @param arg2 the second object to check.
       */
      static areEqual(arg1: any, arg2: any): void;
      /**
       * Propagates an assertion using the specified message
       *  if the specified objects are not equal.
       * @param arg1 the first object to check.
       * @param arg2 the second object to check.
       * @param msg the assertion message.
       */
      static areEqual(arg1: any, arg2: any, msg: string): void;
      /**
       * Propagates an assertion
       *  if the specified objects are not the same.
       * @param arg1 the first object to check.
       * @param arg2 the second object to check.
       */
      static areSame(arg1: any, arg2: any): void;
      /**
       * Propagates an assertion using the specified message
       *  if the specified objects are not the same.
       * @param arg1 the first object to check.
       * @param arg2 the second object to check.
       * @param msg the assertion message.
       */
      static areSame(arg1: any, arg2: any, msg: string): void;
      /**
       * Propagates a failure assertion.
       *
       */
      static fail(): void;
      /**
       * Propagates a failure assertion using the
       *  specified message.
       * @param msg the assertion message.
       */
      static fail(msg: string): void;
      /**
       * Propagates an assertion
       *  if the specified check does not evaluate to
       *  an empty object.
       * @param arg the object to check.
       */
      static isEmpty(arg: any): void;
      /**
       * Propagates an assertion using the specified message
       *  if the specified check does not evaluate to
       *  an empty object.
       * @param arg the object to check.
       * @param msg the assertion message.
       */
      static isEmpty(arg: any, msg: string): void;
      /**
       * Propagates an assertion if the
       *  specified check does not evaluate to false.
       * @param check the condition to check.
       */
      static isFalse(check: boolean): void;
      /**
       * Propagates an assertion using the specified message
       *  if the specified check does not evaluate to false.
       * @param check the condition to check.
       * @param msg the assertion message.
       */
      static isFalse(check: boolean, msg: string): void;
      /**
       * Propagates an assertion if the specified object 'arg' is not an instance
       *  of the specified class 'clazz'.
       *
       *  For example, the following call does not propagate an assertion:
       *
       *      var test = new dw.util.HashMap();
       *      dw.util.Assert.isInstanceOf(dw.util.HashMap, test);
       *
       *
       *
       *  But the following call will propagate an assertion:
       *
       *      var test = new dw.util.Set();
       *      dw.util.Assert.isInstanceOf(dw.util.HashMap, test);
       *
       *
       *
       *  Note that 'clazz' can only be a Demandware API Scripting class.
       * @param clazz the scripting class to use to check the object.
       * @param arg the object to check.
       */
      static isInstanceOf(clazz: any, arg: any): void;
      /**
       * Propagates an assertion using the specified message
       *  if the specified object is not an instance of the specified class.
       *
       *  For example, the following call does not propagate an assertion:
       *
       *      var test = new dw.util.HashMap();
       *      dw.util.Assert.isInstanceOf(dw.util.HashMap, test);
       *
       *
       *
       *  But the following call will propagate an assertion:
       *
       *      var test = new dw.util.Set();
       *      dw.util.Assert.isInstanceOf(dw.util.HashMap, test);
       *
       *
       *
       *  Note that 'clazz' can only be a Demandware API Scripting class.
       * @param clazz the scripting class to use to check the object.
       * @param arg the object to check.
       * @param msg the assertion message.
       */
      static isInstanceOf(clazz: any, arg: any, msg: string): void;
      /**
       * Propagates an assertion
       *  if the specified object is empty.
       * @param arg the object to check.
       */
      static isNotEmpty(arg: any): void;
      /**
       * Propagates an assertion using the specified message
       *  if the specified object is empty.
       * @param arg the object to check.
       * @param msg the assertion message.
       */
      static isNotEmpty(arg: any, msg: string): void;
      /**
       * Propagates an assertion if the
       *  specified object is null.
       * @param arg the object to check.
       */
      static isNotNull(arg: any): void;
      /**
       * Propagates an assertion using the specified message
       *  if the specified object is null.
       * @param arg the object to check.
       * @param msg the assertion message.
       */
      static isNotNull(arg: any, msg: string): void;
      /**
       * Propagates an assertion
       *  if the specified object is not null.
       * @param arg the object to check.
       */
      static isNull(arg: any): void;
      /**
       * Propagates an assertion using the specified message
       *  if the specified object is not null.
       * @param arg the object to check.
       * @param msg the assertion message.
       */
      static isNull(arg: any, msg: string): void;
      /**
       * Propagates an assertion if the
       *  specified check does not evaluate to true.
       * @param check the condition to check.
       */
      static isTrue(check: boolean): void;
      /**
       * Propagates an assertion using the specified message
       *  if the specified check does not evaluate to true.
       * @param check the condition to check.
       * @param msg the assertion message.
       */
      static isTrue(check: boolean, msg: string): void;
    }

    /**
     * The Integer class is a helper class to represent an arbitray long integer number.
     *  The Demandware framework doesn&apos;t use this class, but in some special cases
     *  web services that declare a XML element wird &quot;xsd:integer&quot;, which is by definition
     *  an arbitray long integer number, require the use of this class.
     *
     *  The class is designed in a way that it can be used very similar to a
     *  desktop calculator. For example:
     *
     *  <code>
     *  var i = new Integer( 10 );
     *  var result = d.add( 2 ).sub( 3 ).get();
     *  </code>
     *
     *  The above code will return 9 as result.
     */
    class BigInteger {
      /**
       * Constructs a new Integer with the value 0.
       *
       */
      constructor();
      /**
       * Constructs a new Integer using the specified Number value.
       * @param value the value to use.
       */
      constructor(value: number);
      /**
       * Constructs a new Integer using the specified string representation of
       *  a number.
       * @param value the value to use.
       */
      constructor(value: string);

      /**
       * Returns a new Integer with the absolute value of this Integer.
       *
       * @return the new Integer
       */
      abs(): dw.util.BigInteger;
      /**
       * Adds a Number value to this Integer and returns the new Integer.
       * @param value the value to add to this Integer.
       * @return the new Integer with the value added.
       */
      add(value: number): dw.util.BigInteger;
      /**
       * Adds an Integer value to this Integer and returns the new Integer.
       * @param value the value to add to this Integer.
       * @return the new Integer with the value added.
       */
      add(value: dw.util.BigInteger): dw.util.BigInteger;
      /**
       * Divides this Integer by the specified Integer and returns the new Integer.
       * @param value the value to use to divide this Integer.
       * @return the new Integer.
       */
      divide(value: number): dw.util.BigInteger;
      /**
       * Divides this Integer by the specified Integer and returns the new Integer.
       * @param value the value to use to divide this Integer.
       * @return the new Integer.
       */
      divide(value: dw.util.BigInteger): dw.util.BigInteger;
      /**
       * Compares two Integer values whether they are equivalent.
       * @param other the object to compare against this Integer.
       */
      equals(other: any): boolean;
      /**
       * Returns the value of the Integer as a Number.
       *
       * @return the value of the Integer.
       */
      get(): number;
      /**
       * Calculates the hash code for this Integer;
       *
       */
      hashCode(): number;
      /**
       * Multiples the specified Number value with this Integer and returns the new Integer.
       * @param value the value to multiply with this Integer.
       * @return the new Integer.
       */
      multiply(value: number): dw.util.BigInteger;
      /**
       * Multiples the specified Integer value with this Integer and returns the new Integer.
       * @param value the value to multiply with this Integer.
       * @return the new Integer.
       */
      multiply(value: dw.util.BigInteger): dw.util.BigInteger;
      /**
       * Returns a new Integer with the negated value of this Integer.
       *
       * @return the new Integer
       */
      negate(): dw.util.BigInteger;
      /**
       * Subtracts the specified Number value from this Integer and returns the new Integer.
       * @param value the value to add to this Integer.
       * @return the new Integer with the value subtraced.
       */
      subtract(value: number): dw.util.BigInteger;
      /**
       * Subtracts the specified Integer value from this Integer and returns the new Integer.
       * @param value the value to add to this Integer.
       * @return the new Integer with the value subtraced.
       */
      subtract(value: dw.util.BigInteger): dw.util.BigInteger;
      /**
       * Returns a string representation of this object.
       *
       * @return a string representation of this object.
       */
      toString(): string;
      /**
       * The valueOf() method is called by the ECMAScript interpret to return
       *  the "natural" value of an object. The Inetger object returns its
       *  current value as number. With this behavior script snippets can
       *  be written like:
       *
       *
       *  var i = new Integer( 10 );
       *  var x = 1 + d.add( 2 );
       *
       *
       *  where x will be at the end 13.
       *
       * @return the value of this object.
       */
      valueOf(): any;
    }

    /**
     * A simple immutable class representing an array of bytes, used for working
     *  with binary data in a scripting context.
     *
     *  <b>Limitation:</b>
     *  The size of the resulting byte representation is limited to 10k bytes.
     */
    class Bytes {
      /**
       * The maximum number of bytes that a Bytes object can represent == 10KB
       */
      static readonly MAX_BYTES = 10240;

      /**
       * The number of bytes represented by this object.
       */
      readonly length: number;

      /**
       * Construct a Bytes object from the given string using the default
       *  encoding. Convenience for Bytes( string, "UTF-8" ).
       * @param string The string to encode into a Bytes object, must not be null.
       */
      constructor(string: string);
      /**
       * Construct a Bytes object from the given string using the given encoding.
       *  This method always replaces malformed input and unmappable character
       *  sequences with encoding defaults.
       * @param string The string to encode into a Bytes object, must not be null.
       * @param encoding The name of a supported encoding, or null in which case the default encoding (UTF-8) is used.
       */
      constructor(string: string, encoding: string);

      /**
       * Returns the value of the byte at position index as an integer. If index
       *  is out of range an exception is thrown. The byte is interpreted as signed
       *  and so the value returned will always be between -128 and +127.
       * @param index The index of the byte.
       * @return The byte value at the specified index.
       */
      byteAt(index: number): number;
      /**
       * Return a new Bytes object containing the subsequence of this object's
       *  bytes specified by the index and length parameters.
       * @param index The initial index of the range to be copied, inclusive
       * @param length The number of bytes in the range to be copied.
       * @return a new Bytes object representing a subsequence of this Bytes object.
       */
      bytesAt(index: number, length: number): dw.util.Bytes;
      /**
       * Returns the number of bytes represented by this object.
       *
       * @return The number of bytes.
       */
      getLength(): number;
      /**
       * Absolute get method for reading a signed integer value (32 bit) in
       *  network byte order(= big endian).
       * @param index The byte index at which to read the number.
       * @return The read number.
       */
      intAt(index: number): number;
      /**
       * Return a new Bytes object which has the same bytes as this one in reverse
       *  order.
       *
       * @return a new Bytes object representing the reverse of this Bytes object.
       */
      reverse(): dw.util.Bytes;
      /**
       * Absolute get method for reading a signed short value (16 bit) in network
       *  byte order(= big endian).
       * @param index The byte index at which to read the number.
       * @return The read number.
       */
      shortAt(index: number): number;
      /**
       * Constructs a new String by decoding this array of bytes using the
       *  default encoding.  Convenience for toString( "UTF-8" ).
       *
       * @return A String representing the decoded array of bytes.
       */
      toString(): string;
      /**
       * Constructs a new String by decoding this array of bytes using the
       *  specified encoding.
       * @param encoding The name of a supported encoding.
       * @return A String representing the decoded array of bytes.
       */
      toString(encoding: string): string;
    }

    /**
     * Represents a Calendar and is based on the java.util.Calendar
     *  class. Refer to the java.util.Calendar documentation for
     *  more information.<br><br>
     *  <b>IMPORTANT NOTE:</b> Please use the <a href="class_dw_util_StringUtils.html#dw_util_StringUtils_formatCalendar_Calendar_DetailAnchor">StringUtils.formatCalendar(Calendar)</a>
     *  functions to convert a Calendar object into a String.
     */
    class Calendar {
      /**
       * Indicates whether the HOUR is before or after noon.
       */
      static readonly AM_PM = 9;
      /**
       * Value for the month of year field representing April.
       */
      static readonly APRIL = 3;
      /**
       * Value for the month of year field representing August.
       */
      static readonly AUGUST = 7;
      /**
       * Represents a date.
       */
      static readonly DATE = 5;
      /**
       * Represents a day of the month.
       */
      static readonly DAY_OF_MONTH = 5;
      /**
       * Represents a day of the week.
       */
      static readonly DAY_OF_WEEK = 7;
      /**
       * Represents a day of the week in a month.
       */
      static readonly DAY_OF_WEEK_IN_MONTH = 8;
      /**
       * Represents a day of the year.
       */
      static readonly DAY_OF_YEAR = 6;
      /**
       * Value for the month of year field representing December.
       */
      static readonly DECEMBER = 11;
      /**
       * Indicates the daylight savings offset in milliseconds.
       */
      static readonly DST_OFFSET = 16;
      /**
       * Indicates the era such as 'AD' or 'BC' in the Julian calendar.
       */
      static readonly ERA = 0;
      /**
       * Value for the month of year field representing February.
       */
      static readonly FEBRUARY = 1;
      /**
       * Value for the day of the week field representing Friday.
       */
      static readonly FRIDAY = 6;
      /**
       * Represents an hour.
       */
      static readonly HOUR = 10;
      /**
       * Represents an hour of the day.
       */
      static readonly HOUR_OF_DAY = 11;
      /**
       * The input date pattern, for instance MM/dd/yyyy
       */
      static readonly INPUT_DATE_PATTERN = 3;
      /**
       * The input date time pattern, for instance MM/dd/yyyy h:mm a
       */
      static readonly INPUT_DATE_TIME_PATTERN = 5;
      /**
       * The input time pattern, for instance h:mm a
       */
      static readonly INPUT_TIME_PATTERN = 4;
      /**
       * Value for the month of year field representing January.
       */
      static readonly JANUARY = 0;
      /**
       * Value for the month of year field representing July.
       */
      static readonly JULY = 6;
      /**
       * Value for the month of year field representing June.
       */
      static readonly JUNE = 5;
      /**
       * The long date pattern, for instance MMM/d/yyyy
       */
      static readonly LONG_DATE_PATTERN = 1;
      /**
       * Value for the month of year field representing March.
       */
      static readonly MARCH = 2;
      /**
       * Value for the month of year field representing May.
       */
      static readonly MAY = 4;
      /**
       * Represents a millisecond.
       */
      static readonly MILLISECOND = 14;
      /**
       * Represents a minute.
       */
      static readonly MINUTE = 12;
      /**
       * Value for the day of the week field representing Monday.
       */
      static readonly MONDAY = 2;
      /**
       * Represents a month where the first month of the year is 0.
       */
      static readonly MONTH = 2;
      /**
       * Value for the month of year field representing November.
       */
      static readonly NOVEMBER = 10;
      /**
       * Value for the month of year field representing October.
       */
      static readonly OCTOBER = 9;
      /**
       * Value for the day of the week field representing Saturday.
       */
      static readonly SATURDAY = 7;
      /**
       * Represents a second.
       */
      static readonly SECOND = 13;
      /**
       * Value for the month of year field representing September.
       */
      static readonly SEPTEMBER = 8;
      /**
       * The short date pattern, for instance M/d/yy
       */
      static readonly SHORT_DATE_PATTERN = 0;
      /**
       * Value for the day of the week field representing Sunday.
       */
      static readonly SUNDAY = 1;
      /**
       * Value for the day of the week field representing Thursday.
       */
      static readonly THURSDAY = 5;
      /**
       * The time pattern, for instance h:mm:ss a
       */
      static readonly TIME_PATTERN = 2;
      /**
       * Value for the day of the week field representing Tuesday.
       */
      static readonly TUESDAY = 3;
      /**
       * Value for the day of the week field representing Wednesday.
       */
      static readonly WEDNESDAY = 4;
      /**
       * Represents a week of the month.
       */
      static readonly WEEK_OF_MONTH = 4;
      /**
       * Represents a week in the year.
       */
      static readonly WEEK_OF_YEAR = 3;
      /**
       * Represents a year.
       */
      static readonly YEAR = 1;
      /**
       * Indicates the raw offset from GMT in milliseconds.
       */
      static readonly ZONE_OFFSET = 15;

      /**
       * The first day of the week base on locale context. For example, in the US
       *  the first day of the week is SUNDAY. However, in France the
       *  first day of the week is MONDAY.
       */
      firstDayOfWeek: number;
      /**
       * The current time stamp of this calendar. This method
       *  is also used to convert a Calendar into a Date.
       *
       *  WARNING: Keep in mind that the returned Date object's time is always
       *           interpreted in the time zone GMT. This means time zone information
       *           set at the calendar object will not be honored and gets lost.
       */
      time: Date;
      /**
       * The current time zone of this calendar.
       */
      timeZone: string;

      /**
       * Creates a new Calendar object that is set to the current
       *  time. The default time zone of the Calendar object is GMT.
       *
       *  WARNING: Keep in mind that the time stamp represented by the new calendar
       *           is always interpreted in the time zone GMT. This means time zone
       *           information at the calendar object needs to be set separately by
       *           using the setTimeZone(String) method.
       *
       */
      constructor();
      /**
       * Creates a new Calendar object for the given Date object. The time is set to
       *  the given Date object's time. The default time zone of the Calendar object is GMT.
       *
       *  WARNING: Keep in mind that the given Date object is always
       *           interpreted in the time zone GMT. This means time zone
       *           information at the calendar object needs to be set separately by
       *           using the setTimeZone(String) method.
       * @param date the date for which the calendar will be set.
       */
      constructor(date: Date);

      /**
       * Adds or subtracts the specified amount of time to the given
       *  calendar field, based on the calendar's rules.
       * @param field the calendar field.
       * @param value the amount of date or time to be added to the field
       */
      add(field: number, value: number): void;
      /**
       * Indicates if this Calendar represents a time after
       *  the time represented by the specified Object.
       * @param obj the object to test.
       * @return true if this Calendar represents a time after the time represented by the specified Object, false otherwise.
       */
      after(obj: any): boolean;
      /**
       * Indicates if this Calendar represents a time before
       *  the time represented by the specified Object.
       * @param obj the object to test.
       * @return true if this Calendar represents a time before the time represented by the specified Object, false otherwise.
       */
      before(obj: any): boolean;
      /**
       * Sets all the calendar field values and the time value
       *  (millisecond offset from the Epoch) of this Calendar undefined.
       *
       */
      clear(): void;
      /**
       * Sets the given calendar field value and the time value
       *  (millisecond offset from the Epoch) of this Calendar undefined.
       * @param field the calendar field to be cleared.
       */
      clear(field: number): void;
      /**
       * Compares the time values (millisecond offsets from the Epoch)
       *  represented by two Calendar objects.
       * @param anotherCalendar the Calendar to be compared.
       * @return the value 0 if the time represented by the argument is equal to the time represented by this Calendar; a value less than 0 if the time of this Calendar is before the time represented by the argument; and a value greater than 0 if the time of this Calendar is after the time represented by the argument.
       */
      compareTo(anotherCalendar: dw.util.Calendar): number;
      /**
       * Compares two calendar values whether they are equivalent.
       * @param other the object to compare against this calendar.
       */
      equals(other: any): boolean;
      /**
       * Returns the value of the given calendar field.
       * @param field the calendar field to retrieve.
       * @return the value for the given calendar field.
       */
      get(field: number): number;
      /**
       * Returns the maximum value that the specified calendar
       *  field could have.
       * @param field the calendar field.
       * @return the maximum value that the specified calendar field could have.
       */
      getActualMaximum(field: number): number;
      /**
       * Returns the minimum value that the specified calendar
       *  field could have.
       * @param field the calendar field.
       * @return the minimum value that the specified calendar field could have.
       */
      getActualMinimum(field: number): number;
      /**
       * Returns the first day of the week base on locale context. For example, in the US
       *  the first day of the week is SUNDAY. However, in France the
       *  first day of the week is MONDAY.
       *
       * @return the first day of the week base on locale context. For example, in the US the first day of the week is SUNDAY. However, in France the first day of the week is MONDAY.
       */
      getFirstDayOfWeek(): number;
      /**
       * Returns the maximum value for the given calendar
       *  field.
       * @param field the calendar field.
       * @return the maximum value for the given calendar field.
       */
      getMaximum(field: number): number;
      /**
       * Returns the minimum value for the given calendar
       *  field.
       * @param field the calendar field.
       * @return the minimum value for the given calendar field.
       */
      getMinimum(field: number): number;
      /**
       * Returns the current time stamp of this calendar. This method
       *  is also used to convert a Calendar into a Date.
       *
       *  WARNING: Keep in mind that the returned Date object's time is always
       *           interpreted in the time zone GMT. This means time zone information
       *           set at the calendar object will not be honored and gets lost.
       *
       * @return the current time stamp of this calendar as a Date.
       */
      getTime(): Date;
      /**
       * Returns the current time zone of this calendar.
       *
       * @return the current time zone of this calendar.
       */
      getTimeZone(): string;
      /**
       * Calculates the hash code for a calendar;
       *
       */
      hashCode(): number;
      /**
       * Indicates if the specified year is a leap year.
       * @param year the year to test.
       * @return true if the specified year is a leap year.
       */
      isLeapYear(year: number): boolean;
      /**
       * Checks, whether two calendar dates fall on the same day.
       *
       *  The method performs comparison based on both calendar's
       *  field values by honoring the defined time zones.
       *
       *
       *  Examples:
       *
       *  new Calendar( new Date( "2002/02/28 13:45" ).isSameDay( new Calendar( new Date( "2002/02/28 06:01" ) ) );
       *  would return true.
       *  new Calendar( new Date( "2002/02/28 13:45" ).isSameDay( new Calendar( new Date( "2002/02/12 13:45" ) ) );
       *  would return false.
       *  new Calendar( new Date( "2002/02/28 13:45" ).isSameDay( new Calendar( new Date( "1970/02/28 13:45" ) ) );
       *  would return false.
       *   var cal1 = new Calendar( new Date( "2002/02/28 02:00" );
       *  cal1.setTimeZone( "Etc/GMT+1" );
       *  var cal2 = new Calendar( new Date( "2002/02/28 00:00" );
       *  cal2.setTimeZone( "Etc/GMT+1" );
       *  cal1.isSameDay( cal2 );
       *  would return false since the time zone is applied first which results in comparing 2002/02/28 01:00 for cal1
       *  with 2002/02/27 23:00 for cal2.
       * @param other the calendar to compare against this calendar.
       */
      isSameDay(other: dw.util.Calendar): boolean;
      /**
       * Checks, whether two calendar dates fall on the same day.
       *
       *  The method performs comparison based on both calendar's
       *  time stamps by ignoring any defined time zones.
       *
       *
       *  Examples:
       *
       *  new Calendar( new Date( "2002/02/28 13:45" ).isSameDayByTimestamp( new Calendar( new Date( "2002/02/28 06:01" ) ) );
       *  would return true.
       *  new Calendar( new Date( "2002/02/28 13:45" ).isSameDayByTimestamp( new Calendar( new Date( "2002/02/12 13:45" ) ) );
       *  would return false.
       *  new Calendar( new Date( "2002/02/28 13:45" ).isSameDayByTimestamp( new Calendar( new Date( "1970/02/28 13:45" ) ) );
       *  would return false.
       *   var cal1 = new Calendar( new Date( "2002/02/28 02:00" );
       *  cal1.setTimeZone( "Etc/GMT+1" );
       *  var cal2 = new Calendar( new Date( "2002/02/28 00:00" );
       *  cal2.setTimeZone( "Etc/GMT+1" );
       *  cal1.isSameDayByTimestamp( cal2 );
       *  would return true since the time zone is not applied first which results in comparing 2002/02/28 02:00 for cal1
       *  with 2002/02/28 00:00 for cal2.
       * @param other the calendar to compare against this calendar.
       */
      isSameDayByTimestamp(other: dw.util.Calendar): boolean;
      /**
       * Indicates if the field is set.
       * @param field the field to test.
       * @return true if the field is set, false otherwise.
       */
      isSet(field: number): boolean;
      /**
       * Parses the string according to the date and time format pattern and set
       *  the time at this calendar object. For the specification of the date and
       *  time format pattern see the javadoc of the JDK class java.text.SimpleDateFormat.
       *  If a time zone is included in the format string,
       *  this time zone is used to interpet the time. Otherwise the currently set
       *  calendar time zone is used to parse the given time string.
       * @param timeString the time string to parsed
       * @param format the time format string
       */
      parseByFormat(timeString: string, format: string): void;
      /**
       * Parses the string according the date format pattern of the given locale.
       *  If the locale name is invalid, an exception is thrown. The currently set
       *  calendar time zone is used to parse the given time string.
       * @param timeString the time string to parsed
       * @param locale the locale id, which defines the date format pattern
       * @param pattern the pattern is one of calendar pattern e.g. SHORT_DATE_PATTERN as defined in the regional settings for the locale
       */
      parseByLocale(timeString: string, locale: string, pattern: number): void;
      /**
       * Rolls the specified field up or down one value.
       * @param field the field to roll.
       * @param up if true rolls the field up, if false rolls the field down.
       */
      roll(field: number, up: boolean): void;
      /**
       * Rolls the specified field using the specified value.
       * @param field the field to roll.
       * @param amount the amount to roll the field.
       */
      roll(field: number, amount: number): void;
      /**
       * Sets the given calendar field to the given value.
       * @param field the calendar field to set.
       * @param value the value to set in the field.
       */
      set(field: number, value: number): void;
      /**
       * Sets the values for the calendar fields YEAR, MONTH, and DAY_OF_MONTH.
       * @param year the value for year.
       * @param month the value for month.
       * @param date the value for date.
       */
      set(year: number, month: number, date: number): void;
      /**
       * Sets the values for the calendar fields YEAR, MONTH,
       *  DAY_OF_MONTH, HOUR_OF_DAY, and MINUTE.
       * @param year the value for year.
       * @param month the value for month.
       * @param date the value for date.
       * @param hourOfDay the value for hour of day.
       * @param minute the value for minute.
       */
      set(
        year: number,
        month: number,
        date: number,
        hourOfDay: number,
        minute: number
      ): void;
      /**
       * Sets the values for the calendar fields YEAR, MONTH,
       *  DAY_OF_MONTH, HOUR_OF_DAY, MINUTE and SECOND.
       * @param year the value for year.
       * @param month the value for month.
       * @param date the value for date.
       * @param hourOfDay the value for hour of day.
       * @param minute the value for minute.
       * @param second the value for second.
       */
      set(
        year: number,
        month: number,
        date: number,
        hourOfDay: number,
        minute: number,
        second: number
      ): void;
      /**
       * Sets what the first day of the week is.
       * @param value the day to set as the first day of the week.
       */
      setFirstDayOfWeek(value: number): void;
      /**
       * Sets the current time stamp of this calendar.
       *
       *  WARNING: Keep in mind that the set Date object's time is always
       *           interpreted in the time zone GMT. This means that time zone
       *           information at the calendar object needs to be set separately by
       *           using the setTimeZone(String) method.
       * @param date the current time stamp of this calendar.
       */
      setTime(date: Date): void;
      /**
       * Sets the current time zone of this calendar.
       *
       *  WARNING: Keep in mind that the time stamp represented by the calendar is
       *           always interpreted in the time zone GMT. Changing the time zone will not
       *           change the calendar's time stamp.
       * @param timeZone the current time zone value to set.
       */
      setTimeZone(timeZone: string): void;
    }

    /**
     * Represents a collection of objects.
     */
    class Collection<T> {
      /**
       * Returns true if the collection is empty.
       */
      readonly empty: boolean;
      /**
       * The length of the collection. This is similar to
       *  to a ECMA array of 'products.length'.
       */
      readonly length: number;

      /**
       * Adds the specified objects to the collection. The method can also
       *  be called with an ECMA array as argument.
       *
       *  If called with a single ECMA array as argument the individual elements of
       *  that array are added to the collection. If the array object itself should
       *  be added use the method add1().
       * @param values the values to add.
       * @return true if the values were added, false otherwise.
       */
      add(...values: T[]): boolean;
      /**
       * The method adds a single object to the collection.
       * @param object the object to add.
       * @return true if the object was added, false otherwise.
       */
      add1(object: T): boolean;
      /**
       * Adds the collection of objects to the collection.
       * @param objs the objects to add.
       * @return true if the objects were added, false otherwise.
       */
      addAll(objs: dw.util.Collection<T>): boolean;
      /**
       * Clears the collection.
       *
       */
      clear(): void;
      /**
       * Returns true if the collection contains the specified object.
       * @param obj the object to locate in this collection.
       * @return true if the collection contains the specified object, false otherwise.
       */
      contains(obj: T): boolean;
      /**
       * Returns true if the collection contains all of the objects
       *  in the specified collection.
       * @param objs the collection of objects to locate in this collection.
       * @return true if the collection contains all of the specified objects, false otherwise.
       */
      containsAll(objs: dw.util.Collection<T>): boolean;
      /**
       * Returns the length of the collection. This is similar to
       *  to a ECMA array of 'products.length'.
       *
       * @return the length of the collection.
       */
      getLength(): number;
      /**
       * Returns true if the collection is empty.
       *
       * @return true if the collection is empty, false otherwise
       */
      isEmpty(): boolean;
      /**
       * Returns an iterator that can be used to access
       *  the members of the collection.
       *
       * @return an iterator that can be used to access the members of the collection.
       */
      iterator(): dw.util.Iterator<T>;
      /**
       * Removes the specified object from the collection.
       * @param obj the object to remove.
       * @return true if the specified object was removed, false otherwise.
       */
      remove(obj: T): boolean;
      /**
       * Removes all of object in the specified object from the collection.
       * @param objs the collection of objects to remove.
       * @return true if the all of the specified objects were removed, false otherwise.
       */
      removeAll(objs: dw.util.Collection<T>): boolean;
      /**
       * Removes all of object in the collection that are not in the
       *  specified collection.
       * @param objs the collection of objects to retain in the collection.
       * @return true if the collection retains all of the specified objects, false otherwise.
       */
      retainAll(objs: dw.util.Collection<T>): boolean;
      /**
       * Returns the size of the collection.
       *
       * @return the size of the collection.
       */
      size(): number;
      /**
       * Returns all elements of this collection in a newly created array. The returned array is independent of this collection and
       *  can be modified without changing the collection. The elements in the array are in the same order as they are returned when
       *  iterating over this collection.
       *
       * @return a newly created array.
       */
      toArray(): Array<T>;
      /**
       * Returns a subset of the elements of this collection in a newly created array. The returned array is independent of this collection and
       *  can be modified without changing the collection. The elements in the array are in the same order as they are returned when
       *  iterating over this collection.
       * @param start the number of elements to iterate before adding elements to the array. Negative values are treated as 0.
       * @param size the maximum number of elements to add to the array. Nonpositive values always result in empty array.
       * @return a newly created array.
       */
      toArray(start: number, size: number): Array<T>;
    }

    /**
     * Represents a currency supported by the system.
     */
    class Currency {
      /**
       * Gets the ISO 4217 mnemonic currency code of this currency.
       */
      readonly currencyCode: string;
      /**
       * Gets the default number of fraction digits used with this currency.
       *  For example, the default number of fraction digits for the Euro is 2,
       *  while for the Japanese Yen it's 0.
       */
      readonly defaultFractionDigits: number;
      /**
       * Gets a long name for this currency. e.g. "United States Dollar".
       *  The returned name is the one stored in the system for this currency.
       *  Currently only English names are available, but in the future
       *  this method may return a locale-specific name.
       */
      readonly name: string;
      /**
       * Gets the symbol of this currency. e.g. "$" for the US Dollar.
       */
      readonly symbol: string;

      /**
       * Returns a Currency instance for the given currency code,
       *  or null if there is no such currency.
       * @param currencyCode the ISO 4217 mnemonic code of the currency.
       * @return the Currency instance for the given currency code.
       */
      static getCurrency(currencyCode: string): dw.util.Currency;
      /**
       * Gets the ISO 4217 mnemonic currency code of this currency.
       *
       * @return the ISO 4217 mnemonic currency code of this currency.
       */
      getCurrencyCode(): string;
      /**
       * Gets the default number of fraction digits used with this currency.
       *  For example, the default number of fraction digits for the Euro is 2,
       *  while for the Japanese Yen it's 0.
       *
       * @return the default number of fraction digits used with this currency.
       */
      getDefaultFractionDigits(): number;
      /**
       * Gets a long name for this currency. e.g. "United States Dollar".
       *  The returned name is the one stored in the system for this currency.
       *  Currently only English names are available, but in the future
       *  this method may return a locale-specific name.
       *
       * @return a long name for this currency. e.g. "United States Dollar".
       */
      getName(): string;
      /**
       * Gets the symbol of this currency. e.g. "$" for the US Dollar.
       *
       * @return the symbol of this currency.
       */
      getSymbol(): string;
      /**
       * Returns the ISO 4217 mnemonic currency code of this currency.
       *
       * @return the ISO 4217 mnemonic currency code of this currency.
       */
      toString(): string;
    }

    /**
     * A class with several utility methods for Date objects.
     */
    class DateUtils {
      /**
       * Returns the current time stamp in the time zone of the
       *  instance.
       *
       * @return the current time stamp in the time zone of the instance.
       */
      static nowForInstance(): Date;
      /**
       * Returns the current timestamp in the time zone of the
       *  current site.
       *
       * @return the current timestamp in the time zone of the current site.
       */
      static nowForSite(): Date;
      /**
       * Returns the current time stamp in UTC.
       *
       * @return the current time stamp in UTC.
       */
      static nowInUTC(): Date;
    }

    /**
     * The Decimal class is a helper class to perform decimal arithmetic in
     *  scripts and to represent a decimal number with arbitray length. The decimal
     *  class avoids arithmetic errors, which are typical for calculating with
     *  floating numbers, that are based on a binary mantissa.
     *
     *  The class is designed in a way that it can be used very similar to a
     *  desktop calculator.
     *
     *  <code>
     *  var d = new Decimal( 10.0 );
     *  var result = d.add( 2.0 ).sub( 3.0 ).get();
     *  </code>
     *
     *  The above code will return 9 as result.
     */
    class Decimal {
      /**
       * Constructs a new Decimal with the value 0.
       *
       */
      constructor();
      /**
       * Constructs a new decimal using the specified Number value.
       * @param value the value to use.
       */
      constructor(value: number);
      /**
       * Constructs a new Decimal using the specified string representation of
       *  a number.
       * @param value the value to use.
       */
      constructor(value: string);

      /**
       * Returns a new Decimal with the absolute value of this Decimal.
       *
       * @return the new Decimal
       */
      abs(): dw.util.Decimal;
      /**
       * Adds a Number value to this Decimal and returns the new Decimal.
       * @param value the value to add to this decimal.
       * @return the new decimal with the value added.
       */
      add(value: number): dw.util.Decimal;
      /**
       * Adds a Decimal value to this Decimal and returns the new Decimal.
       * @param value the value to add to this decimal.
       * @return the new decimal with the value added.
       */
      add(value: dw.util.Decimal): dw.util.Decimal;
      /**
       * Adds a percentage value to the current value of the
       *  decimal. For example a value of 10 represent 10% or a value of
       *  85 represents 85%.
       * @param value the value to add.
       * @return a new decimal with the added percentage value.
       */
      addPercent(value: number): dw.util.Decimal;
      /**
       * Adds a percentage value to the current value of the
       *  decimal. For example a value of 10 represent 10% or a value of
       *  85 represents 85%.
       * @param value the value to add.
       * @return a new decimal with the added percentage value.
       */
      addPercent(value: dw.util.Decimal): dw.util.Decimal;
      /**
       * Divides the specified Number value with this decimal and returns the new
       *  decimal.
       *
       *  When performing the division, 34 digits precision and a rounding mode of
       *  HALF_EVEN is used to prevent quotients with nonterminating decimal
       *  expansions.
       * @param value the value to use to divide this decimal.
       * @return the new decimal.
       */
      divide(value: number): dw.util.Decimal;
      /**
       * Divides the specified Decimal value with this decimal and returns the new
       *  decimal.
       *
       *  When performing the division, 34 digits precision and a rounding mode of
       *  HALF_EVEN is used to prevent quotients with nonterminating decimal
       *  expansions.
       * @param value the value to use to divide this decimal.
       * @return the new decimal.
       */
      divide(value: dw.util.Decimal): dw.util.Decimal;
      /**
       * Compares two decimal values whether they are equivalent.
       * @param other the object to comapre against this decimal.
       */
      equals(other: any): boolean;
      /**
       * Returns the value of the Decimal as a Number.
       *
       * @return the value of the Decimal.
       */
      get(): number;
      /**
       * Calculates the hash code for this decimal;
       *
       */
      hashCode(): number;
      /**
       * Multiples the specified Number value with this Decimal and returns the new Decimal.
       * @param value the value to multiply with this decimal.
       * @return the new decimal.
       */
      multiply(value: number): dw.util.Decimal;
      /**
       * Multiples the specified Decimal value with this Decimal and returns the new Decimal.
       * @param value the value to multiply with this decimal.
       * @return the new decimal.
       */
      multiply(value: dw.util.Decimal): dw.util.Decimal;
      /**
       * Returns a new Decimal with the negated value of this Decimal.
       *
       * @return the new Decimal
       */
      negate(): dw.util.Decimal;
      /**
       * Rounds the current value of the decimal using the specified
       *  number of decimals. The parameter
       *  specifies the number of digest after the decimal point.
       * @param decimals the number of decimals to use.
       * @return the decimal that has been rounded.
       */
      round(decimals: number): dw.util.Decimal;
      /**
       * Subtracts the specified Number value from this Decimal and returns the new Decimal.
       * @param value the value to add to this decimal.
       * @return the new decimal with the value subtraced.
       */
      subtract(value: number): dw.util.Decimal;
      /**
       * Subtracts the specified Decimal value from this Decimal and returns the new Decimal.
       * @param value the value to add to this decimal.
       * @return the new decimal with the value subtraced.
       */
      subtract(value: dw.util.Decimal): dw.util.Decimal;
      /**
       * Subtracts a percentage value from the current value of the
       *  decimal. For example a value of 10 represent 10% or a value of
       *  85 represents 85%.
       * @param value the value to subtract.
       * @return a new decimal with the subtracted percentage value.
       */
      subtractPercent(value: number): dw.util.Decimal;
      /**
       * Subtracts a percentage value from the current value of the
       *  decimal. For example a value of 10 represent 10% or a value of
       *  85 represents 85%.
       * @param value the value to subtract.
       * @return a new decimal with the subtracted percentage value.
       */
      subtractPercent(value: dw.util.Decimal): dw.util.Decimal;
      /**
       * Returns a string representation of this object.
       *
       * @return a string representation of this object.
       */
      toString(): string;
      /**
       * The valueOf() method is called by the ECMAScript interpret to return
       *  the "natural" value of an object. The Decimal object returns its
       *  current value as number. With this behavior script snippets can
       *  be written like:
       *
       *
       *  var d = new Decimal( 10.0 );
       *  var x = 1.0 + d.add( 2.0 );
       *
       *
       *  where x will be at the end 13.0.
       *
       * @return the value of this object.
       */
      valueOf(): any;
    }

    /**
     * <a href="class_dw_util_FilteringCollection.html">FilteringCollection</a> is an extension of
     *  <a href="class_dw_util_Collection.html">Collection</a> which provides possibilities to
     *
     *  <ul>
     *  <li><i>filter</i> the elements to return a new
     *  <a href="class_dw_util_FilteringCollection.html">FilteringCollection</a> with a filtered set of elements</li>
     *  <li><i>sort</i> the elements to return a new
     *  <a href="class_dw_util_FilteringCollection.html">FilteringCollection</a> with a defined sort order</li>
     *  <li><i>transform</i> the elements to return a new
     *  <a href="class_dw_util_FilteringCollection.html">FilteringCollection</a> containing related elements</li>
     *  <li><i>provide a map</i> of the elements against a predefined key</li>
     *  </ul>
     *
     *  <p>
     *  <b>Usage</b> - In the current version each
     *  <a href="class_dw_util_FilteringCollection.html">FilteringCollection</a> provides a set of predefined
     *  <i>qualifier</i> constants which can be passed into the
     *  <a href="class_dw_util_FilteringCollection.html#dw_util_FilteringCollection_select_Object_DetailAnchor">select(Object)</a> method used to <i>filter</i> the elements. Generally
     *  <i>qualifiers</i> have the prefix <i>QUALIFIER_</i>. A second method
     *  <a href="class_dw_util_FilteringCollection.html#dw_util_FilteringCollection_sort_Object_DetailAnchor">sort(Object)</a> is used to create a new instance with a different
     *  element ordering, which takes an <i>orderB&lt;</i> constant. Generally
     *  <i>orderBys</i> have the prefix ORDERBY_: examples are
     *  <a href="class_dw_order_ShippingOrder.html#dw_order_ShippingOrder_ORDERBY_ITEMID_DetailAnchor">ShippingOrder.ORDERBY_ITEMID</a>,
     *  <a href="class_dw_order_ShippingOrder.html#dw_order_ShippingOrder_ORDERBY_ITEMPOSITION_DetailAnchor">ShippingOrder.ORDERBY_ITEMPOSITION</a>, and <a href="class_dw_util_FilteringCollection.html#dw_util_FilteringCollection_ORDERBY_REVERSE_DetailAnchor">ORDERBY_REVERSE</a> can
     *  be used to provide a <a href="class_dw_util_FilteringCollection.html">FilteringCollection</a> with the reverse
     *  ordering. An example with method <a href="class_dw_order_ShippingOrder.html#dw_order_ShippingOrder_getItems_DetailAnchor">ShippingOrder.getItems()</a>:
     *
     *  <br>
     *  <code>
     *  <br>var allItems     : FilteringCollection = shippingOrder.items;
     *  <br>var productItems : FilteringCollection = allItems.select(ShippingOrder.QUALIFIER_PRODUCTITEMS);
     *  <br>var serviceItems : FilteringCollection = allItems.select(ShippingOrder.QUALIFIER_SERVICEITEMS);
     *  <br>var byPosition   : FilteringCollection = productItems.sort(ShippingOrder.ORDERBY_ITEMPOSITION);
     *  <br>var revByPosition: FilteringCollection = byPosition.sort(FilteringCollection.ORDERBY_REVERSE);
     *  <br>var mapByItemID  : Map = allItems.asMap();
     *  </code></p>
     */
    class FilteringCollection<T> extends dw.util.Collection<T> {
      /**
       * Pass this orderBy with the sort(Object) method to
       *  obtain a new FilteringCollection with the reversed sort
       *  order. Only use on a FilteringCollection which has been
       *  previously sorted.
       */
      static readonly ORDERBY_REVERSE: any;

      /**
       * Returns a Map containing the elements of this
       *  FilteringCollection against a predefined key. The key
       *  used is documented in the method returning the
       *  FilteringCollection and is typically the ItemID assigned
       *  to an element in the collection.
       *
       * @return a Map containing the elements of this FilteringCollection against a predefined key.
       */
      asMap(): dw.util.Map<any, any>;
      /**
       * Select a new FilteringCollection instance by passing a
       *  predefined qualifier as an argument to this method. See
       *  FilteringCollection.
       * @param qualifier - possible qualifiers are documented in the method returning the FilteringCollection
       * @return a new FilteringCollection instance
       */
      select(qualifier: T): dw.util.FilteringCollection<T>;
      /**
       * Select a new FilteringCollection instance by passing a
       *  predefined orderBy as an argument to this method. See
       *  FilteringCollection.
       * @param orderBy - possible orderBys are documented in the method returning the FilteringCollection
       * @return a new FilteringCollection instance
       */
      sort(orderBy: T): dw.util.FilteringCollection<T>;
    }

    /**
     * Read-only class representing a position on the earth (latitude and longitude)
     *  and information associated with that location (e.g. country, city, etc). The
     *  Commerce Cloud Digital system can provide geolocation information for a Request
     *  and this information can be used in customer group segmentation rules.
     *  <p>
     *  Note: This class is not related to the store locator API (i.e. the
     *  GetNearestStores pipelet) which uses a static set of store locations loaded
     *  into the system by the merchant.
     *  </p><p>
     *  This product includes GeoLite2 data created by MaxMind, available from <a href="http://www.maxmind.com">http://www.maxmind.com</a>.</p>
     */
    class Geolocation {
      /**
       * Returns 'true' if a valid GeoLocation was found for the IP address
       *  (meaning at least Latitude and Longitude were found), false otherwise.
       */
      readonly available: boolean;
      /**
       * Get the city name in English associated with this location.
       */
      readonly city: string;
      /**
       * Get the ISO country code associated with this location.
       */
      readonly countryCode: string;
      /**
       * Get the country name in English that the system associates with this location on the
       *  earth.
       */
      readonly countryName: string;
      /**
       * Get the latitude coordinate associated with this location which is a
       *  number between -90.0 and +90.0.
       */
      readonly latitude: number;
      /**
       * Get the longitude coordinate associated with this location which is a
       *  number between -180.0 and +180.0.
       */
      readonly longitude: number;
      /**
       * Get the metro code associated with this location.
       */
      readonly metroCode: string;
      /**
       * Get the postal code associated with this location.
       */
      readonly postalCode: string;
      /**
       * Get the region (e.g. province or state) code for this location.
       */
      readonly regionCode: string;
      /**
       * Get the region (e.g. province in state) name in English that the system
       *  associates with this location.
       */
      readonly regionName: string;

      /**
       * Constructor for a Geolocation object
       * @param countryCode the ISO country code associated with this location. The two-character ISO 3166-1 alpha code for the country.
       * @param countryName the country name in English that the system associates with this location on the earth.
       * @param regionCode the region (e.g. province or state) code for this location. This is a string up to three characters long containing the subdivision portion of the code.
       * @param regionName the region (e.g. province in state) name in English that the system associates with this location.
       * @param metroCode the metro code associated with this location. The metro code of the location if the location is in the US. See the  Google AdWords API for values
       * @param city the city name in English associated with this location.
       * @param postalCode the postal code associated with this location.
       * @param latitude the latitude coordinate associated with this location which is a number between -90.0 and +90.0.
       * @param longitude the longitude coordinate associated with this location which is a number between -180.0 and +180.0.
       */
      constructor(
        countryCode: string,
        countryName: string,
        regionCode: string,
        regionName: string,
        metroCode: string,
        city: string,
        postalCode: string,
        latitude: number,
        longitude: number
      );

      /**
       * Get the city name in English associated with this location.
       *
       * @return the city that the system associates with this location on the earth.
       */
      getCity(): string;
      /**
       * Get the ISO country code associated with this location.
       *
       * @return The two-character ISO 3166-1 alpha code for the country.
       */
      getCountryCode(): string;
      /**
       * Get the country name in English that the system associates with this location on the
       *  earth.
       *
       * @return the country name that the system associates with this location on the earth.
       */
      getCountryName(): string;
      /**
       * Get the latitude coordinate associated with this location which is a
       *  number between -90.0 and +90.0.
       *
       * @return The latitude of the location as a floating point number.
       */
      getLatitude(): number;
      /**
       * Get the longitude coordinate associated with this location which is a
       *  number between -180.0 and +180.0.
       *
       * @return The longitude of the location as a floating point number.
       */
      getLongitude(): number;
      /**
       * Get the metro code associated with this location.
       *
       * @return The metro code of the location if the location is in the US. See the Google AdWords API for returned values.
       */
      getMetroCode(): string;
      /**
       * Get the postal code associated with this location.
       *
       * @return The postal code of the location. Postal codes are not available for all countries. In some countries, this will only contain part of the postal code.
       */
      getPostalCode(): string;
      /**
       * Get the region (e.g. province or state) code for this location.
       *
       * @return This is a string up to three characters long containing the subdivision portion of the code.
       */
      getRegionCode(): string;
      /**
       * Get the region (e.g. province in state) name in English that the system
       *  associates with this location.
       *
       * @return the region name that the system associates with this location on the earth.
       */
      getRegionName(): string;
      /**
       * Returns 'true' if a valid GeoLocation was found for the IP address
       *  (meaning at least Latitude and Longitude were found), false otherwise.
       *
       * @return 'true' if a valid GeoLocation was found for the IP address (meaning at least Latitude and Longitude were found), false otherwise.
       */
      isAvailable(): boolean;
    }

    /**
     * Represents a hash map of objects.
     */
    class HashMap<K, V> extends dw.util.Map<any, any> {
      /**
       * Constructs a new HashMap.
       *
       */
      constructor();

      /**
       * Returns a shallow copy of this map.
       *
       * @return a shallow copy of this map.
       */
      clone(): dw.util.HashMap<K, V>;
    }

    /**
     * Represents a HashSet
     */
    class HashSet extends dw.util.Set<any> {
      /**
       * Constructs a new HashMap.
       *
       */
      constructor();
      /**
       * Construct a new HashSet by
       *  initializing the HashSet with the elements of the
       *  given collection.
       * @param collection the collection to add to the set.
       */
      constructor(collection: dw.util.Collection<any>);

      /**
       * Returns a shallow copy of this set.
       *
       * @return a shallow copy of this set.
       */
      clone(): dw.util.HashSet;
    }

    /**
     * The Iterator class allows you to access items in a collection.
     */
    class Iterator<T> {
      /**
       * Convert the iterator into a list. After this conversion the
       *  iterator is empty and hasNext() will always return false.
       *
       *  Note: This method should be used with care. For example a large database
       *  result is pulled into memory completely with this method and can cause
       *  an OutOfMemory situation.
       *
       * @return the iterator as a list.
       */
      asList(): dw.util.List<T>;
      /**
       * Converts a sub-sequence within the iterator into a list.
       *
       *  Note: This method should be used with care. For example a large database
       *  result is pulled into memory completely with this method and can cause
       *  an OutOfMemory situation.
       * @param start the number of elements to iterate before adding elements to the sublist. Negative values are treated as 0.
       * @param size the maximum number of elements to add to the sublist. Nonpositive values always result in empty list.
       * @return a sub-sequence within the iterator into a list.
       */
      asList(start: number, size: number): dw.util.List<T>;
      /**
       * Indicates if there are more elements.
       *
       * @return true if there are more elements, false otherwise.
       */
      hasNext(): boolean;
      /**
       * Returns the next element from the Iterator.
       *
       * @return the next element from the Iterator.
       */
      next(): T;
    }

    /**
     * This class implements a HashMap, which guarantees a iteration order
     *  according the put-order of the elements in the map.
     */
    class LinkedHashMap<K, V> extends dw.util.Map<any, any> {
      /**
       * Constructs a new LinkedHashMap.
       *
       */
      constructor();

      /**
       * Returns a shallow copy of this map.
       *
       * @return a shallow copy of this map.
       */
      clone(): dw.util.LinkedHashMap<K, V>;
    }

    /**
     * The class LinkedHashSet implements a hash set with a guaranteed iteration
     *  order. The elements are iterated in the order they have been added to the
     *  HashSet.
     */
    class LinkedHashSet<T> extends dw.util.Set<T> {
      /**
       * Constructs a new LinkHashSet.
       *
       */
      constructor();
      /**
       * Constructor for a new LinkedHashSet. The constructor
       *  initializes the LinkedHashSet with the elements of the
       *  given collection.
       * @param collection the collection of items to insert into this set.
       */
      constructor(collection: dw.util.Collection<T>);

      /**
       * Returns a shallow copy of this set.
       *
       * @return a shallow copy of this set.
       */
      clone(): dw.util.LinkedHashSet<T>;
    }

    /**
     * An ordered collection of objects. The user of a List has precise control over
     *  where in the list each element is inserted. The user can access elements by
     *  their integer index (position in the list), and search for elements in the
     *  list. Lists are zero based similar to arrays. Unlike sets, lists allow
     *  duplicate elements.
     */
    class List<T> extends dw.util.Collection<T> {
      /**
       * Convenience variable, for an empty and immutable list.
       */
      static EMPTY_LIST: dw.util.List<any>;

      /**
       * Adds the specified object into the list at the specified index.
       * @param index the index to use.
       * @param value the object to insert.
       */
      addAt(index: number, value: T): void;
      /**
       * Creates and returns a new List that is the result of concatenating this
       *  list with each of the specified values. This list itself is unmodified.
       *  If any of the specified values is itself an array or a Collection, then
       *  the elements of that Collection or array are appended to the new list
       *  rather than the object itself.
       * @param values one or more objects to concatenate.
       * @return a new List that is the result of concatenating this list with each of the specified values.
       */
      concat(...values: T[]): dw.util.List<T>;
      /**
       * Replaces all of the elements in the list with the given object.
       * @param obj the object to use during replacement.
       */
      fill(obj: T): void;
      /**
       * Returns the object at the specified index.
       * @param index the index to use.
       * @return the object at the specified index.
       */
      get(index: number): T;
      /**
       * Returns the index of the first occurrence of the specified element in
       *  this list, or -1 if this list does not contain the element.
       * @param value the element to use.
       * @return the index of the specified object or -1 if the passed object is not found in the list.
       */
      indexOf(value: T): number;
      /**
       * Converts all elements of the list to a string by calling the toString()
       *  method and then concatenates them together, with a comma between
       *  elements.
       *
       * @return The string that results from converting each element of the list to a string and then concatenating them together, with a comma between elements.
       */
      join(): string;
      /**
       * Converts all elements of the list to a string by calling the toString()
       *  method and then concatenates them together, with the separator string
       *  between elements. If null is passed, then the comma character is used as
       *  a separator.
       * @param separator The separator string. May be null in which case the comma character is used.
       * @return The string that results from converting each element of the list to a string and then concatenating them together, with the separator string between elements.
       */
      join(separator: string): string;
      /**
       * Returns the index of the last occurrence of the specified element in this
       *  list, or -1 if this list does not contain the element.
       * @param value the element to use.
       * @return the last index of the specified object or -1 if the passed object is not found in the list.
       */
      lastIndexOf(value: T): number;
      /**
       * Removes and returns the last element from the list.
       *
       * @return The last element of the list or null if the list is already empty.
       */
      pop(): T;
      /**
       * Appends the specified values to the end of the list in order.
       * @param values One or more values to be appended to the end of the list.
       * @return The new length of the list, after the specified values are appended to it.
       */
      push(...values: T[]): number;
      /**
       * Removes the object at the specified index.
       * @param index the index to use.
       * @return the object that was removed.
       */
      removeAt(index: number): T;
      /**
       * Replaces all occurrences of oldValue with newValue.
       * @param oldValue the old object.
       * @param newValue the new object.
       * @return true if one or more elements were replaced, false otherwise.
       */
      replaceAll(oldValue: T, newValue: T): boolean;
      /**
       * Reverses the order of the elements in the list.
       *
       */
      reverse(): void;
      /**
       * Rotates the elements in the list by the specified distance.
       * @param distance the distance to use.
       */
      rotate(distance: number): void;
      /**
       * Replaces the object at the specified index in this list with the specified object.
       * @param index the index to use.
       * @param value the object to use when replacing the existing object.
       * @return the replaced object.
       */
      set(index: number, value: T): T;
      /**
       * Removes and returns the first element of the list. If the list is already
       *  empty, this method simply returns null.
       *
       * @return The former first element of the list, or null is list is already empty.
       */
      shift(): T;
      /**
       * Randomly permutes the elements in the list.
       *
       */
      shuffle(): void;
      /**
       * Returns the size of this list.
       *
       * @return the size of this list.
       */
      size(): number;
      /**
       * Returns a slice, or sublist, of this list. The returned list contains the
       *  element specified by from and all subsequent elements up to
       *  the end of this list.
       * @param from The index at which the slice is to begin. If negative, this argument specifies a position measured from the end of this list. That, -1 indicates the last element, -2 indicates the next from the last element, and so on.
       * @return A new List that contains the elements of this list from the element specified by from up to the end of this list.
       */
      slice(from: number): dw.util.List<T>;
      /**
       * Returns a slice, or sublist, of this list. The returned list contains the
       *  element specified by from and all subsequent elements up to,
       *  but not including, the element specified by to.
       * @param from The index at which the slice is to begin. If negative, this argument specifies a position measured from the end of this list. That, -1 indicates the last element, -2 indicates the next from the last element, and so on.
       * @param to The index immediately after the end of the slice. If this argument is negative, it specifies an element measured from the end of this list.
       * @return A new List that contains the elements of this list from the element specified by from up to, but not including, the element specified by to.
       */
      slice(from: number, to: number): dw.util.List<T>;
      /**
       * Sorts the elements of the list based on their natural
       *  order.
       *
       *  This sort is guaranteed to be stable:  equal elements will
       *  not be reordered as a result of the sort.
       *
       */
      sort(): void;
      /**
       * Sorts the elements of a list. The order of the elements is
       *  determined with a comparator (see PropertyComparator) or with the help
       *  of the given function. The function must take two parameters and return
       *  a value <0 if the first parameter is smaller than the second, a value
       *  of 0 if both are equal and a value if >0 if the first one is greater
       *  than the second parameter.
       *
       *  This sort is guaranteed to be stable:  equal elements will
       *  not be reordered as a result of the sort.
       * @param comparator an instance of a PropertyComparator or a comparison function
       */
      sort(comparator: T): void;
      /**
       * Returns a list containing the elements in this list identified
       *  by the specified arguments.
       * @param from the beginning index of the elements to move to the new list.
       * @param to the ending index of the elements to move to the new list.
       * @return the new list containing the elements.
       */
      subList(from: number, to: number): dw.util.List<T>;
      /**
       * Swaps the elements at the specified positions in the list.
       * @param i the first element to swap.
       * @param j the second element to swap.
       */
      swap(i: number, j: number): void;
      /**
       * Inserts values at the beginning of the list.  The first argument
       *  becomes the new element 0;  the second argument becomes element 1;
       *  and so on.
       * @param values The values to insert into the list.
       * @return The new length of the lest.
       */
      unshift(...values: T[]): number;
    }

    /**
     * Represents a <code>Locale</code> supported by the system.
     */
    class Locale {
      /**
       * The country/region code for this Locale, which will
       *  either be the empty string or an upercase ISO 3166 2-letter code.
       */
      readonly country: string;
      /**
       * A name for the Locale's country that is appropriate for
       *  display to the user, or an empty string if no country has been specified
       *  for the Locale.
       *  The display country is returned in the language defined for this locale,
       *  and not in the language of the session locale.
       */
      readonly displayCountry: string;
      /**
       * A name for the Locale's language that is appropriate for
       *  display to the user, or an empty string if no language has been specified
       *  for the Locale.
       *  The display language is returned in the language defined for this locale,
       *  and not in the language of the session locale.
       */
      readonly displayLanguage: string;
      /**
       * A name for the Locale that is appropriate for
       *  display to the user, or an empty string if no display name has been
       *  specified for the Locale.
       *  The display name is returned in the language defined for this locale,
       *  and not in the language of the session locale.
       */
      readonly displayName: string;
      /**
       * The String representation of the 'localeID'.
       *
       *
       *  The identifier of the Locale. Contains a combination of the
       *  language and the country key, concatenated by "_", e.g. "en_US". This
       *  attribute is the primary key of the class.
       */
      readonly ID: string;
      /**
       * A three-letter abbreviation for this Locale's country, or an
       *  empty string if no country has been specified for the Locale
       *  .
       */
      readonly ISO3Country: string;
      /**
       * A three-letter abbreviation for this Locale's language, or an
       *  empty string if no language has been specified for the
       *  Locale.
       */
      readonly ISO3Language: string;
      /**
       * The language code for this Locale, which will either
       *  be the empty string or a lowercase ISO 639 code.
       */
      readonly language: string;

      /**
       * Returns the country/region code for this Locale, which will
       *  either be the empty string or an upercase ISO 3166 2-letter code.
       *
       * @return the country/region code for this Locale, which will either be the empty string or an upercase ISO 3166 2-letter code.
       */
      getCountry(): string;
      /**
       * Returns a name for the Locale's country that is appropriate for
       *  display to the user, or an empty string if no country has been specified
       *  for the Locale.
       *  The display country is returned in the language defined for this locale,
       *  and not in the language of the session locale.
       *
       * @return a name for the Locale's country that is appropriate for display to the user, or an empty string if no country has been specified for the Locale.
       */
      getDisplayCountry(): string;
      /**
       * Returns a name for the Locale's language that is appropriate for
       *  display to the user, or an empty string if no language has been specified
       *  for the Locale.
       *  The display language is returned in the language defined for this locale,
       *  and not in the language of the session locale.
       *
       * @return a name for the Locale's language that is appropriate for display to the user, or an empty string if no language has been specified for the Locale.
       */
      getDisplayLanguage(): string;
      /**
       * Returns a name for the Locale that is appropriate for
       *  display to the user, or an empty string if no display name has been
       *  specified for the Locale.
       *  The display name is returned in the language defined for this locale,
       *  and not in the language of the session locale.
       *
       * @return a name for the Localethat is appropriate for display to the user, or an empty string if no display name has been specified for the Locale.
       */
      getDisplayName(): string;
      /**
       * Returns the String representation of the 'localeID'.
       *
       *
       *  The identifier of the Locale. Contains a combination of the
       *  language and the country key, concatenated by "_", e.g. "en_US". This
       *  attribute is the primary key of the class.
       *
       * @return the String representation of the 'localeID'.
       */
      getID(): string;
      /**
       * Returns a three-letter abbreviation for this Locale's country, or an
       *  empty string if no country has been specified for the Locale
       *  .
       *
       * @return a three-letter abbreviation for this lLocale's country, or an empty string if no country has been specified for the Locale.
       */
      getISO3Country(): string;
      /**
       * Returns a three-letter abbreviation for this Locale's language, or an
       *  empty string if no language has been specified for the
       *  Locale.
       *
       * @return a three-letter abbreviation for this Locale's language, or an empty string if no language has been specified for the Locale.
       */
      getISO3Language(): string;
      /**
       * Returns the language code for this Locale, which will either
       *  be the empty string or a lowercase ISO 639 code.
       *
       * @return the language code for this Locale, which will either be the empty string or a lowercase ISO 639 code.
       */
      getLanguage(): string;
      /**
       * Returns a Locale instance for the given localeId, or
       *  null if no suchLocale could be found.
       * @param localeId the localeID of the desired Locale
       * @return the Locale instance for the given localeId, or null if no suchLocale could be found.
       */
      static getLocale(localeId: string): dw.util.Locale;
      /**
       * Returns the String representation of the 'localeID'.
       *
       *  The identifier of the Locale. Contains a combination of the
       *  language and the country key, concatenated by "_", e.g. "en_US". This
       *  attribute is the primary key of the class.
       *
       * @return the String representation of the 'localeID'.
       */
      toString(): string;
    }

    /**
     * Represents a Map of objects.
     */
    class Map<K, V> {
      /**
       * Identifies if this map is empty.
       */
      readonly empty: boolean;
      /**
       * Convenience variable, for an empty and immutable list.
       */
      static EMPTY_MAP: dw.util.Map<any, any>;
      /**
       * The size of the map. This is a bean attribute method and
       *  supports the access to the collections
       *  length similar to a ECMA array, such as 'products.length'.
       */
      readonly length: number;
      /**
       * Returns the value associated with the key or null
       */
      readonly [name: string]: any;

      /**
       * Clears the map of all objects.
       *
       */
      clear(): void;
      /**
       * Identifies if this map contains an element identfied
       *  by the specified key.
       * @param key the key to use.
       * @return true if this map contains an element whose key is equal to the specified key.
       */
      containsKey(key: K): boolean;
      /**
       * Identifies if this map contains an element identfied
       *  by the specified value.
       * @param value the value to use.
       * @return true if this map contains an element whose value is equal to the specified value.
       */
      containsValue(value: V): boolean;
      /**
       * Returns a set of the map's entries. The returned set is actually a view to the entries of this map.
       *
       * @return a set of the map's entries.
       */
      entrySet(): dw.util.Set<dw.util.MapEntry<K, V>>;
      /**
       * Returns the object associated with the key or null.
       * @param key the key to use.
       * @return the object associated with the key or null.
       */
      get(key: K): V;
      /**
       * REturns the size of the map. This is a bean attribute method and
       *  supports the access to the collections
       *  length similar to a ECMA array, such as 'products.length'.
       *
       * @return the number of objects in the map.
       */
      getLength(): number;
      /**
       * Identifies if this map is empty.
       *
       * @return true if the map is empty, false otherwise.
       */
      isEmpty(): boolean;
      /**
       * Returns a set of the map's keys. The returned set is actually a view to the keys of this map.
       *
       * @return a set of the map's keys.
       */
      keySet(): dw.util.Set<K>;
      /**
       * Puts the specified value into the map using the
       *  specified key to identify it.
       * @param key the key to use to identify the value.
       * @param value the object to put into the map.
       * @return previous value associated with specified key, or null if there was no mapping for key.
       */
      put(key: K, value: V): V;
      /**
       * Copies all of the objects inside the specified map
       *  into this map.
       * @param other the map whose contents are copied into this map.
       */
      putAll(other: Map<K, V>): void;
      /**
       * Removes the object from the map that is identified by the key.
       * @param key the key that identifies the object to remove.
       * @return the removed object or null.
       */
      remove(key: K): V;
      /**
       * Returns the size of the map.
       *
       * @return the number of objects in the map.
       */
      size(): number;
      /**
       * Returns a collection of the values contained in this map.
       *
       * @return a collection of the values contained in this map
       */
      values(): dw.util.Collection<V>;
    }

    /**
     * The class represent an entry within a Map.
     */
    class MapEntry<K, V> {
      /**
       * The entry's key.
       */
      readonly key: K;
      /**
       * The entry's value.
       */
      readonly value: V;

      /**
       * Returns the entry's key.
       *
       * @return the entry's key.
       */
      getKey(): K;
      /**
       * Returns the entry's value.
       *
       * @return the entry's value.
       */
      getValue(): V;
    }

    /**
     * Encapsulates the key for a mapping read in with the ImportKeyValueMapping job step. Can be either single or compound keys. For example, a
     *  single string (e.g. product id) or multiple string components (e.g. product id and site).
     */
    class MappingKey {
      /**
       * Gets the (possible compound) key. If the key consists of only of a single value, the string array
       *  will simply contain a single element.
       */
      readonly keyComponents: string;
      /**
       * Gets a key that contains only a single key component (i.e. that is not a compound key). Returns null if this is
       *  not a single component key.
       */
      readonly singleComponentKey: string;

      /**
       * Instantiates a new key using compound key components. A key can consist of a single string (e.g. product id) or
       *  multiple string components (e.g. product id and site). Ctor accepts single string or multiple components for a
       *  compound key.
       * @param keyComponents the key components
       */
      constructor(...keyComponents: string[]);

      /**
       * Gets the (possible compound) key. If the key consists of only of a single value, the string array
       *  will simply contain a single element.
       *
       * @return the key
       */
      getKeyComponents(): String[];
      /**
       * Gets a key that contains only a single key component (i.e. that is not a compound key). Returns null if this is
       *  not a single component key.
       *
       * @return the single key
       */
      getSingleComponentKey(): string;
    }

    /**
     * Used to manage and interface with mappings loaded into the system via the ImportKeyValueMapping job step. Class can be
     *  used to retrieve values for known keys, iterate over all keys known in a mapping or list all known mappings.
     *  <p>
     *  Mappings are read into the system using the ImportKeyValueMapping job step.
     *  </p><p>
     *  Generic mapping capability enables you to map keys to values, with the mapping stored in a high-performance data
     *  store that is independent of the database. This supports large datasets, with high performance for lookup. An example
     *  of using this feature is to map SKUs from a backend system to Commerce Cloud Digital SKUs on-the-fly in Digital script, so
     *  that interaction with the backend system is transparent and does not require adding Digital SKUs to the third
     *  party system.</p>
     */
    class MappingMgr {
      /**
       * List all known mappings.
       */
      static readonly mappingNames: dw.util.Collection<string>;

      /**
       * Returns a map containing value(s) associated to the specified key for the specified mapping.
       * @param mappingName the mapping name
       * @param key the key
       */
      static get(
        mappingName: string,
        key: dw.util.MappingKey
      ): dw.util.Map<string, any>;
      /**
       * Gets the first string value of a mapping by name and key. Ordering is determined by the input CSV file. Throws an
       *  exception if mappingName does not exist.
       * @param mappingName the mapping name
       * @param key the key
       * @return the value if a single value. The first value sequentially if a compound value.
       */
      static getFirst(mappingName: string, key: dw.util.MappingKey): string;
      /**
       * List all known mappings.
       *
       * @return the collection of mapping names
       */
      static getMappingNames(): dw.util.Collection<string>;
      /**
       * Key iterator over known mapping keys by mapping name. Throws an exception if mappingName does not exist.
       * @param mappingName the mapping name
       * @return the seekable iterator
       */
      static keyIterator(mappingName: string): dw.util.SeekableIterator;
    }

    /**
     * This comparator can be used for the List sort() methods and for the SortSet
     *  and SortedMap classes. The comparator can be used to make a comparison based
     *  on a property of the contained objects. The Comparison is done based on the
     *  natural order of the values. It is guaranteed to work for Numbers, Strings,
     *  Dates, Money and Quantity values.
     */
    class PropertyComparator {
      /**
       * Constructs the comparator from the variable length argument list. The
       *  parameters are property names that are to be used for the comparison.
       *  When comparing two objects, the comparator first compares them by the
       *  first property. If the two objects have equal values for the first
       *  property, the comparator then compares them by the second property,
       *  etc, until one object is determined to be less than the other or they are
       *  equal. Each parameter must be either a simple name like "totalSum" or can
       *  be a reference to a custom attribute like "custom.mytotal". Each
       *  parameter may also be prefixed with an optional '+' or '-' character to
       *  indicate that the objects should be sorted ascending or descending
       *  respectively by that property. If not specified for a given property then
       *  '+' (ascending sort) is assumed.
       *
       *  For example: new PropertyComparator("+prop1", "-prop2", "prop3")
       *  constructs a Comparator which sorts by prop1 ascending, prop2 descending,
       *  and finally prop3 ascending.
       *
       *  The comparator created with this constructor treats null values as
       *  greater than any other value.
       * @param property The property name to compare by first.
       * @param otherProperties Additional property names to sort by if two objects have the same values for the first property.
       */
      constructor(property: string, ...otherProperties: string[]);
      /**
       * Constructs the comparator. The specified parameter is the name of the
       *  property that is used for the comparison. The parameter must be either a
       *  simple name like "totalSum" or can be a reference to a custom attribute
       *  like "custom.mytotal".
       *
       *  The comparator created with this constructor is setup with ascending or
       *  descending sort order depending on value of sortOrder and null values
       *  being greater than any other value.
       * @param propertyName the name of the property that is used for the comparison.
       * @param sortOrder the sort order to use where true means ascending and false means descending.
       */
      constructor(propertyName: string, sortOrder: boolean);
      /**
       * Constructs the comparator. The specified parameter is the name of the
       *  property that is used for the comparison. The parameter must be either a
       *  simple name like "totalSum" or can be a reference to a custom attribute
       *  like "custom.mytotal".
       * @param propertyName the name of the property that is used for the comparison.
       * @param sortOrder the sort order to use where true means ascending and false means descending.
       * @param nullGreater true means null is greater than any other value
       */
      constructor(
        propertyName: string,
        sortOrder: boolean,
        nullGreater: boolean
      );

      /**
       * Compares its two arguments for order. Returns a negative integer, zero,
       *  or a positive integer as the first argument is less than, equal to, or
       *  greater than the second. By default a null value is treated always
       *  greater than any other value. In the constructor of a PropertyComparator
       *  this default behavior can be changed.
       * @param arg1 the first object to compare.
       * @param arg2 the second object to compare.
       * @return a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second.
       */
      compare(arg1: any, arg2: any): number;
    }

    /**
     * SecureEncoder contains many methods for manipulating untrusted data Strings
     *  into RFC-Compliant Strings for a given context by encoding &quot;bad&quot; data into
     *  the proper format.
     */
    class SecureEncoder {
      /**
       * Encodes a given input for use in a general HTML context. E.g.
       *  text content and text attributes. This method takes the UNION of allowed
       *  characters between the two context, so may be more imprecise that the
       *  more specific contexts. Generally, this method is preferred unless you
       *  specifically understand the context in which untrusted data will be
       *  output.
       *
       *
       *  Example Usage:
       *   <div>${SecureEncoder.forHtmlContent(unsafeData)}</div>
       *
       *  <input value="${SecureEncoder.forHtmlContent(unsafeData)}" />
       *
       *
       *  Flow:
       *
       *  Allow AlphaNumerics and some Special characters
       *  Replace Illegal Control Characters (Below 0x1F or between 0x7F and 0x9F)
       *  with &#xfffd;, the Unicode Replacement Character
       *  Replace special HTML characters with their HTML Entity equivalents
       * @param input untrusted input to be encoded, if necessary
       * @return a properly encoded string for the given input
       */
      static forHtmlContent(input: string): string;
      /**
       * Encodes a given input for use in an HTML Attribute guarded by a double
       *  quote. This method is preferred if you understand exactly how the output
       *  of this will be used in the HTML document.
       *
       *
       *  Example Usage:
       *   <div id="${SecureEncoder.forHtmlInDoubleQuoteAttribute(unsafeData)}"></div>
       *
       *
       *  Flow:
       *
       *  Allow AlphaNumerics and some Special characters
       *  Replace Illegal Control Characters (Below 0x1F or between 0x7F and 0x9F)
       *  with &#xfffd;, the Unicode Replacement Character
       *  Replace special HTML characters with their HTML Entity equivalents
       * @param input untrusted input to be encoded, if necessary
       * @return a properly encoded string for the given input
       */
      static forHtmlInDoubleQuoteAttribute(input: string): string;
      /**
       * Encodes a given input for use in an HTML Attribute guarded by a single
       *  quote. This method is preferred if you understand exactly how the output
       *  of this will be used in the HTML document.
       *
       *
       *  Example Usage:
       *   <div id='${SecureEncoder.forHtmlInSingleQuoteAttribute(unsafeData)}'></div>
       *
       *
       *  Flow:
       *
       *  Allow AlphaNumerics and some Special characters
       *  Replace Illegal Control Characters (Below 0x1F or between 0x7F and 0x9F)
       *  with &#xfffd;, the Unicode Replacement Character
       *  Replace special HTML characters with their HTML Entity equivalents
       * @param input untrusted input to be encoded, if necessary
       * @return a properly encoded string for the given input
       */
      static forHtmlInSingleQuoteAttribute(input: string): string;
      /**
       * Encodes a given input for use in an HTML Attribute left unguarded.
       *  This method is preferred if you understand exactly how the output
       *  of this will be used in the HTML document.
       *
       *
       *  Example Usage:
       *   <div id=${SecureEncoder.forHtmlUnquotedAttribute(unsafeData)}></div>
       *
       *
       *  Flow:
       *
       *  Allow AlphaNumerics and some Special characters
       *  Replace Illegal Control Characters (Below 0x1F or between 0x7F and 0x9F)
       *  with &#xfffd;, the Unicode Replacement Character
       *  Replace special HTML characters with their HTML Entity equivalents
       * @param input untrusted input to be encoded, if necessary
       * @return a properly encoded string for the given input
       */
      static forHtmlUnquotedAttribute(input: string): string;
      /**
       * Encodes a given input for use in JavaScript inside an HTML attribute.
       *  This method is preferred if you understand exactly how the output
       *  of the will be used in the page
       *
       *
       *  Example Usage:
       *   <button onclick="alert('${SecureEncoder.forJavaScriptInAttribute(unsafeData)}');">
       *
       *
       *  Flow:
       *
       *  Allow AlphaNumerics and some Special characters
       *  Slash escape certain illegal characters
       *  Replace special JavaScript characters with their Hex Encoded
       *  equivalents prepended with \\x for character codes under 128 and
       *  \\u for character codes over 128
       * @param input untrusted input to be encoded, if necessary
       * @return a properly encoded string for the given input
       */
      static forJavaScriptInAttribute(input: string): string;
      /**
       * Encodes a given input for use in JavaScript inside an HTML block.
       *  This method is preferred if you understand exactly how the output
       *  of the will be used in the page
       *
       *
       *  Example Usage:
       *   <script type="text/javascript">
       *      var data = "${SecureEncoder.forJavaScriptInBlock(unsafeData)}";
       *  </script>
       *
       *
       *  Flow:
       *
       *  Allow AlphaNumerics and some Special characters
       *  Slash escape certain illegal characters
       *  Replace special JavaScript characters with their Hex Encoded
       *  equivalents prepended with \\x for character codes under 128 and
       *  \\u for character codes over 128
       * @param input untrusted input to be encoded, if necessary
       * @return a properly encoded string for the given input
       */
      static forJavaScriptInBlock(input: string): string;
      /**
       * Encodes a given input for use in JavaScript inside an HTML context.
       *  This method takes the UNION of allowed characters among the other
       *  contexts, so may be more imprecise that the more specific contexts.
       *  Generally, this method is preferred unless you specifically understand
       *  the context in which untrusted data will be output.
       *
       *
       *  Example Usage:
       *   <script type="text/javascript">
       *      var data = "${SecureEncoder.forJavaScriptInHTML(unsafeData)}";
       *  </script>
       *
       *  <button onclick="alert('${SecureEncoder.forJavaScriptInHTML(unsafeData)}');">
       *
       *
       *  Flow:
       *
       *  Allow AlphaNumerics and some Special characters
       *  Slash escape certain illegal characters
       *  Replace special JavaScript characters with their Hex Encoded
       *  equivalents prepended with \\x for character codes under 128 and
       *  \\u for character codes over 128
       * @param input untrusted input to be encoded, if necessary
       * @return a properly encoded string for the given input
       */
      static forJavaScriptInHTML(input: string): string;
      /**
       * Encodes a given input for use in JavaScript inside a JavaScript source
       *  file. This method is preferred if you understand exactly how the output
       *  of the will be used in the page
       *
       *
       *  Example Usage:
       *   <...inside foobar.js...>
       *  var data = "${SecureEncoder.forJavaScriptInSource(unsafeData)}";
       *
       *
       *  Flow:
       *
       *  Allow AlphaNumerics and some Special characters
       *  Slash escape certain illegal characters
       *  Replace special JavaScript characters with their Hex Encoded
       *  equivalents prepended with \\x for character codes under 128 and
       *  \\u for character codes over 128
       * @param input untrusted input to be encoded, if necessary
       * @return a properly encoded string for the given input
       */
      static forJavaScriptInSource(input: string): string;
      /**
       * Encodes a given input for use in a JSON Object Value to prevent
       *  escaping into a trusted context.
       *
       *
       *  Example Usage:
       *   var json = {"trusted_data" : SecureEncoder.forJSONValue(unsafeData)};
       *  return JSON.stringify(json);
       *
       *
       *  Flow:
       *
       *  Allow AlphaNumerics
       *  Slash escape certain illegal characters
       *  Replace all other characters with their Hex Encoded
       *  equivalents prepended with \\u
       * @param input untrusted input to be encoded, if necessary
       * @return a properly encoded string for the given input
       */
      static forJSONValue(input: string): string;
      /**
       * Encodes a given input for use as a component of a URI. This is
       *  equivalent to javascript's encodeURIComponent and does a realistic
       *  job of encoding.
       *
       *
       *  Example Usage:
       *   <a href="http://host.com?value=${SecureEncoder.forUriComponent(unsafeData)}"/>
       *
       *
       *  Allows:
       *  A-Z, a-z, 0-9, -, _, ., ~, !, *, ', (, )
       *
       *  Flow:
       *
       *  Allow AlphaNumerics and some Special characters
       *  Percent encode all other characters
       * @param input untrusted input to be encoded, if necessary
       * @return a properly encoded string for the given input
       */
      static forUriComponent(input: string): string;
      /**
       * Encodes a given input for use as a component of a URI. This is a strict
       *  encoder and fully complies with RFC3986.
       *
       *
       *  Example Usage:
       *   <a href="http://host.com?value=${SecureEncoder.forUriComponentStrict(unsafeData)}"/>
       *
       *
       *  Allows:
       *  A-Z, a-z, 0-9, -, _, ., ~
       *
       *  Flow:
       *
       *  Allow AlphaNumerics and some Special characters
       *  Percent encode all other characters
       * @param input untrusted input to be encoded, if necessary
       * @return a properly encoded string for the given input
       */
      static forUriComponentStrict(input: string): string;
      /**
       * Encodes a given input for use in an XML comments.
       *  This method is preferred if you understand the context in which
       *  untrusted data will be output.
       *
       *
       *  Note: It is recommended that you use a real parser, as this method
       *  can be misused, but is left here if a parser is unavailable to you
       *
       *  Example Usage:
       *   <!-- ${SecureEncoder.forXmlCommentContent(unsafeData)} -->
       *
       *
       *  Flow:
       *
       *  Allow AlphaNumerics and some Special characters
       *  Replace Illegal Control Characters (Below 0x1F or between
       *  0x7F and 0x84 or between 0x86 and 0x9F or between 0xFDD0 and 0xFDDF)
       *  with an empty string
       *  Replace special XML characters with their default XML Entity equivalents
       * @param input untrusted input to be encoded, if necessary
       * @return a properly encoded string for the given input
       */
      static forXmlCommentContent(input: string): string;
      /**
       * Encodes a given input for use in a general XML context. E.g.
       *  text content and text attributes. This method takes the UNION of allowed
       *  characters between the other contexts, so may be more imprecise that the
       *  more specific contexts. Generally, this method is preferred unless you
       *  specifically understand the context in which untrusted data will be
       *  output.
       *
       *
       *  Note: It is recommended that you use a real parser, as this method
       *  can be misused, but is left here if a parser is unavailable to you
       *
       *  Example Usage:
       *   <foo>${SecureEncoder.forXmlContent(unsafeData)}</foo>
       *
       *  <bar attr="${SecureEncoder.forXmlContent(unsafeData)}"></bar>
       *
       *
       *  Flow:
       *
       *  Allow AlphaNumerics and some Special characters
       *  Replace Illegal Control Characters (Below 0x1F or between
       *  0x7F and 0x84 or between 0x86 and 0x9F or between 0xFDD0 and 0xFDDF)
       *  with an empty string
       *  Replace special XML characters with their default XML Entity equivalents
       * @param input untrusted input to be encoded, if necessary
       * @return a properly encoded string for the given input
       */
      static forXmlContent(input: string): string;
      /**
       * Encodes a given input for use in an XML attribute guarded by a double
       *  quote. This method is preferred if you understand the context in which
       *  untrusted data will be output.
       *
       *
       *  Note: It is recommended that you use a real parser, as this method
       *  can be misused, but is left here if a parser is unavailable to you
       *
       *  Example Usage:
       *   <bar attr="${SecureEncoder.forXmlInDoubleQuoteAttribute(unsafeData)}"></bar>
       *
       *
       *  Flow:
       *
       *  Allow AlphaNumerics and some Special characters
       *  Replace Illegal Control Characters (Below 0x1F or between
       *  0x7F and 0x84 or between 0x86 and 0x9F or between 0xFDD0 and 0xFDDF)
       *  with an empty string
       *  Replace special XML characters with their default XML Entity equivalents
       * @param input untrusted input to be encoded, if necessary
       * @return a properly encoded string for the given input
       */
      static forXmlInDoubleQuoteAttribute(input: string): string;
      /**
       * Encodes a given input for use in an XML attribute guarded by a single
       *  quote. This method is preferred if you understand the context in which
       *  untrusted data will be output.
       *
       *
       *  Note: It is recommended that you use a real parser, as this method
       *  can be misused, but is left here if a parser is unavailable to you
       *
       *  Example Usage:
       *   <bar attr='${SecureEncoder.forXmlInSingleQuoteAttribute(unsafeData)}'></bar>
       *
       *
       *  Flow:
       *
       *  Allow AlphaNumerics and some Special characters
       *  Replace Illegal Control Characters (Below 0x1F or between
       *  0x7F and 0x84 or between 0x86 and 0x9F or between 0xFDD0 and 0xFDDF)
       *  with an empty string
       *  Replace special XML characters with their default XML Entity equivalents
       * @param input untrusted input to be encoded, if necessary
       * @return a properly encoded string for the given input
       */
      static forXmlInSingleQuoteAttribute(input: string): string;
    }

    /**
     * SecureFilter contains many methods for manipulating untrusted data Strings
     *  into RFC-Compliant Strings for a given context by removing &quot;bad&quot; data from
     *  the untrusted data.
     */
    class SecureFilter {
      /**
       * Filters illegal characters from a given input for use in a general HTML
       *  context. E.g. text content and text attributes. This method takes the
       *  UNION of allowed characters among all contexts, so may be more
       *  imprecise that the more specific contexts. Generally, this method is
       *  preferred unless you specifically understand the context in which
       *  untrusted data will be output.
       *
       *
       *  Example Usage:
       *   <div>${SecureFilter.forHtmlContent(unsafeData)}</div>
       *
       *  <input value="${SecureFilter.forHtmlContent(unsafeData)}" />
       *
       *
       *  Flow:
       *
       *  Allow AlphaNumerics and some Special characters
       *  Remove all other characters
       * @param input untrusted input to be filtered, if necessary
       * @return a properly filtered string for the given input
       */
      static forHtmlContent(input: string): string;
      /**
       * Filters illegal characters from a given input for use in an HTML
       *  Attribute guarded by a double quote. This method is preferred if you
       *  understand exactly how the output of this will be used in the HTML
       *  document.
       *
       *
       *  Example Usage:
       *   <div id="${SecureFilter.forHtmlInDoubleQuoteAttribute(unsafeData)}"></div>
       *
       *
       *  Flow:
       *
       *  Allow AlphaNumerics and some Special characters
       *  Remove all other characters
       * @param input untrusted input to be filtered, if necessary
       * @return a properly filtered string for the given input
       */
      static forHtmlInDoubleQuoteAttribute(input: string): string;
      /**
       * Filters illegal characters from a given input for use in an HTML
       *  Attribute guarded by a single quote. This method is preferred if you
       *  understand exactly how the output of this will be used in the HTML
       *  document.
       *
       *
       *  Example Usage:
       *   <div id='${SecureFilter.forHtmlInSingleQuoteAttribute(unsafeData)}'></div>
       *
       *
       *  Flow:
       *
       *  Allow AlphaNumerics and some Special characters
       *  Remove all other characters
       * @param input untrusted input to be filterd, if necessary
       * @return a properly filtered string for the given input
       */
      static forHtmlInSingleQuoteAttribute(input: string): string;
      /**
       * Filters illegal characters from a given input for use in an HTML
       *  Attribute left unguarded. This method is preferred if you understand
       *  exactly how the output of this will be used in the HTML document.
       *
       *
       *  Example Usage:
       *   <div id=${SecureFilter.forHtmlUnquotedAttribute(unsafeData)}></div>
       *
       *
       *  Flow:
       *
       *  Allow AlphaNumerics and some Special characters
       *  Remove all other characters
       * @param input untrusted input to be filtered, if necessary
       * @return a properly filtered string for the given input
       */
      static forHtmlUnquotedAttribute(input: string): string;
      /**
       * Filters illegal characters from a given input for use in JavaScript
       *  inside an HTML attribute. This method is preferred if you understand
       *  exactly how the output of the will be used in the page
       *
       *
       *  Example Usage:
       *   <button onclick="alert('${SecureFilter.forJavaScriptInAttribute(unsafeData)}');">
       *
       *
       *  Flow:
       *
       *  Allow AlphaNumerics and some Special characters
       *  Remove all other characters
       * @param input untrusted input to be filtered, if necessary
       * @return a properly filtered string for the given input
       */
      static forJavaScriptInAttribute(input: string): string;
      /**
       * Filters illegal characters from a given input for use in JavaScript
       *  inside an HTML block. This method is preferred if you understand
       *  exactly how the output of the will be used in the page
       *
       *
       *  Example Usage:
       *   <script type="text/javascript">
       *      var data = "${SecureFilter.forJavaScriptInBlock(unsafeData)}";
       *  </script>
       *
       *
       *  Flow:
       *
       *  Allow AlphaNumerics and some Special characters
       *  Remove all other characters
       * @param input untrusted input to be filtered, if necessary
       * @return a properly filtered string for the given input
       */
      static forJavaScriptInBlock(input: string): string;
      /**
       * Filters illegal characters from a given input for use in JavaScript
       *  inside an HTML context. This method takes the UNION of allowed
       *  characters among the other contexts, so may be more imprecise that the
       *  more specific contexts. Generally, this method is preferred unless you
       *  specifically understand the context in which untrusted data will be
       *  output.
       *
       *
       *  Example Usage:
       *   <script type="text/javascript">
       *      var data = "${SecureFilter.forJavaScriptInHTML(unsafeData)}";
       *  </script>
       *
       *  <button onclick="alert('${SecureFilter.forJavaScriptInHTML(unsafeData)}');">
       *
       *
       *  Flow:
       *
       *  Allow AlphaNumerics and some Special characters
       *  Remove all other characters
       * @param input untrusted input to be filtered, if necessary
       * @return a properly filtered string for the given input
       */
      static forJavaScriptInHTML(input: string): string;
      /**
       * Filters illegal characters from a given input for use in JavaScript
       *  inside a JavaScript source file. This method is preferred if you
       *  understand exactly how the output of the will be used in the page
       *
       *
       *  Example Usage:
       *   <...inside foobar.js...>
       *  var data = "${SecureFilter.forJavaScriptInSource(unsafeData)}";
       *
       *
       *  Flow:
       *
       *  Allow AlphaNumerics and some Special characters
       *  Remove all other characters
       * @param input untrusted input to be filtered, if necessary
       * @return a properly filtered string for the given input
       */
      static forJavaScriptInSource(input: string): string;
      /**
       * Filters illegal characters from a given input for use in a JSON Object
       *  Value to prevent escaping into a trusted context.
       *
       *
       *  Example Usage:
       *   var json = {"trusted_data" : SecureFilter.forJSONValue(unsafeData)};
       *  return JSON.stringify(json);
       *
       *
       *  Flow:
       *
       *  Allow AlphaNumerics
       *  Remove all other characters
       * @param input ed input to be filtered, if necessary
       * @return a properly filtered string for the given input
       */
      static forJSONValue(input: string): string;
      /**
       * Filters illegal characters from a given input for use as a component
       *  of a URI. This is equivalent to javascript's filterURIComponent and
       *  does a realistic job of encoding.
       *
       *
       *  Example Usage:
       *   <a href="http://host.com?value=${SecureFilter.forUriComponent(unsafeData)}"/>
       *
       *
       *  Allows:
       *  A-Z, a-z, 0-9, -, _, ., ~, !, *, ', (, )
       *
       *  Flow:
       *
       *  Allow AlphaNumerics and some Special characters
       *  Remove all other characters
       * @param input untrusted input to be filtered, if necessary
       * @return a properly filtered string for the given input
       */
      static forUriComponent(input: string): string;
      /**
       * Filters illegal characters from a given input for use as a component
       *  of a URI. This is a strict filter and fully complies with RFC3986.
       *
       *
       *  Example Usage:
       *   <a href="http://host.com?value=${SecureFilter.forUriComponentStrict(unsafeData)}"/>
       *
       *
       *  Allows:
       *  A-Z, a-z, 0-9, -, _, ., ~
       *
       *  Flow:
       *
       *  Allow AlphaNumerics and some Special characters
       *  Remove all other characters
       * @param input untrusted input to be filtered, if necessary
       * @return a properly filtered string for the given input
       */
      static forUriComponentStrict(input: string): string;
      /**
       * Filters illegal characters from a given input for use in an XML
       *  comments. This method is preferred if you understand the context in
       *  which untrusted data will be output.
       *
       *
       *  Note: It is recommended that you use a real parser, as this method
       *  can be misused, but is left here if a parser is unavailable to you
       *
       *  Example Usage:
       *   <!-- ${SecureFilter.forXmlCommentContent(unsafeData)} -->
       *
       *
       *  Flow:
       *
       *  Allow AlphaNumerics and some Special characters
       *  Remove all other characters
       * @param input untrusted input to be filtered, if necessary
       * @return a properly filtered string for the given input
       */
      static forXmlCommentContent(input: string): string;
      /**
       * Filters illegal characters from a given input for use in a general XML
       *  context. E.g. text content and text attributes. This method takes the
       *  UNION of allowed characters between the other contexts, so may be more
       *  imprecise that the more specific contexts. Generally, this method is
       *  preferred unless you specifically understand the context in which
       *  untrusted data will be output.
       *
       *
       *  Note: It is recommended that you use a real parser, as this method
       *  can be misused, but is left here if a parser is unavailable to you
       *
       *  Example Usage:
       *   <foo>${SecureFilter.forXmlContent(unsafeData)}</foo>
       *
       *  <bar attr="${SecureFilter.forXmlContent(unsafeData)}"></bar>
       *
       *
       *  Flow:
       *
       *  Allow AlphaNumerics and some Special characters
       *  Remove all other characters
       * @param input untrusted input to be filtered, if necessary
       * @return a properly filtered string for the given input
       */
      static forXmlContent(input: string): string;
      /**
       * Filters illegal characters from a given input for use in an XML
       *  attribute guarded by a double quote. This method is preferred if you
       *  understand the context in which untrusted data will be output.
       *
       *
       *  Note: It is recommended that you use a real parser, as this method
       *  can be misused, but is left here if a parser is unavailable to you
       *
       *  Example Usage:
       *   <bar attr="${SecureFilter.forXmlInDoubleQuoteAttribute(unsafeData)}"></bar>
       *
       *
       *  Flow:
       *
       *  Allow AlphaNumerics and some Special characters
       *  Remove all other characters
       * @param input untrusted input to be filtered, if necessary
       * @return a properly filtered string for the given input
       */
      static forXmlInDoubleQuoteAttribute(input: string): string;
      /**
       * Filters illegal characters from a given input for use in an XML
       *  attribute guarded by a single quote. This method is preferred if you
       *  understand the context in which untrusted data will be output.
       *
       *
       *  Note: It is recommended that you use a real parser, as this method
       *  can be misused, but is left here if a parser is unavailable to you
       *
       *  Example Usage:
       *   <bar attr='${SecureFilter.forXmlInSingleQuoteAttribute(unsafeData)}'></bar>
       *
       *
       *  Flow:
       *
       *  Allow AlphaNumerics and some Special characters
       *  Remove all other characters
       * @param input untrusted input to be filtered, if necessary
       * @return a properly filtered string for the given input
       */
      static forXmlInSingleQuoteAttribute(input: string): string;
    }

    /**
     * A special Iterator, which is returned by the system to iterate through large
     *  sets of data. The iterator supports seeking forward to a random position.
     *  This is a typical action when paging forward in a result set. The Iterator is
     *  primarily returned from search operations.<br><br>
     *  Starting with API version 10.6, these iterators can only
     *  be iterated once to avoid possible memory problems for really large
     *  result sets. Putting them into the pipeline dictionary and trying to loop them
     *  multiple times is no longer possible because this would require buffering the
     *  iterated elements internally.<br><br>
     *  Prior to 10.6, and for all customers still running API version 10.4
     *  (compatibility mode), SeekableIterator instances stored in the pipeline
     *  dictionary could be iterated multiple times (for example, by several loop
     *  nodes).
     */
    class SeekableIterator extends dw.util.Iterator<any> {
      /**
       * The total element count for this iterator. The
       *  method returns -1, if the total count is not known.
       */
      readonly count: number;

      /**
       * Closes all system resources associated with this iterator.
       *
       *  Calling this method is strongly recommended if not all elements of this iterator are
       *  retrieved. This will allow the system to release system resources immediately.
       *  The SeekableIterator is closed automatically if all elements are retrieved.
       *  Then calling method close() is optional.
       *
       */
      close(): void;
      /**
       * Returns the first element of this iterator and closes it.
       *
       *  If the iterator does not contain another element null is returned.
       *  If any of the methods next(), forward(int) or forward(int,int) have been called before
       *  null is returned.
       *  This method is useful if only the first element of an iterator is needed.
       *
       *  A possible example for the use of first() is:
       *
       *  OrderMgr.queryOrders("queryString", "sortString", args).first()
       *
       * @return the first element of an iterator and closes the iterator or returns null if the iterator doesn't have another element or the methods next(), forward(int) or forward(int,int) have already been called.
       */
      first(): any;
      /**
       * Seeks forward by the given number of elements. The number of
       *  seek steps must be 0 or a positive number.
       * @param n the number of elements to seek forward.
       */
      forward(n: number): void;
      /**
       * Seeks forward by the given number of elements and limits the
       *  iteration to the given number of elements. The method is typically
       *  used to position and trim an iterator for paging. The getCount()
       *  method will still return the total count of the underlying data
       *  collection.
       * @param n the number of elements to seek forward.
       * @param size the maximum number of elements return from the iterator
       */
      forward(n: number, size: number): void;
      /**
       * Returns the total element count for this iterator. The
       *  method returns -1, if the total count is not known.
       *
       * @return the total element count for this iterator or -1.
       */
      getCount(): number;
      /**
       * Indicates if there are more elements.
       *
       * @return true if there are more elements, false otherwise.
       */
      hasNext(): boolean;
      /**
       * Returns the next element from the Iterator.
       *
       * @return the next element from the Iterator.
       */
      next(): any;
    }

    /**
     * Represents a set of objects.
     */
    class Set<T> extends dw.util.Collection<T> {
      /**
       * Convenience variable, for an empty and immutable list.
       */
      static EMPTY_SET: dw.util.Set<any>;
    }

    /**
     * A map that further guarantees that it will be in ascending key order,
     *  sorted according to the natural ordering of its keys,
     *  or by a comparator provided at sorted map creation time. This order is reflected
     *  when iterating over the sorted map&apos;s collection views (returned by the entrySet,
     *  keySet and values methods).
     *  Note that sorting by natural order is only supported for Number,
     *  String, Date, Money and Quantity as key.
     */
    class SortedMap<K, V> extends dw.util.Map<any, any> {
      /**
       * Constructor to create a new SortedMap.
       *
       */
      constructor();
      /**
       * Constructor to create a new SortedMap.
       *
       *  The constructor takes a compare function as additional parameter. This comparator
       *  determines identity and the order of the element keys for this map.
       *  The order of the elements is determined with a comparator (see PropertyComparator)
       *  or with the help of the given function. The function must take two parameters
       *  and return a value <=-1 if the first parameter is smaller than the second,
       *  a value if >=1 if the first one is greater than the second parameter
       *  and a value in between like 0 if both are equal.
       * @param comparator an instance of a PropertyComparator or a comparison function
       */
      constructor(comparator: any);

      /**
       * Returns a shallow copy of this map.
       *
       * @return a shallow copy of this map.
       */
      clone(): dw.util.SortedMap<K, V>;
      /**
       * Returns the first (lowest) key currently in this sorted map.
       *
       * @return the first (lowest) key currently in this sorted map.
       */
      firstKey(): any;
      /**
       * Returns a view of the portion of this map whose keys are strictly less than toKey.
       * @param key high endpoint (exclusive) of the headMap.
       * @return a view of the portion of this map whose keys are strictly less than toKey.
       */
      headMap(key: any): dw.util.SortedMap<K, V>;
      /**
       * Returns the last (highest) key currently in this sorted map.
       *
       * @return the last (highest) key currently in this sorted map.
       */
      lastKey(): any;
      /**
       * Returns a view of the portion of this map whose keys range from fromKey, inclusive,
       *  to toKey, exclusive. (If fromKey and toKey are equal, the returned sorted map is empty.)
       * @param from low endpoint (inclusive) of the subMap.
       * @param to high endpoint (exclusive) of the subMap.
       * @return a view of the portion of this map whose keys range from fromKey, inclusive, to toKey, exclusive.
       */
      subMap(from: any, to: any): dw.util.SortedMap<K, V>;
      /**
       * Returns a view of the portion of this map whose keys are greater than or equal
       *  to fromKey. The returned sorted map is backed by this map, so changes in the
       *  returned sorted map are reflected in this map, and vice-versa. The returned
       *  sorted map supports all optional map operations.
       * @param key low endpoint (inclusive) of the tailMap.
       * @return a view of the portion of this map whose keys are greater than or equal to fromKey.
       */
      tailMap(key: any): dw.util.SortedMap<K, V>;
    }

    /**
     * A set that further guarantees that its iterator
     *  will traverse the set in ascending element order,
     *  sorted according to the natural ordering of its
     *  elements (only supported for Number, String,
     *  Date, Money and Quantity), or by a comparator
     *  provided at sorted set creation time.
     */
    class SortedSet<T> extends dw.util.Set<T> {
      /**
       * Constructor to create a new SortedSet.
       *
       */
      constructor();
      /**
       * Constructor to create a new SortedSet.
       *
       *  The constructor takes a compare function as additional parameter. This comparator
       *  determines identity and the order of the elements for this set.
       *  The order of the elements is determined with a comparator (see PropertyComparator)
       *  or with the help of the given function. The function must take two parameters
       *  and return a value <=-1 if the first parameter is smaller than the second,
       *  a value if >=1 if the first one is greater than the second parameter
       *  and a value in between like 0 if both are equal.
       * @param comparator an instance of a PropertyComparator or a comparison function
       */
      constructor(comparator: T);
      /**
       * Constructor for a new SortedSet. The constructor
       *  initializes the SortedSet with the elements of the
       *  given collection.
       * @param collection the collection of objects that are inserted into the set.
       */
      constructor(collection: dw.util.Collection<T>);

      /**
       * Returns a shallow copy of this set.
       *
       * @return a shallow copy of this set.
       */
      clone(): dw.util.SortedSet<T>;
      /**
       * Returns the first (lowest) element currently in this sorted set.
       *
       * @return the first (lowest) element currently in this sorted set.
       */
      first(): T;
      /**
       * Returns a view of the portion of this sorted set whose elements
       *  are strictly less than toElement. The returned sorted set is
       *  backed by this sorted set, so changes in the returned sorted
       *  set are reflected in this sorted set, and vice-versa. The returned
       *  sorted set supports all optional set operations.
       * @param key high endpoint (exclusive) of the headSet.
       * @return a view of the specified initial range of this sorted set.
       */
      headSet(key: T): dw.util.SortedSet<T>;
      /**
       * Returns the last (highest) element currently in this sorted set.
       *
       * @return the last (highest) element currently in this sorted set.
       */
      last(): T;
      /**
       * Returns a view of the portion of this sorted set whose elements
       *  range from fromElement, inclusive, to toElement, exclusive. (If
       *  fromElement and toElement are equal, the returned sorted set is empty.)
       *  The returned sorted set is backed by this sorted set, so changes in
       *  the returned sorted set are reflected in this sorted set, and vice-versa.
       *  The returned sorted set supports all optional set operations that this
       *  sorted set supports.
       * @param from low endpoint (inclusive) of the subSet.
       * @param to high endpoint (exclusive) of the subSet.
       * @return a view of the specified range within this sorted set.
       */
      subSet(from: T, to: T): dw.util.SortedSet<T>;
      /**
       * Returns a view of the portion of this sorted set whose elements
       *  are greater than or equal to fromElement. The returned sorted set
       *  is backed by this sorted set, so changes in the returned sorted
       *  set are reflected in this sorted set, and vice-versa. The returned
       *  sorted set supports all optional set operations.
       * @param key low endpoint (inclusive) of the tailSet.
       * @return a view of the specified final range of this sorted set.
       */
      tailSet(key: T): dw.util.SortedSet<T>;
    }

    /**
     * String utility class.
     */
    class StringUtils {
      /**
       * String encoding type HTML.
       */
      static readonly ENCODE_TYPE_HTML = 0;
      /**
       * String encoding type WML.
       */
      static readonly ENCODE_TYPE_WML = 2;
      /**
       * String encoding type XML.
       */
      static readonly ENCODE_TYPE_XML = 1;
      /**
       * String truncate mode 'char'. Truncate string to the nearest character. Default mode if no truncate mode is specified.
       */
      static readonly TRUNCATE_CHAR = "char";
      /**
       * String truncate mode 'sentence'. Truncate string to the nearest sentence.
       */
      static readonly TRUNCATE_SENTENCE = "sentence";
      /**
       * String truncate mode 'word'. Truncate string to the nearest word.
       */
      static readonly TRUNCATE_WORD = "word";

      /**
       * Interprets a Base64 encoded string as byte stream of an UTF-8 encoded string.
       *
       *  The method throws an IllegalArgumentException in case the encoding
       *  failed because of a mismatch between the input string and the character encoding.
       * @param base64 the Base64 encoded string - should not be empty or null.
       * @return the decoded string.
       */
      static decodeBase64(base64: string): string;
      /**
       * Interprets a Base64 encoded string as the byte stream representation of a string.
       *  The given character encoding is used for decoding the byte stream into the
       *  character representation.
       *
       *  The method throws an IllegalArgumentException in case the encoding
       *  failed because of a mismatch between the input String and the character encoding.
       * @param base64 the Base64 encoded string - should not be empty or null.
       * @param characterEncoding the character encoding to read the input string - should not be empty or null.
       * @return the decoded string.
       */
      static decodeBase64(base64: string, characterEncoding: string): string;
      /**
       * Convert a given syntax-safe string to a string according to the
       *  selected character entity encoding type.
       * @param str String to be decoded
       * @param type decode type
       * @return decoded string
       */
      static decodeString(str: string, type: number): string;
      /**
       * Encodes the byte representation of the given string as Base64.
       *  The string is converted into the byte representation with UTF-8 encoding.
       *
       *  The method throws an IllegalArgumentException in case the encoding
       *  failed because of a mismatch between the input string and the character encoding.
       * @param str the string to encode - should not be empty or null.
       * @return the encoded string.
       */
      static encodeBase64(str: string): string;
      /**
       * Encodes the byte representation of the given string as Base64.
       *  The string is converted into the byte representation using the given
       *  character encoding.
       *
       *  The method throws an IllegalArgumentException in case the encoding
       *  failed because of a mismatch between the input string and the character encoding.
       * @param str the string to encode - should not be empty or null.
       * @param characterEncoding the character encoding to read the input string - should not be empty or null.
       * @return the encoded string.
       */
      static encodeBase64(str: string, characterEncoding: string): string;
      /**
       * Convert a given string to a syntax-safe string according to the
       *  selected character entity encoding type.
       * @param str String to be encoded
       * @param type encode type
       * @return encoded string
       */
      static encodeString(str: string, type: number): string;
      /**
       * Returns a formatted string using the specified format and arguments.
       *  The formatting string is a Java MessageFormat expression, e.g.
       *  format( "Message: {0}, {1}", "test", 10 ) would result in "Message: test, 10".
       *
       *  If a Collection is passed as the only argument, the elements of this collection
       *  are used as arguments for the formatting.
       * @param format Java like formatting string.
       * @param args optional list of arguments or a collection, which are included into the result string
       * @return the formatted result string.
       */
      static format(format: string, ...args: any[]): string;
      /**
       * Formats a Calendar object with Calendar.INPUT_DATE_TIME_PATTERN format
       *  of the current request locale, for example "MM/dd/yyyy h:mm a" for the
       *  locale en_US. The used time zone is the time zone of the calendar object.
       * @param calendar the calendar object.
       * @return a string representation of the formatted calendar object.
       */
      static formatCalendar(calendar: dw.util.Calendar): string;
      /**
       * Formats a Calendar object with the provided date format. The format is a
       *  Java date format, like "yyy-MM-dd". The used time zone is the time zone
       *  of the calendar object.
       * @param calendar the calendar object to be printed
       * @param format the format to use.
       * @return a string representation of the formatted calendar object.
       */
      static formatCalendar(calendar: dw.util.Calendar, format: string): string;
      /**
       * Formats a Calendar object with the date format defined by the provided locale
       *  and Calendar pattern.  The locale can be for instance the request.getLocale().
       *  The used time  zone is the time zone of the calendar object.
       * @param calendar the calendar object to be printed
       * @param locale the locale, which defines the date format to be used
       * @param pattern the pattern is one of a calendar pattern e.g. SHORT_DATE_PATTERN as defined in the regional settings for the locale
       * @return a string representation of the formatted calendar object.
       */
      static formatCalendar(
        calendar: dw.util.Calendar,
        locale: string,
        pattern: number
      ): string;
      /**
       * Formats a date with the default date format of the current site.
       * @param date the date to format.
       * @return a string representation of the formatted date.
       */
      static formatDate(date: Date): string;
      /**
       * Formats a date with the provided date format. The format is the
       *  Java date format, like "yyyy-MM-DD". The locale of the calling context
       *  request is used in formatting.
       * @param date the date to format.
       * @param format the format to use.
       * @return a string representation of the formatted date.
       */
      static formatDate(date: Date, format: string): string;
      /**
       * Formats a date with the provided date format in specified locale. The format is
       *  Java date format, like "yyyy-MM-DD".
       * @param date the date to format.
       * @param format the format to use.
       * @param locale the locale to use.
       * @return a string representation of the formatted date.
       */
      static formatDate(date: Date, format: string, locale: string): string;
      /**
       * Returns a formatted integer number using the default integer format of the current
       *  site. The method can be also called to format a floating number as integer.
       * @param number the number to format.
       * @return a formatted an integer number with the default integer format of the current site.
       */
      static formatInteger(number: number): string;
      /**
       * Formats a Money Object with the default money format of the current request locale.
       * @param money The Money instance that should be formatted.
       * @return The formatted String representation of the passed money. In case of an error the string 'N/A' is returned.
       */
      static formatMoney(money: dw.value.Money): string;
      /**
       * Returns a formatted number using the default number format of the current site.
       *
       *  Decimal and grouping separators are used as specified in the locales regional settings.
       * @param number the number to format.
       * @return a formatted number using the default number format of the current site.
       */
      static formatNumber(number: number): string;
      /**
       * Returns a formatted string using the specified number and format. The format is
       *  Java number format, like "#,###.00". To format as an integer
       *  number provide "0" as format string. The locale of the calling context
       *  request is used in formatting.
       *
       *  Decimal and grouping separators are used as specified in the locales regional settings (when configured, otherwise a fallback to the internal configuration is done).
       * @param number the number to format.
       * @param format the format to use.
       * @return a formatted string using the specified number and format.
       */
      static formatNumber(number: number, format: string): string;
      /**
       * Returns a formatted number as a string using the specified number format in specified locale. The format is
       *  Java number format, like "#,###.00". To format as an integer
       *  number provide "0" as format string.
       *
       *  Decimal and grouping separators are used as specified in the locales regional settings (when configured, otherwise a fallback to the internal configuration is done).
       * @param number the number to format.
       * @param format the format to use.
       * @param locale the locale to use.
       * @return a formatted number as a string using the specified number format in specified locale.
       */
      static formatNumber(
        number: number,
        format: string,
        locale: string
      ): string;
      /**
       * Return a string in which specified number of characters in the suffix is not changed
       *  and the rest of the characters replaced with specified character.
       * @param str String to garble
       * @param replaceChar character to use as a replacement
       * @param suffixLength length of the suffix
       * @return the garbled string.
       */
      static garble(
        str: string,
        replaceChar: string,
        suffixLength: number
      ): string;
      /**
       * Returns the string with leading white space removed.
       * @param str the String to remove characters from.
       * @return the string with leading white space removed.
       */
      static ltrim(str: string): string;
      /**
       * This method provides cell padding functionality to the template.
       * @param str the string to process
       * @param width The absolute value of this number defines the width of the cell. A possitive number forces left, a negative number right alignment. A '0' doesn't change the string.
       * @return the processed string.
       */
      static pad(str: string, width: number): string;
      /**
       * Returns the string with trailing white space removed.
       * @param str the String to remove characters from.
       * @return the string with trailing white space removed.
       */
      static rtrim(str: string): string;
      /**
       * Convert a given string to an HTML-safe string.
       *  This method substitutes characters that conflict with HTML syntax
       *  (<,>,&,") and characters that are beyond the ASCII
       *  chart (Unicode 160-255) to HTML 3.2 named character entities.
       * @param str String to be converted.
       * @return converted string.
       */
      static stringToHtml(str: string): string;
      /**
       * Converts a given string to a WML-safe string.
       *  This method substitutes characters that conflict with WML syntax
       *  (<,>,&,',"$) to WML named character entities.
       * @param str String to be converted.
       * @return the converted string.
       */
      static stringToWml(str: string): string;
      /**
       * Converts a given string to a XML-safe string.
       *  This method substitutes characters that conflict with XML syntax
       *  (<,>,&,',") to XML named character entities.
       * @param str String to be converted.
       * @return the converted string.
       */
      static stringToXml(str: string): string;
      /**
       * Returns the string with leading and trailing white space removed.
       * @param str the string to trim.
       * @return the string with leading and trailing white space removed.
       */
      static trim(str: string): string;
      /**
       * Truncate the string to the specified length using specified truncate mode. Optionally,
       *  append suffix to truncated string.
       * @param str string to truncate
       * @param maxLength maximum length of the truncated string, not including suffix
       * @param mode truncate mode (TRUNCATE_CHAR, TRUNCATE_WORD, TRUNCATE_SENTENCE), if null TRUNCATE_CHAR is assumed
       * @param suffix suffix append to the truncated string
       * @return the truncated string.
       */
      static truncate(
        str: string,
        maxLength: number,
        mode: string,
        suffix: string
      ): string;
    }

    /**
     * Reads an ISML template from the file system and renders it into a
     *  <a href="class_dw_value_MimeEncodedText.html">MimeEncodedText</a> object. Optional substitution values can be
     *  passed to the isml template via the <a href="class_dw_util_Template.html#dw_util_Template_render_Map_DetailAnchor">render(Map)</a>
     *  method. Substitution parameters can be accessed within the template through
     *
     *  <pre>     &lt;isprint value=&quot;${param.parameter}&quot;&gt;
     *  </pre>
     *
     *  or for backward compatibility through
     *
     *  <pre>     &lt;isprint value=&quot;${pdict.parameter}&quot;&gt;
     *  </pre>
     *
     *  The access through pdict only gives access to the parameter map provided at
     *  rendering time and doesn&apos;t offer access to the system PipelineDictionary. The
     *  pdict access to the property map is only considered to ease the transition
     *  from SendMail pipelet API based templates. If the PipelineDictionary or
     *  properties of the PipelineDictionary are needed, they need to be included in
     *  the Property map passed to the render method.
     */
    class Template {
      /**
       * Creates a new template. Doesn't render the template until
       *  render() or render(Map)
       *  is invoked. The current request localeID will be used for Rendering.
       * @param templateName file system path to the ISML template
       */
      constructor(templateName: string);
      /**
       * Creates a new template with the locale being set to the given localeID.
       *  Rendering doesn't happen until render() or
       *  render(Map) is invoked.
       * @param templateName file system path to the ISML template
       * @param localeID localeID to be used for Rendering
       */
      constructor(templateName: string, localeID: string);

      /**
       * Renders the template specified at instantiation time, without any
       *  substitution parameters. Any isprint tags referring to param/pdict will
       *  be unresolved and will be replaced with empty strings. If there's an
       *  explicit localeID set through setLocale(String),
       *  it takes precedence over the localeID associated with the current
       *  request.
       *
       * @return MimeEncodedText with isprint tags referring to param/pdict replaced with an empty String
       */
      render(): dw.value.MimeEncodedText;
      /**
       * Renders the template specified at instantiation time with the given
       *  substitution parameters. These parameters are available to ISML templates
       *  through variables named 'param' and 'pdict'. Note that in this context,
       *  pdict is not referring to the system PipelineDictionary, as the System
       *  Pipeline Dictionary is not accessible from this script API. If there's an
       *  explicit localeID set through setLocale(String),
       *  it takes precedence over the localeID associated with the current
       *  request.
       * @param params Map of substitution parameters which are specified within the ISML template. Access is available from within the ISML template through named variables param or pdict.
       * @return MimeEncodedText containing the rendered template. Variables in the template referring to param/pdict are replaced with the value from the params map or empty if the value isn't found in the map
       */
      render(params: dw.util.Map<any, any>): dw.value.MimeEncodedText;
      /**
       * Sets an optional localeID which is used instead of the current requests
       *  localeID.
       * @param localeID to be used for processing this template. Throws an exception if localeID is blank
       * @return this Template object
       */
      setLocale(localeID: string): dw.util.Template;
    }

    /**
     * Utility methods around generating unique IDs.
     */
    class UUIDUtils {
      /**
       * The method generates a unique id.
       *
       * @return the generated unique id
       */
      static createUUID(): string;
    }
  }

  namespace value {
    /**
     * The class represents a single value for an Enumeration type. Enumeration
     *  types can be configured through the business manager for custom attributes.
     *  Some system attributes, e.g. the order status, are also of Enumeration types.
     *
     *  <p>Each EnumValue has a base value and a display value.  The type of the base
     *  value can be either String or Integer. Every EnumValue has a display value.</p>
     *
     *  <p>If the value of an Enumeration type object attribute is
     *  <code>null</code>, when that attribute is accessed an EnumValue is returned
     *  that has a base value of <code>null</code>, rather than <code>null</code>
     *  itself.  This means that <code>empty(object.attribute)</code> would be
     *  <code>false</code>, and <code>empty(object.attribute.value)</code> would be
     *  <code>true</code></p>.
     */
    class EnumValue {
      /**
       * The display value of the enumeration value. If no display value
       *  is configured the method return the string representation of the value.
       */
      readonly displayValue: string;
      /**
       * The value of the enumeration value. This is either an integer
       *  value or a string.
       */
      readonly value: any;

      /**
       * Returns the display value of the enumeration value. If no display value
       *  is configured the method return the string representation of the value.
       *
       */
      getDisplayValue(): string;
      /**
       * Returns the value of the enumeration value. This is either an integer
       *  value or a string.
       *
       */
      getValue(): any;
      /**
       * Same as getDisplayValue().
       *
       */
      toString(): string;
      /**
       * According the ECMA specification, this method returns the "natural"
       *  primitive value of this object. Here it is equivalent to getValue().
       *
       */
      valueOf(): any;
    }

    /**
     * Container for an arbitrary text string its mime type, and encoding
     */
    class MimeEncodedText {
      /**
       * The encoding of the text. Encoding is set at creation time and
       *  can't be changed afterwards
       */
      readonly encoding: string;
      /**
       * The mime type of the text. Mime type is set at creation time and
       *  can't be changed afterwards.
       */
      readonly mimeType: string;
      /**
       * The text. Text is set at creation time and can't be changed
       *  afterwards.
       */
      readonly text: string;

      /**
       * Creates a new MimeEncodedText with explicit values for mime type and
       *  encoding.
       * @param text text to be stored
       * @param mimeType mime type of the text. For example, "text/plain" or "text/html"
       * @param encoding Encoding of the text. For example, "UTF-8" or "ISO-8859-1"
       */
      constructor(text: string, mimeType: string, encoding: string);
      /**
       * Creates a new MimeEncodedText with the given String as text, mime type of
       *  "text/plain;charset=UTF-8" and encoding of "UTF-8"
       * @param text text to be stored
       */
      constructor(text: string);

      /**
       * Returns the encoding of the text. Encoding is set at creation time and
       *  can't be changed afterwards
       *
       * @return encoding of the text
       */
      getEncoding(): string;
      /**
       * Returns the mime type of the text. Mime type is set at creation time and
       *  can't be changed afterwards.
       *
       * @return the MimeType of the text
       */
      getMimeType(): string;
      /**
       * Returns the text. Text is set at creation time and can't be changed
       *  afterwards.
       *
       * @return text stored
       */
      getText(): string;
    }

    /**
     * Represents money in Commerce Cloud Digital.
     */
    class Money {
      /**
       * Represents that there is no money available.
       */
      static readonly NOT_AVAILABLE: dw.value.Money;

      /**
       * Identifies if the instance contains settings for value and currency.
       */
      readonly available: boolean;
      /**
       * The ISO 4217 currency mnemonic (such as 'USD', 'EUR') of the currency the
       *  money value relates to.
       *
       *  Note a money instance may also describe a price that is 'not available'.
       *  In this case the value of this attribute is N/A.
       */
      readonly currencyCode: string;
      /**
       * The money as Decimal, null is returned when the money is not available.
       */
      readonly decimalValue: dw.util.Decimal;
      /**
       * The value of the money instance.
       */
      readonly value: number;
      /**
       * Return the value of the money instance or null if the
       *  Money instance is NOT_AVAILABLE.
       */
      readonly valueOrNull: number;

      /**
       * Constructs a new money instance with the specified amount for the specified
       *  currency. Note that each currency has a precision (number of digits after the
       *  decimal point) and that values beyond the precision are "rounded up" to their
       *  "nearest neighbor" following the rules of java.math.RoundingMode.HALF_UP.
       * @param value The value of the money instance. Must not be null.
       * @param currencyCode The ISO 4217 mnemonic of currency the amount is specified in. Must not be null.
       */
      constructor(value: number, currencyCode: string);

      /**
       * Returns a Money instance by adding
       *  the specified Money object to the current object. Only objects representing the
       *  same currency can be added. If one of the Money values is N/A, the
       *  result is N/A.
       * @param value the Money object to add to this Money instance.
       * @return the Money object representing the sum of the operands.
       */
      add(value: dw.value.Money): dw.value.Money;
      /**
       * Adds a certain percentage to the money object. The percent value is given
       *  as true percent value, so for example 10 represent 10%. If this Money is
       *  N/A the result is also N/A.
       * @param percent the percent value
       * @return new Money object with the result of the calculation
       */
      addPercent(percent: number): dw.value.Money;
      /**
       * Adds a rate (e.g. 0.05) to the money object. This is typically for example
       *  to add a tax rate.
       * @param value the rate to add.
       * @return a new Money object with rate added.
       */
      addRate(value: number): dw.value.Money;
      /**
       * Compares two Money values. An exception is thrown if the two Money values
       *  are of different currency. If one of the Money values represents the N/A value
       *  it is treated as 0.0.
       * @param other the money instance to comare against this money instance.
       * @return the comparison of 0 if the money instances are equal or non-0 if they are different.
       */
      compareTo(other: dw.value.Money): number;
      /**
       * Divide Money object by specified divisor. If this Money is
       *  N/A the result is also N/A.
       * @param divisor the divisor.
       * @return Money object representing division result
       */
      divide(divisor: number): dw.value.Money;
      /**
       * Compares two money values whether they are equivalent.
       * @param other the object to compare against this money instance.
       * @return true if equal, false otherwise.
       */
      equals(other: any): boolean;
      /**
       * Returns the ISO 4217 currency mnemonic (such as 'USD', 'EUR') of the currency the
       *  money value relates to.
       *
       *  Note a money instance may also describe a price that is 'not available'.
       *  In this case the value of this attribute is N/A.
       *
       * @return the value of the currency code.
       */
      getCurrencyCode(): string;
      /**
       * Returns the money as Decimal, null is returned when the money is not available.
       *
       * @return the money as Decimal
       */
      getDecimalValue(): dw.util.Decimal;
      /**
       * Returns the value of the money instance.
       *
       * @return the value of the money instance.
       */
      getValue(): number;
      /**
       * Return the value of the money instance or null if the
       *  Money instance is NOT_AVAILABLE.
       *
       * @return Value of money instance or null.
       */
      getValueOrNull(): number;
      /**
       * Calculates the hash code for a money;
       *
       */
      hashCode(): number;
      /**
       * Identifies if the instance contains settings for value and currency.
       *
       * @return true if the instance is initialized with value and currency, false if the state is 'not available'.
       */
      isAvailable(): boolean;
      /**
       * Identifies if two Money value have the same currency.
       * @param value the Money value passed to be tested
       * @return true if both instances have the same currency, false otherwise.
       */
      isOfSameCurrency(value: dw.value.Money): boolean;
      /**
       * Multiply Money object by specified factor. If this Money is
       *  N/A the result is also N/A.
       * @param factor multiplication factor
       * @return Money object representing multiplication result.
       */
      multiply(factor: number): dw.value.Money;
      /**
       * Multiplies the Money object with the given quantity. If this Money is
       *  N/A the result is also N/A.
       * @param quantity the quantity to multiply the value by
       * @return a new Money representing the multiplication result.
       */
      multiply(quantity: dw.value.Quantity): dw.value.Money;
      /**
       * Method returns a new instance of Money with the same currency but
       *  different value. An N/A instance is returned if value is null.
       * @param value as a decimal
       * @return new Money instance with same currency
       */
      newMoney(value: dw.util.Decimal): dw.value.Money;
      /**
       * Convenience method.
       *  Calculates and returns the percentage off this price represents in
       *  relation to the passed base price.  The result is generally equal to
       *  100.0 - this.percentOf(value).  For example, if this value
       *  is $30 and the passed value is $50, then the return
       *  value will be 40.0, representing a 40% discount.
       *
       *  This method will return null if the compare value is null, this value or
       *  the compare value is unavailable, or the compare value equals 0.0.
       * @param value The price to compare to this price
       * @return The percentage discount this price represents in relation to the passed base price.
       */
      percentLessThan(value: dw.value.Money): number;
      /**
       * Convenience method.
       *  Calculates and returns the percentage of the passed value this
       *  price represents.  For example, if this value is $30 and
       *  the passed value is $50, then the return value will be 60.0 (i.e. 60%).
       *
       *  This method will return null if the compare value is null, this value or
       *  the compare value is unavailable, or the compare value equals 0.0.
       * @param value The price to compare to this price
       * @return The percentage of the compare price this price represents, or null.
       */
      percentOf(value: dw.value.Money): number;
      /**
       * Prorates the specified values using the specified discount.
       * @param dist the proration discount.
       * @param values the values to prorate.
       * @return the prorated values.
       */
      static prorate(
        dist: dw.value.Money,
        ...values: dw.value.Money[]
      ): Money[];
      /**
       * Returns a new Money instance by substracting the specified Money object
       *  from the current object. Only objects representing the
       *  same currency can be subtracted. If one of the Money values is N/A, the
       *  result is N/A.
       * @param value the Money object to subtract
       * @return the Money object representing the result of subtraction.
       */
      subtract(value: dw.value.Money): dw.value.Money;
      /**
       * Subtracts a certain percentage from the money object. The percent value is given
       *  as true percent value, so for example 10 represent 10%. If this Money is
       *  N/A the result is also N/A.
       * @param percent the percent value
       * @return new Money object with the result of the calculation
       */
      subtractPercent(percent: number): dw.value.Money;
      /**
       * Subtracts a rate (e.g. 0.05) from the money object. This is typically for example
       *  to subtract a tax rates.
       * @param value the rate to subtract.
       * @return a new Money object with rate subtracted.
       */
      subtractRate(value: number): dw.value.Money;
      /**
       * Returns a string representation of Money according to the regional settings configured for current request
       *  locale, for example '$59.00' or 'USD 59.00'.
       *
       * @return The formatted String representation of the passed money. In case of an error the string 'N/A' is returned.
       */
      toFormattedString(): string;
      /**
       * Returns a string representation for the numeric value of this money.
       *  The number is formatted with the decimal symbols of the platforms
       *  default locale.
       *
       * @return a string representation for the numeric value of this money.
       */
      toNumberString(): string;
      /**
       * Returns a string representation of this Money object.
       *
       * @return a string representation of this Money object.
       */
      toString(): string;
      /**
       * According to the ECMA spec returns the "natural" primitve value. Here
       *  the value portion of the Money is returned.
       *
       */
      valueOf(): any;
    }

    /**
     * Represents the quantity of an item.
     */
    class Quantity {
      /**
       * Identifies if the instance contains settings for value and unit.
       */
      readonly available: boolean;
      /**
       * The quantity as Decimal, null is returned when the quantity is not available.
       */
      readonly decimalValue: dw.util.Decimal;
      /**
       * The value for unit which identifies the
       *  unit of measure for the quantity. Examples of unit
       *  are 'inches' or 'pounds'.
       */
      readonly unit: string;
      /**
       * The quantity value.
       */
      readonly value: number;

      /**
       * Creates a new quantity instance with the specified value and unit.
       * @param value the actual quantity, must not be null
       * @param unit the unit identifier for the quantity, must not be null
       */
      constructor(value: number, unit: string);

      /**
       * Add Quantity object to the current object. Only objects representing the same unit can be added.
       * @param value Quantity object
       * @return Quantity object representing the sum of the operands
       */
      add(value: dw.value.Quantity): dw.value.Quantity;
      /**
       * Compares two Quantity values. An exception is thrown if the two Quantities values
       *  are of different unit. If one of the Quantity values represents the N/A value
       *  it is treated as 0.0.
       * @param other the other quantity to compare.
       * @return the comparison.
       */
      compareTo(other: dw.value.Quantity): number;
      /**
       * Divide Quantity object by specified divisor.
       * @param divisor divisor
       * @return Quantity object representing division result
       */
      divide(divisor: number): dw.value.Quantity;
      /**
       * Compares two decimal values whether they are equivalent.
       * @param other the object to compare against this quantity instance.
       * @return true if equal, false otherwise.
       */
      equals(other: any): boolean;
      /**
       * Returns the quantity as Decimal, null is returned when the quantity is not available.
       *
       * @return the quantity as Decimal
       */
      getDecimalValue(): dw.util.Decimal;
      /**
       * Returns the value for unit which identifies the
       *  unit of measure for the quantity. Examples of unit
       *  are 'inches' or 'pounds'.
       *
       * @return the unit value.
       */
      getUnit(): string;
      /**
       * Returns the quantity value.
       *
       * @return the quantity value.
       */
      getValue(): number;
      /**
       * Calculates the hash code for a decimal.
       *
       * @return the hash code.
       */
      hashCode(): number;
      /**
       * Identifies if the instance contains settings for value and unit.
       *
       * @return true if the instance is initialized with value and unit, false if the state is 'not available'.
       */
      isAvailable(): boolean;
      /**
       * Identifies if two Quantities have the same unit.
       * @param value the second quantity for the comparison.
       * @return true if both quantities have the same unit, false otherwise.
       */
      isOfSameUnit(value: dw.value.Quantity): boolean;
      /**
       * Multiply Quantity object by specified factor.
       * @param factor multiplication factor
       * @return Quantity object representing multiplication result
       */
      multiply(factor: number): dw.value.Quantity;
      /**
       * Method returns a new instance of Quantity with the same unit but
       *  different value. An N/A instance is returned if value is null.
       * @param value as a decimal
       * @return new Quantity instance with same unit
       */
      newQuantity(value: dw.util.Decimal): dw.value.Quantity;
      /**
       * Rounds the Quantity value to the number of specified decimal digits.
       * @param precision number of decimal digits after the decimal point
       * @return the new rounded Quantity value
       */
      round(precision: number): dw.value.Quantity;
      /**
       * Subtract Quantity object from the current object. Only objects representing the same unit can be subtracted.
       * @param value Quantity object to subtract
       * @return Quantity object representing the result of subtraction
       */
      subtract(value: dw.value.Quantity): dw.value.Quantity;
      /**
       * Returns a string representation of this quantity object.
       *
       * @return a string representation of this quantity object.
       */
      toString(): string;
      /**
       * According to the ECMA spec returns the "natural" primitive value. Here
       *  the value portion of the Quantity is returned.
       *
       */
      valueOf(): any;
    }
  }

  namespace web {
    /**
     * Used to generate and validate CSRF tokens. CSRFProtection allows
     *  applications to protect themselves against CSRF attacks, using
     *  synchronizer tokens, a best practice. Once created, these tokens
     *  are tied to a user&#x2019;s session and valid for 60 minutes.
     *  <p>
     *  Usage:<br>
     *  Adding CSRF token to forms:
     *
     *  </p><pre> //CSRF token generation
     *  &lt;form ... action=&quot;<protected location>&quot;&gt;
     *    &lt;input name=&quot;foo&quot; value=&quot;bar&quot;&gt;
     *    &lt;input name=&quot;${dw.web.CSRFProtection.getTokenName()}&quot;
     *              value=&quot;${dw.web.CSRFProtection.generateToken()&quot;&gt;
     *  &lt;/form&gt;
     *  </protected></pre>
     *
     *  Then, in scripts call:
     *
     *  <pre> dw.web.CSRFProtection.validateRequest();
     *  </pre>
     */
    class CSRFProtection {
      /**
       * The system generated CSRF token name. Currently, this name is not user configurable. Must be used for
       *  validateRequest() to work
       */
      static readonly tokenName: string;

      /**
       * Constructs a new unique CSRF token for this session.
       *
       * @return a new CSRF token
       */
      static generateToken(): string;
      /**
       * Returns the system generated CSRF token name. Currently, this name is not user configurable. Must be used for
       *  validateRequest() to work
       *
       * @return System-generated CSRF token parameter name
       */
      static getTokenName(): string;
      /**
       * Verifies that a client request contains a valid CSRF token, and that
       *  the token has not expired. Returns true if these conditions are met,
       *  and false otherwise
       *
       * @return true if request contains a valid CSRF token, false otherwise
       */
      static validateRequest(): boolean;
    }

    /**
     * Represents the click stream in the session. A maximum number of 50 clicks is
     *  recorded per session. After the maximum is reached, each time the customer
     *  clicks on a new link, the oldest click stream entry is purged. The
     *  ClickStream always remembers the first click.
     *  <p>
     *  The click stream is consulted when the GetLastVisitedProducts pipelet is
     *  called to retrieve the products that the customer has recently visited.</p>
     */
    class ClickStream {
      /**
       * A collection with all clicks. The first entry is the oldest
       *  entry. The last entry is the latest entry. The method returns a copy of
       *  the click stream, which makes it safe to work with the click stream,
       *  while it might be modified.
       */
      readonly clicks: dw.util.List<dw.web.ClickStreamEntry>;
      /**
       * Identifies if the clickstream recording is enabled or not.
       *  It is considered enabled if either:
       *  the method Session.isTrackingAllowed() returns true
       *  or if the above method returns false but the preference 'ClickstreamHonorDNT' is set to false.
       *
       *  When clickstream tracking is not enabled the getFirst method still operates as expected
       *  but the rest of the clicks are not collected.
       */
      readonly enabled: boolean;
      /**
       * The first click within this session. This first click
       *  is stored independent of whether entries are purged.
       */
      readonly first: dw.web.ClickStreamEntry;
      /**
       * The last recorded click stream, which is also typically
       *  the current click. In where rare cases (e.g. RedirectURL pipeline) this
       *  is not the current click, but instead the last recorded click.
       */
      readonly last: dw.web.ClickStreamEntry;
      /**
       * Identifies if this is only a partial click stream. If the maximum number
       *  of clicks (50) is recorded, the oldest entry is automatically purged with
       *  each additional click. In this case, this flag indicates that the click
       *  stream is only partial.
       */
      readonly partial: boolean;

      /**
       * Returns a collection with all clicks. The first entry is the oldest
       *  entry. The last entry is the latest entry. The method returns a copy of
       *  the click stream, which makes it safe to work with the click stream,
       *  while it might be modified.
       *
       * @return a collection of ClickStreamEntry instances, sorted chronologically.
       */
      getClicks(): dw.util.List<dw.web.ClickStreamEntry>;
      /**
       * Returns the first click within this session. This first click
       *  is stored independent of whether entries are purged.
       *
       * @return the first click within this session.
       */
      getFirst(): dw.web.ClickStreamEntry;
      /**
       * Returns the last recorded click stream, which is also typically
       *  the current click. In where rare cases (e.g. RedirectURL pipeline) this
       *  is not the current click, but instead the last recorded click.
       *
       * @return the last recorded click stream, which is also typically the current click.
       */
      getLast(): dw.web.ClickStreamEntry;
      /**
       * Identifies if the clickstream recording is enabled or not.
       *  It is considered enabled if either:
       *  the method Session.isTrackingAllowed() returns true
       *  or if the above method returns false but the preference 'ClickstreamHonorDNT' is set to false.
       *
       *  When clickstream tracking is not enabled the getFirst method still operates as expected
       *  but the rest of the clicks are not collected.
       *
       * @return whether clickstream tracking is enabled
       */
      isEnabled(): boolean;
      /**
       * Identifies if this is only a partial click stream. If the maximum number
       *  of clicks (50) is recorded, the oldest entry is automatically purged with
       *  each additional click. In this case, this flag indicates that the click
       *  stream is only partial.
       *
       * @return true if this click stream is partial, false otherwise.
       */
      isPartial(): boolean;
    }

    /**
     * Represent an entry in the click stream.
     */
    class ClickStreamEntry {
      /**
       * The host.
       */
      readonly host: string;
      /**
       * The locale sent from the user agent.
       */
      readonly locale: string;
      /**
       * The path.
       */
      readonly path: string;
      /**
       * The name of the called pipeline. In most cases the
       *  name can be derived from the path, but not in all cases. If with
       *  URL rewritting a special landing page is defined for a DNS name, than
       *  the system internally might use a specific pipeline associated with
       *  this landing page.
       */
      readonly pipelineName: string;
      /**
       * The query string.
       */
      readonly queryString: string;
      /**
       * The referer.
       */
      readonly referer: string;
      /**
       * The remote address.
       */
      readonly remoteAddress: string;
      /**
       * The entry's timestamp.
       */
      readonly timestamp: number;
      /**
       * The full URL for this click. The URL is returned as relative
       *  URL.
       */
      readonly url: string;
      /**
       * The user agent.
       */
      readonly userAgent: string;

      /**
       * Returns the host.
       *
       * @return the host.
       */
      getHost(): string;
      /**
       * Returns the locale sent from the user agent.
       *
       * @return the locale sent from the user agent.
       */
      getLocale(): string;
      /**
       * Returns a specific parameter value from the stored query
       *  string. The method can be used to extract a source code or
       *  affiliate id out of the URLs in the click stream.
       *
       *  The method returns null if there is no parameter with the given name.
       * @param name the name of the parameter.
       * @return the value associated with the specified parameter, or null.
       */
      getParameter(name: string): string;
      /**
       * Returns the path.
       *
       * @return the path.
       */
      getPath(): string;
      /**
       * Returns the name of the called pipeline. In most cases the
       *  name can be derived from the path, but not in all cases. If with
       *  URL rewritting a special landing page is defined for a DNS name, than
       *  the system internally might use a specific pipeline associated with
       *  this landing page.
       *
       * @return the name of the called pipeline.
       */
      getPipelineName(): string;
      /**
       * Returns the query string.
       *
       * @return the query string.
       */
      getQueryString(): string;
      /**
       * Returns the referer.
       *
       * @return the referer.
       */
      getReferer(): string;
      /**
       * Returns the remote address.
       *
       * @return the remote address.
       */
      getRemoteAddress(): string;
      /**
       * Returns the entry's timestamp.
       *
       * @return the entry's timestamp.
       */
      getTimestamp(): number;
      /**
       * Returns the full URL for this click. The URL is returned as relative
       *  URL.
       *
       * @return the full URL for this click.
       */
      getUrl(): string;
      /**
       * Returns the user agent.
       *
       * @return the user agent.
       */
      getUserAgent(): string;
    }

    /**
     * Represents an HTTP cookie used for storing information on a client browser.
     *  Cookies are passed along in the HTTP request and can be retrieved by
     *  calling dw.system.Request.getHttpCookies().
     *  <p>
     *  <b>Note:</b> this class allows access to sensitive security-related data.
     *  Pay special attention to PCI DSS v3. requirements 2, 4, and 12.
     *  </p><p>
     *  See <a href="class_dw_system_Request.html#dw_system_Request_getHttpCookies_DetailAnchor">Request.getHttpCookies()</a>.</p>
     */
    class Cookie {
      /**
       * Default name for cookies with empty strings.
       */
      static readonly EMPTYNAME = "dw_emptyname__";

      /**
       * The comment associated with the cookie.
       */
      comment: string;
      /**
       * The domain associated with the cookie.
       */
      domain: string;
      /**
       * Identifies if the cookie is http-only.
       */
      httpOnly: boolean;
      /**
       * The maximum age of the cookie, specified in seconds.
       *  By default, -1 indicating the cookie will persist until client shutdown.
       */
      maxAge: number;
      /**
       * The cookie's name.
       */
      readonly name: string;
      /**
       * The path for the cookie.
       */
      path: string;
      /**
       * Identifies if the cookie is secure.
       */
      secure: boolean;
      /**
       * The cookie's value.
       */
      value: string;
      /**
       * The version for the cookie. 0 means original Netscape cookie and
       *  1 means RFC 2109 compliant cookie.
       */
      version: number;

      /**
       * Constructs a new cookie using the specified name and value.
       * @param name the name for the cookie.
       * @param value the cookie's value.
       */
      constructor(name: string, value: string);

      /**
       * Returns the comment associated with the cookie.
       *
       * @return the comment associated with the cookie.
       */
      getComment(): string;
      /**
       * Returns the domain associated with the cookie.
       *
       * @return the domain associated with the cookie.
       */
      getDomain(): string;
      /**
       * Returns the maximum age of the cookie, specified in seconds.
       *  By default, -1 indicating the cookie will persist until client shutdown.
       *
       * @return an integer specifying the maximum age of the cookie in seconds; if negative, means the cookie persists until client shutdown
       */
      getMaxAge(): number;
      /**
       * Returns the cookie's name.
       *
       * @return the cookie's name.
       */
      getName(): string;
      /**
       * Returns the path for the cookie.
       *
       * @return the path for the cookie.
       */
      getPath(): string;
      /**
       * Identifies if the cookie is secure.
       *
       * @return true if the cookie is secure, false otherwise.
       */
      getSecure(): boolean;
      /**
       * Returns the cookie's value.
       *
       * @return the cookie's value.
       */
      getValue(): string;
      /**
       * Returns the version for the cookie. 0 means original Netscape cookie and
       *  1 means RFC 2109 compliant cookie.
       *
       * @return the version for the cookie.
       */
      getVersion(): number;
      /**
       * Identifies if the cookie is http-only.
       *
       * @return true if the cookie is http-only, false otherwise.
       */
      isHttpOnly(): boolean;
      /**
       * Sets the comment associated with the cookie.
       *
       *  Setting a comment automatically changes the cookie to be a RFC 2109
       *  (set-cookie2) compliant cookie, because comments are only supported with
       *  RFC cookies and not with Netscapes original cookie.
       * @param comment the comment associated with the cookie.
       */
      setComment(comment: string): void;
      /**
       * Sets the domain associated with the cookie.
       * @param domain the comment associated with the cookie.
       */
      setDomain(domain: string): void;
      /**
       * Sets the http-only state for the cookie.
       * @param httpOnly sets http-only state for the cookie.
       */
      setHttpOnly(httpOnly: boolean): void;
      /**
       * Sets the maximum age of the cookie in seconds.
       *
       *  A positive value indicates that the cookie will expire after that many
       *  seconds have passed. Note that the value is the maximum age when the
       *  cookie will expire, not the cookie's current age.
       *
       *  A negative value means that the cookie is not stored persistently and
       *  will be deleted when the client exits. A zero value causes the
       *  cookie to be deleted.
       * @param age an integer specifying the maximum age of the cookie in seconds; if negative, means the cookie is not stored; if zero, deletes the cookie
       */
      setMaxAge(age: number): void;
      /**
       * Sets the path for the cookie.
       * @param path the path for the cookie.
       */
      setPath(path: string): void;
      /**
       * Sets the secure state for the cookie.
       * @param secure sets secure state for the cookie.
       */
      setSecure(secure: boolean): void;
      /**
       * Sets the cookie's value.
       * @param value the value to set in the cookie.
       */
      setValue(value: string): void;
      /**
       * Sets the version for the cookie. 0 means original Netscape cookie and
       *  1 means RFC 2109 compliant cookie. The default is 0.
       * @param version the version for the cookie.
       */
      setVersion(version: number): void;
    }

    /**
     * The class provides an index and associative array like access to the Cookies
     *  of the current request. Cookies can be retrieved by calling
     *  dw.system.Request.getHttpCookies().
     *  <p>
     *  <b>Note:</b> this class allows access to sensitive security-related data.
     *  Pay special attention to PCI DSS v3. requirements 2, 4, and 12.
     *  </p><p>
     *  See <a href="class_dw_system_Request.html#dw_system_Request_getHttpCookies_DetailAnchor">Request.getHttpCookies()</a>.</p>
     */
    class Cookies {
      /**
       * The number of known cookies.
       */
      readonly cookieCount: number;
      /**
       * Returns the dw.web.Cookie with this name or null
       */
      readonly [name: string]: any;

      /**
       * Returns the number of known cookies.
       *
       * @return the number of cookies
       */
      getCookieCount(): number;
    }

    /**
     * The class is the top level element in the form instance hierachy.
     */
    class Form extends dw.web.FormGroup {
      /**
       * The secure key html name to be used for the hidden input field
       *  that will contain the secure key value.
       */
      readonly secureKeyHtmlName: string;
      /**
       * The secure key value that is generated for the form to use
       *  in a hidden input field for authentication.
       */
      readonly secureKeyValue: string;
      /**
       * Returns the Form element with this name.
       */
      readonly [name: string]: dw.web.FormElement | any;

      /**
       * Returns the secure key html name to be used for the hidden input field
       *  that will contain the secure key value.
       *
       * @return the secure key html name
       */
      getSecureKeyHtmlName(): string;
      /**
       * Returns the secure key value that is generated for the form to use
       *  in a hidden input field for authentication.
       *
       * @return the secure key value
       */
      getSecureKeyValue(): string;
    }

    /**
     * The FormAction class represents the action in form instance hierarchy.
     */
    class FormAction extends dw.web.FormElement {
      /**
       * The optional description for the action. The description could be used
       *  as tooltip for the action.
       */
      readonly description: string;
      /**
       * The optional label for the action. The label would be typically used
       *  as button text.
       */
      readonly label: string;
      /**
       * The object that was bound to the form in which the action
       *  is contained. The method is a convenience method for getParent().getObject().
       *  In most cases this is actually the object for which
       *  the specific action is triggered.
       */
      readonly object: any;
      /**
       * Identifies if the form action was submitted from
       *  the client to the server.
       */
      readonly submitted: boolean;
      /**
       * Identifies that this action is triggerd. An
       *  action is only triggered if it was submitted and the constraints, regarding
       *  a valid form, are met.
       */
      readonly triggered: boolean;
      /**
       * In case of an image button, returns the x coordinate of the last click.
       */
      readonly x: number;
      /**
       * In case of an image button, returns the y coordinate of the last click.
       */
      readonly y: number;

      /**
       * Returns the optional description for the action. The description could be used
       *  as tooltip for the action.
       *
       * @return the optional description for the action.
       */
      getDescription(): string;
      /**
       * Returns the optional label for the action. The label would be typically used
       *  as button text.
       *
       * @return the optional label for the action.
       */
      getLabel(): string;
      /**
       * Returns the object that was bound to the form in which the action
       *  is contained. The method is a convenience method for getParent().getObject().
       *  In most cases this is actually the object for which
       *  the specific action is triggered.
       *
       * @return the object that was bound to the form in which the action is contained.
       */
      getObject(): any;
      /**
       * In case of an image button, returns the x coordinate of the last click.
       *
       * @return the x coordinate of the last click.
       */
      getX(): number;
      /**
       * In case of an image button, returns the y coordinate of the last click.
       *
       * @return the y coordinate of the last click.
       */
      getY(): number;
      /**
       * Identifies if the form action was submitted from
       *  the client to the server.
       *
       * @return true if the form action was submitted, false otherwise.
       */
      isSubmitted(): boolean;
      /**
       * Identifies that this action is triggerd. An
       *  action is only triggered if it was submitted and the constraints, regarding
       *  a valid form, are met.
       *
       * @return true if the action is triggered, false otherwise.
       */
      isTriggered(): boolean;
    }

    /**
     * Represents a form element.
     */
    class FormElement {
      /**
       * A dynamic html name for the field. It can be used to suppress any autocompletion
       *  support from a browser, e.g. for credit card related fields. It can be also
       *  used for a unique form name, if one form is used multiple times in a page.
       */
      readonly dynamicHtmlName: string;
      /**
       * The ID of the form element. The is is unique within the parent
       *  element of the form.
       */
      readonly formId: string;
      /**
       * The global unique name of the field, which can be used as name
       *  in the html form. For radio buttons this name is not unique.
       */
      readonly htmlName: string;
      /**
       * The parent within the form.
       */
      readonly parent: dw.web.FormElement;
      /**
       * Identifies if this element and all its children elements are
       *  valid. A form element, which was not submitted in the last
       *  request is always valid.
       */
      readonly valid: boolean;
      /**
       * Provides a combined view on the validation status as per isValid() and getError(). In
       *  addition it also provides the data as returned by the validation in case a validation
       *  script was used.
       */
      readonly validationResult: dw.web.FormElementValidationResult;

      /**
       * This method clears the whole form. After clearing a form it
       *  contains no value or the default value, is not bound to any business
       *  object and has the status of being valid.
       *
       */
      clearFormElement(): void;
      /**
       * Returns a dynamic html name for the field. It can be used to suppress any autocompletion
       *  support from a browser, e.g. for credit card related fields. It can be also
       *  used for a unique form name, if one form is used multiple times in a page.
       *
       * @return a dynamic html name.
       */
      getDynamicHtmlName(): string;
      /**
       * The ID of the form element. The is is unique within the parent
       *  element of the form.
       *
       * @return the ID of the form.
       */
      getFormId(): string;
      /**
       * Returns the global unique name of the field, which can be used as name
       *  in the html form. For radio buttons this name is not unique.
       *
       * @return the global unique name of the field.
       */
      getHtmlName(): string;
      /**
       * The parent within the form.
       *
       * @return the parent within the form.
       */
      getParent(): dw.web.FormElement;
      /**
       * Provides a combined view on the validation status as per isValid() and getError(). In
       *  addition it also provides the data as returned by the validation in case a validation
       *  script was used.
       *
       * @return the validation status (valid, error, data)
       */
      getValidationResult(): dw.web.FormElementValidationResult;
      /**
       * The method can be called to explicitly invalidate a form element. The
       *  error text will be set to the one of two possible preconfigured custom
       *  error messages associated with the form definition. The "value-error"
       *  message will be used for FormField instances and "form-error" will be
       *  used for FormGroup instances.
       *
       */
      invalidateFormElement(): void;
      /**
       * The method can be called to explicitly invalidate a field. The error
       *  text is set to the given error message.
       * @param error the error text to use.
       */
      invalidateFormElement(error: string): void;
      /**
       * Identifies if this element and all its children elements are
       *  valid. A form element, which was not submitted in the last
       *  request is always valid.
       *
       * @return true if this element and all its children elements are valid, false otherwise.
       */
      isValid(): boolean;
    }

    /**
     * Represents a form element validation result. The validation script specified for form groups and fields can create
     *  such FormElementValidationResult with the desired validity, message and data and can then return it. The server side form
     *  element validation will evaluate these settings, i.e. calculate the corresponding element validity and message. The optional
     *  data provided with this instance will be kept and can be accessed again from the form element after server side validation.
     */
    class FormElementValidationResult {
      /**
       * Provides optional data acquired during validation.
       */
      readonly data: dw.util.Map<string, string>;
      /**
       * Provides an optional message in case of validation failure.
       */
      message: string;
      /**
       * States if the validation succeeded or failed.
       */
      valid: boolean;

      /**
       * Creates a FormElementValidationResult with given setting for the validity but without any message.
       * @param valid the desired validity
       */
      constructor(valid: boolean);
      /**
       * Creates a FormElementValidationResult with given setting for the validity and corresponding message.
       *  This is especially useful to represent a failed validation including some error message.
       * @param valid the desired validity
       * @param message the desired message
       */
      constructor(valid: boolean, message: string);
      /**
       * Creates a FormElementValidationResult with given setting for the validity and corresponding message.
       *  This is especially useful to represent a failed validation including some error message. Additional
       *  data can be stored, too.
       * @param valid the desired validity
       * @param message the desired message
       * @param data the desired data
       */
      constructor(valid: boolean, message: string, data: dw.util.Map<any, any>);

      /**
       * Adds optional data acquired during validation.
       * @param key the key for which the data value will be stored
       * @param value the data value that is stored for the given key
       */
      addData(key: any, value: any): void;
      /**
       * Provides optional data acquired during validation.
       *
       * @return the data acquired during validation
       */
      getData(): dw.util.Map<string, string>;
      /**
       * Provides an optional message in case of validation failure.
       *
       * @return the message for validation failure
       */
      getMessage(): string;
      /**
       * States if the validation succeeded or failed.
       *
       * @return true if the validation succeeded
       */
      isValid(): boolean;
      /**
       * Sets an optional message in case of validation failure.
       * @param message the message for validation failure
       */
      setMessage(message: string): void;
      /**
       * Sets if the validation succeeded or failed.
       * @param valid if the validation succeeded
       */
      setValid(valid: boolean): void;
    }

    /**
     * Represents a field in a form.
     */
    class FormField extends dw.web.FormElement {
      /**
       * Identifies if the current selected state of this field is checked. In case of
       *  a boolean field the method directly represent the boolean value. In case
       *  of a string or int field, the method returns true if the current value
       *  matched with the value specified as "selected-value". In this way a
       *  selected status can be as determined for non-boolean fields.
       */
      readonly checked: boolean;
      /**
       * An optinal description for the field.
       */
      readonly description: string;
      /**
       * The error text that will be shown to the user when the field is
       *  invalid. The error messages that may be returned by this method are
       *  defined in the form field definition under the following attribute names:
       *
       *
       *  missing-error
       *  parse-error
       *  range-error
       *  value-error
       *
       *
       *  The framework performs error checks in a specific order, and so if there
       *  are multiple errors for a single FormField, the following sequence
       *  defines which error is returned:
       *
       *
       *  When submitting a form entry, whitespace is first trimmed from user
       *  entry and the entry is parsed into native data type (boolean, date,
       *  integer, number, or string). A regex, if defined, is also matched against
       *  the input. If there is an error while parsing or matching with regex,
       *  "parse-error" is set as error.
       *  If field was marked as "mandatory" but there is no entry,
       *  "missing-error" is returned
       *  The min/max and minlength/maxlength checks are performed. If test
       *  failed, "range-error" is returned.
       *  value-error or form-error are returned when "invalidate()" was called
       *  programatically (or pipelet InvalidateFormElement is used)
       *
       *
       *  If the field is valid, this method returns null. If no error message was
       *  specified in the form field definition, this method also returns null.
       */
      readonly error: string;
      /**
       * indicates a boolean/checkbox field in the form definition
       */
      static FIELD_TYPE_BOOLEAN: number;
      /**
       * indicates a date field in the form definition
       */
      static FIELD_TYPE_DATE: number;
      /**
       * indicates an integer field in the form definition
       */
      static FIELD_TYPE_INTEGER: number;
      /**
       * indicates a number field in the form definition
       */
      static FIELD_TYPE_NUMBER: number;
      /**
       * indicates a string field in the form definition
       */
      static FIELD_TYPE_STRING: number;
      /**
       * The current external string representation of the
       *  value in this field.
       */
      htmlValue: string;
      /**
       * An optional label text for the field.
       */
      readonly label: string;
      /**
       * Indicates if the field is mandatory.
       */
      readonly mandatory: boolean;
      /**
       * The maximum length for the form field. A maximum length can
       *  be specified for all form data types, but is only used to validate fields
       *  of type "string". For other data types the value is just provided as an
       *  easy way to dynamically format the user interface. If not specified in
       *  the form definition the default minimum length is Integer.MAX_VALUE.
       */
      readonly maxLength: number;
      /**
       * The maximum value for a form field. A maximum value is only
       *  applicable for fields with the data type "int", "number" and "date".
       *  If a maximum value was not specified in the form definition the method
       *  returns null.
       */
      readonly maxValue: any;
      /**
       * The minimum length for the form field. A minimum length can
       *  be specified for all form data types, but is only used to validate fields
       *  of type "string". For other data types the value is just provided as an
       *  easy way to dynamically format the user interface. If not specified in
       *  the form definition the default minimum length is 0.
       */
      readonly minLength: number;
      /**
       * The minimum value for a form field. A minimum value is only
       *  applicable for fields with the data type "int", "number" and "date".
       *  If a minimum value was not specified in the form definition the method
       *  returns null.
       */
      readonly minValue: any;
      /**
       * A list of possible values for this field. The method
       *  is typically used to render a selection list or to render radio buttons.
       */
      options: dw.web.FormFieldOptions;
      /**
       * An optional regular expression pattern, which was set in the form
       *  definition. A pattern is only used for validation only for string fields.
       *  If no pattern was set, the method returns null.
       */
      readonly regEx: string;
      /**
       * Identifies if the current selected state of this field is selected. In case of
       *  a boolean field the method directly represent the boolean value. In case
       *  of a string or int field, the method returns true if the current value
       *  matched with the value specified as "selected-value". In this way a
       *  selected status can be as determined for non-boolean fields.
       */
      readonly selected: boolean;
      /**
       * The selected options or null if the field has no option
       *  or non is selected.
       */
      readonly selectedOption: dw.web.FormFieldOption;
      /**
       * The object that was optionally associated with the
       *  currently selected option.
       */
      readonly selectedOptionObject: any;
      /**
       * The method returns the type of the field. The type is one of the
       *  FIELD_TYPE constants defined in this class.
       */
      readonly type: number;
      /**
       * The internal value representation, which can be a string, a
       *  number, a boolean or a date.
       */
      value: any;

      /**
       * Returns an optinal description for the field.
       *
       * @return an optional description for the field.
       */
      getDescription(): string;
      /**
       * Returns the error text that will be shown to the user when the field is
       *  invalid. The error messages that may be returned by this method are
       *  defined in the form field definition under the following attribute names:
       *
       *
       *  missing-error
       *  parse-error
       *  range-error
       *  value-error
       *
       *
       *  The framework performs error checks in a specific order, and so if there
       *  are multiple errors for a single FormField, the following sequence
       *  defines which error is returned:
       *
       *
       *  When submitting a form entry, whitespace is first trimmed from user
       *  entry and the entry is parsed into native data type (boolean, date,
       *  integer, number, or string). A regex, if defined, is also matched against
       *  the input. If there is an error while parsing or matching with regex,
       *  "parse-error" is set as error.
       *  If field was marked as "mandatory" but there is no entry,
       *  "missing-error" is returned
       *  The min/max and minlength/maxlength checks are performed. If test
       *  failed, "range-error" is returned.
       *  value-error or form-error are returned when "invalidate()" was called
       *  programatically (or pipelet InvalidateFormElement is used)
       *
       *
       *  If the field is valid, this method returns null. If no error message was
       *  specified in the form field definition, this method also returns null.
       *
       * @return the error text that will be shown to the user when the field is invalid.
       */
      getError(): string;
      /**
       * Returns the current external string representation of the
       *  value in this field.
       *
       * @return the current external string representation of the value in this field.
       */
      getHtmlValue(): string;
      /**
       * Returns an optional label text for the field.
       *
       * @return an optional label text for the field.
       */
      getLabel(): string;
      /**
       * Returns the maximum length for the form field. A maximum length can
       *  be specified for all form data types, but is only used to validate fields
       *  of type "string". For other data types the value is just provided as an
       *  easy way to dynamically format the user interface. If not specified in
       *  the form definition the default minimum length is Integer.MAX_VALUE.
       *
       * @return maximum length or MAX_VALUE
       */
      getMaxLength(): number;
      /**
       * Returns the maximum value for a form field. A maximum value is only
       *  applicable for fields with the data type "int", "number" and "date".
       *  If a maximum value was not specified in the form definition the method
       *  returns null.
       *
       * @return maximum value or null
       */
      getMaxValue(): any;
      /**
       * Returns the minimum length for the form field. A minimum length can
       *  be specified for all form data types, but is only used to validate fields
       *  of type "string". For other data types the value is just provided as an
       *  easy way to dynamically format the user interface. If not specified in
       *  the form definition the default minimum length is 0.
       *
       * @return minimum length or 0
       */
      getMinLength(): number;
      /**
       * Returns the minimum value for a form field. A minimum value is only
       *  applicable for fields with the data type "int", "number" and "date".
       *  If a minimum value was not specified in the form definition the method
       *  returns null.
       *
       * @return minimum value or null
       */
      getMinValue(): any;
      /**
       * Returns a list of possible values for this field. The method
       *  is typically used to render a selection list or to render radio buttons.
       *
       * @return a list of possible values for this field.
       */
      getOptions(): dw.web.FormFieldOptions;
      /**
       * Returns an optional regular expression pattern, which was set in the form
       *  definition. A pattern is only used for validation only for string fields.
       *  If no pattern was set, the method returns null.
       *
       * @return the regular expression used for validation or null
       */
      getRegEx(): string;
      /**
       * Returns the selected options or null if the field has no option
       *  or non is selected.
       *
       * @return the selected options or null if the field has no option or non is selected.
       */
      getSelectedOption(): dw.web.FormFieldOption;
      /**
       * Returns the object that was optionally associated with the
       *  currently selected option.
       *
       * @return the object that was optionally associated with the currently selected option.
       */
      getSelectedOptionObject(): any;
      /**
       * The method returns the type of the field. The type is one of the
       *  FIELD_TYPE constants defined in this class.
       *
       * @return the type of the form field
       */
      getType(): number;
      /**
       * Returns the internal value representation, which can be a string, a
       *  number, a boolean or a date.
       *
       * @return the internal value representation, which can be a string, a number, a boolean or a date.
       */
      getValue(): any;
      /**
       * Identifies if the current selected state of this field is checked. In case of
       *  a boolean field the method directly represent the boolean value. In case
       *  of a string or int field, the method returns true if the current value
       *  matched with the value specified as "selected-value". In this way a
       *  selected status can be as determined for non-boolean fields.
       *
       * @return true if current selected state of this field is checked.
       */
      isChecked(): boolean;
      /**
       * Indicates if the field is mandatory.
       *
       * @return true if the field is mandatory, false otherwise.
       */
      isMandatory(): boolean;
      /**
       * Identifies if the current selected state of this field is selected. In case of
       *  a boolean field the method directly represent the boolean value. In case
       *  of a string or int field, the method returns true if the current value
       *  matched with the value specified as "selected-value". In this way a
       *  selected status can be as determined for non-boolean fields.
       *
       * @return true if current selected state of this field is checked.
       */
      isSelected(): boolean;
      /**
       * A form field has two value representations, the HTML value and the plain
       *  value. The HTML value is always a string representation of the field value.
       *  The plain value is the fully typed and validated field value.
       *
       *  The sets the HTML value for a field. The method is typically called from
       *  the HTTP POST processing framework. The method than parses, validates
       *  and assigns the value to the typed field value (see getValue()). If the
       *  value is invalid the typed field value is set to null and the valid
       *  flag is set to false. The error property contains an error message
       *  for the form.
       * @param htmlValue the HTML value to use.
       */
      setHtmlValue(htmlValue: string): void;
      /**
       * The method can be called to update an option list based on the
       *  given key and values in the given map.
       * @param optionValues a Map with the values for the option list
       */
      setOptions(optionValues: dw.util.Map<any, any>): void;
      /**
       * The method can be called to update an option list based on the
       *  given key and values in the given map. The method also expects
       *  and index range. This index range only makes sense when the Map is
       *  a SortedMap.
       * @param optionValues a Map with the values for the option list.
       * @param begin the index of the first element to use as option value.
       * @param end the last of the last element to use as option value.
       */
      setOptions(
        optionValues: dw.util.Map<any, any>,
        begin: number,
        end: number
      ): void;
      /**
       * The method can be called to update an option list based on the
       *  given iterator with objects. The option list is updated using
       *  the bindings specified in the form definition. If no bindings are
       *  specified in the form definition the elements are interpreted as
       *  pure strings.
       * @param optionValues an iterator hows elements are used as option values
       * @param begin the index of the first element to use as option value
       * @param end the last of the last element to use as option value
       */
      setOptions(
        optionValues: dw.util.Iterator<any>,
        begin: number,
        end: number
      ): void;
      /**
       * The method can be called to update an option list based on the
       *  given iterator with objects.
       * @param optionValues an iterator whose elements are used as option values
       */
      setOptions(optionValues: dw.util.Iterator<any>): void;
      /**
       * Sets the typed value of the field. The value is than immediately
       *  formatted into the external string representation, which is availble
       *  through the getHtmlValue() method. Also the valid flag is set
       *  to true. The actual value is not validated against the rules defined
       *  in the form definition. The method is typically used to directly set
       *  a typed value and to circumvent the validation rules.
       *
       *  The type of the argument must match with the type of the field.
       * @param value the value to set.
       */
      setValue(value: any): void;
    }

    /**
     * Represents an option for a form field.
     */
    class FormFieldOption {
      /**
       * Identifies if this option is checked.
       */
      readonly checked: boolean;
      /**
       * The value for the HTML value attribute of a HTML option element.
       */
      readonly htmlValue: string;
      /**
       * The value for the HTML label attribute of the HTML option element.
       *  If not specified in the form option definition the label is identical with
       *  the string representation of option value (see getValue()).
       */
      label: string;
      /**
       * The object that was bound to this option value.
       */
      readonly object: any;
      /**
       * The ID of the option. This is an internal ID used to uniquely
       *  reference this option. If not specified in the form option definition
       *  the ID is identical with the string representation of the option value
       *  (see getValue()).
       */
      readonly optionId: string;
      /**
       * The parent, which is a field element.
       */
      readonly parent: dw.web.FormField;
      /**
       * Identifies if this option is selected.
       */
      readonly selected: boolean;
      /**
       * The actual value associated with this option. This value is formatted
       *  and than returned as HTML value with the method getHtmlValue().
       */
      readonly value: any;

      /**
       * Returns the value for the HTML value attribute of a HTML option element.
       *
       * @return the value for the HTML value attribute of a HTML option element.
       */
      getHtmlValue(): string;
      /**
       * Returns the value for the HTML label attribute of the HTML option element.
       *  If not specified in the form option definition the label is identical with
       *  the string representation of option value (see getValue()).
       *
       * @return the value for the HTML label attribute of the HTML option element.
       */
      getLabel(): string;
      /**
       * Returns the object that was bound to this option value.
       *
       * @return the object that was bound to this option value.
       */
      getObject(): any;
      /**
       * Returns the ID of the option. This is an internal ID used to uniquely
       *  reference this option. If not specified in the form option definition
       *  the ID is identical with the string representation of the option value
       *  (see getValue()).
       *
       * @return the ID of the option.
       */
      getOptionId(): string;
      /**
       * The parent, which is a field element.
       *
       * @return the parent form field.
       */
      getParent(): dw.web.FormField;
      /**
       * The actual value associated with this option. This value is formatted
       *  and than returned as HTML value with the method getHtmlValue().
       *
       * @return the value associated with this option
       */
      getValue(): any;
      /**
       * Identifies if this option is checked.
       *
       * @return true if this option is checked, false otherwise.
       */
      isChecked(): boolean;
      /**
       * Identifies if this option is selected.
       *
       * @return true if this option is selected, false otherwise.
       */
      isSelected(): boolean;
      /**
       * Sets the label attribute for this option.
       * @param label the label value.
       */
      setLabel(label: string): void;
    }

    /**
     * The class represents the list of options for a field. The class supports
     *  an index style access to the options, e.g. myfield.options[2] or
     *  myfield.options.red.
     */
    class FormFieldOptions {
      /**
       * The number of option values.
       */
      readonly optionsCount: number;

      /**
       * Returns the number of option values.
       *
       */
      getOptionsCount(): number;
    }

    /**
     * The class is the central class within the whole form handling. It is
     *  the container element for fields and other form elements. A form group
     *  can contain other forms, also called sub-forms.
     *
     *  Access to the elements of a form is provided via an index based access or
     *  via an associative array access. For example, the field &quot;firstname&quot; can be accessed
     *  with the expression &quot;myform.firstname&quot;.
     */
    class FormGroup extends dw.web.FormElement {
      /**
       * The number of elements in the form.
       */
      readonly childCount: number;
      /**
       * A form-wide error message. If no error message
       *  is present the method returns null.
       */
      readonly error: string;
      /**
       * The object that was bound to this form group.
       */
      readonly object: any;
      /**
       * The action that was submitted with the last request. The action is
       *  set independent whether the form must be valid for this action. The method
       *  returns null if no action at all was submitted with the last request for this
       *  form group.
       */
      readonly submittedAction: dw.web.FormAction;
      /**
       * The action that was triggered with the last request. An action is
       *  only marked as triggered if the constraints regarding form validation are
       *  meet. The method returns null if no action was marked as triggered.
       */
      readonly triggeredAction: dw.web.FormAction;

      /**
       * The method copies the value from a form into the object, which was previously
       *  bound to the form. The method is equivalent to the pipelet AcceptForm.
       *
       *  This method is equivalent to the call formgroup.copyFrom( formgroup.object ).
       *
       */
      accept(): void;
      /**
       * The method updates the form with the values from the given object.
       *
       *  The method call is basically equivalent to the pipelet UpdateFormWithObject.
       *
       *  The method not only copies the value, it also binds the object to the form. Binding means that the form keeps the
       *  information from which objects the values were taken. This can be used for two purposes:
       *
       *  for lists it makes it easier in the code to find the associated object, for example in case of a related
       *  action, and
       *  it allows to copy back the values from the form into the object (see accept()).
       *
       *  Because of this bind behavior, the operation is also sometimes called a bind-operation.
       * @param obj the object from, which the values are read
       */
      copyFrom(obj: any): void;
      /**
       * The method updates the object with the values from the form.
       *
       *  The method call is basically equivalent to the pipelet UpdateObjectWithForm.
       *
       *  The method needs a submitted form. The copyTo call is delegated to the form fields. Each form field than checks
       *  if its value was submitted as part of the form:
       *
       *  If this is true, the object gets updated with the form field value.
       *  If this is false, the object will not be updated.
       *
       *  This is the reason why you cannot copy values from one object into another object by using
       *  copyFrom(Object) and copyTo(Object) within the same request (e.g. by one call to a script or
       *  controller).
       * @param obj the object, which is updated from the form
       */
      copyTo(obj: any): void;
      /**
       * Returns the number of elements in the form.
       *
       * @return the number of elements in the form.
       */
      getChildCount(): number;
      /**
       * Returns a form-wide error message. If no error message
       *  is present the method returns null.
       *
       * @return a form-wide error message or null.
       */
      getError(): string;
      /**
       * The object that was bound to this form group.
       *
       * @return the bound object.
       */
      getObject(): any;
      /**
       * Returns the action that was submitted with the last request. The action is
       *  set independent whether the form must be valid for this action. The method
       *  returns null if no action at all was submitted with the last request for this
       *  form group.
       *
       * @return the action that was submitted with the last request or null.
       */
      getSubmittedAction(): dw.web.FormAction;
      /**
       * Returns the action that was triggered with the last request. An action is
       *  only marked as triggered if the constraints regarding form validation are
       *  meet. The method returns null if no action was marked as triggered.
       *
       * @return the action that was triggered with the last request.
       */
      getTriggeredAction(): dw.web.FormAction;
    }

    /**
     * Represents a list of forms.
     */
    class FormList extends dw.web.FormGroup {
      /**
       * The selected list items if the list is
       *  configured to support selection of items.
       */
      readonly selectManyItems: dw.util.List<dw.web.FormListItem>;
      /**
       * A list of all selected objects if the list is configured
       *  to support the selection of items. The objects are the objects that were
       *  bound to each row.
       */
      readonly selectManyObjects: dw.util.List<any>;
      /**
       * The default list item if the list is configured to
       *  support the selection of a default item.
       */
      readonly selectOneItem: dw.web.FormListItem;
      /**
       * The selected object if the list is configured to
       *  support the selection of a default item. The object is the object
       *  bound to the item.
       */
      readonly selectOneObject: any;

      /**
       * returns the selected list items if the list is
       *  configured to support selection of items.
       *
       * @return a List of FormListItem elements or null if no selection was configured for the form.
       */
      getSelectManyItems(): dw.util.List<dw.web.FormListItem>;
      /**
       * Returns a list of all selected objects if the list is configured
       *  to support the selection of items. The objects are the objects that were
       *  bound to each row.
       *
       * @return a List of objects or null if no selection was configured for the form.
       */
      getSelectManyObjects(): dw.util.List<any>;
      /**
       * Returns the default list item if the list is configured to
       *  support the selection of a default item.
       *
       * @return the default FormListItem elements or null if no selection was configured
       */
      getSelectOneItem(): dw.web.FormListItem;
      /**
       * Returns the selected object if the list is configured to
       *  support the selection of a default item. The object is the object
       *  bound to the item.
       *
       * @return the selected object.
       */
      getSelectOneObject(): any;
    }

    /**
     * Represents an item in a form list.
     */
    class FormListItem extends dw.web.FormGroup {
      /**
       * The index of this item with the list.
       */
      readonly itemIndex: number;

      /**
       * Returns the index of this item with the list.
       *
       * @return the index of this item with the list.
       */
      getItemIndex(): number;
    }

    /**
     * The Forms object provides access to all current forms in the session. The individual forms are retrieved as a dynamic
     *  property, for example &apos;forms.searchform&apos;. It is typically retrieved from the session via
     *  <a href="class_dw_system_Session.html#dw_system_Session_getForms_DetailAnchor">Session.getForms()</a>. But it is also available in the <a href="class_dw_system_PipelineDictionary.html">PipelineDictionary</a> and can be
     *  accessed via &apos;pdict.CurrentForms&apos;.
     *  <p>
     *  Note that values stored with a form on the session are deleted if the request locale is changed during the session.</p>
     */
    class Forms {
      /**
       * Returns the Form with this name.
       */
      readonly [name: string]: dw.web.Form;
    }

    /**
     * Represents an HTTP parameter.
     */
    class HttpParameter {
      /**
       * The value of the current HttpParameter attribute as a boolean. If
       *  there is more than one value defined, only the first one is returned. For an
       *  undefined attribute it returns null.
       */
      readonly booleanValue: boolean;
      /**
       * The value of the current HttpParameter attribute as a date. If
       *  there is more than one value defined, only the first one is returned. For
       *  an undefined attribute and if attribute is not a date it return null.
       */
      readonly dateValue: Date;
      /**
       * The value of the current HttpParameter attribute as a number. If
       *  there is more than one value defined, only the first one is returned. For
       *  an undefined attribute it returns 0.0.
       */
      readonly doubleValue: number;
      /**
       * Identifies if there is a value for the http parameter attribute
       *  and whether the value is empty.
       *  A value is treated as empty if it's not blank.
       */
      readonly empty: boolean;
      /**
       * The value of the current HttpParameter attribute as int. If there
       *  is more than one value defined, only the first one is returned. For an
       *  undefined attribute it returns null.
       */
      readonly intValue: number;
      /**
       * The raw value for this HttpParameter instance.
       *  The raw value is the not trimmed String value of this HTTP parameter.
       *  If there is more than one value defined, only the first one is returned. For an
       *  undefined attribute the method returns a null.
       */
      readonly rawValue: string;
      /**
       * A Collection of all raw values for this HTTP parameter.
       *  The raw value is the not trimmed String value of this HTTP parameter.
       */
      readonly rawValues: dw.util.Collection<string>;
      /**
       * The value of the current HttpParameter attribute. If there is
       *  more than one value defined, only the first one is returned. For an
       *  undefined attribute the method returns a null.
       */
      readonly stringValue: string;
      /**
       * A Collection of all defined values for this HTTP parameter.
       */
      readonly stringValues: dw.util.Collection<string>;
      /**
       * Identifies if the parameter was submitted. This is equivalent to the
       *  check, whether the parameter has a value.
       */
      readonly submitted: boolean;
      /**
       * The value of the current HttpParameter attribute. If there is
       *  more than one value defined, only the first one is returned. For an
       *  undefined attribute the method returns null.
       */
      readonly value: string;
      /**
       * A Collection of all defined values for this current HTTP parameter.
       */
      readonly values: dw.util.Collection<string>;

      /**
       * Identifies if the given value is part of the actual values.
       * @param value the value to check.
       * @return true if the value is among the actual values, false otherwise.
       */
      containsStringValue(value: string): boolean;
      /**
       * Returns the value of the current HttpParameter attribute as a boolean. If
       *  there is more than one value defined, only the first one is returned. For an
       *  undefined attribute it returns null.
       *
       * @return the actual value as a boolean or null of no value is available.
       */
      getBooleanValue(): boolean;
      /**
       * Returns the value of the current HttpParameter attribute as a boolean. If there
       *  is more than one value defined, only the first one is returned. For an
       *  undefined attribute it returns the given default value.
       * @param defaultValue the default value to use.
       * @return the value of the parameter or the default value if empty.
       */
      getBooleanValue(defaultValue: boolean): boolean;
      /**
       * Returns the value of the current HttpParameter attribute as a date. If
       *  there is more than one value defined, only the first one is returned. For
       *  an undefined attribute and if attribute is not a date it return null.
       *
       * @return the actual value as date or null if empty.
       */
      getDateValue(): Date;
      /**
       * Returns the value of the current HttpParameter attribute as a date. If
       *  there is more than one value defined, only the first one is returned. For
       *  an undefined attribute it returns the given default value and if
       *  the attributes is not a date it returns null.
       * @param defaultValue the default value to use.
       * @return the data value of the attribute or the default value if empty
       */
      getDateValue(defaultValue: Date): Date;
      /**
       * Returns the value of the current HttpParameter attribute as a number. If
       *  there is more than one value defined, only the first one is returned. For
       *  an undefined attribute it returns 0.0.
       *
       * @return the actual value as double or null if the parameter has no value.
       */
      getDoubleValue(): number;
      /**
       * Returns the value of the current HttpParameter attribute as a number. If
       *  there is more than one value defined, only the first one is returned. For
       *  an undefined attribute it returns the given default value.
       * @param defaultValue the default value to use.
       * @return the actual value as double or the default value if empty.
       */
      getDoubleValue(defaultValue: number): number;
      /**
       * Returns the value of the current HttpParameter attribute as int. If there
       *  is more than one value defined, only the first one is returned. For an
       *  undefined attribute it returns null.
       *
       * @return the actual value as an integer or null of no value is available.
       */
      getIntValue(): number;
      /**
       * Returns the value of the current HttpParameter attribute as an integer. If there
       *  is more than one value defined, only the first one is returned. For an
       *  undefined attribute it returns the given default value.
       * @param defaultValue the default value to use.
       * @return the value of the parameter or the default value if empty.
       */
      getIntValue(defaultValue: number): number;
      /**
       * Returns the raw value for this HttpParameter instance.
       *  The raw value is the not trimmed String value of this HTTP parameter.
       *  If there is more than one value defined, only the first one is returned. For an
       *  undefined attribute the method returns a null.
       *
       * @return the actual value or null.
       */
      getRawValue(): string;
      /**
       * Returns a Collection of all raw values for this HTTP parameter.
       *  The raw value is the not trimmed String value of this HTTP parameter.
       *
       * @return the raw values as a Collection of String, might be empty
       */
      getRawValues(): dw.util.Collection<string>;
      /**
       * Returns the value of the current HttpParameter attribute. If there is
       *  more than one value defined, only the first one is returned. For an
       *  undefined attribute the method returns a null.
       *
       * @return the actual value or null.
       */
      getStringValue(): string;
      /**
       * Returns the value of the current HttpParameter attribute. If there is
       *  more than one value defined, only the first one is returned. For an
       *  undefined attribute the method returns the given default value.
       * @param defaultValue the default value to use.
       * @return the actual value or the default value.
       */
      getStringValue(defaultValue: string): string;
      /**
       * Returns a Collection of all defined values for this HTTP parameter.
       *
       * @return the actual values as Collection.
       */
      getStringValues(): dw.util.Collection<string>;
      /**
       * Returns the value of the current HttpParameter attribute. If there is
       *  more than one value defined, only the first one is returned. For an
       *  undefined attribute the method returns null.
       *
       * @return the actual value or null.
       */
      getValue(): string;
      /**
       * Returns a Collection of all defined values for this current HTTP parameter.
       *
       * @return the actual values as Collection.
       */
      getValues(): dw.util.Collection<string>;
      /**
       * Identifies if the given String is an actual value of this http parameter.
       * @param value the value to check.
       * @return true if the value is among the actual values, false otherwise.
       */
      isChecked(value: string): boolean;
      /**
       * Identifies if there is a value for the http parameter attribute
       *  and whether the value is empty.
       *  A value is treated as empty if it's not blank.
       *
       * @return true if a value is empty, false otherwise.
       */
      isEmpty(): boolean;
      /**
       * Identifies if the parameter was submitted. This is equivalent to the
       *  check, whether the parameter has a value.
       *
       * @return true if a value is there, false otherwise.
       */
      isSubmitted(): boolean;
      /**
       * Returns the value of the current HttpParameter attribute. If there is
       *  more than one value defined, only the first one is returned. For an
       *  undefined attribute the method returns an empty string.
       *
       * @return the actual value or an empty String.
       */
      toString(): string;
    }

    /**
     * A map of HTTP parameters.
     */
    class HttpParameterMap {
      /**
       * The number of paramters in this http parameter map.
       */
      readonly parameterCount: number;
      /**
       * A collection of all parameter names.
       */
      readonly parameterNames: dw.util.Set<string>;
      /**
       * The HTTP request body as string (e.g. useful for XML posts). A body
       *  is only returned if the request is a POST or PUT request and was not send
       *  with "application/x-www-form-urlencoded" encoding. If the request was send
       *  with that encoding it is interpreted as form data and the body will be empty.
       */
      readonly requestBodyAsString: string;
      /**
       * Returns the HttpParameter with this name.
       */
      readonly [name: string]: dw.web.HttpParameter | any;

      /**
       * Returns the http parameter for the given key or an empty http parameter,
       *  if no parameter is defined for that key. An empty parameter returns
       *  false for the method isDefined().
       * @param name the key whose associated http parameter is to be returned.
       * @return the http parameter or an empty http parameter.
       */
      get(name: any): dw.web.HttpParameter;
      /**
       * Returns the number of paramters in this http parameter map.
       *
       * @return the number parameters.
       */
      getParameterCount(): number;
      /**
       * Returns a sub-map containing all parameters that start with the given
       *  prefix. The prefix will be removed from the parameter names in the returned
       *  sub-map. For example with the parameters "pre_P1" and "pre_p2" a call with
       *  "pre_" as parameter will return a HttpParameterMap containing "P1" and "P2".
       * @param prefix the prefix to use when creating the sub-map.
       * @return the sub-map containing the target parameters.
       */
      getParameterMap(prefix: string): dw.web.HttpParameterMap;
      /**
       * Returns a collection of all parameter names.
       *
       * @return a set of all parameter names
       */
      getParameterNames(): dw.util.Set<string>;
      /**
       * Returns the HTTP request body as string (e.g. useful for XML posts). A body
       *  is only returned if the request is a POST or PUT request and was not send
       *  with "application/x-www-form-urlencoded" encoding. If the request was send
       *  with that encoding it is interpreted as form data and the body will be empty.
       *
       * @return the http request body
       */
      getRequestBodyAsString(): string;
      /**
       * Identifies if the parameter has been submitted.
       * @param key the parameter to check.
       * @return true if the parameter has been submitted, false otherwise.
       */
      isParameterSubmitted(key: string): boolean;
      /**
       * This method can be called to process a form submission for an HTML form
       *  with encoding type "multipart/form-data". Such a form can have a mixture
       *  of "regular" HTML form fields and also file uploads.
       *
       *  Form fields are available via get(Object) without calling this method.
       *  Uploaded files still need to be processed via the passed callback function.
       *
       *  This callback function is called for each file upload part in the request.
       *  The parameters are the field name, the content type and the original file
       *  name. The function can return either a null, which means that the upload
       *  of this part should be skipped, or return a dw.io.File instance. If the
       *  file is an existing directory the system will automatically generate a
       *  unique file name. If the file is not an existing directory the uploaded
       *  content will be directly stored into that file. An existing file with the
       *  same name will be deleted. If the file can't be deleted for whatever reason,
       *  the upload is stored with a generated unique file name in the indicated directory.
       *
       *  An automatically generated file name consists of the the prefix "upload",
       *  a time stamp, a unique id and the extension tmp. For example:
       *  "upload_20070114221535_bc7H1aOadI9qYaaacovPd3lqna.tmp".
       *
       *
       *  var params : HttpParameterMap = pdict.CurrentHttpParameterMap;
       *
       *  // Get the file name from the first field. This is works because the
       *  // parameter map is updated before the file part is parsed.
       *  var files : LinkedHashMap = params.processMultipart( (function( field, ct, oname ){
       *      return new File( File.IMPEX + "/" + params.firstField );
       *  }) );
       * @param callback a callback function, which takes the field name, content type and original file name as input
       * @return a LinkedHashMap where the keys are the actual file names and the values are references to the File, or null if this is not a multipart request
       */
      processMultipart(callback: Function): dw.util.LinkedHashMap<any, any>;
    }

    /**
     * Iterator used in &lt;ISLOOP&gt; implementation. It defines properties used to determine loop status.
     *  LoopIterator object is assigned to variable declared in &quot;status&quot; attribute of the &lt;ISLOOP&gt; tag.
     */
    class LoopIterator extends dw.util.Iterator<any> {
      /**
       * Return begin iteration index. By default begin index is 0.
       */
      readonly begin: number;
      /**
       * Return iteration count, starting with 1.
       */
      readonly count: number;
      /**
       * Return end iteration index. By default end index equals 'length - 1', provided that length is determined.
       *  If length cannot be determined end index is -1.
       */
      readonly end: number;
      /**
       * Identifies if count is an even value.
       */
      readonly even: boolean;
      /**
       * Identifies if the iterator is positioned at first iteratable item.
       */
      readonly first: boolean;
      /**
       * Return iteration index, which is the position of the iterator in the underlying iteratable object.
       *  Index is 0-based and is calculated according the following formula: Index = (Count - 1) * Step.
       */
      readonly index: number;
      /**
       * Identifies if the iterator is positioned at last iteratable item.
       */
      readonly last: boolean;
      /**
       * Return the length of the object. If length cannot be determined, -1 is returned.
       */
      readonly length: number;
      /**
       * Identifies if count is an odd value.
       */
      readonly odd: boolean;
      /**
       * Return iterator step.
       */
      readonly step: number;

      /**
       * Return begin iteration index. By default begin index is 0.
       *
       * @return the begin iteration index.
       */
      getBegin(): number;
      /**
       * Return iteration count, starting with 1.
       *
       * @return the iteration count.
       */
      getCount(): number;
      /**
       * Return end iteration index. By default end index equals 'length - 1', provided that length is determined.
       *  If length cannot be determined end index is -1.
       *
       */
      getEnd(): number;
      /**
       * Return iteration index, which is the position of the iterator in the underlying iteratable object.
       *  Index is 0-based and is calculated according the following formula: Index = (Count - 1) * Step.
       *
       * @return the iteration index.
       */
      getIndex(): number;
      /**
       * Return the length of the object. If length cannot be determined, -1 is returned.
       *
       * @return the length of the object
       */
      getLength(): number;
      /**
       * Return iterator step.
       *
       * @return the iterator step.
       */
      getStep(): number;
      /**
       * Identifies if count is an even value.
       *
       * @return true if count is even, false otherwise.
       */
      isEven(): boolean;
      /**
       * Identifies if the iterator is positioned at first iteratable item.
       *
       * @return true if the iterator is at first item, false otherwise.
       */
      isFirst(): boolean;
      /**
       * Identifies if the iterator is positioned at last iteratable item.
       *
       * @return true if iterator is at last item, false otherwise.
       */
      isLast(): boolean;
      /**
       * Identifies if count is an odd value.
       *
       * @return true if count is odd, false otherwise.
       */
      isOdd(): boolean;
    }

    /**
     * Contains meta data about the page.
     *
     *  For each request an instance of this class will be placed in the pipeline
     *  dictionary under the key &quot;CurrentPageMetaData&quot;.
     *  The information stored in CurrentPageMetaData can be referenced in templates
     *  and rendered in an HTML head section:
     *  for example:
     *  <pre> <code>
     *  &lt;head&gt;
     *  &lt;title&gt;${pdict.CurrentPageMetaData.title}&lt;/title&gt;
     *  &lt;meta name=&quot;description&quot; content=&quot;${pdict.CurrentPageMetaData.description}&quot;/&gt;
     *  .
     *  .
     *  .
     *  &lt;/head&gt;
     *  </code>
     *  </pre>
     *
     *  To update the CurrentPageMetaData there is the pipelet UpdatePageMetaData
     *  provided.
     */
    class PageMetaData {
      /**
       * The page's description.
       */
      description: string;
      /**
       * The page's key words.
       */
      keywords: string;
      /**
       * All page meta tags added to this container.
       */
      readonly pageMetaTags: Array<dw.web.PageMetaTag>;
      /**
       * The page's title.
       */
      title: string;

      /**
       * Adds a page meta tag to this container.
       * @param pageMetaTag the page meta tag to be added
       */
      addPageMetaTag(pageMetaTag: dw.web.PageMetaTag): void;
      /**
       * Adds a page meta tags list to this container.
       * @param pageMetaTags the page meta tags list to be added
       */
      addPageMetaTags(pageMetaTags: Array<any>): void;
      /**
       * Returns the page's description.
       *
       * @return the page's description.
       */
      getDescription(): string;
      /**
       * Returns the page's key words.
       *
       * @return the page's key words.
       */
      getKeywords(): string;
      /**
       * Returns all page meta tags added to this container.
       *
       * @return page meta tags
       */
      getPageMetaTags(): Array<dw.web.PageMetaTag>;
      /**
       * Returns the page's title.
       *
       * @return the page's title.
       */
      getTitle(): string;
      /**
       * Returns true if a page meta tag with the given ID is set, false otherwise.
       * @param id the ID to be check if a page meta tag is set
       * @return true if a page meta tag with the given ID is set, false otherwise
       */
      isPageMetaTagSet(id: string): boolean;
      /**
       * Sets the page's description.
       * @param description the page's description.
       */
      setDescription(description: string): void;
      /**
       * Sets the page's key words.
       * @param keywords the page's key words.
       */
      setKeywords(keywords: string): void;
      /**
       * Sets the page's title.
       * @param title the page's title.
       */
      setTitle(title: string): void;
    }

    /**
     * Page meta tags are used in HTML documents to provide structured data about a web
     *  page. They are usually part of the head section. Common tags are for example robots,
     *  description or social tags like open graph (e.g. &apos;og:title&apos;). <p>
     *
     *  Page meta tags can be obtained within:
     *
     *  </p><ul>
     *      <li>home page context</li>
     *      <ul>
     *          <li><a href="class_dw_system_Site.html">Site</a></li>
     *      </ul>
     *      <li>detail page context</li>
     *      <ul>
     *          <li><a href="class_dw_catalog_Product.html">Product</a></li>
     *          <li><a href="class_dw_content_Content.html">Content</a></li>
     *      </ul>
     *      <li>listing page context</li>
     *      <ul>
     *          <li><a href="class_dw_catalog_ProductSearchModel.html">ProductSearchModel</a></li>
     *          <li><a href="class_dw_content_ContentSearchModel.html">ContentSearchModel</a></li>
     *      </ul>
     *  </ul>
     *
     *  and can be set at <a href="class_dw_web_PageMetaData.html">PageMetaData</a> container object, which is always available
     *  in the pipeline dictionary and is used as transfer object to fill the head area with meaningful
     *  page meta tag elements.
     */
    class PageMetaTag {
      /**
       * The page meta tag content.
       */
      readonly content: string;
      /**
       * The page meta tag ID.
       */
      readonly ID: string;
      /**
       * Returns true if the page meta tag type is name, false otherwise.
       */
      readonly name: boolean;
      /**
       * Returns true if the page meta tag type is property, false otherwise.
       */
      readonly property: boolean;
      /**
       * Returns true if the page meta tag type is title, false otherwise.
       */
      readonly title: boolean;

      /**
       * Returns the page meta tag content.
       *
       * @return page meta tag content
       */
      getContent(): string;
      /**
       * Returns the page meta tag ID.
       *
       * @return page meta tag ID
       */
      getID(): string;
      /**
       * Returns true if the page meta tag type is name, false otherwise.
       *
       * @return true if the page meta tag type is name, false otherwise
       */
      isName(): boolean;
      /**
       * Returns true if the page meta tag type is property, false otherwise.
       *
       * @return true if the page meta tag type is property, false otherwise
       */
      isProperty(): boolean;
      /**
       * Returns true if the page meta tag type is title, false otherwise.
       *
       * @return true if the page meta tag type is title, false otherwise
       */
      isTitle(): boolean;
    }

    /**
     * A page model is a helper class to apply a pages to a collection of
     *  elements or an iterator of elements and supports creating URLs for
     *  continued paging through the elements.
     *
     *  The page model is intended to be initialized with the collection or
     *  iterator, than the paging position is applyed and than the elements are
     *  extracted with getPageElements().
     *
     *  In case the page model is initialized with a collection the page model
     *  can be reused multiple times.
     */
    class PagingModel<T> {
      /**
       * The default page size.
       */
      static readonly DEFAULT_PAGE_SIZE = 10;
      /**
       * The maximum supported page size.
       */
      static readonly MAX_PAGE_SIZE = 2000;
      /**
       * The URL Parameter used for the page size.
       */
      static readonly PAGING_SIZE_PARAMETER = "sz";
      /**
       * The URL parameter used for the start position.
       */
      static readonly PAGING_START_PARAMETER = "start";

      /**
       * The count of the number of items in the model.
       */
      readonly count: number;
      /**
       * The index number of the current page. The page
       *  counting starts with 0. The method also works with a miss-aligned
       *  start. In that case the start is always treated as the start of
       *  a page.
       */
      readonly currentPage: number;
      /**
       * Identifies if the model is empty.
       */
      readonly empty: boolean;
      /**
       * The index of the last element on the current page.
       */
      readonly end: number;
      /**
       * The maximum possible page number. Counting for pages starts
       *  with 0.  The method also works with a miss-aligned start. In that case
       *  the returned number might be higher than ((count-1) / pageSize).
       */
      readonly maxPage: number;
      /**
       * The total page count. The method also works
       *  with a miss-aligned start. In that case the returned number might
       *  be higher than (count / pageSize).
       */
      readonly pageCount: number;
      /**
       * An iterator that can be used to iterate through the elements of
       *  the current page.
       *
       *  In case of a collection as the page models source, the method can be
       *  called multiple times. Each time a fresh iterator is returned.
       *
       *  In case of an iterator as the page models source, the method must be
       *  called only once. The method will always return the same iterator,
       *  which means the method amy return an exhausted iterator.
       */
      readonly pageElements: dw.util.Iterator<T>;
      /**
       * The size of the page.
       */
      pageSize: number;
      /**
       * The current start position from which iteration will start.
       */
      start: number;

      /**
       * Constructs the PagingModel using the specified iterator and count value.
       *  Count must not be negative.
       *
       *  Note: A valid count must be provided. The PageModel class can not be used
       *  if the number of elements is unknown. Without knowning the number of
       *  elements it still would be possible to return the elements of a particular
       *  page, but it would be not possible to calculate data like the total number
       *  of pages or to construct an URL to jump to a particular page.
       * @param elements the iterator containing the model elements.
       * @param count the count of elements.
       */
      constructor(elements: dw.util.Iterator<T>, count: number);
      /**
       * Constructs the PagingModel using the specified collection.
       * @param elements the collection containing the model elements.
       */
      constructor(elements: dw.util.Collection<T>);

      /**
       * Returns an URL containing the page size parameter appended to the
       *  specified url. The name of the page size parameter is 'sz' (see
       *  PAGE_SIZE_PARAMETER). The start position parameter is not appended to the
       *  returned URL.
       * @param url the URL to append the page size parameter to.
       * @param pageSize the page size
       * @return an URL that contains the page size parameter.
       */
      static appendPageSize(url: dw.web.URL, pageSize: number): dw.web.URL;
      /**
       * Returns an URL by appending the current page start position and the
       *  current page size to the URL.
       * @param url the URL to append the current paging position to.
       * @return an URL containing the current paging position.
       */
      appendPaging(url: dw.web.URL): dw.web.URL;
      /**
       * Returns an URL by appending the paging parameters for a desired
       *  page start position and the current page size to the specified url. The name of
       *  the page start position parameter is 'start' (see PAGING_START_PARAMETER)
       *  and the page size parameter is 'sz' (see PAGE_SIZE_PARAMETER).
       * @param url the URL to append the paging parameter to.
       * @param position the start position.
       * @return an URL that contains the paging parameters.
       */
      appendPaging(url: dw.web.URL, position: number): dw.web.URL;
      /**
       * Returns the count of the number of items in the model.
       *
       * @return the count of the number of items in the model.
       */
      getCount(): number;
      /**
       * Returns the index number of the current page. The page
       *  counting starts with 0. The method also works with a miss-aligned
       *  start. In that case the start is always treated as the start of
       *  a page.
       *
       * @return the index number of the current page.
       */
      getCurrentPage(): number;
      /**
       * Returns the index of the last element on the current page.
       *
       * @return the index of the last element on the current page.
       */
      getEnd(): number;
      /**
       * Returns the maximum possible page number. Counting for pages starts
       *  with 0.  The method also works with a miss-aligned start. In that case
       *  the returned number might be higher than ((count-1) / pageSize).
       *
       * @return the maximum possible page number.
       */
      getMaxPage(): number;
      /**
       * Returns the total page count. The method also works
       *  with a miss-aligned start. In that case the returned number might
       *  be higher than (count / pageSize).
       *
       * @return the total page count.
       */
      getPageCount(): number;
      /**
       * Returns an iterator that can be used to iterate through the elements of
       *  the current page.
       *
       *  In case of a collection as the page models source, the method can be
       *  called multiple times. Each time a fresh iterator is returned.
       *
       *  In case of an iterator as the page models source, the method must be
       *  called only once. The method will always return the same iterator,
       *  which means the method amy return an exhausted iterator.
       *
       * @return an iterator that you use to iterate through the elements of the current page.
       */
      getPageElements(): dw.util.Iterator<T>;
      /**
       * Returns the size of the page.
       *
       * @return the size of the page.
       */
      getPageSize(): number;
      /**
       * Returns the current start position from which iteration will start.
       *
       * @return the current start position from which iteration will start.
       */
      getStart(): number;
      /**
       * Identifies if the model is empty.
       *
       * @return true if the model is empty, false otherwise.
       */
      isEmpty(): boolean;
      /**
       * Sets the size of the page. The page size must be greater or
       *  equal to 1.
       * @param pageSize the size of the page.
       */
      setPageSize(pageSize: number): void;
      /**
       * Sets the current start position from which iteration will start.
       * @param start the current start position from which iteration will start.
       */
      setStart(start: number): void;
    }

    /**
     * Library class which provides methods for retrieving messages from properties
     *  resource bundles which contain locale-specific strings. When your program
     *  needs a locale-specific String, it loads it from the resource bundle that is
     *  appropriate for the user&apos;s current locale. In this way, the program code is
     *  largely independent of the user&apos;s locale.
     *  <p>
     *  In Commerce Cloud Digital, resources are associated with the templates of a cartridge.
     *  These bundles consist of properties files with a common name defined in the
     *  template/resources directory of a site cartridge. For example:
     *
     *  </p><ul>
     *  <li>templates/resources/message.properties</li>
     *  <li>templates/resources/message_en.properties</li>
     *  <li>templates/resources/message_en_US.properties</li>
     *  <li>templates/resources/message_de_DE.properties</li>
     *  </ul>
     *
     *  Resource bundle lookup generally follows the same rules as the Java
     *  ResourceBundle class, where the locale used for lookup is based on the
     *  current request. See method javadoc for additional details.
     *  <p>
     *  Properties resource files are assumed to use the UTF-8 character
     *  encoding. Unicode escape sequences are also supported.</p>
     */
    class Resource {
      /**
       * Returns the message from the default properties resource bundle (base
       *  name "message") corresponding to the specified key and the request
       *  locale.
       *
       *  This method is equivalent to msg(String, null).
       * @param key resource bundle message key
       * @return the resource bundle message or the key itself if no message is defined.
       */
      static msg(key: string): string;
      /**
       * Returns the message from the default properties resource bundle (base
       *  name "message") corresponding to the specified key and the request
       *  locale. If no message for the key is found, returns the default message
       *  if it is not null, otherwise returns the key itself.
       *
       *  This method is equivalent to msg(key, null, defaultMessage).
       * @param key resource bundle message key
       * @param defaultMessage default message to return if no message corresponding to the key is found
       * @return the resource bundle message or default message
       */
      static msg(key: string, defaultMessage: string): string;
      /**
       * Returns the message from the specified properties resource bundle. The
       *  resource bundle is located by iterating the site cartridges and looking
       *  for a bundle with the specified name in the cartridge template/resources
       *  directory. If it finds a bundle, it tries to return a message from the
       *  bundle using standard Java ResourceBundle logic. If a message is found in
       *  that cartridge's bundle, it is returned, otherwise, the next cartridge is
       *  examined.
       *
       *  The method throws an exception if the key is null.
       * @param key resource bundle message key
       * @param bundleName base bundle name, if null, default bundle name, "message", is used
       * @param defaultMessage default message to return if no message corresponding to the key is found and defaultMessage is not null
       * @return the resource bundle message or default message
       */
      static msg(
        key: string,
        bundleName: string,
        defaultMessage: string
      ): string;
      /**
       * Returns the message from the specified properties resource bundle, with
       *  the provided arguments substituted for the message argument placeholders
       *  (specified using the Java MessageFormat approach).
       *
       *  If null is passed for the varargs argument, this method is equivalent to
       *  msg(key, bundleName, defaultMessage).
       * @param key resource bundle message key
       * @param bundleName base bundle name, if null, default bundle name, "message", is used
       * @param defaultMessage default message to return if no message corresponding to the key is found and defaultMessage is not null
       * @param args optional list of arguments or a collection, which are included into the result string
       * @return the resource bundle message or default message
       */
      static msgf(
        key: string,
        bundleName: string,
        defaultMessage: string,
        ...args: any[]
      ): string;
    }

    /**
     * Represents a URL in Commerce Cloud Digital.
     */
    class URL {
      /**
       * Makes the URL absolute and ensures that the protocol of the request is used
       *  or http in a mail context.
       *  Note: This method is not applicable for static content or image transformation
       *  URLs. In this case a runtime exception is thrown.
       *
       * @return A new URL instance.
       */
      abs(): dw.web.URL;
      /**
       * Append a request parameter to this URL.
       * @param name The parameter name. Must not be null.
       * @param value The parameter value. If null, then treated as empty value.
       * @return A reference to this URL.
       */
      append(name: string, value: string): dw.web.URL;
      /**
       * Appends, if applicable, a CSRF protection token to this URL. The CSRF token will only be appended under the following conditions:
       *
       *  the URL is a pipeline URL
       *  the URL is for Business Manager
       *  CSRF validation is not disabled
       *
       *
       *  If a CSRF token already exists in the URL, it will be replaced with a newly generated one.
       *
       * @return a reference to this URL, with a CSRF token appended if applicable.
       */
      appendCSRFTokenBM(): dw.web.URL;
      /**
       * Updates the URL with the specified host name
       *  Note: This method is not applicable for static content or image transformation
       *  URLs. In this case a runtime exception is thrown.
       * @param host The host name that is used to update the URL.
       * @return A new URL instance.
       */
      host(host: string): dw.web.URL;
      /**
       * Makes the URL absolute and ensures that the protocol http is used.
       *  Note: This method is not applicable for static content or image transformation
       *  URLs. In this case a runtime exception is thrown.
       *
       * @return A new URL instance.
       */
      http(): dw.web.URL;
      /**
       * Makes the URL absolute and ensures that the protocol https is used.
       *  Note: This method is not applicable for static content or image transformation
       *  URLs. In this case a runtime exception is thrown.
       *
       * @return A new URL instance.
       */
      https(): dw.web.URL;
      /**
       * Makes the URL relative.
       *  Note: This method is not applicable for static content or image transformation
       *  URLs. In this case a runtime exception is thrown.
       *
       * @return A new URL instance.
       */
      relative(): dw.web.URL;
      /**
       * Remove a request parameter from this URL. If the parameter is not part
       *  of the URL, nothing is done.
       * @param name The parameter name. Must not be null.
       * @return A reference to this URL.
       */
      remove(name: string): dw.web.URL;
      /**
       * Updates the URL with the site host name
       *  Note: This method is not applicable for static content or image transformation
       *  URLs. In this case a runtime exception is thrown.
       *
       * @return A new URL instance.
       */
      siteHost(): dw.web.URL;
      /**
       * Return String representation of the URL.
       *
       * @return the URL as a string.
       */
      toString(): string;
    }

    /**
     * The class is needed for the URL creation within template processing. It
     *  represents a reference to a pipeline name and start node, usually used in a
     *  HREF or a FORM action. URLAction instances are usually passed to one of the
     *  methods in <a href="class_dw_web_URLUtils.html">URLUtils</a> in order to generate an appropriately
     *  constructed Commerce Cloud Digital URL.  For example:
     *  <p>
     *  <code>
     *   var urlAction : URLAction = new URLAction(&quot;SimplePipeline-Start&quot;, &quot;SampleSite&quot;);<br>
     *   var url : URL = URLUtils.abs(false, urlAction1);<br>
     *   // url.toString() equals &quot;http://&quot; + request.httpHost + &quot;/on/demandware.store/Sites-SampleSite-Site/default/SimplePipeline-Start&quot;<br>
     *  </code></p>
     */
    class URLAction {
      /**
       * Constructs an action for the current site and locale.
       * @param action the target pipeline/controller, e.g. 'Default-Start'
       */
      constructor(action: string);
      /**
       * Constructs an action for the specified site and the current locale.
       * @param action the target pipeline/controller, e.g. 'Default-Start'
       * @param siteName the target site, e.g. 'SampleSite'
       */
      constructor(action: string, siteName: string);
      /**
       * Constructs an action for the specified site and locale.
       * @param action the target pipeline/controller, e.g.: 'Default-Start'
       * @param siteName the target site, e.g. 'SampleSite'
       * @param locale the target locale, e.g. 'default'
       */
      constructor(action: string, siteName: string, locale: string);
      /**
       * Constructs an URL action for the specified site, locale and hostname.
       *  The hostname must be defined in the site alias settings. If no hostname is provided, the HTTP/HTTPS
       *  host defined in the site alias settings will be used. If no HTTP/HTTPS host is defined in the site alias
       *  settings, the hostname of the current request is used.
       * @param action the target pipeline/controller, e.g.: 'Default-Start'
       * @param siteName the target site, e.g. 'SampleSite'
       * @param locale the target locale, e.g. 'default'
       * @param hostName the host name, e.g. www.shop.com'
       */
      constructor(
        action: string,
        siteName: string,
        locale: string,
        hostName: string
      );
    }

    /**
     * This class represents a key-value-pair for URL parameters.
     */
    class URLParameter {
      /**
       * Constructs the parameter using the specified name and value and endocded
       *  in the form "name=value".
       * @param aName the name
       * @param aValue the value
       */
      constructor(aName: string, aValue: string);
      /**
       * Constructs the parameter using the specified name and value. If the "encodeName" is set to true,
       *  the parameter is encoded in the form "name=value". Otherwise, it only
       *  contains the "value" (needed for URL patterns).
       * @param aName the name
       * @param aValue the value
       * @param encodeName if true, the name will be part of the string form
       */
      constructor(aName: string, aValue: string, encodeName: boolean);
    }

    /**
     * Represents a URLRedirect in Commerce Cloud Digital.
     */
    class URLRedirect {
      /**
       * The URL which was calculated to be the redirect URL.
       *  The Location parameter can be directly used as value for an redirect location.
       */
      readonly location: string;
      /**
       * The corresponding status code for the redirect location.
       */
      readonly status: number;

      /**
       * Returns the URL which was calculated to be the redirect URL.
       *  The Location parameter can be directly used as value for an redirect location.
       *
       * @return redirect location
       */
      getLocation(): string;
      /**
       * Returns the corresponding status code for the redirect location.
       *
       * @return status code
       */
      getStatus(): number;
    }

    /**
     * URLRedirect manager class. Methods in this class generate URLRedirects based on the
     *  current configuration for Static, Dynamic and URLRedirect mappings in Commerce
     *  Cloud Digital.
     *
     *  Information used to calculate URLRedirects are determined from the current HTTP
     *  request. The URL which is used to find a redirect can be accessed with <a href="class_dw_web_URLRedirectMgr.html#dw_web_URLRedirectMgr_getRedirectOrigin_DetailAnchor">getRedirectOrigin()</a>.
     */
    class URLRedirectMgr {
      /**
       * An URLRedirect object, containing a location and status. The redirect is calculated
       *  based on origin url of current request and the configured Static, Dynamic and URLRedirect mappings for
       *  the requested site.
       */
      static readonly redirect: dw.web.URLRedirect;
      /**
       * The relative origin url (without protocol, port, hostname and site path information)
       *  which will be used in getRedirect() to calculate a redirect location for.
       */
      static readonly redirectOrigin: string;

      /**
       * Returns an URLRedirect object, containing a location and status. The redirect is calculated
       *  based on origin url of current request and the configured Static, Dynamic and URLRedirect mappings for
       *  the requested site.
       *
       * @return URLRedirect containing the location and status code, null in case of no redirect was found
       */
      static getRedirect(): dw.web.URLRedirect;
      /**
       * Returns the relative origin url (without protocol, port, hostname and site path information)
       *  which will be used in getRedirect() to calculate a redirect location for.
       *
       * @return relative origin url
       */
      static getRedirectOrigin(): string;
    }

    /**
     * URL utility class. Methods in this class generate URLs used in Commerce Cloud Digital.<p>
     *
     *  Site related information in the generated URLs is determined from the current HTTP request.</p><p>
     *
     *  Methods belong to two groups: generating absolute and relative URLs. Absolute URL methods
     *  are further subdivided into those creating URLs with specified protocol and those
     *  using protocol information from the request. Corresponding to the protocol, the host name
     *  from the HTTP/HTTPS host preference is used. If preference is not set, the host name from the
     *  current request is included in resulting absolute URL.</p><p>
     *
     *  URLs do not include a session ID anymore. The appendSID argument therefore does not have any effect.</p><p>
     *
     *  When creating a pipeline URL with one of the methods url(), http(), https() or abs() by default
     *  the generated URL is a Commerce Cloud Digital URL (&quot;/on/demandware.store/...&quot;). If search friendly URLs are
     *  enabled (old or new) the methods generate search friendly URLs. Search friendly URLs are only generated for
     *  certain pipeline names. Here a list of these pipeline names:
     *  </p><ul>
     *  <li>Product-Show with a &apos;pid&apos; parameter [productID] - search friendly URL for a product</li>
     *  <li>Product-ShowInCategory with the &apos;cgid&apos; parameter [categoryID] and &apos;pid&apos; parameter [productID] - search friendly URL for a product shown in a specific category</li>
     *  <li>Search-Show with a &apos;cgid&apos; parameter [categoryID] - search friendly URL for a category</li>
     *  <li>Search-Show with a &apos;pid&apos; parameter [productID] - search friendly URL for a product</li>
     *  <li>Search-ShowContent with a &apos;fdid&apos; parameter [folderID] - search friendly URL for a folder (ONLY works with new storefront URLs)</li>
     *  <li>Page-Show with a &apos;cid&apos; parameter [contentID] - search friendly URL for a content page</li>
     *  </ul>
     *
     *  Parameter <code>transform</code>:<p>
     *
     *  Some methods allow the specification of image transformation parameters. Image
     *  transformation is only performed if the Dynamic Imaging Service (DIS) is available
     *  for the Commerce Cloud Digital instance. Otherwise a standard static content URL is returned.
     *  The to-be-transformed image needs to be hosted on Digital.</p><p>
     *
     *  Image transformation parameters are specified as JavaScript object literal. They
     *  are translated into URL parameters. See <a href="https://documentation.b2c.commercecloud.salesforce.com/DOC1/topic/com.demandware.dochelp/ImageManagement/CreatingImageTransformationURLs.html?cp=0_3_0_5_6_1">Create Image Transformation URLs.</a></p><p>
     *
     *  <table>
     *  <tbody><tr>
     *      <th>Type of transformation</th>
     *      <th>Parameters</th>
     *      <th>Description</th>
     *  </tr>
     *  <tr>
     *      <td>Scale an image</td>
     *      <td>
     *          <code>scaleWidth</code><br>
     *          <code>scaleHeight</code><br>
     *          <code>scaleMode</code>
     *      </td>
     *      <td>
     *          The <code>scaleWidth</code> and <code>scaleHeight</code> parameters
     *          are both integers; setting one of these parameters triggers a
     *          scaling operation. If both are provided, the one that scales the
     *          image less is used to calculate the scale factor. The image is then
     *          automatically cropped accord to the second dimension, with a
     *          centered position of the cropped area. If the parameter would scale
     *          the image larger, only this operation is applied, if the image
     *          remains within acceptable pixel dimensions.<p>
     *
     *          Note: <code>scaleMode</code> can only be used in combination with <code>scaleHeight</code> and <code>scaleWidth</code>.</p><p>
     *
     *          The <code>scaleMode</code> parameter can be set to <code>cut</code>
     *          or <code>fit</code>. The default <code>scaleMode</code> is
     *          <code>cut</code>, the behavior of which is explained above. If you
     *          specify <code>fit</code> as the <code>scaleMode</code>, the system
     *          scales the image into the given box of dimensions while keeping the
     *          aspect ratio (possibly resulting in a smaller image in one
     *          dimension).
     *      </p></td>
     *  </tr>
     *  <tr>
     *      <td>Overlay an image</td>
     *      <td>
     *          <code>imageX</code><br>
     *          <code>imageY</code><br>
     *          <code>imageURI</code>
     *      </td>
     *      <td>
     *          The <code>imageX</code> and <code>imageY</code> parameters are both
     *          integers. Valid values for these parameters are 0 or greater.<p>
     *
     *          Supported formats are <code>png</code>, <code>jpg</code>, <code>jp2</code>, and
     *          <code>gif</code>.</p><p>
     *
     *          The <code>imageURI</code> parameter can be set to the absolute path
     *          of the overlaid image. The value of the <code>imageURI</code>
     *          parameter must be given in proper URL encoding, and it cannot exceed
     *          400 characters in length. The path may include query string
     *          parameters, which supports dynamically generating the overlaid image
     *          itself through this service; that is, the overlaid image can itself
     *          be a transformed image.</p><p>
     *
     *          If the overlaid image extends over the primary image&apos;s boundaries,
     *          the overlaid image is cropped so that it fits directly over the
     *          primary image.
     *      </p></td>
     *  </tr>
     *  <tr>
     *      <td>Crop an image</td>
     *      <td>
     *          <code>cropX</code><br>
     *          <code>cropY</code><br>
     *          <code>cropWidth</code><br>
     *          <code>cropHeight</code>
     *      </td>
     *      <td>
     *          The <code>cropX</code>, <code>cropY</code>, <code>cropWidth</code>,
     *          <code>cropHeight</code> parameters are integers. All four parameters
     *          must be specified to trigger a cropping operation.<p>
     *
     *          Valid values for the <code>cropX</code> and <code>cropY</code>
     *          parameters are 0 or greater. If the crop location defined by
     *          <code>cropX</code> and <code>cropY</code> is outside the image area,
     *          nothing is cropped.</p><p>
     *
     *          Valid values for the <code>cropWidth</code> and
     *          <code>cropHeight</code> parameters are 10 or greater. If the
     *          <code>cropWidth</code> and <code>cropHeight</code> parameters
     *          specify a size that is greater than the original image, the crop
     *          area is reduced to the actual image area. If <code>cropWidth</code>
     *          and <code>cropHeight</code> are 0 or less, no transformation is
     *          applied.
     *      </p></td>
     *  </tr>
     *  <tr>
     *      <td>Format an image</td>
     *      <td><code>format</code></td>
     *      <td>
     *          The <code>format</code> parameter specifies the target format of the
     *          image. Supported formats are <code>png</code>, <code>jpg</code>, <code>jp2</code>, and
     *          <code>gif</code>. If no target format is specified, no format
     *          conversion is performed.<p>
     *
     *          The source image file is references with attribute
     *          <code>relPath</code>. Source image&apos;s format is recognized by the
     *          file extension which must be <code>tif</code>, <code>tiff</code>,
     *          <code>jpg</code>, <code>jpeg</code>, <code>png</code>, or
     *          <code>gif</code>.</p><p>
     *
     *          In the generated URL the file extension of the target format is used
     *          in the URL path. This is to make sure the image is loaded from an
     *          URL with a matching file extension. The source format is provided as
     *          URL parameter.
     *      </p></td>
     *  </tr>
     *  <tr>
     *      <td>Adjust image compression quality</td>
     *      <td><code>quality</code></td>
     *      <td>
     *          The <code>quality</code> parameter specifies a quality setting for <code>jpg</code> and <code>jp2</code> images,
     *          and specifies the compression level for <code>png</code> images.<p>
     *
     *          For <code>jpg</code> and <code>jp2</code> images, you can set values from 1&#x2013;100 for the highest quality.
     *          The default quality is 80. If you&apos;re not changing the default quality, you don&apos;t need to pass in a value.</p><p>
     *
     *          For <code>png</code> images, the quality setting has no effect on the appearance of the <code>png</code>, since the compression is always lossless.
     *          Instead you can use the quality setting to set the zlib compression level and filter-type for PNG images.
     *          The tens digit sets the zlib compression level(1-9). The ones digit sets the filter type.</p><p>
     *
     *          If the <code>png</code> setting is not present or set to 0, it uses a default value of 75.
     *          If this setting is set to 100, it actually equals the quality setting 90.
     *      </p></td>
     *  </tr>
     *  <tr>
     *      <td>Adjust Metadata stripping</td>
     *      <td><code>strip</code></td>
     *      <td>
     *          The <code>strip</code> parameter specifies if metadata like EXIF and color profiles is
     *          stripped from the image during transformation.<p>
     *
     *          Valid values for the <code>strip</code> parameter are between <code>true</code> and <code>false</code>.
     *          The default is <code>true</code>
     *      </p></td>
     *  </tr>
     *  <tr>
     *      <td>Change background color</td>
     *      <td><code>bgcolor(color) or bgcolor(color+alpha)</code></td>
     *      <td>
     *          The <code>bgcolor</code> parameter specifies the background color for images that support transparency
     *          as well as JPEG images when being converted from a format that supports transparency.
     *          Optionally, alpha setting for PNG images are also supported.<p>
     *
     *          <code>bgcolor</code> expects a 6 digit hexadecimal value of RGB with an optional
     *          two hexadecimal characters representing alpha value that determines transparency.</p><p>
     *
     *          FF0000 = Red</p><p>
     *
     *          FF000077 = Red with 50% transparency</p><p>
     *
     *          Alpha values are optional. When the alpha value is omitted, the resulting color is opaque.
     *          Alpha values are only valid when the image output format is PNG.
     *      </p></td>
     *  </tr>
     *  </tbody></table>
     *
     *  Example:</p><p>
     *     The following code</p><p>
     *     <code>var url = URLUtils.imageURL(&apos;/somepath/image.png&apos;, {scaleWidth: 100, format: &apos;jpg&apos;});</code></p><p>
     *     will produce an image transformation URL like</p><p>
     *     <code>http://&lt;image server host name&gt;/.../on/demandware.static/.../somepath/image.jpg?sw=100&amp;sfrm=png</code>.</p>
     */
    class URLUtils {
      /**
       * ID for a catalog context. See staticURL() method.
       */
      static readonly CONTEXT_CATALOG = "ContextCatalog";
      /**
       * ID for a library context. See staticURL() method.
       */
      static readonly CONTEXT_LIBRARY = "ContextLibrary";
      /**
       * ID for a site context (= assigned cartridges). See staticURL() method.
       */
      static readonly CONTEXT_SITE = "ContextSite";

      /**
       * Return an absolute URL with protocol and host from the current request.
       * @param action URL action
       * @param params URL parameters
       * @return an absolute URL with protocol and host from the current request.
       */
      static abs(
        action: dw.web.URLAction,
        ...params: dw.web.URLParameter[]
      ): dw.web.URL;
      /**
       * Return an absolute URL with protocol and host from current request.
       *
       *  Note: The use of this method is deprecated, because session URL rewriting
       *        is no longer supported. Use the corresponding abs() method without the
       *        appendSID parameter instead.
       * @param appendSID when true the resulting URL will include session ID.
       * @param action URL action
       * @param params URL parameters
       * @return an absolute URL with protocol and host from current request.
       */
      static abs(
        appendSID: boolean,
        action: dw.web.URLAction,
        ...params: dw.web.URLParameter[]
      ): dw.web.URL;
      /**
       * Return an absolute URL with protocol and host from current request.
       * @param action the pipeline, which should be invoked, e.g.: 'Pipeline-StartNode'
       * @param namesAndParams several strings with name=value pairs, for example: 'pid', 'value1', 'cgid', value2'.
       * @return an absolute URL with protocol and host from current request.
       */
      static abs(action: string, ...namesAndParams: string[]): dw.web.URL;
      /**
       * Return an absolute URL with protocol and host from current request.
       *
       *  Note: The use of this method is deprecated, because session URL rewriting
       *        is no longer supported. Use the corresponding method abs() without the
       *        appendSID parameter instead.
       * @param appendSID when true the resulting URL will include session ID.
       * @param action the pipeline, which should be invoked, e.g.: 'Pipeline-StartNode'
       * @param namesAndParams several strings with name=value pairs, e.g.: 'pid', 'value1', 'cgid', value2'.
       * @return an absolute URL with protocol and host from current request.
       */
      static abs(
        appendSID: boolean,
        action: string,
        ...namesAndParams: string[]
      ): dw.web.URL;
      /**
       * Similar to absStatic( String, String, String ) this method returns a static URL for a resource
       *  in the current site. The method assumes, that the URL refers to an image an
       *  supports an additional parameter with optional image transformation parameters.
       *  The image transformation parameters must be specified as JavaScript object literal.
       * @param context Either CONTEXT_CATALOG, CONTEXT_LIBRARY or CONTEXT_SITE
       * @param contextID Optional context id, currently only used to specify a catalog id
       * @param relPath Relative path within the catalog or library
       * @param transform Object with transformation parameters (see class header)
       * @return URL for the specified location
       */
      static absImage(
        context: string,
        contextID: string,
        relPath: string,
        transform: any
      ): dw.web.URL;
      /**
       * Similar to absStatic( String ) this method returns a static URL for a resource
       *  in the current site. The method assumes, that the URL refers to an image an
       *  supports an additional parameter with optional image transformation parameters.
       *  The image transformation parameters must be specified as JavaScript object literal.
       * @param relPath the relative path of the file
       * @param transform Object with transformation parameters (see class header)
       * @return the URL for the specified image resource
       */
      static absImage(relPath: string, transform: any): dw.web.URL;
      /**
       * Returns the absolute URL to the static location of the specified context. The context
       *  can be either a specific catalog (URLUtils.CONTEXT_CATALOG),
       *  a content library (URLUtils.CONTEXT_LIBRARY) or a site (URLUtils.CONTEXT_SITE).
       *  Respectively either a URL to images in a catalog, a library or a site are created.
       *
       *  The contextID parameter is optional and only used for context CONTEXT_CATALOG, where
       *  is specifies the ID of a specific catalog. If defined, the static URL for the specified
       *  catalog is returned. If not defined, the static URL for the current site catalog
       *  is returned (or null if no site catalog is defined).
       *  For context CONTEXT_SITE and context CONTEXT_LIBRARY, the contextID parameter is
       *  ignored and the static URL for the current site / site library is returned.
       *
       *  Parameter relPath can be defined to specify the relative path within the context-specific
       *  path.
       *
       *  The method returns an absolute URL with the same protocol as the current request.
       * @param context Either CONTEXT_CATALOG, CONTEXT_LIBRARY or CONTEXT_SITE
       * @param contextID Optional context id, currently only used to specify a catalog id
       * @param relPath Relative path within the catalog or library
       * @return URL for the specified location
       */
      static absStatic(
        context: string,
        contextID: string,
        relPath: string
      ): dw.web.URL;
      /**
       * The method returns a static URL for a resource in the current site. Site
       *  resources are actually located in the cartridges associated with the site.
       *  This resources are typically logos, button images, CSS files and JavaScript
       *  files. The method will transform the given relative path to include cache
       *  related information, which enables better cache control.
       *
       *  The created URL is an absolute URL with same protocol as the current incoming
       *  request.
       *
       *  Note: This method replaces the original mechanisms of using the webroot()
       *  method to construct a URL. The new method is better integrated into the
       *  overall cache management.
       * @param relPath the relative path of the file
       * @return the URL for the specified location
       */
      static absStatic(relPath: string): dw.web.URL;
      /**
       * Return an absolute web root URL with protocol and host same as the current request.
       *
       *  Note: The use of this method is deprecated. The method absStatic() should
       *  be used instead. It provides better cache integration.
       *
       * @return an absolute web root URL with protocol, host from current request.
       */
      static absWebRoot(): dw.web.URL;
      /**
       * Return a URL, which can be used in combination with an Interaction Continue Node, to
       *  continue the user interface flow.
       *
       * @return an absolute URL with protocol and host from current context request.
       */
      static continueURL(): dw.web.URL;
      /**
       * Generates a hostname-only url if an alias is set, or an url to the Home-Show
       *    pipeline in the default format using the protocol of the incoming request.
       *
       * @return a hostname-only url if an alias is set, or an url to the Home-Show pipeline in the default format using the protocol of the incoming request.
       */
      static home(): dw.web.URL;
      /**
       * Return an absolute URL with HTTP protocol. If an HTTP host is configured in the preferences
       *  the returned URL will include that host, otherwise, the host from current request is used.
       * @param action URL action
       * @param params URL parameters
       * @return an absolute URL with HTTP protocol.
       */
      static http(
        action: dw.web.URLAction,
        ...params: dw.web.URLParameter[]
      ): dw.web.URL;
      /**
       * Return an absolute URL with HTTP protocol. If an HTTP host is configured in the preferences
       *  the returned URL will include that host, otherwise, the host from current request is used.
       *
       *  Note: The use of this method is deprecated, because session URL rewriting
       *        is no longer supported. Use the corresponding http() method without the
       *        appendSID parameter instead.
       * @param appendSID when true the resulting URL will include session ID.
       * @param action URL action
       * @param params URL parameters
       * @return an absolute URL with HTTP protocol.
       */
      static http(
        appendSID: boolean,
        action: dw.web.URLAction,
        ...params: dw.web.URLParameter[]
      ): dw.web.URL;
      /**
       * Return an absolute URL with HTTP protocol. If an HTTP host is configured in the preferences
       *  the returned URL will include that host, otherwise, the host from current request is used.
       * @param action the pipeline, which should be invoked, e.g.: 'Pipeline-StartNode'
       * @param namesAndParams several strings with name=value pairs, e.g.: 'pid', 'value1', 'cgid', value2'.
       * @return an absolute URL with HTTP protocol.
       */
      static http(action: string, ...namesAndParams: string[]): dw.web.URL;
      /**
       * Return an absolute URL with HTTP protocol. If an HTTP host is configured in the preferences
       *  the returned URL will include that host, otherwise, the host from current request is used.
       *
       *  Note: The use of this method is deprecated, because session URL rewriting
       *        is no longer supported. Use the corresponding http() method without the
       *        appendSID parameter instead.
       * @param appendSID when true the resulting URL will include session ID.
       * @param action the pipeline, which should be invoked, e.g.: 'Pipeline-StartNode'
       * @param namesAndParams several strings with name=value pairs, e.g.: 'pid', 'value1', 'cgid', value2'.
       * @return an absolute URL with HTTP protocol.
       */
      static http(
        appendSID: boolean,
        action: string,
        ...namesAndParams: string[]
      ): dw.web.URL;
      /**
       * Return a URL, which can be used in combination with an Interaction Continue Node, to
       *  continue the user interface flow. For security reasons the httpContinue() function returns
       *  a HTTPS continue URL if the interaction flow has started with a HTTPS request. Otherwise a
       *  HTTP continue URL is returned.
       *  If an HTTP/HTTPS host is configured in the preferences the returned URL will include that
       *  host, otherwise, the host from current request is used.
       *
       * @return an absolute URL with HTTP protocol.
       */
      static httpContinue(): dw.web.URL;
      /**
       * Generates a hostname-only url if an alias is set, or an url to the Home-Show
       *    pipeline in the default format using the HTTP protocol.
       *
       * @return a hostname-only url if an alias is set, or an url to the Home-Show pipeline in the default format using the HTTP protocol.
       */
      static httpHome(): dw.web.URL;
      /**
       * Similar to httpStatic( String, String, String ) this method returns a static URL for a resource
       *  in the current site. The method assumes, that the URL refers to an image an
       *  supports an additional parameter with optional image transformation parameters.
       *  The image transformation parameters must be specified as JavaScript object literal.
       * @param context Either CONTEXT_CATALOG, CONTEXT_LIBRARY or CONTEXT_SITE
       * @param contextID Optional context id, currently only used to specify a catalog id
       * @param relPath Relative path within the catalog or library
       * @param transform Object with transformation parameters (see class header)
       * @return URL for the specified location
       */
      static httpImage(
        context: string,
        contextID: string,
        relPath: string,
        transform: any
      ): dw.web.URL;
      /**
       * Similar to httpStatic( String, String, String ) this method returns a static URL for a resource
       *  in the current site. The method assumes, that the URL refers to an image an
       *  supports an additional parameter with optional image transformation parameters.
       *  The image transformation parameters must be specified as JavaScript object literal.
       *
       *  The host parameter is optional. If provided, then this host name will be used
       *  in precedence to the host name provided by the current request. The specified host
       *  name must be defined in the alias settings for the site, otherwise an exception will
       *  be thrown.
       * @param host Optional host name, used to set the host explicitly.
       * @param context Either CONTEXT_CATALOG, CONTEXT_LIBRARY or CONTEXT_SITE
       * @param contextID Optional context id, currently only used to specify a catalog id
       * @param relPath Relative path within the catalog or library
       * @param transform Object with transformation parameters
       * @return URL for the specified location
       */
      static httpImage(
        host: string,
        context: string,
        contextID: string,
        relPath: string,
        transform: any
      ): dw.web.URL;
      /**
       * Similar to httpStatic( String ) this method returns a static URL for a resource
       *  in the current site. The method assumes, that the URL refers to an image an
       *  supports an additional parameter with optional image transformation parameters.
       *  The image transformation parameters must be specified as JavaScript object literal.
       * @param relPath the relative path of the file
       * @param transform Object with transformation parameters (see class header)
       * @return the URL for the specified location
       */
      static httpImage(relPath: string, transform: any): dw.web.URL;
      /**
       * Similar to httpStatic( String ) this method returns a static URL for a resource
       *  in the current site. The method assumes, that the URL refers to an image an
       *  supports an additional parameter with optional image transformation parameters.
       *  The image transformation parameters must be specified as JavaScript object literal.
       *
       *  The host parameter is optional. If provided, then this host name will be used
       *  in precedence to the host name provided by the current request. The specified host
       *  name must be defined in the alias settings for the site, otherwise an exception will
       *  be thrown.
       * @param host Optional host name, used to set the host explicitly.
       * @param relPath the relative path of the file
       * @param transform Object with transformation parameters
       * @return the URL for the specified location
       */
      static httpImage(
        host: string,
        relPath: string,
        transform: any
      ): dw.web.URL;
      /**
       * Return an absolute URL with HTTPS protocol. If an HTTPS host is configured in the preferences
       *  the returned URL will include that host, otherwise, the host from current request is used.
       * @param action URL action
       * @param params URL parameters
       * @return an absolute URL with HTTPS protocol.
       */
      static https(
        action: dw.web.URLAction,
        ...params: dw.web.URLParameter[]
      ): dw.web.URL;
      /**
       * Return an absolute URL with HTTPS protocol. If an HTTPS host is configured in the preferences
       *  the returned URL will include that host, otherwise, the host from current request is used.
       *
       *  Note: The use of this method is deprecated, because session URL rewriting
       *        is no longer supported. Use the corresponding https() method without the
       *        appendSID parameter instead.
       * @param appendSID when true the resulting URL will include session ID.
       * @param action URL action
       * @param params URL parameters
       * @return an absolute URL with HTTPS protocol.
       */
      static https(
        appendSID: boolean,
        action: dw.web.URLAction,
        ...params: dw.web.URLParameter[]
      ): dw.web.URL;
      /**
       * Return an absolute URL with HTTPS protocol. If an HTTPS host is configured in the preferences
       *  the returned URL will include that host, otherwise, the host from current request is used.
       * @param action the pipeline, which should be invoked, e.g.: 'Pipeline-StartNode'
       * @param namesAndParams several strings with name=value pairs, e.g.: 'pid', 'value1', 'cgid', value2'.
       * @return an absolute URL with HTTPS protocol.
       */
      static https(action: string, ...namesAndParams: string[]): dw.web.URL;
      /**
       * Return an absolute URL with HTTPS protocol. If an HTTPS host is configured in the preferences
       *  the returned URL will include that host, otherwise, the host from current request is used.
       *
       *  Note: The use of this method is deprecated, because session URL rewriting
       *        is no longer supported. Use the corresponding https() method without the
       *        appendSID parameter instead.
       * @param appendSID when true the resulting URL will include session ID
       * @param action the pipeline, which should be invoked, e.g.: 'Pipeline-StartNode'
       * @param namesAndParams several strings with name=value pairs, e.g.: 'pid', 'value1', 'cgid', value2'.
       * @return an absolute URL with HTTPS protocol.
       */
      static https(
        appendSID: boolean,
        action: string,
        ...namesAndParams: string[]
      ): dw.web.URL;
      /**
       * Return a URL, which can be used in combination with an Interaction Continue Node, to
       *  continue the user interface flow. An absolute URL with HTTPS protocol is returned.
       *  If an HTTPS host is configured in the preferences the returned URL will include that
       *  host, otherwise, the host from current request is used.
       *
       * @return an absolute URL with HTTPS protocol.
       */
      static httpsContinue(): dw.web.URL;
      /**
       * Generates a hostname-only url if an alias is set, or an url to the Home-Show
       *    pipeline in the default format using the HTTPS protocol.
       *
       * @return a hostname-only url if an alias is set, or an url to the Home-Show pipeline in the default format using the HTTPS protocol..
       */
      static httpsHome(): dw.web.URL;
      /**
       * Similar to httpsStatic( String, String, String ) this method returns a static URL for a resource
       *  in the current site. The method assumes, that the URL refers to an image an
       *  supports an additional parameter with optional image transformation parameters.
       *  The image transformation parameters must be specified as JavaScript object literal.
       * @param context Either CONTEXT_CATALOG, CONTEXT_LIBRARY or CONTEXT_SITE
       * @param contextID Optional context id, currently only used to specify a catalog id
       * @param relPath Relative path within the catalog or library
       * @param transform Object with transformation parameters (see class header)
       * @return URL for the specified location
       */
      static httpsImage(
        context: string,
        contextID: string,
        relPath: string,
        transform: any
      ): dw.web.URL;
      /**
       * Similar to httpsStatic( String, String, String ) this method returns a static URL for a resource
       *  in the current site. The method assumes, that the URL refers to an image an
       *  supports an additional parameter with optional image transformation parameters.
       *  The image transformation parameters must be specified as JavaScript object literal.
       *
       *  The host parameter is optional. If provided, then this host name will be used
       *  in precedence to the host name provided by the current request. The specified host
       *  name must be defined in the alias settings for the site, otherwise an exception will
       *  be thrown.
       * @param host Optional host name, used to set the host explicitly.
       * @param context Either CONTEXT_CATALOG, CONTEXT_LIBRARY or CONTEXT_SITE
       * @param contextID Optional context id, currently only used to specify a catalog id
       * @param relPath Relative path within the catalog or library
       * @param transform Object with transformation parameters
       * @return URL for the specified location
       */
      static httpsImage(
        host: string,
        context: string,
        contextID: string,
        relPath: string,
        transform: any
      ): dw.web.URL;
      /**
       * Similar to httpsStatic( String ) this method returns a static URL for a resource
       *  in the current site. The method assumes, that the URL refers to an image an
       *  supports an additional parameter with optional image transformation parameters.
       *  The image transformation parameters must be specified as JavaScript object literal.
       * @param relPath the relative path of the file
       * @param transform Object with transformation parameters (see class header)
       * @return the URL for the specified location
       */
      static httpsImage(relPath: string, transform: any): dw.web.URL;
      /**
       * Similar to httpsStatic( String ) this method returns a static URL for a resource
       *  in the current site. The method assumes, that the URL refers to an image an
       *  supports an additional parameter with optional image transformation parameters.
       *  The image transformation parameters must be specified as JavaScript object literal.
       *
       *  The host parameter is optional. If provided, then this host name will be used
       *  in precedence to the host name provided by the current request. The specified host
       *  name must be defined in the alias settings for the site, otherwise an exception will
       *  be thrown.
       * @param host Optional host name, used to set the host explicitly.
       * @param relPath the relative path of the file
       * @param transform Object with transformation parameters
       * @return the URL for the specified location
       */
      static httpsImage(
        host: string,
        relPath: string,
        transform: any
      ): dw.web.URL;
      /**
       * Returns the absolute URL to the static location of the specified context. The context
       *  can be either a specific catalog (URLUtils.CONTEXT_CATALOG),
       *  a content library (URLUtils.CONTEXT_LIBRARY) or a site (URLUtils.CONTEXT_SITE).
       *  Respectively either a URL to images in a catalog, a library or a site are created.
       *
       *  The contextID parameter is optional and only used for context CONTEXT_CATALOG, where
       *  is specifies the ID of a specific catalog. If defined, the static URL for the specified
       *  catalog is returned. If not defined, the static URL for the current site catalog
       *  is returned (or null if no site catalog is defined).
       *  For context CONTEXT_SITE and context CONTEXT_LIBRARY, the contextID parameter is
       *  ignored and the static URL for the current site / site library is returned.
       *
       *  Parameter relPath can be defined to specify the relative path within the context-specific
       *  path.
       *
       *  The method returns an absolute URL with HTTPS protocol.
       * @param context Either CONTEXT_CATALOG, CONTEXT_LIBRARY or CONTEXT_SITE
       * @param contextID Optional context id, currently only used to specify a catalog id
       * @param relPath Relative path within the catalog or library
       * @return URL for the specified location
       */
      static httpsStatic(
        context: string,
        contextID: string,
        relPath: string
      ): dw.web.URL;
      /**
       * Returns the absolute URL to the static location of the specified context. The context
       *  can be either a specific catalog (URLUtils.CONTEXT_CATALOG),
       *  a content library (URLUtils.CONTEXT_LIBRARY) or a site (URLUtils.CONTEXT_SITE).
       *  Respectively either a URL to images in a catalog, a library or a site are created.
       *
       *  The host parameter is optional. If provided, then this host name will be used
       *  in precedence to the host name provided by the current request. The specified host
       *  name must be defined in the alias settings for the site, otherwise an exception will
       *  be thrown.
       *
       *  The contextID parameter is optional and only used for context CONTEXT_CATALOG, where
       *  is specifies the ID of a specific catalog. If defined, the static URL for the specified
       *  catalog is returned. If not defined, the static URL for the current site catalog
       *  is returned (or null if no site catalog is defined).
       *  For context CONTEXT_SITE and context CONTEXT_LIBRARY, the contextID parameter is
       *  ignored and the static URL for the current site / site library is returned.
       *
       *  Parameter relPath can be defined to specify the relative path within the context-specific
       *  path.
       *
       *  The method returns an absolute URL with HTTPS protocol.
       * @param host Optional host name, used to set the host explicitly.
       * @param context Either CONTEXT_CATALOG, CONTEXT_LIBRARY or CONTEXT_SITE
       * @param contextID Optional context id, currently only used to specify a catalog id
       * @param relPath Relative path within the catalog or library
       * @return URL for the specified location
       */
      static httpsStatic(
        host: string,
        context: string,
        contextID: string,
        relPath: string
      ): dw.web.URL;
      /**
       * The method returns a static URL for a resource in the current site. Site
       *  resources are actually located in the cartridges associated with the site.
       *  This resources are typically logos, button images, CSS files and JavaScript
       *  files. The method will transform the given relative path to include cache
       *  related information, which enables better cache control.
       *
       *  The created URL is an absolute URL with HTTPS protocol.
       *
       *  Note: This method replaces the original mechanisms of using the webroot()
       *  method to construct a URL. The new method is better integrated into the
       *  overall cache management.
       * @param relPath the relative path of the file
       * @return the URL for the specified location
       */
      static httpsStatic(relPath: string): dw.web.URL;
      /**
       * The method returns a static URL for a resource in the current site. Site
       *  resources are actually located in the cartridges associated with the site.
       *  This resources are typically logos, button images, CSS files and JavaScript
       *  files. The method will transform the given relative path to include cache
       *  related information, which enables better cache control.
       *
       *  The host parameter is optional. If provided, then this host name will be used
       *  in precedence to the host name provided by the current request. The specified host
       *  name must be defined in the alias settings for the site, otherwise an exception will
       *  be thrown.
       *
       *  The created URL is an absolute URL with HTTPS protocol.
       *
       *  Note: This method replaces the original mechanisms of using the webroot()
       *  method to construct a URL. The new method is better integrated into the
       *  overall cache management.
       * @param host Optional host name, used to set the host explicitly.
       * @param relPath the relative path of the file
       * @return the URL for the specified location
       */
      static httpsStatic(host: string, relPath: string): dw.web.URL;
      /**
       * Returns the absolute URL to the static location of the specified context. The context
       *  can be either a specific catalog (URLUtils.CONTEXT_CATALOG),
       *  a content library (URLUtils.CONTEXT_LIBRARY) or a site (URLUtils.CONTEXT_SITE).
       *  Respectively either a URL to images in a catalog, a library or a site are created.
       *
       *  The contextID parameter is optional and only used for context CONTEXT_CATALOG, where
       *  is specifies the ID of a specific catalog. If defined, the static URL for the specified
       *  catalog is returned. If not defined, the static URL for the current site catalog
       *  is returned (or null if no site catalog is defined).
       *  For context CONTEXT_SITE and context CONTEXT_LIBRARY, the contextID parameter is
       *  ignored and the static URL for the current site / site library is returned.
       *
       *  Parameter relPath can be defined to specify the relative path within the context-specific
       *  path.
       *
       *  The method returns an absolute URL with HTTP protocol.
       * @param context Either CONTEXT_CATALOG, CONTEXT_LIBRARY or CONTEXT_SITE
       * @param contextID Optional context id, currently only used to specify a catalog id
       * @param relPath Relative path within the catalog or library
       * @return URL for the specified location
       */
      static httpStatic(
        context: string,
        contextID: string,
        relPath: string
      ): dw.web.URL;
      /**
       * Returns the absolute URL to the static location of the specified context. The context
       *  can be either a specific catalog (URLUtils.CONTEXT_CATALOG),
       *  a content library (URLUtils.CONTEXT_LIBRARY) or a site (URLUtils.CONTEXT_SITE).
       *  Respectively either a URL to images in a catalog, a library or a site are created.
       *
       *  The host parameter is optional. If provided, then this host name will be used
       *  in precedence to the host name provided by the current request. The specified host
       *  name must be defined in the alias settings for the site, otherwise an exception will
       *  be thrown.
       *
       *  The contextID parameter is optional and only used for context CONTEXT_CATALOG, where
       *  is specifies the ID of a specific catalog. If defined, the static URL for the specified
       *  catalog is returned. If not defined, the static URL for the current site catalog
       *  is returned (or null if no site catalog is defined).
       *  For context CONTEXT_SITE and context CONTEXT_LIBRARY, the contextID parameter is
       *  ignored and the static URL for the current site / site library is returned.
       *
       *  Parameter relPath can be defined to specify the relative path within the context-specific
       *  path.
       *
       *  The method returns an absolute URL with HTTP protocol.
       * @param host Optional host name, used to set the host explicitly.
       * @param context Either CONTEXT_CATALOG, CONTEXT_LIBRARY or CONTEXT_SITE
       * @param contextID Optional context id, currently only used to specify a catalog id
       * @param relPath Relative path within the catalog or library
       * @return URL for the specified location
       */
      static httpStatic(
        host: string,
        context: string,
        contextID: string,
        relPath: string
      ): dw.web.URL;
      /**
       * The method returns a static URL for a resource in the current site. Site
       *  resources are actually located in the cartridges associated with the site.
       *  This resources are typically logos, button images, CSS files and JavaScript
       *  files. The method will transform the given relative path to include cache
       *  related information, which enables better cache control.
       *
       *  The created URL is an absolute URL with HTTP protocol.
       *
       *  Note: This method replaces the original mechanisms of using the webroot()
       *  method to construct a URL. The new method is better integrated into the
       *  overall cache management.
       * @param relPath the relative path of the file
       * @return the URL for the specified location
       */
      static httpStatic(relPath: string): dw.web.URL;
      /**
       * The method returns a static URL for a resource in the current site. Site
       *  resources are actually located in the cartridges associated with the site.
       *  This resources are typically logos, button images, CSS files and JavaScript
       *  files. The method will transform the given relative path to include cache
       *  related information, which enables better cache control.
       *
       *  The host parameter is optional. If provided, then this host name will be used
       *  in precedence to the host name provided by the current request. The specified host
       *  name must be defined in the alias settings for the site, otherwise an exception will
       *  be thrown.
       *
       *  The created URL is an absolute URL with HTTP protocol.
       *
       *  Note: This method replaces the original mechanisms of using the webroot()
       *  method to construct a URL. The new method is better integrated into the
       *  overall cache management.
       * @param host Optional host name, used to set the host explicitly.
       * @param relPath the relative path of the file
       * @return the URL for the specified location
       */
      static httpStatic(host: string, relPath: string): dw.web.URL;
      /**
       * Return an absolute web root URL with HTTPS protocol and host and domain information from the current
       *  request. If an HTTP host is configured in the preferences the returned URL will include that host.
       *
       *  Note: The use of this method is deprecated. The method httpsStatic() should
       *  be used instead. It provides better cache integration.
       *
       * @return an absolute web root URL with HTTPS protocol and host information from the current request.
       */
      static httpsWebRoot(): dw.web.URL;
      /**
       * Return an absolute web root URL with HTTP protocol and host information from current
       *  request. If an HTTP host is configured in the preferences the returned URL will include
       *  that host.
       *
       *  Note: The use of this method is deprecated. The method httpStatic() should
       *  be used instead. It provides better cache integration.
       *
       * @return an absolute web root URL with HTTP protocol and host information from the current request.
       */
      static httpWebRoot(): dw.web.URL;
      /**
       * Similar to staticURL( String, String, String ) this method returns a static URL for a resource
       *  in the current site. The method assumes, that the URL refers to an image an
       *  supports an additional parameter with optional image transformation parameters.
       *  The image transformation parameters must be specified as JavaScript object literal.
       *
       *  The URL returned is always an absolute URL.
       * @param context Either CONTEXT_CATALOG, CONTEXT_LIBRARY or CONTEXT_SITE
       * @param contextID Optional context id, currently only used to specify a catalog id
       * @param relPath Relative path within the catalog or library
       * @param transform Object with transformation parameters (see class header)
       * @return URL for the specified location
       */
      static imageURL(
        context: string,
        contextID: string,
        relPath: string,
        transform: any
      ): dw.web.URL;
      /**
       * Similar to staticURL( String ) this method returns a static URL for a resource
       *  in the current site. The method assumes, that the URL refers to an image an
       *  supports an additional parameter with optional image transformation parameters.
       *  The image transformation parameters must be specified as JavaScript object literal.
       *
       *  The URL returned is always an absolute URL.
       * @param relPath the relative path of the file
       * @param transform Object with transformation parameters (see class header)
       * @return the URL for the specified location
       */
      static imageURL(relPath: string, transform: any): dw.web.URL;
      /**
       * This method is used to create a URL that redirects to a location in
       *  the current site with another host name. When the URL is submitted,
       *  the system copies all system cookies, such that user, session and basket
       *  information are shared across different hosts.
       *  The specified host name must be defined in the alias settings for the site,
       *  otherwise an exception will be thrown when submitting the redirect URL.
       *  If the specified host is the same as the current host, the method will return
       *  a "normal" URL because no redirect is required.
       * @param host Target host with or without a site-path
       * @param url Target URL on current site (relative or absolute), pass null to redirect to new host only
       * @return an absolute secure URL to the redirect mechanism
       */
      static sessionRedirect(host: string, url: dw.web.URL): dw.web.URL;
      /**
       * This method is used to create a URL that redirects to a location in
       *  the current site with another host name. When the URL is submitted,
       *  the system copies all system cookies, such that user, session and basket
       *  information are shared across different hosts.
       *  The specified host name must be defined in the alias settings for the site,
       *  otherwise an exception will be thrown when submitting the redirect URL.
       *  If the specified host is the same as the current host, the method will return
       *  a "normal" URL because no redirect is required.
       *
       *  Note: since this method generates a non-secure (HTTP) link, no
       *  HTTPS Cookies are copied, which might lead to sessions being incorrectly being
       *  detected as hijacked. It is strongly recommended to use sessionRedirect(String, URL)
       *  where possible.
       * @param host Target host with or without a site-path
       * @param url Target URL on current site (relative or absolute), pass null to redirect to new host only
       * @return an absolute URL to the redirect mechanism
       */
      static sessionRedirectHttpOnly(host: string, url: dw.web.URL): dw.web.URL;
      /**
       * Returns the relative URL to the static location of the specified context. The context
       *  can be either a specific catalog (URLUtils.CONTEXT_CATALOG),
       *  a content library (URLUtils.CONTEXT_LIBRARY) or a site (URLUtils.CONTEXT_SITE).
       *  Respectively either a URL to images in a catalog, a library or a site are created.
       *
       *  The contextID parameter is optional and can be used with context either CONTEXT_CATALOG or CONTEXT_LIBRARY, where
       *  it specifies the ID of a specific catalog or a shared library respectively. If defined, the static URL for the specified
       *  catalog/shared library is returned. If not defined, the static URL for the current site catalog/site library
       *  is returned (or null if no site catalog/site library is defined).
       *  For context CONTEXT_SITE, the contextID parameter is ignored and the static URL for the current site is returned.
       *
       *  Parameter relPath can be defined to specify the relative path within the context-specific
       *  path.
       *
       *  The method returns an relative URL with the same protocol as the current request.
       * @param context Either CONTEXT_CATALOG, CONTEXT_LIBRARY or CONTEXT_SITE
       * @param contextID Optional context id, currently only used to specify a catalog id or a shared library id
       * @param relPath Relative path within the catalog or library or site
       * @return URL for the specified location
       */
      static staticURL(
        context: string,
        contextID: string,
        relPath: string
      ): dw.web.URL;
      /**
       * The method returns a static URL for a resource in the current site. Site
       *  resources are actually located in the cartridges associated with the site.
       *  This resources are typically logos, button images, CSS files and JavaScript
       *  files. The method will transform the given relative path to include cache
       *  related information, which enables better cache control.
       *
       *  The created URL is a relative URL.
       *
       *  Note: This method replaces the original mechanisms of using the webroot()
       *  method to construct a URL. The new method is better integrated into the
       *  overall cache management.
       * @param relPath the relative path of the file
       * @return the URL for the specified location
       */
      static staticURL(relPath: string): dw.web.URL;
      /**
       * Return a relative URL.
       * @param action URL action
       * @param params URL parameters
       * @return a relative URL.
       */
      static url(
        action: dw.web.URLAction,
        ...params: dw.web.URLParameter[]
      ): dw.web.URL;
      /**
       * Return a relative URL.
       *
       *  Note: The use of this method is deprecated, because session URL rewriting
       *        is no longer supported. Use the corresponding url() method without the
       *        appendSID parameter instead.
       * @param appendSID when true the resulting URL will include session ID.
       * @param action URL action
       * @param params URL parameters
       * @return a relative URL.
       */
      static url(
        appendSID: boolean,
        action: dw.web.URLAction,
        ...params: dw.web.URLParameter[]
      ): dw.web.URL;
      /**
       * Return a relative URL.
       * @param action the pipeline, which should be invoked, e.g.: 'Pipeline-StartNode'
       * @param namesAndParams several strings with name=value pairs , e.g.: 'pid', 'value1', 'cgid', value2'.
       * @return a relative URL.
       */
      static url(action: string, ...namesAndParams: string[]): dw.web.URL;
      /**
       * Return a relative URL.
       *
       *  Note: The use of this method is deprecated, because session URL rewriting
       *        is no longer supported. Use the corresponding url() method without the
       *        appendSID parameter instead.
       * @param appendSID when true the resulting URL will include session ID.
       * @param action the pipeline, which should be invoked, e.g.: 'Pipeline-StartNode'
       * @param namesAndParams several strings with name=value pairs, e.g.: 'pid', 'value1', 'cgid', value2'.
       * @return a relative URL.
       */
      static url(
        appendSID: boolean,
        action: string,
        ...namesAndParams: string[]
      ): dw.web.URL;
      /**
       * Return a relative web root URL. A web root URL is used to access all static
       *  media context for the site. The actual media file can be referenced by appending
       *  a relative path.
       *
       *  Note: The use of this method is deprecated. The method staticURL() should
       *  be used instead. It provides better cache integration.
       *
       * @return a relative web root URL.
       */
      static webRoot(): dw.web.URL;
    }
  }

  namespace ws {
    /**
     * This class represents a port to a Service Endpoint Interface. This
     *  class provides access to operations the service provides. Use the
     *  WSUtil class to perform operations on the port such as setting
     *  timeout values and configuring security.
     *  <p>
     *  Developers should set a low timeout to ensure responsiveness
     *  of the site and avoid thread exhaustion (see <a href="class_dw_ws_WSUtil.html#dw_ws_WSUtil_setRequestTimeout_Number_Object_DetailAnchor">WSUtil.setRequestTimeout(Number, Object)</a>).
     *  The default request timeout is 15 minutes when the web reference is used in a job,
     *  and 2 minutes otherwise. If the timeout of the calling script is lower,
     *  the script timeout is used.</p>
     */
    class Port {
      /**
       * Property constant for controlling the content type encoding of an outgoing message.
       */
      static readonly ENCODING: string;
      /**
       * The target service endpoint address. When using this property, the URI
       *  scheme for the endpoint address specification must correspond to the
       *  protocol/transport binding for the binding in use.
       */
      static readonly ENDPOINT_ADDRESS_PROPERTY: string;
      /**
       * Password for authentication. This property is used with the USERNAME_PROPERTY.
       *  You can also use the  WSUtil.setUserNamePassword(String, String, Object) method instead of using these
       *  properties.
       */
      static readonly PASSWORD_PROPERTY: string;
      /**
       * This boolean property is used by a service client to indicate whether or not it wants to
       *  participate in a session with a service endpoint. If this property is set to true, the service client indicates
       *  that it wants the session to be maintained. If set to false, the session is not maintained. The default value
       *  for this property is false.
       */
      static readonly SESSION_MAINTAIN_PROPERTY: string;
      /**
       * User name for authentication. This property is used with the PASSWORD_PROPERTY.
       *  You can also use the WSUtil.setUserNamePassword(String, String, Object) method instead of using these
       *  properties.
       */
      static readonly USERNAME_PROPERTY: string;

      constructor();
    }

    /**
     * A utility class for performing SOAP-based operations for Web Services
     *  for use with <a href="class_dw_ws_WebReference2.html">WebReference2</a>. This class provides
     *  methods for setting SOAP headers and a set of constants representing the
     *  well-known supported header names. You also use this class to set connection and request
     *  timeout values for Web Service calls.
     */
    class WSUtil {
      /**
       * This key identifier method is used when the X.509 Certificate is included in the message.
       *  The certificate is Base-64 encoded and included in the request via a BinarySecurityToken element
       */
      static readonly KEY_ID_TYPE_DIRECT_REFERENCE = "DirectReference";
      /**
       * This Key Identifier method only applies for Encryption. Unlike the previous methods
       *  it refers to the way the EncryptedData references the EncryptedKey Element,
       *  rather than the way the EncryptedKey Element refers to the public key.
       */
      static readonly KEY_ID_TYPE_ENC_KEY_SHA1 = "EncryptedKeySHA1";
      /**
       * This key identifier method means that the Issuer Name and Serial Number of a X.509
       *  Certificate is included directly in the KeyInfo Element.
       */
      static readonly KEY_ID_TYPE_ISSUE_SERIAL = "IssuerSerial";
      /**
       * This Key Identifier method refers to a Certificate via a Base-64 encoding of the
       *  Subject Key Identifier.
       */
      static readonly KEY_ID_TYPE_SKI_IDENTIFIER = "SKIKeyIdentifier";
      /**
       * This Key Identifier method refers to the Certificate via a SHA-1 Thumbprint.
       *  The certificate may or may not be included in the request.
       */
      static readonly KEY_ID_TYPE_THUMBPRINT = "Thumbprint";
      /**
       * This key identifier method is similar to KEY_ID_TYPE_DIRECT_REFERENCE, in that the certificate is
       *  included in the request. However, instead of referring to a certificate, the certificate is
       *  included directly in the KeyInfo element.
       */
      static readonly KEY_ID_TYPE_X509_KEY_IDENTIFIER = "X509KeyIdentifier";
      /**
       * WS-Security action property name.
       *  Allowed property values are WS_NO_SECURITY, WS_TIMESTAMP, WS_ENCRYPT,
       *  WS_SIGNATURE, WS_USERNAME_TOKEN or a space separated list of these values.
       */
      static readonly WS_ACTION = "action";
      /**
       * Defines which key identifier type to use for encryption. Permissible
       *  values are:
       *
       *  KEY_ID_TYPE_ISSUE_SERIAL  (default value)
       *  KEY_ID_TYPE_DIRECT_REFERENCE
       *  KEY_ID_TYPE_X509_KEY_IDENTIFIER
       *  KEY_ID_TYPE_THUMBPRINT
       *  KEY_ID_TYPE_SKI_IDENTIFIER
       *  KEY_ID_TYPE_ENC_KEY_SHA1
       */
      static readonly WS_ENC_KEY_ID = "encryptionKeyIdentifier";
      /**
       * WS-Security Encryption: The encryption and decryption keystore alias name
       */
      static readonly WS_ENC_PROP_KEYSTORE_ALIAS =
        "__EncryptionPropKeystoreAlias";
      /**
       * WS-Security Encryption: The encryption and decryption keystore password
       */
      static readonly WS_ENC_PROP_KEYSTORE_PW =
        "__EncryptionPropKeystorePassword";
      /**
       * WS-Security Encryption: The encryption/decryption keystore type ( jks or pkcs12 ),
       *                          default is jks.
       *  Note: The keystore file has the basename of the WSDL file and the
       *  file extension based on the keystore type (e.g. MyService.jks).
       *  The keystore file has to be placed in the same cartridge directory
       *  as the WSDL file.
       */
      static readonly WS_ENC_PROP_KEYSTORE_TYPE =
        "__EncryptionPropKeystoreType";
      /**
       * WS-Security action: Encrypt the message.
       *  The encryption specific parameters define how to encrypt.
       */
      static readonly WS_ENCRYPT = "Encrypt";
      /**
       * WS-Security Encryption: Defines which parts of the request shall be encrypted.
       */
      static readonly WS_ENCRYPTION_PARTS = "encryptionParts";
      /**
       * WS-Security Encryption: The user's name for encryption.
       */
      static readonly WS_ENCRYPTION_USER = "encryptionUser";
      /**
       * WS-Security action: No security.
       */
      static readonly WS_NO_SECURITY = "NoSecurity";
      /**
       * WS-Security password type: Parameter for UsernameToken action to define the encoding
       *  of the password. Allowed values are PW_DIGEST or PW_TEXT.
       */
      static readonly WS_PASSWORD_TYPE = "passwordType";
      /**
       * WS-Security password type "digest": Use a password digest to send the password information.
       */
      static readonly WS_PW_DIGEST = "PasswordDigest";
      /**
       * WS-Security password type "text": Send the password information in clear.
       */
      static readonly WS_PW_TEXT = "PasswordText";
      /**
       * A secrets map with the username and password entries needed to create the password
       *  callback object.
       */
      static readonly WS_SECRETS_MAP = "__SecretsMap";
      /**
       * WS-Security Signature: Defines which signature digest algorithm to use.
       */
      static readonly WS_SIG_DIGEST_ALGO = "signatureDigestAlgorithm";
      /**
       * Defines which key identifier type to use for signature.
       *
       *  Permissible values are:
       *
       *  KEY_ID_TYPE_ISSUE_SERIAL
       *  KEY_ID_TYPE_DIRECT_REFERENCE (default value)
       *  KEY_ID_TYPE_X509_KEY_ID_IDENTIFIER
       *  KEY_ID_TYPE_THUMBPRINT
       *  KEY_ID_TYPE_SKI_IDENTIFIER
       */
      static readonly WS_SIG_KEY_ID = "signatureKeyIdentifier";
      /**
       * WS-Security Signature: The signature keystore alias name.
       */
      static readonly WS_SIG_PROP_KEYSTORE_ALIAS =
        "__SignaturePropKeystoreAlias";
      /**
       * WS-Security Signature: The signature keystore password.
       */
      static readonly WS_SIG_PROP_KEYSTORE_PW =
        "__SignaturePropKeystorePassword";
      /**
       * WS-Security: The signature keystore type ( jks or pkcs12 ), default is jks.
       *  Note: The keystore file has the basename of the WSDL file and the
       *  file extension based on the keystore type (e.g. MyService.jks).
       *  The keystore file has to be placed in the same cartridge directory
       *  as the WSDL file.
       */
      static readonly WS_SIG_PROP_KEYSTORE_TYPE = "__SignaturePropKeystoreType";
      /**
       * WS-Security action: Sign the message.
       *  The signature specific parameters define how to sign and which keys
       *  to use.
       */
      static readonly WS_SIGNATURE = "Signature";
      /**
       * WS-Security Signature: Defines which parts of the request shall be signed.
       */
      static readonly WS_SIGNATURE_PARTS = "signatureParts";
      /**
       * WS-Security Signature: The user's name for signature.
       */
      static readonly WS_SIGNATURE_USER = "signatureUser";
      /**
       * WS-Security action: Add a timestamp to the security header.
       */
      static readonly WS_TIMESTAMP = "Timestamp";
      /**
       * WS-Security user name.
       */
      static readonly WS_USER = "user";
      /**
       * WS-Security action: Add a UsernameToken identification.
       */
      static readonly WS_USERNAME_TOKEN = "UsernameToken";

      constructor();

      /**
       * Adds a header element to the SOAP Header. Each header element should be XML and
       *  it should typically contain a namespace URI.
       * @param port the port.
       * @param xml the header element XML. The XML should contain a namespace URI.
       * @param mustUnderstand directs target endpoint to validate payload.
       * @param actor an URI that identifies that intended recipient of this header element.
       */
      static addSOAPHeader(
        port: any,
        xml: any,
        mustUnderstand: boolean,
        actor: string
      ): void;
      /**
       * Adds a header element to the SOAP Header. Each header element should be XML and
       *  it should typically contain a namespace URI.
       * @param port the port.
       * @param xml the header element XML as a String. The XML should contain a namespace URI.
       * @param mustUnderstand directs target endpoint to validate payload.
       * @param actor an URI that identifies that intended recipient of this header element.
       */
      static addSOAPHeader(
        port: any,
        xml: string,
        mustUnderstand: boolean,
        actor: string
      ): void;
      /**
       * Removes all SOAP header elements from the port's request context.
       * @param port a port returned from one of the WebReference2 getService methods.
       */
      static clearSOAPHeaders(port: any): void;
      /**
       * Creates an javax.xml.ws.Holder instance that wraps the specified element. When a WSDL operation is
       *  defined to have an input and output message using the same type, the operation may require the operation's
       *  object to be wrapped in a holder.
       * @param element the element to be wrapped in the Holder.
       * @return the holder.
       */
      static createHolder(element: any): any;
      /**
       * Returns the connection timeout value for the port.
       * @param port a port returned from one of the WebReference2 getService methods.
       * @return the connection timeout value.
       */
      static getConnectionTimeout(port: any): number;
      /**
       * Returns an HTTP request header property value using the specified key. Null is returned
       *  if the key does not represent an HTTP header property.
       * @param port a port returned from one of the WebReference2 getService methods.
       * @param key the header property key.
       * @return an HTTP request header property value using the specified key or null.
       */
      static getHTTPRequestHeader(port: any, key: string): string;
      /**
       * Returns the value of the SOAP request property using the specified key on a port
       *  returned from one of the WebReference2 getService methods. The property
       *  keys are defined as constants in Port.
       * @param key the key to use.
       * @param port the port on which the property is set.
       * @return the property using the specified key and port.
       */
      static getProperty(key: string, port: any): any;
      /**
       * Returns the read timeout value for a request made on the specified port.
       *  If the request exceeds the timeout value, an error is thrown.
       * @param port a port returned from one of the WebReference2 getService methods.
       * @return the request timeout value for the port.
       */
      static getRequestTimeout(port: any): number;
      /**
       * Returns the property value using the specified key and on a port returned from one of
       *  the WebReference2 getService methods.
       * @param key the key to use.
       * @param port the port on which the property is set
       * @return the property using the specified key and port.
       */
      static getResponseProperty(key: string, port: any): any;
      /**
       * Returns true if the HTTP request may be chunked, false otherwise
       * @param port a port returned from one of the WebReference2 getService methods.
       * @return returns true if the HTTP request may be chunked and false otherwise
       */
      static isAllowChunking(port: any): boolean;
      /**
       * Indicate that HTTP chunked Transfer-Encoding may be used.
       *
       *  The default behavior is true. If false then the request will not
       *  be chunked and the Content-Length will always be sent.
       * @param port a port returned from one of the WebReference2 getService methods.
       * @param allow true to enable chunking, false otherwise
       */
      static setAllowChunking(port: any, allow: boolean): void;
      /**
       * Sets the connection timeout for the port.
       * @param timeoutInMilliseconds the connection timeout.
       * @param port a port returned from one of the WebReference2 getService methods.
       */
      static setConnectionTimeout(
        timeoutInMilliseconds: number,
        port: any
      ): void;
      /**
       * Sets an HTTP request header property using the specified key and value.
       * @param port a port returned from one of the WebReference2 getService methods.
       * @param key the header property key.
       * @param value the header property value. If the value is null, the property identified by the key is removed from the HTTP request header.
       */
      static setHTTPRequestHeader(port: any, key: string, value: string): void;
      /**
       * Set the SOAP request property using the specified key and value on a port
       *  returned from one of the WebReference2 getService() methods. The property
       *  keys are defined as constants in Port.
       * @param key the key to use.
       * @param value the value.
       * @param port the port on which the property is set.
       */
      static setProperty(key: string, value: any, port: any): void;
      /**
       * Sets the read timeout value for a request made on the specified port.
       *  If the request exceeds the timeout value, an error is thrown.
       * @param timeoutInMilliseconds the timeout.
       * @param port a port returned from one of the WebReference2 getService methods.
       */
      static setRequestTimeout(timeoutInMilliseconds: number, port: any): void;
      /**
       * Set the user name and password to use with Basic authentication. For stronger
       *  authentication, use the setWSSecurityConfig(Object, Object, Object) method.
       * @param userName the user name.
       * @param password the password.
       * @param port a port returned from one of the WebReference2 getService methods.
       */
      static setUserNamePassword(
        userName: string,
        password: string,
        port: any
      ): void;
      /**
       * Set the WS-Security configuration for the request and response based on the
       *  constants defined (see above).
       * @param port a port returned from one of the WebReference2 getService methods.
       * @param requestConfigMap the WS-Security request configuration.
       * @param responseConfigMap the WS-Security response configuration.
       */
      static setWSSecurityConfig(
        port: any,
        requestConfigMap: any,
        responseConfigMap: any
      ): void;
    }

    /**
     * Represents a web service defined in a WSDL file. The implementation is backed by a JAX-WS framework. In general,
     *  you should use WebReference2 instead of <a href="class_dw_rpc_WebReference.html">WebReference</a>. However, if your web service
     *  WSDL is using RPC-style calls, you must use <a href="class_dw_rpc_WebReference.html">WebReference</a>.
     *  <p>
     *  To create an instance of a WebReference2, you put a web service WSDL file in the <code>webreferences2</code>
     *  directory and reference the WSDL file in a B2C Commerce Script. You then request the service <a href="class_dw_ws_Port.html">Port</a>
     *  using one the the get service methods. For example, if your WSDL file is <code>MyWSDL.wsdl</code>,
     *  here is how you create an instance of WebReference2 and access the <a href="class_dw_ws_Port.html">Port</a>:
     *  <br>
     *  </p><pre> <code>
     *  var webref : WebReference2 = webreferences2.MyWSDL;
     *  var port : Port = webref.getDefaultService();
     *  </code>
     *  </pre>
     *
     *  Note that all script classes representing your WSDL file are placed in the <code>webreferences2</code>
     *  package. To use classes in the <code>webreferences2</code> package, you do not need to use the <code>importPackage</code>
     *  statement in your B2C Commerce Script file.
     */
    class WebReference2 {
      /**
       * The default service endpoint interface port of the web reference. The default service is
       *  determined as the first service based on the alphabetic order of the service name, and within
       *  the service the first SOAP port based on the alphabetic order of the port name.
       */
      readonly defaultService: dw.ws.Port;

      constructor();

      /**
       * Returns the default service endpoint interface port of the web reference. The default service is
       *  determined as the first service based on the alphabetic order of the service name, and within
       *  the service the first SOAP port based on the alphabetic order of the port name.
       *
       * @return the default service of the web reference.
       */
      getDefaultService(): dw.ws.Port;
      /**
       * Returns a specific service from this web reference.
       * @param service the service to locate.
       * @param portName the name of the port to use.
       * @return a specific service from this web reference.
       */
      getService(service: string, portName: string): dw.ws.Port;
    }
  }

  /**
   * Custom attributes for Promotion object.
   */
  class PromotionCustomAttributes {
    /**
     * Returns the custom attribute with this name. Throws an exception if attribute is not defined
     */
    [name: string]: any;
  }

  /**
   * Custom attributes for Variant object.
   */
  class VariantCustomAttributes {
    /**
     * Returns the custom attribute with this name. Throws an exception if attribute is not defined
     */
    [name: string]: any;
  }

  /**
   * Custom attributes for VariationGroup object.
   */
  class VariationGroupCustomAttributes {
    /**
     * Returns the custom attribute with this name. Throws an exception if attribute is not defined
     */
    [name: string]: any;
  }

  /**
   * Custom attributes for ActiveData object.
   */
  class ActiveDataCustomAttributes {
    /**
     * Returns the custom attribute with this name. Throws an exception if attribute is not defined
     */
    [name: string]: any;
  }

  /**
   * Custom attributes for Request object.
   */
  class RequestCustomAttributes {
    /**
     * Returns the custom attribute with this name. Throws an exception if attribute is not defined
     */
    [name: string]: any;
  }

  /**
   * Custom attributes for Session object.
   */
  class SessionCustomAttributes {
    /**
     * Returns the custom attribute with this name. Throws an exception if attribute is not defined
     */
    [name: string]: any;
  }
}
